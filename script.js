const translations = {
  'zh-CN': {
    // ================================
    // A. é€šç”¨è¯æ¡ (å·²æ‰©å……)
    // ================================
    save: 'ä¿å­˜',
    cancel: 'å–æ¶ˆ',
    confirm: 'ç¡®å®š',
    edit: 'ç¼–è¾‘',
    done: 'å®Œæˆ',
    add: 'æ·»åŠ ',
    back: 'è¿”å›ž',
    next: 'ä¸‹ä¸€æ­¥',
    close: 'å…³é—­',
    reset: 'é‡ç½®',
    upload: 'ä¸Šä¼ ',
    send: 'å‘é€',
    manage: 'ç®¡ç†',
    share: 'åˆ†äº«',
    delete: 'åˆ é™¤',
    publish: 'å‘å¸ƒ',
    refresh: 'åˆ·æ–°',
    search: 'æœç´¢',
    remove: 'ç§»é™¤',
    finish: 'ç»“æŸ',
    details: 'è¯¦æƒ…',
    settings: 'è®¾ç½®',
    title: 'æ ‡é¢˜',
    content: 'å†…å®¹',
    category: 'åˆ†ç±»',
    name: 'åç§°',
    description: 'æè¿°',
    status: 'çŠ¶æ€',
    ok: 'å¥½çš„',
    error: 'é”™è¯¯',
    success: 'æˆåŠŸ',
    warning: 'è­¦å‘Š',
    loading: 'åŠ è½½ä¸­...',
    processing: 'å¤„ç†ä¸­...',
    pleaseWait: 'è¯·ç¨å€™...',
    languageChangedAlert: 'è¯­è¨€å·²åˆ‡æ¢ï¼Œé¡µé¢å³å°†åˆ·æ–°ä»¥åº”ç”¨æ›´æ”¹ã€‚',
    
    // ================================
    // B. å„ä¸ªå±å¹•å’Œç»„ä»¶
    // ================================
    // --- ä¸»å±å¹• & Dock ---
    homeAppQQ: 'QQ',
    homeAppWorldBook: 'ä¸–ç•Œä¹¦',
    homeAppAppearance: 'å¤–è§‚è®¾ç½®',
    homeAppRenderer: 'æ¸²æŸ“å™¨',
    homeAppApiSettings: 'è®¾ç½®',
    homeAppFont: 'å­—ä½“',
    homeAppCPhone: 'CPhone',
    homeAppDouban: 'è±†ç“£',
    homeAppPreset: 'é¢„è®¾',
    homeAppTutorial: 'æ•™ç¨‹',
    homeAppWerewolf: 'ç‹¼äººæ€',
    homeAppX: 'X',

    // --- èŠå¤©åˆ—è¡¨é¡µ ---
    chatListTitle: 'æ¶ˆæ¯',
    navMessages: 'æ¶ˆæ¯',
    navQzone: 'åŠ¨æ€',
    navMemories: 'å›žå¿†',
    navFavorites: 'æ”¶è—',
    navNpcList: 'NPC',

    // --- QZone & åŠ¨æ€ ---
    qzoneTitle: 'å¥½å‹åŠ¨æ€',
    qzoneActionShuoshuo: 'è¯´è¯´',
    qzoneActionPost: 'åŠ¨æ€',
    qzoneActionAlbum: 'ç›¸å†Œ',
    
    // --- CPhone (è§’è‰²æ‰‹æœº) ---
    cphoneTitleSelect: 'é€‰æ‹©ä¸€éƒ¨æ‰‹æœº',
    cphoneAppQQ: 'QQ',
    cphoneAppAlbum: 'ç›¸å†Œ',
    cphoneAppBrowser: 'æµè§ˆå™¨',
    cphoneAppTaobao: 'æ·˜å®',
    cphoneAppMemo: 'å¤‡å¿˜å½•',
    cphoneAppDiary: 'æ—¥è®°',
    cphoneAppAmap: 'é«˜å¾·åœ°å›¾',
    cphoneAppUsage: 'Appè®°å½•',
    cphoneAppMusic: 'ç½‘æ˜“äº‘',
    cphoneAppEphone: 'Ephone',
    cphoneAppFootprints: 'è¶³è¿¹',
    cphoneAlbumTitle: 'TAçš„ç›¸å†Œ',
    cphoneBrowserTitle: 'TAçš„æµè§ˆå™¨åŽ†å²',
    cphoneTaobaoTitle: 'TAçš„æ·˜å®è®¢å•',
    cphoneWalletTitle: 'é’±åŒ…',
    cphoneMemoTitle: 'å¤‡å¿˜å½•',
    cphoneDiaryTitle: 'æ—¥è®°',
    cphoneUsageTitle: 'Appä½¿ç”¨è®°å½•',
    cphoneMusicTitle: 'TAçš„æ­Œå•',
    cphoneArticleTitle: 'æ–‡ç« ',
    cphoneSimulatedChatPlaceholder: 'è¿™æ˜¯æ¨¡æ‹Ÿå¯¹è¯ï¼Œæ— æ³•å‘é€æ¶ˆæ¯',

    // --- ä¸–ç•Œä¹¦ ---
    worldBookTitle: 'ä¸–ç•Œä¹¦',
    worldBookEditorTitle: 'ç¼–è¾‘ä¸–ç•Œä¹¦',
    worldBookEntryEditorTitle: 'ç¼–è¾‘æ¡ç›®',
    worldBookNameLabel: 'ä¹¦å',
    worldBookCategoryLabel: 'åˆ†ç±»',
    worldBookEntriesLabel: 'å†…å®¹æ¡ç›®',
    worldBookAddEntryBtn: '[+] æ·»åŠ æ–°æ¡ç›®',
    worldBookNamePlaceholder: 'è¯·è¾“å…¥ä¸–ç•Œä¹¦çš„åç§°...',
    worldBookImportTitle: 'å¯¼å…¥ä¸–ç•Œä¹¦',

    // --- é¢„è®¾ ---
    presetTitle: 'é¢„è®¾',
    presetEditorTitle: 'ç¼–è¾‘é¢„è®¾',
    presetNameLabel: 'é¢„è®¾åç§°',
    presetCategoryLabel: 'åˆ†ç±»',
    presetEntriesLabel: 'å†…å®¹æ¡ç›®',
    presetAddEntryBtn: '[+] æ·»åŠ æ–°æ¡ç›®',

    // --- æ•™ç¨‹ ---
    tutorialTitle: 'æ•™ç¨‹',
    
    // --- API è®¾ç½® ---
    apiSettingsTitle: 'API è®¾ç½®',
    languageLabel: 'è¯­è¨€',
    apiPresetManagement: 'API é¢„è®¾ç®¡ç†',
    apiPresetSelectLabel: 'é€‰æ‹©æˆ–åˆ‡æ¢é¢„è®¾',
    apiPrimarySettings: 'ä¸»APIè®¾ç½® (ç”¨äºŽèŠå¤©)',
    apiProxyUrlLabel: 'åä»£åœ°å€ (ä¸éœ€è¦æ·»åŠ /v1å™¢~)',
    apiKeyLabel: 'å¯†é’¥ (API Key)',
    apiModelLabel: 'æ¨¡åž‹',
    apiFetchModelsBtn: 'æ‹‰å–ä¸»æ¨¡åž‹',
    apiSecondarySettings: 'å‰¯APIè®¾ç½® (ç”¨äºŽæ€»ç»“é•¿æœŸè®°å¿†)',
    apiSecondaryProxyUrlLabel: 'å‰¯åä»£åœ°å€',
    apiSecondaryKeyLabel: 'å‰¯å¯†é’¥',
    apiSecondaryModelLabel: 'å‰¯æ¨¡åž‹',
    apiFetchSecondaryModelsBtn: 'æ‹‰å–å‰¯æ¨¡åž‹',
    apiBgActivitySettings: 'åŽå°æ´»åŠ¨è®¾ç½®',
    apiEnableBgActivityLabel: 'å¯ç”¨åŽå°è§’è‰²æ´»åŠ¨',
    apiBgIntervalLabel: 'åŽå°æ´»åŠ¨æ£€æµ‹é—´éš” (ç§’)',
    apiBlockCooldownLabel: 'AIè¢«æ‹‰é»‘åŽå†·é™æœŸ (å°æ—¶)',
    apiTtsSettings: 'è¯­éŸ³æ¶ˆæ¯è®¾ç½® (Minimax TTS)',
    apiTtsModelLabel: 'è¯­éŸ³æ¨¡åž‹ (Model)',
    apiPerformanceSettings: 'æ€§èƒ½ä¸Žæ˜¾ç¤ºè®¾ç½®',
    apiChatListRenderWindowLabel: 'èŠå¤©åˆ—è¡¨æ¯æ¬¡åŠ è½½æ¡æ•°',
    apiChatRenderWindowLabel: 'èŠå¤©ç•Œé¢åˆå§‹åŠ è½½æ¡æ•°',
    apiImageGenSettings: 'ç”Ÿå›¾åŠŸèƒ½è®¾ç½®',
    apiEnableImageGenLabel: 'å¯ç”¨AIç”Ÿå›¾åŠŸèƒ½',
    apiEnableNovelAILabel: 'å¯ç”¨ NovelAI å›¾åƒç”Ÿæˆ',
    apiNovelAIModelLabel: 'NovelAI æ¨¡åž‹',
    apiNovelAIKeyLabel: 'NovelAI API Key',
    apiNovelAIGenSettingsBtn: 'ç”Ÿæˆè®¾ç½®',
    apiNovelAITestBtn: 'æµ‹è¯•ç”Ÿæˆ',
    apiStorageOptimization: 'å­˜å‚¨ç©ºé—´ä¼˜åŒ–',
    apiCompressImagesBtn: 'ä¸€é”®åŽ‹ç¼©æœ¬åœ°å›¾ç‰‡',
    apiSaveAllBtn: 'ä¿å­˜æ‰€æœ‰è®¾ç½®',
    apiExportDataBtn: 'å¯¼å‡ºæ•°æ®',
    apiImportDataBtn: 'å¯¼å…¥å¤‡ä»½æ–‡ä»¶',
    apiCleanupDataBtn: 'æ¸…ç†å†—ä½™æ•°æ®',
    apiDeleteWorldBooksBtn: 'åˆ é™¤ä¸–ç•Œä¹¦',
    apiAdvancedCleanupBtn: 'é«˜çº§æ•°æ®æ¸…ç†',
    apiCheckAndFixDataBtn: 'æ•°æ®æ£€æŸ¥ä¸Žä¿®å¤',

    // --- èŠå¤©ç•Œé¢ ---
    chatHeaderOnline: 'åœ¨çº¿',
    chatHeaderLongTermMemory: 'é•¿æœŸè®°å¿†',
    chatHeaderListenTogether: 'ä¸€èµ·å¬',
    chatHeaderChatSettings: 'èŠå¤©è®¾ç½®',
    chatSelectionCancel: 'å–æ¶ˆ',
    chatSelectionScreenshot: 'é•¿æˆªå›¾',
    chatSelectionFavorite: 'æ”¶è—',
    chatSelectionShare: 'åˆ†äº«',
    chatSelectionSoftDelete: 'åˆ é™¤(é€šçŸ¥AI)',
    chatSelectionHardDelete: 'å½»åº•åˆ é™¤',
    chatReplyTo: 'å›žå¤',
    chatInputPlaceholder: 'è¾“å…¥æ¶ˆæ¯...',
    chatWaitForReply: 'ç­‰å¾…å›žå¤',
    
    // --- å¤–è§‚è®¾ç½® ---
    appearanceTitle: 'å¤–è§‚è®¾ç½®',
    appearanceSaveAll: 'ä¿å­˜æ‰€æœ‰å¤–è§‚è®¾ç½®',
    
    // --- å­—ä½“è®¾ç½® ---
    fontSettingsTitle: 'å­—ä½“è®¾ç½®',
    fontPresetManagement: 'å­—ä½“é¢„è®¾ç®¡ç†',
    fontFileUrlLabel: 'å­—ä½“æ–‡ä»¶URL (.ttf, .otf, .woffç­‰)',
    fontPreviewLabel: 'å®žæ—¶é¢„è§ˆ',
    fontPreviewText1: 'ä½ å¥½ä¸–ç•Œ Hello World',
    fontPreviewText2: 'è¿™æ˜¯å­—ä½“é¢„è§ˆæ•ˆæžœï¼Œ12345ã€‚',
    fontSaveAndApply: 'ä¿å­˜å¹¶åº”ç”¨',
    fontResetDefault: 'æ¢å¤é»˜è®¤å­—ä½“',

    // --- æ¸²æŸ“è§„åˆ™ ---
    rendererTitle: 'æ¸²æŸ“è§„åˆ™',
    rendererEditorTitle: 'ç¼–è¾‘è§„åˆ™',
    rendererCreateTitle: 'åˆ›å»ºæ–°è§„åˆ™',
    rendererRuleName: 'è§„åˆ™åç§°',
    rendererBindScope: 'ç»‘å®šèŒƒå›´',
    rendererScopeGlobal: 'å…¬ç”¨ (æ‰€æœ‰è§’è‰²)',
    rendererRegex: 'æ­£åˆ™è¡¨è¾¾å¼ (ä½¿ç”¨gä½œä¸ºæ ‡å¿—)',
    rendererHtmlTemplate: 'HTML æ¨¡æ¿ (ç”¨ $1, $2 å¼•ç”¨)',
    rendererEnableRule: 'å¯ç”¨è§„åˆ™',
    
    // --- å…¶ä»– ---
    myAlbumTitle: 'æˆ‘çš„ç›¸å†Œ',
    albumPhotosTitle: 'ç›¸å†Œåç§°',
    npcEditorTitleAdd: 'æ·»åŠ  NPC',
    npcEditorTitleEdit: 'ç¼–è¾‘ NPC',
    npcAvatarLabel: 'NPC å¤´åƒ',
    npcUploadAvatar: 'ä¸Šä¼ å¤´åƒ',
    npcNicknameLabel: 'NPC æ˜µç§°',
    npcPersonaLabel: 'NPC äººè®¾',
    npcEnableBgActivity: 'å¯ç”¨ç‹¬ç«‹åŽå°æ´»åŠ¨',
    npcActionCooldown: 'ç‹¬ç«‹è¡ŒåŠ¨å†·å´ (åˆ†é’Ÿ)',
    npcAssociatedChars: 'å…³è”çš„è§’è‰² (NPCä¼šåŽ»è¯„è®ºè¿™äº›è§’è‰²çš„åŠ¨æ€)',
    // ... å¯ä»¥ç»§ç»­æ·»åŠ å…¶ä»–æ‰€æœ‰ç¼ºå¤±çš„æ–‡æœ¬
 
  },
  'en': {
    // ================================
    // A. Generic Terms (Expanded)
    // ================================
    save: 'Save',
    cancel: 'Cancel',
    confirm: 'Confirm',
    edit: 'Edit',
    done: 'Done',
    add: 'Add',
    back: 'Back',
    next: 'Next',
    close: 'Close',
    reset: 'Reset',
    upload: 'Upload',
    send: 'Send',
    manage: 'Manage',
    share: 'Share',
    delete: 'Delete',
    publish: 'Publish',
    refresh: 'Refresh',
    search: 'Search',
    remove: 'Remove',
    finish: 'Finish',
    details: 'Details',
    settings: 'Settings',
    title: 'Title',
    content: 'Content',
    category: 'Category',
    name: 'Name',
    description: 'Description',
    status: 'Status',
    ok: 'OK',
    error: 'Error',
    success: 'Success',
    warning: 'Warning',
    loading: 'Loading...',
    processing: 'Processing...',
    pleaseWait: 'Please wait...',
    languageChangedAlert: 'Language switched. The page will reload to apply changes.',
    
    // ================================
    // B. Screens and Components
    // ================================
    // --- Home Screen & Dock ---
    homeAppQQ: 'QQ',
    homeAppWorldBook: 'World Book',
    homeAppAppearance: 'Appearance',
    homeAppRenderer: 'Renderer',
    homeAppApiSettings: 'Settings',
    homeAppFont: 'Fonts',
    homeAppCPhone: 'CPhone',
    homeAppDouban: 'Douban',
    homeAppPreset: 'Presets',
    homeAppTutorial: 'Tutorial',
    homeAppWerewolf: 'Werewolf',
    homeAppX: 'X',

    // --- Chat List Screen ---
    chatListTitle: 'Messages',
    navMessages: 'Messages',
    navQzone: 'Moments',
    navMemories: 'Memories',
    navFavorites: 'Favorites',
    navNpcList: 'NPCs',

    // --- QZone & Moments ---
    qzoneTitle: 'Moments',
    qzoneActionShuoshuo: 'Status',
    qzoneActionPost: 'Post',
    qzoneActionAlbum: 'Album',
    
    // --- CPhone (Character's Phone) ---
    cphoneTitleSelect: 'Select a Phone',
    cphoneAppQQ: 'QQ',
    cphoneAppAlbum: 'Album',
    cphoneAppBrowser: 'Browser',
    cphoneAppTaobao: 'Taobao',
    cphoneAppMemo: 'Memo',
    cphoneAppDiary: 'Diary',
    cphoneAppAmap: 'Amap',
    cphoneAppUsage: 'App Usage',
    cphoneAppMusic: 'Music',
    cphoneAppEphone: 'Ephone',
    cphoneAppFootprints: 'Footprints',
    cphoneAlbumTitle: 'Their Album',
    cphoneBrowserTitle: 'Their Browser History',
    cphoneTaobaoTitle: 'Their Taobao Orders',
    cphoneWalletTitle: 'Wallet',
    cphoneMemoTitle: 'Memo',
    cphoneDiaryTitle: 'Diary',
    cphoneUsageTitle: 'App Usage Log',
    cphoneMusicTitle: 'Their Playlist',
    cphoneArticleTitle: 'Article',
    cphoneSimulatedChatPlaceholder: 'This is a simulated chat, messages cannot be sent',

    // --- World Book ---
    worldBookTitle: 'World Book',
    worldBookEditorTitle: 'Edit World Book',
    worldBookEntryEditorTitle: 'Edit Entry',
    worldBookNameLabel: 'Book Name',
    worldBookCategoryLabel: 'Category',
    worldBookEntriesLabel: 'Content Entries',
    worldBookAddEntryBtn: '[+] Add New Entry',
    worldBookNamePlaceholder: 'Enter the name of the world book...',
    worldBookImportTitle: 'Import World Book',

    // --- Presets ---
    presetTitle: 'Presets',
    presetEditorTitle: 'Edit Preset',
    presetNameLabel: 'Preset Name',
    presetCategoryLabel: 'Category',
    presetEntriesLabel: 'Content Entries',
    presetAddEntryBtn: '[+] Add New Entry',

    // --- Tutorial ---
    tutorialTitle: 'Tutorial',
    
    // --- API Settings ---
    apiSettingsTitle: 'API Settings',
    languageLabel: 'Language',
    apiPresetManagement: 'API Preset Management',
    apiPresetSelectLabel: 'Select or Switch Preset',
    apiPrimarySettings: 'Primary API Settings (for Chat)',
    apiProxyUrlLabel: 'Proxy URL (No /v1 needed~)',
    apiKeyLabel: 'API Key',
    apiModelLabel: 'Model',
    apiFetchModelsBtn: 'Fetch Primary Models',
    apiSecondarySettings: 'Secondary API Settings (for Summarization)',
    apiSecondaryProxyUrlLabel: 'Secondary Proxy URL',
    apiSecondaryKeyLabel: 'Secondary API Key',
    apiSecondaryModelLabel: 'Secondary Model',
    apiFetchSecondaryModelsBtn: 'Fetch Secondary Models',
    apiTemperatureLabel: 'API Temperature',
    apiBgActivitySettings: 'Background Activity Settings',
    apiEnableBgActivityLabel: 'Enable Background Character Activity',
    apiBgIntervalLabel: 'Background Activity Interval (sec)',
    apiBlockCooldownLabel: 'AI Block Cooldown (hours)',
    apiTtsSettings: 'Voice Message Settings (Minimax TTS)',
    apiTtsModelLabel: 'Voice Model',
    apiPerformanceSettings: 'Performance & Display Settings',
    apiChatListRenderWindowLabel: 'Chat List Batch Load Count',
    apiChatRenderWindowLabel: 'Chat View Initial Load Count',
    apiImageGenSettings: 'Image Generation Settings',
    apiEnableImageGenLabel: 'Enable AI Image Generation',
    apiEnableNovelAILabel: 'Enable NovelAI Image Generation',
    apiNovelAIModelLabel: 'NovelAI Model',
    apiNovelAIKeyLabel: 'NovelAI API Key',
    apiNovelAIGenSettingsBtn: 'Generation Settings',
    apiNovelAITestBtn: 'Test Generation',
    apiStorageOptimization: 'Storage Optimization',
    apiCompressImagesBtn: 'Compress Local Images',
    apiSaveAllBtn: 'Save All Settings',
    apiExportDataBtn: 'Export Data',
    apiImportDataBtn: 'Import Backup File',
    apiCleanupDataBtn: 'Cleanup Redundant Data',
    apiDeleteWorldBooksBtn: 'Delete World Books',
    apiAdvancedCleanupBtn: 'Advanced Data Cleanup',
    apiCheckAndFixDataBtn: 'Data Check & Repair',
    
    // --- Chat Screen ---
    chatHeaderOnline: 'Online',
    chatHeaderLongTermMemory: 'Long-term Memory',
    chatHeaderListenTogether: 'Listen Together',
    chatHeaderChatSettings: 'Chat Settings',
    chatSelectionCancel: 'Cancel',
    chatSelectionScreenshot: 'Long Screenshot',
    chatSelectionFavorite: 'Favorite',
    chatSelectionShare: 'Share',
    chatSelectionSoftDelete: 'Delete (Notify AI)',
    chatSelectionHardDelete: 'Erase',
    chatReplyTo: 'Reply to',
    chatInputPlaceholder: 'Type a message...',
    chatWaitForReply: 'Wait for Reply',

    // --- Appearance Settings ---
    appearanceTitle: 'Appearance Settings',
    appearanceSaveAll: 'Save All Appearance Settings',

    // --- Font Settings ---
    fontSettingsTitle: 'Font Settings',
    fontPresetManagement: 'Font Preset Management',
    fontFileUrlLabel: 'Font File URL (.ttf, .otf, .woff, etc.)',
    fontPreviewLabel: 'Live Preview',
    fontPreviewText1: 'Hello World ä½ å¥½ä¸–ç•Œ',
    fontPreviewText2: 'This is a font preview effect, 12345.',
    fontSaveAndApply: 'Save and Apply',
    fontResetDefault: 'Reset to Default Font',
    
    // --- Renderer ---
    rendererTitle: 'Rendering Rules',
    rendererEditorTitle: 'Edit Rule',
    rendererCreateTitle: 'Create New Rule',
    rendererRuleName: 'Rule Name',
    rendererBindScope: 'Binding Scope',
    rendererScopeGlobal: 'Global (All Characters)',
    rendererRegex: 'Regular Expression (use g flag)',
    rendererHtmlTemplate: 'HTML Template (use $1, $2)',
    rendererEnableRule: 'Enable Rule',

    // --- Others ---
    myAlbumTitle: 'My Albums',
    albumPhotosTitle: 'Album Name',
    npcEditorTitleAdd: 'Add NPC',
    npcEditorTitleEdit: 'Edit NPC',
    npcAvatarLabel: 'NPC Avatar',
    npcUploadAvatar: 'Upload Avatar',
    npcNicknameLabel: 'NPC Nickname',
    npcPersonaLabel: 'NPC Persona',
    npcEnableBgActivity: 'Enable Independent Background Activity',
    npcActionCooldown: 'Independent Action Cooldown (min)',
    npcAssociatedChars: 'Associated Characters (NPC will comment on their moments)',
    // ... You can continue adding all other missing texts
  }
};

let currentLanguage = 'zh-CN';

function setLanguage(lang) {
    if (!translations[lang]) {
        console.warn(`Language "${lang}" not found. Defaulting to 'zh-CN'.`);
        lang = 'zh-CN';
    }
    currentLanguage = lang;
    localStorage.setItem('ephone-language', lang);
    document.documentElement.lang = lang;

    document.querySelectorAll('[data-lang-key]').forEach(el => {
        const key = el.getAttribute('data-lang-key');
        if (translations[lang][key]) {
            el.textContent = translations[lang][key];
        }
    });

    document.querySelectorAll('[data-lang-key-placeholder]').forEach(el => {
        const key = el.getAttribute('data-lang-key-placeholder');
        if (translations[lang][key]) {
            el.placeholder = translations[lang][key];
        }
    });
    
    document.querySelectorAll('[data-lang-key-title]').forEach(el => {
        const key = el.getAttribute('data-lang-key-title');
        if (translations[lang][key]) {
            el.title = translations[lang][key];
        }
    });
}

function initLanguage() {
    const savedLang = localStorage.getItem('ephone-language') || 'zh-CN';
    const langSelector = document.getElementById('language-select');

    if (langSelector) {
        langSelector.value = savedLang;
        langSelector.addEventListener('change', (e) => {
            const newLang = e.target.value;
            alert(translations[newLang].languageChangedAlert);
            localStorage.setItem('ephone-language', newLang);
            setTimeout(() => window.location.reload(), 100);
        });
    }
    setLanguage(savedLang);
}

    (function() {
        'use strict';
        
        // ä¸‹è½½å›¾ç‰‡çš„æ ¸å¿ƒå‡½æ•°
        function downloadImage(imageSrc, filename) {
            try {
                // åˆ›å»ºä¸€ä¸ªéšè—çš„ä¸‹è½½é“¾æŽ¥
                const link = document.createElement('a');
                link.href = imageSrc;
                link.download = filename;
                link.style.display = 'none';
                
                document.body.appendChild(link);
                link.click();  // è§¦å‘ä¸‹è½½
                
                // çŸ­æš‚å»¶è¿ŸåŽç§»é™¤é“¾æŽ¥
                setTimeout(() => {
                    document.body.removeChild(link);
                }, 100);
                
                console.log('âœ… [NAIä¸‹è½½] å¼€å§‹ä¸‹è½½å›¾ç‰‡:', filename);
                
                // æ˜¾ç¤ºä¸‹è½½æç¤º
                showDownloadToast();
            } catch (error) {
                console.error('âŒ [NAIä¸‹è½½] ä¸‹è½½å¤±è´¥:', error);
                showDownloadToast('ä¸‹è½½å¤±è´¥ï¼Œè¯·é‡è¯•', 'error');
            }
        }
        
        // æ˜¾ç¤ºä¸‹è½½æç¤ºï¼ˆä¸´æ—¶Toastï¼‰
        function showDownloadToast(message = 'ðŸ“¥ å›¾ç‰‡ä¸‹è½½ä¸­...', type = 'success') {
            const toast = document.createElement('div');
            toast.textContent = message;
            toast.style.cssText = `
                position: fixed;
                bottom: 20px;
                right: 20px;
                background: ${type === 'success' ? '#4CAF50' : '#f44336'};
                color: white;
                padding: 12px 24px;
                border-radius: 8px;
                box-shadow: 0 4px 12px rgba(0,0,0,0.3);
                z-index: 10000;
                font-size: 14px;
                pointer-events: none;
                opacity: 0;
                transform: translateY(20px);
                transition: all 0.3s ease;
            `;
            
            document.body.appendChild(toast);
            
            // åŠ¨ç”»è¿›å…¥
            setTimeout(() => {
                toast.style.opacity = '1';
                toast.style.transform = 'translateY(0)';
            }, 10);
            
            // 2ç§’åŽæ·¡å‡ºå¹¶ç§»é™¤
            setTimeout(() => {
                toast.style.opacity = '0';
                toast.style.transform = 'translateY(-20px)';
                setTimeout(() => {
                    toast.remove();
                }, 300);
            }, 2000);
        }
        
        // ç”Ÿæˆæ™ºèƒ½æ–‡ä»¶å
        function generateFilename(imgElement) {
            // å°è¯•ä»Žtitleå±žæ€§èŽ·å–promptï¼ˆç”¨äºŽæ–‡ä»¶åï¼‰
            const title = imgElement.getAttribute('title') || imgElement.getAttribute('alt') || '';
            
            // æ¸…ç†titleï¼Œæå–å‰30ä¸ªæœ‰æ•ˆå­—ç¬¦
            let cleanTitle = title
                .replace(/[^a-zA-Z0-9\u4e00-\u9fa5\s]/g, '_')  // ä¿ç•™ä¸­è‹±æ–‡å­—æ¯æ•°å­—å’Œç©ºæ ¼
                .replace(/\s+/g, '_')  // ç©ºæ ¼è½¬ä¸‹åˆ’çº¿
                .substring(0, 30);
            
            if (!cleanTitle) {
                cleanTitle = 'NAI_Image';
            }
            
            // æ·»åŠ æ—¶é—´æˆ³ï¼ˆç²¾ç¡®åˆ°ç§’ï¼‰
            const timestamp = new Date().toISOString()
                .replace(/[-:]/g, '')
                .replace('T', '_')
                .split('.')[0];  // æ ¼å¼ï¼š20250124_123045
            
            // ç”Ÿæˆæ–‡ä»¶å
            return `${cleanTitle}_${timestamp}.png`;
        }
        
        // ä¸ºå›¾ç‰‡æ·»åŠ åŒå‡»æ—¶çš„è§†è§‰åé¦ˆ
        function addVisualFeedback(imgElement) {
            const originalTransform = imgElement.style.transform || '';
            const originalTransition = imgElement.style.transition || '';
            
            // æ·»åŠ ç¼©æ”¾åŠ¨ç”»
            imgElement.style.transition = 'transform 0.15s ease';
            imgElement.style.transform = 'scale(0.95)';
            
            setTimeout(() => {
                imgElement.style.transform = originalTransform;
                setTimeout(() => {
                    imgElement.style.transition = originalTransition;
                }, 150);
            }, 150);
        }
        
        // ä¸‰å‡»æ£€æµ‹ç›¸å…³å˜é‡
        let clickCount = 0;
        let clickTimer = null;
        let lastClickedElement = null;
        
        // å…¨å±€äº‹ä»¶ç›‘å¬å™¨ï¼ˆäº‹ä»¶å§”æ‰˜ - ä¸‰å‡»è§¦å‘ï¼‰
        document.addEventListener('click', function(e) {
            const target = e.target;
            
            // æ£€æŸ¥æ˜¯å¦æ˜¯NAIå›¾ç‰‡ï¼ˆrealimag-image æˆ– naiimag-imageï¼‰
            if (target.tagName === 'IMG' && 
                (target.classList.contains('realimag-image') || 
                 target.classList.contains('naiimag-image'))) {
                
                // å¦‚æžœç‚¹å‡»çš„æ˜¯åŒä¸€ä¸ªå…ƒç´ ï¼Œå¢žåŠ è®¡æ•°
                if (target === lastClickedElement) {
                    clickCount++;
                } else {
                    // ç‚¹å‡»äº†ä¸åŒçš„å…ƒç´ ï¼Œé‡ç½®è®¡æ•°
                    clickCount = 1;
                    lastClickedElement = target;
                }
                
                // æ¸…é™¤ä¹‹å‰çš„å®šæ—¶å™¨
                if (clickTimer) {
                    clearTimeout(clickTimer);
                }
                
                // å¦‚æžœè¾¾åˆ°ä¸‰å‡»
                if (clickCount === 3) {
                    // é‡ç½®è®¡æ•°
                    clickCount = 0;
                    lastClickedElement = null;
                    
                    // é˜»æ­¢é»˜è®¤è¡Œä¸ºå’Œäº‹ä»¶å†’æ³¡
                    e.preventDefault();
                    e.stopPropagation();
                    
                    console.log('ðŸ–¼ï¸ [NAIä¸‹è½½] æ£€æµ‹åˆ°ä¸‰å‡»NAIå›¾ç‰‡');
                    
                    // æ·»åŠ è§†è§‰åé¦ˆ
                    addVisualFeedback(target);
                    
                    // èŽ·å–å›¾ç‰‡æºï¼ˆå¯èƒ½æ˜¯base64æˆ–URLï¼‰
                    const imageSrc = target.src;
                    
                    if (!imageSrc || imageSrc === 'about:blank') {
                        console.warn('âš ï¸ [NAIä¸‹è½½] å›¾ç‰‡æºä¸ºç©ºï¼Œæ— æ³•ä¸‹è½½');
                        showDownloadToast('å›¾ç‰‡åŠ è½½ä¸­ï¼Œè¯·ç¨åŽé‡è¯•', 'error');
                        return;
                    }
                    
                    // ç”Ÿæˆæ–‡ä»¶å
                    const filename = generateFilename(target);
                    
                    // è§¦å‘ä¸‹è½½
                    downloadImage(imageSrc, filename);
                } else {
                    // è®¾ç½®å®šæ—¶å™¨ï¼Œ500msåŽé‡ç½®è®¡æ•°ï¼ˆå¦‚æžœç”¨æˆ·åœæ­¢ç‚¹å‡»ï¼‰
                    clickTimer = setTimeout(() => {
                        clickCount = 0;
                        lastClickedElement = null;
                    }, 500);
                }
            }
        }, true);  // ä½¿ç”¨æ•èŽ·é˜¶æ®µï¼Œç¡®ä¿ä¼˜å…ˆå¤„ç†
        
        console.log('âœ… [NAIä¸‹è½½] ä¸‰å‡»ä¸‹è½½åŠŸèƒ½å·²åˆå§‹åŒ–');
        console.log('ðŸ’¡ [NAIä¸‹è½½] æç¤ºï¼šä¸‰å‡»ä»»æ„NAIå›¾ç‰‡å³å¯ä¸‹è½½');
    })();


if ('serviceWorker' in navigator) {
        
        window.addEventListener('load', () => {
          
          navigator.serviceWorker.register('./sw.js')
            .then(registration => {
              
              console.log('ServiceWorker æ³¨å†ŒæˆåŠŸï¼Œä½œç”¨åŸŸä¸º: ', registration.scope);
            })
            .catch(error => {
              
              console.log('ServiceWorker æ³¨å†Œå¤±è´¥: ', error);
            });
        });
      }
  
if (!Array.prototype.findLastIndex) {
  Object.defineProperty(Array.prototype, 'findLastIndex', {
    value: function(predicate) {
      if (this == null) {
        throw new TypeError('Cannot read property \'findLastIndex\' of null or undefined');
      }
      if (typeof predicate !== 'function') {
        throw new TypeError('predicate must be a function');
      }
      let o = Object(this);
      let len = o.length >>> 0;
      let thisArg = arguments[1];
      let k = len - 1;
      while (k >= 0) {
        let kValue = o[k];
        if (predicate.call(thisArg, kValue, k, o)) {
          return k;
        }
        k--;
      }
      return -1;
    },
    configurable: true,
    writable: true
  });
}

const dynamicIslandContent = document.getElementById('dynamic-island-content');
const islandAlbumArt = document.getElementById('island-album-art');
const islandLyricContainer = document.getElementById('island-lyric-container');
const islandLyricText = document.getElementById('island-lyric-text');
const phoneScreenForIsland = document.getElementById('phone-screen');
        
        let activeMessageTimestamp = null;
        let activeTransferTimestamp = null; 
         
        let lastRawAiResponse = ''; 
        let lastResponseTimestamps = []; 
        let lastPrivateMessagesSent = [];          
        let currentQzoneReplyContext = null;
        let editingNpcId = null; 
        let pendingBackupData = null;        
                const GEMINI_API_URL = 'https://generativelanguage.googleapis.com/v1beta/models'
            
            function getRandomValue(str) {
                
                if (str.includes(',')) {
                    
                    const arr = str.split(',').map(item => item.trim());
                    
                    const randomIndex = Math.floor(Math.random() * arr.length);
                    
                    return arr[randomIndex];
                }
                
                return str;
            }
            function isImage(content) {
                if(content.image_url && content.image_url.url){
                    let currentImageData = content.image_url.url
                    
                    const base64Data = currentImageData.split(',')[1];
                    
                    const mimeType = currentImageData.match(/^data:(.*);base64/)[1];
                    return [
                        {text: 'ç”¨æˆ·å‘ä½ å‘é€äº†ä¸€å¼ å›¾ç‰‡'},
                        {
                            inline_data: {
                                mime_type: mimeType,
                                data: base64Data
                            }
                        }
                    ]
                }
                return []
            }
        
        
        
        function getGeminiResponseText(data) {
            
            if (data.choices && Array.isArray(data.choices) && data.choices.length > 0 && data.choices[0].message && data.choices[0].message.content) {
                return data.choices[0].message.content;
            }
        
            
            if (data.candidates && Array.isArray(data.candidates) && data.candidates.length > 0 && data.candidates[0].content && data.candidates[0].content.parts) {
                return data.candidates[0].content.parts[0].text;
            }
        
            
            console.error("Gemini APIè¿”å›žäº†éžé¢„æœŸçš„æ ¼å¼:", data);
            let errorReason = "AIè¿”å›žäº†ç©ºå†…å®¹æˆ–æœªçŸ¥æ ¼å¼ã€‚";
        
            
            
            if (data.candidates && Array.isArray(data.candidates) && data.candidates.length > 0 && data.candidates[0].finishReason === 'SAFETY') {
                const safetyRatings = data.candidates[0].safetyRatings;
                const blockedCategories = safetyRatings
                    .filter(r => r.probability !== 'NEGLIGIBLE' && r.probability !== 'LOW')
                    .map(r => `${r.category} (æ¦‚çŽ‡: ${r.probability})`)
                    .join(', ');
                errorReason = `å†…å®¹å› å®‰å…¨ç­–ç•¥è¢«å±è”½ã€‚è§¦å‘ç±»åˆ«: ${blockedCategories || 'æœªçŸ¥'}`;
            }
            
            else if (data.promptFeedback?.blockReason) {
                const reason = data.promptFeedback.blockReason;
                const details = data.promptFeedback.safetyRatings?.map(r => `${r.category}: ${r.probability}`).join(', ');
                errorReason = `å†…å®¹å› å®‰å…¨ç­–ç•¥è¢«å±è”½ (åŽŸå› : ${reason})ã€‚è¯¦æƒ…: ${details || 'æ— '}`;
            } 
            
            else if (data.error) {
                errorReason = `APIé”™è¯¯: ${data.error.message}`;
            }
            
            
            throw new Error(errorReason);
        }
          
        

            document.addEventListener('DOMContentLoaded', () => {
document.addEventListener('visibilitychange', () => {
  // å½“åº”ç”¨ä»ŽåŽå°åˆ‡æ¢åˆ°å‰å°æ—¶
  if (document.visibilityState === 'visible') {
    console.log('åº”ç”¨å·²è¿”å›žå‰å°ï¼Œæ­£åœ¨æ£€æŸ¥æ›´æ–°...');
    // ç¡®ä¿ Service Worker å·²ç»å‡†å¤‡å¥½
    navigator.serviceWorker.ready.then(registration => {
      // é™é»˜åœ°è§¦å‘ä¸€æ¬¡æ›´æ–°æ£€æŸ¥
      registration.update();
    });
  }
});
function toGeminiRequestData(model, apiKey, systemInstruction, messagesForDecision) {
    const apiTemperature = state.globalSettings.apiTemperature || 0.8; 
    const roleType = {
        user: 'user',
        assistant: 'model',
        system: 'user'
    };

 
    const contents = [
        {
            role: 'user',
            parts: [{ text: systemInstruction }]
        },
        {
            role: 'model',
            parts: [{ text: 'å¥½çš„ï¼Œæˆ‘æ˜Žç™½äº†ã€‚æˆ‘ä¼šä¸¥æ ¼éµå®ˆä»¥ä¸Šæ‰€æœ‰è§„åˆ™å’Œè®¾å®šã€‚' }]
        },

        ...messagesForDecision.map((item) => {
            const parts = [];
            
            if (Array.isArray(item.content)) {
                item.content.forEach(part => {
                    if (part.type === 'text') {
                        parts.push({ text: part.text });
                    } else if (part.type === 'image_url' && part.image_url && part.image_url.url) {
                        
                        const currentImageData = part.image_url.url;
                        const base64Data = currentImageData.split(',')[1];
                        const mimeTypeMatch = currentImageData.match(/^data:(.*);base64/);
                        if (mimeTypeMatch && base64Data) {
                            parts.push({
                                inline_data: {
                                    mime_type: mimeTypeMatch[1],
                                    data: base64Data
                                }
                            });
                        }
                    }
                });
            } else {
                
                parts.push({ text: String(item.content) });
            }
            return { role: roleType[item.role], parts: parts };
        })
    ];

    
    return {
        url: `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${getRandomValue(apiKey)}`,
        data: {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                contents: contents,
                generationConfig: {
                    temperature: apiTemperature, 
                },
            })
        }
    };
}
  
        
                
                
                
                const db = new Dexie('GeminiChatDB');
        const avatarFrames = [ { id: 'none', url: '', name: 'æ— ' }, { id: 'frame_cat_ear', url: 'https://i.postimg.cc/fLDnz5Pn/IMG-5574.gif', name: '1' }, { id: 'frame_ribbon', url: 'https://i.postimg.cc/HxH3cNHz/IMG-6871.gif', name: '2' }, { id: 'frame_flower', url: 'https://i.postimg.cc/jCVK0fGL/IMG-6890.gif', name: '3' }, { id: 'frame_tech', url: 'https://i.postimg.cc/85Zsyjwn/IMG-6895.gif', name: '4' }, { id: 'frame_5', url: 'https://i.postimg.cc/cJtpZCB3/IMG-6894.gif', name: '5' }, { id: 'frame_6', url: 'https://i.postimg.cc/63sDQKMm/IMG-6893.gif', name: '6' }, { id: 'frame_7', url: 'https://i.postimg.cc/cHQPgzj4/IMG-6888.gif', name: '7' }, { id: 'frame_8', url: 'https://i.postimg.cc/dVLXm3Xf/IMG-6885.gif', name: '8' }, { id: 'frame_9', url: 'https://i.postimg.cc/kGsZwbq0/IMG-6886.gif', name: '9' }, { id: 'frame_10', url: 'https://i.postimg.cc/63NmX03s/IMG-4366.gif', name: '10' }, { id: 'frame_11', url: 'https://i.postimg.cc/zvz2LGK0/IMG-4367.gif', name: '11' }, { id: 'frame_12', url: 'https://i.postimg.cc/prsGKMBx/IMG-4370.gif', name: '12' }, { id: 'frame_13', url: 'https://i.postimg.cc/gk0BmrY0/IMG-4371.gif', name: '13' }, { id: 'frame_14', url: 'https://i.postimg.cc/fRt2SFSn/IMG-4368.gif', name: '14' }, { id: 'frame_cat_ear', url: 'https://i.postimg.cc/kGgwJhPH/IMG-4374.gif', name: '1' }, { id: 'frame_ribbon', url: 'https://i.postimg.cc/PrcKH436/IMG-4376.gif', name: '2' }, { id: 'frame_flower', url: 'https://i.postimg.cc/fRV86FMq/IMG-4381.gif', name: '3' }, { id: 'frame_tech', url: 'https://i.postimg.cc/HsyqMVyk/IMG-4385.gif', name: '4' }, { id: 'frame_5', url: 'https://i.postimg.cc/qBbKK7dS/IMG-4386.gif', name: '5' }, { id: 'frame_6', url: 'https://i.postimg.cc/05wnd389/IMG-4388.gif', name: '6' }, { id: 'frame_7', url: 'https://i.postimg.cc/RZNLhbbr/IMG-4389.gif', name: '7' }, { id: 'frame_8', url: 'https://i.postimg.cc/fLTc42dg/IMG-4391.gif', name: '8' }, { id: 'frame_9', url: 'https://i.postimg.cc/FzbGNdRT/IMG-4392.gif', name: '9' }, { id: 'frame_10', url: 'https://i.postimg.cc/XY63sTS3/IMG-4393.gif', name: '10' }, { id: 'frame_11', url: 'https://i.postimg.cc/Cx9vCVWH/IMG-4395.gif', name: '11' }, { id: 'frame_12', url: 'https://i.postimg.cc/kMfPQBwQ/IMG-4396.gif', name: '12' }, { id: 'frame_13', url: 'https://i.postimg.cc/CLrZQMMD/IMG-4398.gif', name: '13' }, { id: 'frame_14', url: 'https://i.postimg.cc/L4zwDhTC/IMG-4399.gif', name: '14' }, { id: 'frame_cat_ear', url: 'https://i.postimg.cc/yN3s8szM/IMG-4400.gif', name: '1' }, { id: 'frame_ribbon', url: 'https://i.postimg.cc/59Cn1tkB/IMG-4401.gif', name: '2' }, { id: 'frame_flower', url: 'https://i.postimg.cc/g0s1V0PX/IMG-4402.gif', name: '3' }, { id: 'frame_tech', url: 'https://i.postimg.cc/Jn1DFPgY/IMG-4403.gif', name: '4' }, { id: 'frame_5', url: 'https://i.postimg.cc/q7cQnDy1/IMG-4404.gif', name: '5' }, { id: 'frame_6', url: 'https://i.postimg.cc/RFK3q2t0/IMG-4407.gif', name: '6' }, { id: 'frame_7', url: 'https://i.postimg.cc/gcV0VR2t/IMG-4408.gif', name: '7' }, { id: 'frame_8', url: 'https://i.postimg.cc/W1CjLb4J/IMG-4409.gif', name: '8' }, { id: 'frame_9', url: 'https://i.postimg.cc/Ss7pM6fW/IMG-4410.gif', name: '9' }, { id: 'frame_10', url: 'https://i.postimg.cc/nrFfYX3N/IMG-4412.gif', name: '10' }, { id: 'frame_11', url: 'https://i.postimg.cc/cHWp0KG6/IMG-4413.gif', name: '11' }, { id: 'frame_12', url: 'https://i.postimg.cc/4yNjHrdg/IMG-4414.gif', name: '12' }, { id: 'frame_13', url: 'https://i.postimg.cc/hPX5F8Qp/IMG-4415.gif', name: '13' }, { id: 'frame_14', url: 'https://i.postimg.cc/vHCSG1WM/IMG-4416.gif', name: '14' }, { id: 'frame_cat_ear', url: 'https://i.postimg.cc/x1Hp80Rm/IMG-4417.gif', name: '1' }, { id: 'frame_ribbon', url: 'https://i.postimg.cc/FHRcCGfH/IMG-4418.gif', name: '2' }, { id: 'frame_flower', url: 'https://i.postimg.cc/13hhJ77p/IMG-4419.gif', name: '3' }, { id: 'frame_tech', url: 'https://i.postimg.cc/J4WCQd2j/IMG-4420.gif', name: '4' }, { id: 'frame_5', url: 'https://i.postimg.cc/Dydkpd9H/IMG-4421.gif', name: '5' }, { id: 'frame_6', url: 'https://i.postimg.cc/mrkvDxPW/IMG-4422.gif', name: '6' }, { id: 'frame_7', url: 'https://i.postimg.cc/76Tj3g1B/IMG-4425.gif', name: '7' }, { id: 'frame_8', url: 'https://i.postimg.cc/3N5Vndn3/IMG-4426.gif', name: '8' }, { id: 'frame_9', url: 'https://i.postimg.cc/05DLr0yj/IMG-4427.gif', name: '9' }, { id: 'frame_10', url: 'https://i.postimg.cc/GhR6DT4Q/IMG-4428.gif', name: '10' }, { id: 'frame_11', url: 'https://i.postimg.cc/fRTF24jS/IMG-4430.gif', name: '11' }, { id: 'frame_12', url: 'https://i.postimg.cc/R0WYmcYM/IMG-4431.gif', name: '12' }, { id: 'frame_13', url: 'https://i.postimg.cc/nrJSqNhz/IMG-4432.gif', name: '13' }, { id: 'frame_14', url: 'https://i.postimg.cc/tC9mJ0cv/IMG-4438.gif', name: '14' }, { id: 'frame_cat_ear', url: 'https://i.postimg.cc/XNkQTHvf/IMG-5561.gif', name: '1' }, { id: 'frame_ribbon', url: 'https://i.postimg.cc/Mpv5fzm5/IMG-4439.gif', name: '2' }, { id: 'frame_flower', url: 'https://i.postimg.cc/T1tjhsyB/IMG-4720.gif', name: '3' }, { id: 'frame_tech', url: 'https://i.postimg.cc/c4JMPd2W/IMG-4724.gif', name: '4' }, { id: 'frame_5', url: 'https://i.postimg.cc/g2XykNGB/IMG-4727.gif', name: '5' }, { id: 'frame_6', url: 'https://i.postimg.cc/y8MmJcd6/IMG-4728.gif', name: '6' }, { id: 'frame_7', url: 'https://i.postimg.cc/Lsjzj5Yt/IMG-4729.gif', name: '7' }, { id: 'frame_8', url: 'https://i.postimg.cc/bNdk33SN/IMG-4893.gif', name: '8' }, { id: 'frame_9', url: 'https://i.postimg.cc/4x9tTy1D/IMG-5563.gif', name: '9' }, { id: 'frame_10', url: 'https://i.postimg.cc/DZshzKv6/IMG-5576.gif', name: '10' }, { id: 'frame_11', url: 'https://i.postimg.cc/Fsvr71JL/IMG-5573.gif', name: '11' }, { id: 'frame_12', url: 'https://i.postimg.cc/Fz3HwLk9/IMG-5569.gif', name: '12' }, { id: 'frame_13', url: 'https://i.postimg.cc/wjH180kn/IMG-5566.gif', name: '13' }, { id: 'frame_14', url: 'https://i.postimg.cc/MG6qtLYK/IMG-5565.gif', name: '14' }, { id: 'frame_cat_ear', url: 'https://i.postimg.cc/CKgDNYVb/IMG-5577.gif', name: '1' }, { id: 'frame_ribbon', url: 'https://i.postimg.cc/hj4dkrvj/IMG-5578.gif', name: '2' }, { id: 'frame_flower', url: 'https://i.postimg.cc/hj4dkrvj/IMG-5578.gif', name: '3' }, { id: 'frame_tech', url: 'https://i.postimg.cc/C5XnfpNB/IMG-5579.gif', name: '4' }, { id: 'frame_5', url: 'https://i.postimg.cc/4y7mGFgJ/IMG-5716.gif', name: '5' }, { id: 'frame_6', url: 'https://i.postimg.cc/FzM1Hgr0/IMG-5717.gif', name: '6' }, { id: 'frame_7', url: 'https://i.postimg.cc/rF4KYbjj/IMG-5720.gif', name: '7' }, { id: 'frame_8', url: 'https://i.postimg.cc/6pLTBvDG/IMG-5721.gif', name: '8' }, { id: 'frame_9', url: 'https://i.postimg.cc/VNK6Ccsf/IMG-5722.gif', name: '9' }, { id: 'frame_10', url: 'https://i.postimg.cc/wx72fhr2/IMG-5968.gif', name: '10' }, { id: 'frame_11', url: 'https://i.postimg.cc/QdrqdvdY/IMG-5969.gif', name: '11' }, { id: 'frame_12', url: 'https://i.postimg.cc/0yd0MZ6k/IMG-5971.gif', name: '12' }, { id: 'frame_13', url: 'https://i.postimg.cc/1zmcp66p/IMG-5973.gif', name: '13' }, { id: 'frame_14', url: 'https://i.postimg.cc/wBw5Fvcn/IMG-5974.gif', name: '14' }, { id: 'frame_cat_ear', url: 'https://i.postimg.cc/R0pfKYvB/IMG-5976.gif', name: '1' }, { id: 'frame_ribbon', url: 'https://i.postimg.cc/9fQZ425b/IMG-5975.gif', name: '2' }, { id: 'frame_flower', url: 'https://i.postimg.cc/v8V9xXjJ/IMG-6137.gif', name: '3' }, { id: 'frame_tech', url: 'https://i.postimg.cc/WbmkXzsS/IMG-6138.gif', name: '4' }, { id: 'frame_5', url: 'https://i.postimg.cc/Dw2bDhZh/IMG-6140.gif', name: '5' }, { id: 'frame_6', url: 'https://i.postimg.cc/ZqQBCyLY/IMG-6144.gif', name: '6' }, { id: 'frame_7', url: 'https://i.postimg.cc/qRCtnMms/IMG-6145.gif', name: '7' }, { id: 'frame_8', url: 'https://i.postimg.cc/1Rwn3XVP/IMG-6146.gif', name: '8' }, { id: 'frame_9', url: 'https://i.postimg.cc/Kv51tW5H/IMG-6147.gif', name: '9' }, { id: 'frame_10', url: 'https://i.postimg.cc/nhcC21Rc/IMG-6148.gif', name: '10' }, { id: 'frame_11', url: 'https://i.postimg.cc/fTWzQRx8/IMG-6149.gif', name: '11' }, { id: 'frame_12', url: 'https://i.postimg.cc/LXyyqDbY/IMG-6294.gif', name: '12' }, { id: 'frame_13', url: 'https://i.postimg.cc/7Zgm1wRy/IMG-6295.gif', name: '13' }, { id: 'frame_14', url: 'https://i.postimg.cc/5tbpnDcQ/IMG-6296.gif', name: '14' }, { id: 'frame_cat_ear', url: 'https://i.postimg.cc/YSRRV8kn/IMG-6297.gif', name: '1' }, { id: 'frame_ribbon', url: 'https://i.postimg.cc/k45sd8gn/IMG-6375.gif', name: '2' }, { id: 'frame_flower', url: 'https://i.postimg.cc/50k390X8/IMG-6376.gif', name: '3' }, { id: 'frame_tech', url: 'https://i.postimg.cc/90RBDh9K/IMG-6377.gif', name: '4' }, { id: 'frame_5', url: 'https://i.postimg.cc/cCpBYbMH/IMG-6552.gif', name: '5' }, { id: 'frame_6', url: 'https://i.postimg.cc/Pf9g2fSL/IMG-6554.gif', name: '6' }, { id: 'frame_7', url: 'https://i.postimg.cc/gkhf597g/IMG-6555.gif', name: '7' }, { id: 'frame_8', url: 'https://i.postimg.cc/g2PfbSFm/IMG-6556.gif', name: '8' }, { id: 'frame_9', url: 'https://i.postimg.cc/pLY3WfR8/IMG-6557.gif', name: '9' }, { id: 'frame_10', url: 'https://i.postimg.cc/65Cmcr7S/IMG-6559.gif', name: '10' }, { id: 'frame_11', url: 'https://i.postimg.cc/Y94XWYKd/IMG-6560.gif', name: '11' }, { id: 'frame_12', url: 'https://i.postimg.cc/ydwLXx7s/IMG-6562.gif', name: '12' }, { id: 'frame_13', url: 'https://i.postimg.cc/G3y73Fj2/IMG-6563.gif', name: '13' }, { id: 'frame_14', url: 'https://i.postimg.cc/TYvkKKkc/IMG-6565.gif', name: '14' }, { id: 'frame_cat_ear', url: 'https://i.postimg.cc/GmcqjZn8/IMG-6566.gif', name: '1' }, { id: 'frame_ribbon', url: 'https://i.postimg.cc/k5Gs0K47/IMG-6567.gif', name: '2' }, { id: 'frame_flower', url: 'https://i.postimg.cc/XJy8JWdh/IMG-6568.gif', name: '3' }, { id: 'frame_tech', url: 'https://i.postimg.cc/fycfcvHf/IMG-6569.gif', name: '4' }, { id: 'frame_5', url: 'https://i.postimg.cc/J7ZxC11H/IMG-6570.gif', name: '5' }, { id: 'frame_6', url: 'https://i.postimg.cc/hPnrSHjy/IMG-4434.gif', name: '6' }, { id: 'frame_7', url: 'https://i.postimg.cc/YqxxjbLp/IMG-6572.gif', name: '7' }, { id: 'frame_8', url: 'https://i.postimg.cc/wjfcQMkZ/IMG-6573.gif', name: '8' }, { id: 'frame_9', url: 'https://i.postimg.cc/Vv8jkCYr/IMG-6574.gif', name: '9' }, { id: 'frame_10', url: 'https://i.postimg.cc/MZ77rdDy/IMG-6850.gif', name: '10' }, { id: 'frame_11', url: 'https://i.postimg.cc/T3NvqJCZ/IMG-6851.gif', name: '11' }, { id: 'frame_12', url: 'https://i.postimg.cc/28TsrxRV/IMG-6852.gif', name: '12' }, { id: 'frame_13', url: 'https://i.postimg.cc/VkV2bLNw/IMG-6853.gif', name: '13' }, { id: 'frame_14', url: 'https://i.postimg.cc/gJ95NSRB/IMG-6854.gif', name: '14' }, { id: 'frame_cat_ear', url: 'https://i.postimg.cc/d1qsQsbQ/IMG-6855.gif', name: '1' }, { id: 'frame_ribbon', url: 'https://i.postimg.cc/gJNYx9pV/IMG-6856.gif', name: '2' }, { id: 'frame_flower', url: 'https://i.postimg.cc/fyPDvxJk/IMG-6860.gif', name: '3' }, { id: 'frame_tech', url: 'https://i.postimg.cc/QMDsSNxg/IMG-6861.gif', name: '4' }, { id: 'frame_5', url: 'https://i.postimg.cc/vBqsQW7X/IMG-6858.gif', name: '5' }, { id: 'frame_6', url: 'https://i.postimg.cc/Y0vwjhb7/IMG-6857.gif', name: '6' }, { id: 'frame_7', url: 'https://i.postimg.cc/90sH9Cn7/IMG-6868.gif', name: '7' }, { id: 'frame_8', url: 'https://i.postimg.cc/Y2PHZzCC/IMG-6866.gif', name: '8' }, { id: 'frame_9', url: 'https://i.postimg.cc/7Z8yYP7v/IMG-6889.gif', name: '9' }, { id: 'frame_10', url: 'https://i.postimg.cc/nryNzTXK/IMG-6915.gif', name: '10' }, { id: 'frame_11', url: 'https://i.postimg.cc/Qx5dqyJ3/IMG-6917.gif', name: '11' }, { id: 'frame_12', url: 'https://i.postimg.cc/Wbr0JSDD/IMG-5316.gif', name: '12' }, { id: 'frame_13', url: 'https://i.postimg.cc/tgR6wjBP/IMG-5570.gif', name: '13' }, { id: 'frame_14', url: 'https://i.postimg.cc/d0WCKxff/IMG-6932.gif', name: '14' }, { id: 'frame_11', url: 'https://i.postimg.cc/Ss3znzk7/IMG-6934.gif', name: '11' }, { id: 'frame_12', url: 'https://i.postimg.cc/nrm9BcL8/IMG-6941.gif', name: '12' }, { id: 'frame_13', url: 'https://i.postimg.cc/ZYvd1jxf/IMG-6937.gif', name: '13' }, { id: 'frame_14', url: 'https://i.postimg.cc/sDFhySn3/IMG-6936.gif', name: '14' }, { id: 'frame_13', url: 'https://i.postimg.cc/43PhvxRq/IMG-6922.gif', name: '13' }, { id: 'frame_14', url: 'https://i.postimg.cc/3Rb46fRZ/IMG-6923.gif', name: '14' }, { id: 'frame_13', url: 'https://i.postimg.cc/PJppkbvn/IMG-6918.gif', name: '13' }, { id: 'frame_14', url: 'https://i.postimg.cc/XqRZNZ9G/IMG-6916.gif', name: '14' }, { id: 'frame_14', url: 'https://i.postimg.cc/RVt6sRzc/IMG-6939.gif', name: '14' }, { id: 'frame_13', url: 'https://i.postimg.cc/mgGc0HbK/IMG-6926.gif', name: '13' }, { id: 'frame_14', url: 'https://i.postimg.cc/P5zLh5JJ/IMG-6942.gif', name: '14' }, { id: 'frame_14', url: 'https://i.postimg.cc/xCqqKGRN/IMG-6929.gif', name: '14' },
              { id: 'frame_12', url: 'https://i.postimg.cc/7LSRp4hx/e7fa949b9pc84cff0dabe57defceb54c.gif', name: '12' },
            { id: 'frame_13', url: 'https://i.postimg.cc/DZgMwc1H/817178fdbpf2ff7740dc98e26ab78759.gif', name: '13' },
            { id: 'frame_14', url: 'https://i.postimg.cc/3NffgJSZ/e09c07034ld7e62266c0a5de6a36ae62.gif', name: '14' },
          { id: 'frame_13', url: 'https://i.postimg.cc/vHDNGfT2/35ac7f372v588bf48d4f659077196b85.gif', name: '13' },
            { id: 'frame_14', url: 'https://i.postimg.cc/KvVsjjgG/3c3aa5219s18b90187ef1f54b3db7ba8.gif', name: '14' },
          { id: 'frame_13', url: 'https://i.postimg.cc/k5P1NHcL/55f3e31d8qbc8a02d152b07b99d31567.gif', name: '13' },
            { id: 'frame_14', url: 'https://i.postimg.cc/FFCTCzpy/641bad3b3udc599fdb63ca75fde427e5.gif', name: '14' },
          { id: 'frame_14', url: 'https://i.postimg.cc/8k7YSLjK/1689aa46aqc4b9ffc0f970e668f56537.gif', name: '14' },
          { id: 'frame_13', url: 'https://i.postimg.cc/J0CZSwyW/IMG-6938.gif', name: '13' },
            { id: 'frame_14', url: 'https://i.postimg.cc/Df1qLzDf/IMG-6927.gif', name: '14' },
          { id: 'frame_14', url: 'https://i.postimg.cc/CLNkrQSW/IMG-6925.gif', name: '14' },
          { id: 'frame_13', url: 'https://i.postimg.cc/y8p9s3Jj/IMG-6919.gif', name: '13' },
            { id: 'frame_14', url: 'https://i.postimg.cc/Lsr1Zd3Z/IMG-6928.gif', name: '14' },
          { id: 'frame_14', url: 'https://i.postimg.cc/Ssgbv41n/IMG-6876.gif', name: '14' },
        { id: 'frame_14', url: 'https://i.postimg.cc/SNByPrf9/IMG-7005.gif', name: '14' },
          { id: 'frame_13', url: 'https://i.postimg.cc/Z5nrCyS5/IMG-7006.gif', name: '13' },
            { id: 'frame_14', url: 'https://i.postimg.cc/mDfMXXFP/IMG-7007.gif', name: '14' },
          { id: 'frame_14', url: 'https://i.postimg.cc/DZrGtrqB/IMG-7008.gif', name: '14' },
          { id: 'frame_13', url: 'https://i.postimg.cc/ZnJNZWHZ/IMG-7009.gif', name: '13' },
            { id: 'frame_14', url: 'https://i.postimg.cc/RhGH0vpt/IMG-7010.gif', name: '14' },
          { id: 'frame_14', url: 'https://i.postimg.cc/tRzPkzRg/IMG-7012.gif', name: '14' },
          { id: 'frame_13', url: 'https://i.postimg.cc/wTTNGs3Q/IMG-7013.gif', name: '13' },
            { id: 'frame_14', url: 'https://i.postimg.cc/3JSG5Jv5/IMG-7014.gif', name: '14' },
          { id: 'frame_14', url: 'https://i.postimg.cc/rwDr8X1d/IMG-7015.gif', name: '14' },
        { id: 'frame_14', url: 'https://i.postimg.cc/DzDy2vS7/IMG-7017.gif', name: '14' },
          { id: 'frame_13', url: 'https://i.postimg.cc/QMVdG9x6/IMG-7016.gif', name: '13' },
            { id: 'frame_14', url: 'https://i.postimg.cc/mZ9hgH3J/IMG-7019.gif', name: '14' },
          { id: 'frame_14', url: 'https://i.postimg.cc/t4ksHGdg/IMG-7020.gif', name: '14' },
          { id: 'frame_13', url: 'https://i.postimg.cc/hP9JpdfT/IMG-7023.gif', name: '13' },
            { id: 'frame_14', url: 'https://i.postimg.cc/wTKyXVT9/IMG-7024.gif', name: '14' },
          { id: 'frame_14', url: 'https://i.postimg.cc/ZqjKXPSv/IMG-7025.gif', name: '14' },
        
          { id: 'frame_14', url: 'https://i.postimg.cc/gj3Tmqz5/mmexport1751030241029.gif', name: '14' },
          { id: 'frame_13', url: 'https://i.postimg.cc/4yCXW52F/mmexport1751030908335.gif', name: '13' },
            { id: 'frame_14', url: 'https://i.postimg.cc/VkXngG72/mmexport1751031208329.gif', name: '14' },
          { id: 'frame_14', url: 'https://i.postimg.cc/LscBkxZb/mmexport1751017556565.gif', name: '14' },
          { id: 'frame_13', url: 'https://i.postimg.cc/1XqzGKwJ/mmexport1751018282681.gif', name: '13' },
            { id: 'frame_14', url: 'https://i.postimg.cc/8kHCQwbQ/mmexport1751020645824.gif', name: '14' },
          { id: 'frame_14', url: 'https://i.postimg.cc/HWynLK7f/mmexport1751021724230.gif', name: '14' },
        { id: 'frame_14', url: 'https://i.postimg.cc/JnwFp3Kx/mmexport1751031208329.gif', name: '14' },
          { id: 'frame_13', url: 'https://i.postimg.cc/HLZNWkQw/mmexport1751031767634.gif', name: '13' },
            { id: 'frame_14', url: 'https://i.postimg.cc/vH2X6N1y/mmexport1751032231179.gif', name: '14' },
          { id: 'frame_14', url: 'https://i.postimg.cc/NFS4ZyvM/mmexport1751032686953.gif', name: '14' },
          { id: 'frame_13', url: 'https://i.postimg.cc/3RpmWc8c/mmexport1751033102811.gif', name: '13' },
            { id: 'frame_14', url: 'https://i.postimg.cc/L5RLr3tg/mmexport1751035976943.gif', name: '14' },
          { id: 'frame_14', url: 'https://i.postimg.cc/4NCPsp5d/mmexport1751034427637.gif', name: '14' },
        { id: 'frame_14', url: 'https://i.postimg.cc/CMv02LHm/mmexport1751034842120.gif', name: '14' },
          { id: 'frame_13', url: 'https://i.postimg.cc/rFnSzWGx/mmexport1751035618517.gif', name: '13' },
            { id: 'frame_14', url: 'https://i.postimg.cc/7YRbzN51/mmexport1751036276038.gif', name: '14' },
          { id: 'frame_14', url: 'https://i.postimg.cc/cJpbtPWq/mmexport1751036607799.gif', name: '14' },
          { id: 'frame_13', url: 'https://i.postimg.cc/HxLV5v92/mmexport1751036977582.gif', name: '13' },
            { id: 'frame_14', url: 'https://i.postimg.cc/D01rYy86/mmexport1751037965259.gif', name: '14' },
          { id: 'frame_14', url: 'https://i.postimg.cc/J4fwkTLW/mmexport1751038167142.gif', name: '14' },
          
          
        { id: 'frame_14', url: 'https://i.postimg.cc/xjpN4swz/IMG-7240.gif', name: '14' },
          { id: 'frame_13', url: 'https://i.postimg.cc/ZnzbGdxX/IMG-7239.gif', name: '13' },
            { id: 'frame_14', url: 'https://i.postimg.cc/DyYDmKtw/IMG-7238.gif', name: '14' },
          { id: 'frame_14', url: 'https://i.postimg.cc/W40f9qtd/IMG-7098.gif', name: '14' },
          { id: 'frame_13', url: 'https://i.postimg.cc/8PsK20jQ/IMG-7236.gif', name: '13' },
            { id: 'frame_14', url: 'https://i.postimg.cc/cHsTXDVz/IMG-7235.gif', name: '14' },
          { id: 'frame_14', url: 'https://i.postimg.cc/sXwm8Yzg/IMG-7234.gif', name: '14' },
        { id: 'frame_14', url: 'https://i.postimg.cc/xTk5xN49/IMG-7233.gif', name: '14' },
          { id: 'frame_13', url: 'https://i.postimg.cc/k5yv6QBv/IMG-7232.gif', name: '13' },
            { id: 'frame_14', url: 'https://i.postimg.cc/yx2m4nbs/IMG-7231.gif', name: '14' },
          { id: 'frame_14', url: 'https://i.postimg.cc/vZt0fFKn/IMB-r-HMBXY.gif', name: '14' },
          { id: 'frame_13', url: 'https://i.postimg.cc/pddJj9zN/IMG-7094.gif', name: '13' },
            { id: 'frame_14', url: 'https://i.postimg.cc/rmB17Qbc/IMB-f-VDf-Fc.gif', name: '14' },
          { id: 'frame_14', url: 'https://i.postimg.cc/VkKjzYTK/IMB-f4kk-CT.gif', name: '14' },
        { id: 'frame_14', url: 'https://i.postimg.cc/B6KD52vz/IMG-7096.gif', name: '14' },
          { id: 'frame_13', url: 'https://i.postimg.cc/9XPwWmwy/IMB-Kf7um-P.gif', name: '13' },
            { id: 'frame_14', url: 'https://i.postimg.cc/mrFhKBGz/IMB-e-QWBpa.gif', name: '14' },
          { id: 'frame_14', url: 'https://i.postimg.cc/bw4wxW2z/IMB-16r-COL.gif', name: '14' },
          { id: 'frame_13', url: 'https://i.postimg.cc/3x0Kx1fz/IMB-K1u-Jp-P.gif', name: '13' },
            { id: 'frame_14', url: 'https://i.postimg.cc/CLz0cJ0d/IMG-7116.gif', name: '14' },
          { id: 'frame_14', url: 'https://i.postimg.cc/fyyGgW61/IMG-7115.gif', name: '14' },
        { id: 'frame_14', url: 'https://i.postimg.cc/gkk7s0vD/IMG-6984.gif', name: '14' },
          { id: 'frame_13', url: 'https://i.postimg.cc/0NpZPgYj/IMG-6985.gif', name: '13' },
            { id: 'frame_14', url: 'https://i.postimg.cc/tTWKKmTN/IMG-7073.gif', name: '14' },
          { id: 'frame_14', url: 'https://i.postimg.cc/jS8tc9wW/IMG-7083.gif', name: '14' },
          { id: 'frame_13', url: 'https://i.postimg.cc/rmRVKJpD/IMG-7087.gif', name: '13' },
            { id: 'frame_14', url: 'https://i.postimg.cc/zvWGPjms/IMG-7090.gif', name: '14' },
          { id: 'frame_14', url: 'https://i.postimg.cc/YSkqDg8V/IMG-7092.gif', name: '14' },
        { id: 'frame_14', url: 'https://i.postimg.cc/FzqHTBng/IMG-7093.gif', name: '14' },
          { id: 'frame_13', url: 'https://i.postimg.cc/tTpZ6wLs/IMG-7095.gif', name: '13' },
            { id: 'frame_14', url: 'https://i.postimg.cc/8P5vt8sW/IMG-7097.gif', name: '14' },
          { id: 'frame_14', url: 'https://i.postimg.cc/wMxmCZVC/IMG-7099.gif', name: '14' },
          { id: 'frame_13', url: 'https://i.postimg.cc/2jxd0FGp/IMG-7100.gif', name: '13' },
            { id: 'frame_14', url: 'https://i.postimg.cc/B6T59xGK/IMG-7101.gif', name: '14' },
          { id: 'frame_14', url: 'https://i.postimg.cc/kXfcgFRN/IMG-7106.gif', name: '14' },
        { id: 'frame_14', url: 'https://i.postimg.cc/htZppbS4/IMG-7107.gif', name: '14' },
          { id: 'frame_13', url: 'https://i.postimg.cc/hPgyjtyn/IMG-7108.gif', name: '13' },
            { id: 'frame_14', url: 'https://i.postimg.cc/HLKvs0Kv/IMG-7109.gif', name: '14' },
          { id: 'frame_14', url: 'https://i.postimg.cc/wjwbnYkp/IMG-7111.gif', name: '14' },
          { id: 'frame_13', url: 'https://i.postimg.cc/bJDMQVkj/IMG-7112.gif', name: '13' },
            { id: 'frame_14', url: 'https://i.postimg.cc/SNWBTP5S/IMG-7113.gif', name: '14' },
          { id: 'frame_14', url: 'https://i.postimg.cc/jCVMQsKH/IMG-7114.gif', name: '14' },
          
          ];

let state = { chats: {}, activeChatId: null, globalSettings: {}, apiConfig: {}, userStickers: [], worldBooks: [], personaPresets: [], qzoneSettings: {}, activeAlbumId: null, cache: { songs: new Map(), lyrics: new Map() }, ttsCache: new Map() };

let werewolfGameState = {
    isActive: false,
    gameMode: null, 
    chatId: null, 
    players: [], 
    currentDay: 1,
    currentPhase: 'setup', 
    nightActions: {}, 
    gameLog: [], 
    discussionLog: [], 
    voteResults: {},
    electionInfo: {
        candidates: [],
        votes: {}
    },
    sheriffId: null,
    lastFailedAction: null,
};
        
        let thoughtsHistoryRenderCount = 0;
        const THOUGHTS_RENDER_WINDOW = 15; 
        

        let qzonePostsRenderCount = 0;
        const QZONE_RENDER_WINDOW = 10; 
          
        let qzonePostsCache = []; 
          
        let musicState = { 
            isActive: false, 
            activeChatId: null, 
            isPlaying: false, 
            playlist: [], 
            currentIndex: -1, 
            playMode: 'order', 
            totalElapsedTime: 0, 
            timerId: null,
            
            parsedLyrics: [],      
            currentLyricIndex: -1  
        };
        let qzoneStickerPanelState = {
            isOpen: false,
            activePostId: null,
            panelEl: null,
            gridEl: null
        };
                const audioPlayer = document.getElementById('audio-player');
                let newWallpaperBase64 = null;
                let isSelectionMode = false;
let cphoneRenderedCount = 0;
let cphoneActiveConversationType = null; 
let isLoadingMoreCphoneMessages = false;
        let activeStickerCategoryId = 'all'; 
                let selectedMessages = new Set();
                let editingMemberId = null;
let isAddingNpcToGroup = false; 
                let editingWorldBookId = null;
               let editingRuleId = null; 
let isLoadingMoreChats = false; 
let isLoadingMoreMessages = false; 
let isLoadingMoreThoughts = false; 
let isLoadingMorePosts = false;    
let sortedChatListItems = [];   
                let editingPersonaPresetId = null;
                let currentReplyContext = null;
        let waimaiTimers = {}; 
        
        let activeMessageTimestamp = null;
let activeCharacterId = null; 
let editingMemoId = null;
let editingDiaryId = null;
let activeDiaryForViewing = null; 
let activeArticleForViewing = null; 
let activeMemoForViewing = null; 
         
        let shoppingCart = []; 
        let editingProductId = null; 
        let activeProductId = null; 
let selectedProducts = new Set();
          
        
        let currentQzoneReplyContext = null; 
          
        let activePostId = null; 
        let activeDoubanPostId = null;
                let photoViewerState = {
                    isOpen: false,
                    photos: [], 
                    currentIndex: -1, 
                };
        
                let unreadPostsCount = 0;
        
                let isFavoritesSelectionMode = false;
                let selectedFavorites = new Set()
        
        let simulationIntervalId = null;
        
                const defaultAvatar = 'https://i.postimg.cc/PxZrFFFL/o-o-1.jpg';
                const defaultMyGroupAvatar = 'https://i.postimg.cc/cLPP10Vm/4.jpg';
                const defaultGroupMemberAvatar = 'https://i.postimg.cc/VkQfgzGJ/1.jpg';
                const defaultGroupAvatar = 'https://i.postimg.cc/gc3QYCDy/1-NINE7-Five.jpg';
                let notificationTimeout;
                let ruleCache = {}; 

const DEFAULT_NOTIFICATION_SOUND = 'https://www.myinstants.com/media/sounds/notification-sound-2.mp3'; 
          
        let gomokuState = {}; 
let readingState = {}; 
        let originalChatMessagesPaddingTop = null; 
        
          

        const DEFAULT_APP_ICONS = {
            'qq': 'https://i.postimg.cc/MTC3Tkw8/IMG-6436.jpg',
            'world-book': 'https://i.postimg.cc/HWf1JKzn/IMG-6435.jpg',
            'wallpaper': 'https://i.postimg.cc/T1j03pQr/IMG-6440.jpg',
            'renderer': 'https://s3plus.meituan.net/opapisdk/op_ticket_885190757_1756312261242_qdqqd_g0eriz.jpeg',
            'api-settings': 'https://i.postimg.cc/MK8rJ8t7/IMG-6438.jpg',
            'font': 'https://i.postimg.cc/pXxk1JXk/IMG-6442.jpg',

            'char-phone': 'https://i.postimg.cc/pXj9h20L/IMG-7275.jpg',
            'douban': 'https://i.postimg.cc/Pq2xJN1g/IMG-7301.jpg',
  
    'preset': 'https://s3plus.meituan.net/opapisdk/op_ticket_885190757_1758510900942_qdqqd_djw0z2.jpeg',
 
            'tutorial': 'https://i.postimg.cc/d10GjC4g/IMG-7302.jpg',
    'werewolf': 'https://i.postimg.cc/k401K5g7/IMG-7304.jpg',
      
    'x': 'https://i.postimg.cc/Y9d3BztC/1.png'
        };
          
       
        const DEFAULT_CPHONE_ICONS = {
            'qq': 'https://i.postimg.cc/MTC3Tkw8/IMG-6436.jpg',
            'album': 'https://i.postimg.cc/HWf1JKzn/IMG-6435.jpg',
            'browser': 'https://i.postimg.cc/KzC2gTq6/IMG-7276.jpg',
            'taobao': 'https://i.postimg.cc/L6R7x16R/IMG-7278.jpg',
            'memo': 'https://i.postimg.cc/J0b6Nym4/IMG-7279.jpg',
            'diary': 'https://i.postimg.cc/DZ541sbt/IMG-7280.jpg',
            'amap': 'https://i.postimg.cc/Jz2Tz0dw/IMG-7281.jpg',
            'usage': 'https://i.postimg.cc/WbF8kzz9/IMG-7282.jpg',
            'music': 'https://is1-ssl.mzstatic.com/image/thumb/Purple112/v4/64/9d/21/649d21e8-a151-6136-3914-256e54f15d9a/AppIcon-0-0-1x_U007emarketing-0-0-0-7-0-0-sRGB-0-0-0-GLES2_U002c0-512MB-85-220-0-0.png/1200x630wa.png',
            'ephone': 'https://i.postimg.cc/pXj9h20L/IMG-7275.jpg'
        };
          
        let repostTargetId = null; 
                const STICKER_REGEX = /(^https:\/\/i\.postimg\.cc\/.+|^https:\/\/files\.catbox\.moe\/.+|^https?:\/\/sharkpan\.xyz\/.+|^data:image|\.(png|jpg|jpeg|gif|webp)\?.*$|\.(png|jpg|jpeg|gif|webp)$)/i;
                
                let currentRenderedCount = 0;
                let lastKnownBatteryLevel = 1;
                let alertFlags = { hasShown40: false, hasShown20: false, hasShown10: false };
                let batteryAlertTimeout;
                const dynamicFontStyle = document.createElement('style');
                dynamicFontStyle.id = 'dynamic-font-style';
                document.head.appendChild(dynamicFontStyle);
        
                const modalOverlay = document.getElementById('custom-modal-overlay');
                const modalTitle = document.getElementById('custom-modal-title');
                const modalBody = document.getElementById('custom-modal-body');
                const modalConfirmBtn = document.getElementById('custom-modal-confirm');
                const modalCancelBtn = document.getElementById('custom-modal-cancel');
                let modalResolve;
        
                function showCustomModal() { 
                    modalOverlay.classList.add('visible'); 
                }
        
                function hideCustomModal() { 
                    modalOverlay.classList.remove('visible'); 
                    modalConfirmBtn.classList.remove('btn-danger'); 
                    if (modalResolve) modalResolve(null); 
                }
        /**
         * ã€å…¨æ–°ã€‘æ ¹æ®ä¿å­˜çš„è®¾ç½®ï¼Œåº”ç”¨æ­Œè¯æ çš„CSSæ ·å¼
         * @param {object} chat - å½“å‰çš„èŠå¤©å¯¹è±¡
         */
        function applyLyricsBarPosition(chat) {
            const lyricsBar = document.getElementById('global-lyrics-bar');
            
            const settings = chat.settings.lyricsPosition || { vertical: 'top', horizontal: 'center', offset: 10 };
            
            
            lyricsBar.style.top = 'auto';
            lyricsBar.style.bottom = 'auto';
            lyricsBar.style.left = 'auto';
            lyricsBar.style.right = 'auto';
            lyricsBar.style.transform = 'none';
        
            
            if (settings.vertical === 'top') {
                lyricsBar.style.top = `${settings.offset}px`;
            } else { 
                lyricsBar.style.bottom = `${settings.offset}px`;
            }
            
            
            switch (settings.horizontal) {
                case 'left':
                    lyricsBar.style.left = '15px'; 
                    break;
                case 'right':
                    lyricsBar.style.right = '15px'; 
                    break;
                case 'center':
                default:
                    lyricsBar.style.left = '50%';
                    lyricsBar.style.transform = 'translateX(-50%)';
                    break;
            }
        }
        
        
        
        /**
         * ã€å…¨æ–°ã€‘å¤„ç†ç”¨æˆ·ä»Žæœ¬åœ°ä¸Šä¼ ç¾¤å¤´åƒçš„æµç¨‹
         * @param {Event} event - æ–‡ä»¶è¾“å…¥æ¡†çš„ change äº‹ä»¶å¯¹è±¡
         */
        async function handleLocalGroupAvatarUpload(event) {
            const file = event.target.files[0];
            if (!file) return;
        
            
            const base64Url = await new Promise(resolve => {
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result);
                reader.readAsDataURL(file);
            });
        
            
            await showCustomAlert("è¯·ç¨å€™...", "æ­£åœ¨è¯·æ±‚AIä¸ºæ–°ç¾¤å¤´åƒå‘½å...");
        
            try {
                
                const description = await getAvatarDescriptionFromApi(base64Url);
                
                if (!description) {
                    throw new Error("AIæœªèƒ½æˆåŠŸæè¿°å›¾ç‰‡ã€‚");
                }
        
                
                const chat = state.chats[state.activeChatId];
                if (!chat.settings.groupAvatarLibrary) {
                    chat.settings.groupAvatarLibrary = [];
                }
                chat.settings.groupAvatarLibrary.push({ name: description, url: base64Url });
                
                
                await db.chats.put(chat);
                renderGroupAvatarLibrary();
                await showCustomAlert("ä¸Šä¼ æˆåŠŸï¼", `AIå·²å°†æ–°ç¾¤å¤´åƒå‘½åä¸ºï¼šâ€œ${description}â€`);
        
            } catch (error) {
                console.error("æœ¬åœ°ç¾¤å¤´åƒä¸Šä¼ åŠè¯†åˆ«å¤±è´¥:", error);
                await showCustomAlert("æ“ä½œå¤±è´¥", `æ— æ³•ä¸ºå¤´åƒå‘½åï¼Œè¯·æ£€æŸ¥ï¼ˆä¸»/å‰¯ï¼‰APIé…ç½®æ˜¯å¦æ­£ç¡®å¹¶æ”¯æŒVisionã€‚\né”™è¯¯: ${error.message}`);
            } finally {
                
                event.target.value = null;
            }
        }
        
        
        
        /**
         * ã€å…¨æ–°ã€‘å¤„ç†ç”¨æˆ·ä»Žæœ¬åœ°ä¸Šä¼ å¤´åƒçš„æµç¨‹
         * @param {Event} event - æ–‡ä»¶è¾“å…¥æ¡†çš„ change äº‹ä»¶å¯¹è±¡
         */
        async function handleLocalAvatarUpload(event) {
            const file = event.target.files[0];
            if (!file) return;
        
            
            const base64Url = await new Promise(resolve => {
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result);
                reader.readAsDataURL(file);
            });
        
            
            await showCustomAlert("è¯·ç¨å€™...", "æ­£åœ¨è¯·æ±‚AIä¸ºæ–°å¤´åƒå‘½å...");
        
            try {
                
                const description = await getAvatarDescriptionFromApi(base64Url);
                
                if (!description) {
                    throw new Error("AIæœªèƒ½æˆåŠŸæè¿°å›¾ç‰‡ã€‚");
                }
        
                
                const chat = state.chats[state.activeChatId];
                if (!chat.settings.aiAvatarLibrary) {
                    chat.settings.aiAvatarLibrary = [];
                }
                chat.settings.aiAvatarLibrary.push({ name: description, url: base64Url });
                
                
                await db.chats.put(chat);
                renderAiAvatarLibrary();
                await showCustomAlert("ä¸Šä¼ æˆåŠŸï¼", `AIå·²å°†æ–°å¤´åƒå‘½åä¸ºï¼šâ€œ${description}â€`);
        
            } catch (error) {
                console.error("æœ¬åœ°å¤´åƒä¸Šä¼ åŠè¯†åˆ«å¤±è´¥:", error);
                await showCustomAlert("æ“ä½œå¤±è´¥", `æ— æ³•ä¸ºå¤´åƒå‘½åï¼Œè¯·æ£€æŸ¥ï¼ˆä¸»/å‰¯ï¼‰APIé…ç½®æ˜¯å¦æ­£ç¡®å¹¶æ”¯æŒVisionã€‚\né”™è¯¯: ${error.message}`);
            } finally {
                
                event.target.value = null;
            }
        }
        
        /**
         * ã€å…¨æ–°ã€‘è°ƒç”¨ï¼ˆå‰¯ï¼‰APIæ¥èŽ·å–å›¾ç‰‡çš„æè¿°
         * @param {string} base64Url - å›¾ç‰‡çš„ Base64 Data URL
         * @returns {Promise<string>} - è¿”å›žAIç”Ÿæˆçš„å›¾ç‰‡æè¿°
         */
        async function getAvatarDescriptionFromApi(base64Url) {
            
            const useSecondaryApi = state.apiConfig.secondaryProxyUrl && state.apiConfig.secondaryApiKey && state.apiConfig.secondaryModel;
            const { proxyUrl, apiKey, model } = useSecondaryApi 
                ? { proxyUrl: state.apiConfig.secondaryProxyUrl, apiKey: state.apiConfig.secondaryApiKey, model: state.apiConfig.secondaryModel }
                : state.apiConfig;
        
            if (!proxyUrl || !apiKey || !model) {
                throw new Error("ä¸»APIå’Œå‰¯APIå‡æœªé…ç½®æˆ–é…ç½®ä¸å®Œæ•´ã€‚");
            }
        
            const prompt = "è¯·ä¸ºè¿™å¼ å›¾ç‰‡èµ·ä¸€ä¸ªç®€æ´çš„ã€é€‚åˆä½œä¸ºå¤´åƒåº“æ ‡ç­¾çš„åå­—ã€‚ä¾‹å¦‚ï¼šâ€œå¾®ç¬‘è‡ªæ‹â€ã€â€œé˜³å…‰ä¸‹çš„çŒ«å’ªâ€ã€â€œè“å‘åŠ¨æ¼«å°‘å¥³â€ã€‚è¯·ç›´æŽ¥å›žç­”åå­—ï¼Œä¸è¦åŠ ä»»ä½•å¤šä½™çš„è§£é‡Šã€‚";
            
            let isGemini = proxyUrl.includes('generativelanguage');
            let response;
        
            if (isGemini) {
                const mimeType = base64Url.match(/^data:(.*);base64/)[1];
                const base64Data = base64Url.split(',')[1];
                const payload = {
                    contents: [{
                        parts: [
                            { text: prompt },
                            { inline_data: { mime_type: mimeType, data: base64Data } }
                        ]
                    }]
                };
                response = await fetch(`${proxyUrl}/${model}:generateContent?key=${apiKey}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
        
            } else { 
                const payload = {
                    model: model,
                    messages: [{
                        role: 'user',
                        content: [
                            { type: 'text', text: prompt },
                            { type: 'image_url', image_url: { url: base64Url } }
                        ]
                    }],
                    max_tokens: 50 
                };
                response = await fetch(`${proxyUrl}/v1/chat/completions`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` },
                    body: JSON.stringify(payload)
                });
            }
        
            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(`API é”™è¯¯: ${errorData.error.message}`);
            }
        
            const data = await response.json();
            let description = isGemini ? getGeminiResponseText(data) : data.choices[0].message.content;
            
            
            return description.trim().replace(/["'â€œâ€â€˜â€™]/g, '');
        }
        
        /**
         * ã€å…¨æ–°ã€‘å½“å•èŠè§’è‰²çš„åç§°è¢«ä¿®æ”¹åŽï¼Œè‡ªåŠ¨åŒæ­¥å…¶åœ¨æ‰€æœ‰ç¾¤èŠä¸­çš„ä¿¡æ¯
         * @param {object} characterChat - è¢«ä¿®æ”¹äº†åç§°çš„ã€å•èŠã€‘chatå¯¹è±¡
         */
        async function syncCharacterNameInGroups(characterChat) {
            
            if (!characterChat || characterChat.isGroup) {
                console.warn("syncCharacterNameInGroups: ä¼ å…¥çš„ä¸æ˜¯æœ‰æ•ˆçš„å•èŠå¯¹è±¡ï¼Œå·²è·³è¿‡åŒæ­¥ã€‚");
                return;
            }
        
            const characterId = characterChat.id;
            const newRemarkName = characterChat.name;        
            const newOriginalName = characterChat.originalName;  
        
            console.log(`æ­£åœ¨ä¸ºè§’è‰² ${characterId} åŒæ­¥æ‰€æœ‰ç¾¤èŠå†…çš„åç§°ä¿¡æ¯...`);
        
            
            for (const chatId in state.chats) {
                const groupChat = state.chats[chatId];
                
                
                if (groupChat.isGroup && groupChat.members) {
                    
                    const memberToUpdate = groupChat.members.find(m => m.id === characterId);
        
                    
                    if (memberToUpdate) {
                        let needsDbUpdate = false; 
                        
                        
                        if (memberToUpdate.groupNickname !== newRemarkName) {
                            memberToUpdate.groupNickname = newRemarkName;
                            needsDbUpdate = true;
                        }
        
                        
                        if (memberToUpdate.originalName !== newOriginalName) {
                            memberToUpdate.originalName = newOriginalName;
                            needsDbUpdate = true;
                        }
        
                        
                        if (needsDbUpdate) {
                            await db.chats.put(groupChat);
                            console.log(`æˆåŠŸå°†ç¾¤èŠ "${groupChat.name}" ä¸­çš„æˆå‘˜ä¿¡æ¯æ›´æ–°`);
                        }
                    }
                }
            }
        }
        
        
        
        
        
        /**
         * ã€å…¨æ–°ã€‘å½“å•èŠè§’è‰²çš„å¤´åƒè¢«ä¿®æ”¹åŽï¼Œè‡ªåŠ¨åŒæ­¥å…¶åœ¨æ‰€æœ‰ç¾¤èŠä¸­çš„å¤´åƒä¿¡æ¯
         * @param {object} characterChat - è¢«ä¿®æ”¹äº†å¤´åƒçš„ã€å•èŠã€‘chatå¯¹è±¡
         */
        async function syncCharacterAvatarInGroups(characterChat) {
            
            if (!characterChat || characterChat.isGroup) {
                console.warn("syncCharacterAvatarInGroups: ä¼ å…¥çš„ä¸æ˜¯æœ‰æ•ˆçš„å•èŠå¯¹è±¡ï¼Œå·²è·³è¿‡åŒæ­¥ã€‚");
                return;
            }
        
            const characterId = characterChat.id;
            const newAvatar = characterChat.settings.aiAvatar; 
        
            console.log(`æ­£åœ¨ä¸ºè§’è‰² ${characterId} åŒæ­¥æ‰€æœ‰ç¾¤èŠå†…çš„å¤´åƒ...`);
        
            
            for (const groupChat of Object.values(state.chats)) {
                if (groupChat.isGroup && groupChat.members) {
                    
                    const memberToUpdate = groupChat.members.find(m => m.id === characterId);
                    
                    
                    if (memberToUpdate && memberToUpdate.avatar !== newAvatar) {
                        memberToUpdate.avatar = newAvatar; 
                        
                        
                        await db.chats.put(groupChat);
                        console.log(`æˆåŠŸå°†è§’è‰² ${characterId} çš„æ–°å¤´åƒåŒæ­¥åˆ°ç¾¤èŠ "${groupChat.name}"`);
                    }
                }
            }
        }
        
        
        /**
         * ã€å…¨æ–° | å·²ä¿®å¤ç”¨æˆ·è¯†åˆ«é—®é¢˜ã€‘æ ¹æ®è§’è‰²æœ¬åï¼Œåœ¨æŒ‡å®šç¾¤èŠä¸­èŽ·å–å…¶æ­£ç¡®çš„æ˜¾ç¤ºåç§°ï¼ˆç¾¤æ˜µç§°ï¼‰
         * @param {object} groupChat - å½“å‰çš„ç¾¤èŠå¯¹è±¡
         * @param {string} originalName - è§’è‰²çš„æœ¬å (e.g., "å°å¯çˆ±", "æ–¹äº¦æ¥·")
         * @returns {string} - è¯¥è§’è‰²åœ¨æ­¤ç¾¤èŠä¸­çš„ç¾¤æ˜µç§°ï¼Œå¦‚æžœæ‰¾ä¸åˆ°åˆ™è¿”å›žå…¶æœ¬å
         */
        function getDisplayNameInGroup(groupChat, originalName) {
            
            if (!groupChat || !groupChat.isGroup || !originalName) {
                return originalName;
            }
        
            
        
            
            
            const userOriginalName = state.qzoneSettings.nickname || '{{user}}';
            if (originalName === userOriginalName) {
                
                return groupChat.settings.myNickname || 'æˆ‘';
            }
        
            
            const member = groupChat.members.find(m => m.originalName === originalName);
            
            
            return member ? member.groupNickname : originalName;
        }
          
        
        
        /**
         * ã€å…¨æ–°ã€‘åˆ‡æ¢æ¸²æŸ“è§„åˆ™çš„åˆ†ç±»é¡µç­¾
         * @param {string} categoryId - è¦åˆ‡æ¢åˆ°çš„åˆ†ç±»ID ('global' æˆ– èŠå¤©ID)
         */
        function switchRuleCategory(categoryId) {
            
            document.querySelectorAll('.rules-tab').forEach(tab => {
                tab.classList.toggle('active', tab.dataset.categoryId === categoryId);
            });
            
            document.querySelectorAll('.rules-category-pane').forEach(pane => {
                pane.classList.toggle('active', pane.dataset.categoryId === categoryId);
            });
        }
        
        
        /**
         * ã€å…¨æ–°ã€‘æ ¹æ®è§’è‰²çš„æœ¬åï¼Œåœ¨æ•´ä¸ªåº”ç”¨ä¸­æŸ¥æ‰¾å…¶æ­£ç¡®çš„æ˜¾ç¤ºåç§°
         * @param {string} originalName - è§’è‰²çš„æœ¬å (e.g., "æŽæ˜Ÿè¾°")
         * @returns {string} - è¯¥è§’è‰²çš„å¤‡æ³¨å/ç¾¤æ˜µç§°/ç”¨æˆ·æ˜µç§°ï¼Œå¦‚æžœæ‰¾ä¸åˆ°åˆ™è¿”å›žå…¶æœ¬å
         */
        
        
        /**
         * ã€å…¨æ–°ã€‘æ ¹æ®è§’è‰²çš„æœ¬åæˆ–æ›¾ç”¨åï¼Œåœ¨æ•´ä¸ªåº”ç”¨ä¸­æŸ¥æ‰¾å…¶æ­£ç¡®çš„ã€å½“å‰æ˜¾ç¤ºåç§°ã€‘
         * @param {string} nameIdentifier - è§’è‰²çš„æœ¬å æˆ– å‚¨å­˜åœ¨æ—§æ•°æ®ä¸­çš„æ›¾ç”¨å
         * @returns {string} - è¯¥è§’è‰²çš„ã€å½“å‰ã€‘å¤‡æ³¨å/ç¾¤æ˜µç§°/ç”¨æˆ·æ˜µç§°ï¼Œå¦‚æžœæ‰¾ä¸åˆ°åˆ™è¿”å›žä¼ å…¥çš„æ ‡è¯†ç¬¦
         */
        function getDisplayNameByOriginalName(nameIdentifier) {
            
            if (!nameIdentifier) return '';
        
            
            if (state.qzoneSettings && nameIdentifier === state.qzoneSettings.nickname) {
                return state.qzoneSettings.nickname;
            }
            
            
            
            let characterChat = Object.values(state.chats).find(chat => !chat.isGroup && chat.originalName === nameIdentifier);
            if (characterChat) {
                return characterChat.name; 
            }
        
            
            characterChat = Object.values(state.chats).find(chat => 
                !chat.isGroup && 
                (chat.nameHistory && chat.nameHistory.includes(nameIdentifier))
            );
            if (characterChat) {
                return characterChat.name; 
            }
        
            
            
            return nameIdentifier;
        }
          
        
        
        
        /**
         * ã€å…¨æ–°ã€‘å¤„ç†AIç”Ÿæˆçš„æ–‡æœ¬ï¼Œå°†ç‰¹æ®Šçš„@å ä½ç¬¦æ›¿æ¢ä¸ºæ­£ç¡®çš„æ˜¾ç¤ºåç§°
         * @param {string} text - AIç”Ÿæˆçš„ã€å¯èƒ½åŒ…å« @[[æœ¬å]] å ä½ç¬¦çš„åŽŸå§‹æ–‡æœ¬
         * @param {object|null} chat - å½“å‰çš„èŠå¤©å¯¹è±¡ (å¦‚æžœæ˜¯ç¾¤èŠï¼Œåˆ™ç”¨äºŽæŸ¥æ‰¾ç¾¤æ˜µç§°)
         * @returns {string} - å¤„ç†å®ŒæˆåŽï¼Œå¯¹ç”¨æˆ·å‹å¥½çš„æ˜¾ç¤ºæ–‡æœ¬
         */
        function processMentions(text, chat = null) {
            
            if (!text || typeof text !== 'string' || !text.includes('@[[')) {
                return text; 
            }
            
            
            return text.replace(/@\[\[([^\]]+)\]\]/g, (match, originalName) => {
                const trimmedOriginalName = originalName.trim();
                let displayName;
                
                
                if (chat && chat.isGroup) {
                    
                    
                    displayName = getDisplayNameInGroup(chat, trimmedOriginalName);
                } else {
                    
                    displayName = getDisplayNameByOriginalName(trimmedOriginalName);
                }
                
                
                return `@${displayName}`;
            });
        }
          
        
        
        
        function showCustomConfirm(title, message, options = {}) {
            return new Promise(resolve => {
                modalResolve = resolve;
                modalTitle.textContent = title;
                modalBody.innerHTML = `<p>${message}</p>`;
        
                
                const confirmBtn = document.getElementById('custom-modal-confirm');
                const cancelBtn = document.getElementById('custom-modal-cancel');
        
                cancelBtn.style.display = 'block';
        
                confirmBtn.textContent = options.confirmText || 'ç¡®å®š';
                cancelBtn.textContent = options.cancelText || 'å–æ¶ˆ';
        
                if (options.confirmButtonClass) {
                    confirmBtn.classList.add(options.confirmButtonClass);
                } else {
                    
                    confirmBtn.classList.remove('btn-danger');
                }
        
                
                confirmBtn.onclick = () => { resolve(true); hideCustomModal(); };
                cancelBtn.onclick = () => { resolve(false); hideCustomModal(); };
                showCustomModal();
            });
        }
          
/**
 * ã€å…¨æ–°ã€‘æ˜¾ç¤ºä¸€ä¸ªä¸´æ—¶çš„å³ä¸‹è§’æç¤ºï¼ˆToastï¼‰
 * @param {string} message - è¦æ˜¾ç¤ºçš„æç¤ºä¿¡æ¯
 * @param {string} type - 'success' (ç»¿è‰²) æˆ– 'error' (çº¢è‰²)
 */
function showDownloadToast(message = 'ðŸ“¥ å›¾ç‰‡ä¸‹è½½ä¸­...', type = 'success') {
    const toast = document.createElement('div');
    toast.textContent = message;
    toast.style.cssText = `
        position: fixed;
        bottom: 20px;
        right: 20px;
        background: ${type === 'success' ? '#4CAF50' : '#f44336'};
        color: white;
        padding: 12px 24px;
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        z-index: 10000;
        font-size: 14px;
        pointer-events: none;
        opacity: 0;
        transform: translateY(20px);
        transition: all 0.3s ease;
    `;
    
    document.body.appendChild(toast);
    
    setTimeout(() => {
        toast.style.opacity = '1';
        toast.style.transform = 'translateY(0)';
    }, 10);
    
    setTimeout(() => {
        toast.style.opacity = '0';
        toast.style.transform = 'translateY(-20px)';
        setTimeout(() => {
            toast.remove();
        }, 300);
    }, 2000);
}

/**
 * ã€å…¨æ–°ã€‘æ ¹æ®promptå’Œæ—¶é—´æˆ³ç”Ÿæˆæ™ºèƒ½æ–‡ä»¶å
 */
function generateFilenameForNai(prompt) {
    let cleanTitle = (prompt || 'NAI_Image')
        .replace(/[^a-zA-Z0-9\u4e00-\u9fa5\s]/g, '_')
        .replace(/\s+/g, '_')
        .substring(0, 30);
    
    const timestamp = new Date().toISOString()
        .replace(/[-:]/g, '')
        .replace('T', '_')
        .split('.')[0];
    
    return `${cleanTitle}_${timestamp}.png`;
}

/**
 * ã€å…¨æ–°ã€‘ä¸‹è½½å›¾ç‰‡çš„æ ¸å¿ƒå‡½æ•°
 */
function downloadNaiImage(imageSrc, prompt) {
    try {
        const filename = generateFilenameForNai(prompt);
        const link = document.createElement('a');
        link.href = imageSrc;
        link.download = filename;
        link.style.display = 'none';
        
        document.body.appendChild(link);
        link.click();
        
        setTimeout(() => {
            document.body.removeChild(link);
        }, 100);
        
        showDownloadToast('ðŸ“¥ å›¾ç‰‡ä¸‹è½½ä¸­...');
    } catch (error) {
        console.error('âŒ [NAIä¸‹è½½] ä¸‹è½½å¤±è´¥:', error);
        showDownloadToast('ä¸‹è½½å¤±è´¥ï¼Œè¯·é‡è¯•', 'error');
    }
}        
function showCustomAlert(title, message) {
    return new Promise(resolve => {
        modalResolve = resolve;
        modalTitle.textContent = title;
        modalBody.innerHTML =`<p style="text-align: left; white-space: pre-wrap;">${message}</p>`;

        
        const confirmBtn = document.getElementById('custom-modal-confirm');
        const cancelBtn = document.getElementById('custom-modal-cancel');

        cancelBtn.style.display = 'none';
        confirmBtn.textContent = 'å¥½çš„';

        confirmBtn.onclick = () => {
            cancelBtn.style.display = 'block'; 
            confirmBtn.textContent = 'ç¡®å®š';
            resolve(true); 
            hideCustomModal();
        };
        showCustomModal();
    });
}
        
/**
         * ã€å…¨æ–°ã€‘è¾…åŠ©å‡½æ•°ï¼šå¤åˆ¶æ–‡æœ¬åˆ°å‰ªè´´æ¿å¹¶æ˜¾ç¤ºæç¤º
         * @param {string} textToCopy - è¦å¤åˆ¶çš„æ–‡æœ¬
         * @param {string} successMessage - æˆåŠŸåŽæ˜¾ç¤ºçš„æç¤ºä¿¡æ¯
         */
        async function copyTextToClipboard(textToCopy, successMessage = 'å†…å®¹å·²å¤åˆ¶åˆ°å‰ªè´´æ¿ï¼') {
            if (!textToCopy) {
                await showCustomAlert('å¤åˆ¶å¤±è´¥', 'æ²¡æœ‰å¯å¤åˆ¶çš„å†…å®¹ã€‚');
                return;
            }
            try {
                await navigator.clipboard.writeText(textToCopy);
                await showCustomAlert('å¤åˆ¶æˆåŠŸ', successMessage);
            } catch (err) {
                console.error('å¤åˆ¶å¤±è´¥:', err);
                await showCustomAlert('å¤åˆ¶å¤±è´¥', 'æ— æ³•è®¿é—®å‰ªè´´æ¿ã€‚');
            }
        }        
        
        function showCustomPrompt(title, placeholder, initialValue = '', type = 'text', extraHtml = '') {
            return new Promise(resolve => {
                modalResolve = resolve;
                modalTitle.textContent = title;
                const inputId = 'custom-prompt-input';
                
                const inputHtml = type === 'textarea' 
                    ? `<textarea id="${inputId}" placeholder="${placeholder}" rows="4" style="width: 100%; padding: 8px; border-radius: 6px; border: 1px solid #ccc; font-size: 16px; box-sizing: border-box; resize: vertical;">${initialValue}</textarea>`
                    : `<input type="${type}" id="${inputId}" placeholder="${placeholder}" value="${initialValue}">`;
                
                modalBody.innerHTML = extraHtml + inputHtml;
                const input = document.getElementById(inputId);
        
                modalBody.querySelectorAll('.format-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        const templateStr = btn.dataset.template;
                        if (templateStr) {
                            try {
                                const templateObj = JSON.parse(templateStr);
                                input.value = JSON.stringify(templateObj, null, 2);
                                input.focus();
                            } catch(e) { console.error("è§£æžæ ¼å¼æ¨¡æ¿å¤±è´¥:", e); }
                        }
                    });
                });
                
                
                const confirmBtn = document.getElementById('custom-modal-confirm');
                const cancelBtn = document.getElementById('custom-modal-cancel');
                
                
                confirmBtn.onclick = () => { resolve(input.value); hideCustomModal(); };
                cancelBtn.onclick = () => { resolve(null); hideCustomModal(); };
        
                showCustomModal();
                setTimeout(() => input.focus(), 100);
            });
        }
          
        
        
        
        /**
         * ã€å·²ä¿®å¤ã€‘æ˜¾ç¤ºä¸€ä¸ªåŒ…å«å¤šä¸ªé€‰é¡¹çš„æ“ä½œèœå•æ¨¡æ€æ¡†
         * @param {string} title - æ¨¡æ€æ¡†çš„æ ‡é¢˜
         * @param {Array<object>} options - æŒ‰é’®é€‰é¡¹æ•°ç»„, e.g., [{ text: 'æŒ‰é’®æ–‡å­—', value: 'è¿”å›žå€¼' }]
         * @returns {Promise<string|null>} - è¿”å›žç”¨æˆ·ç‚¹å‡»æŒ‰é’®çš„valueï¼Œå¦‚æžœå–æ¶ˆåˆ™è¿”å›žnull
         */
        function showChoiceModal(title, options) {
            return new Promise(resolve => {
                const modal = document.getElementById('custom-modal-overlay');
                const modalTitle = document.getElementById('custom-modal-title');
                const modalBody = document.getElementById('custom-modal-body');
                const modalFooter = document.querySelector('#custom-modal .custom-modal-footer');
        
                
                modalTitle.textContent = title;
                modalBody.innerHTML = ''; 
                
                
                modalFooter.innerHTML = ''; 
                modalFooter.style.flexDirection = 'column';
        
                options.forEach(option => {
                    const button = document.createElement('button');
                    button.textContent = option.text;
                    button.onclick = () => {
                        
                        modal.classList.remove('visible');
                        resolve(option.value);
                    };
                    modalFooter.appendChild(button);
                });
        
                
                const cancelButton = document.createElement('button');
                cancelButton.textContent = 'å–æ¶ˆ';
                cancelButton.style.marginTop = '8px';
                cancelButton.style.borderRadius = '8px';
                cancelButton.style.backgroundColor = '#f0f0f0';
                cancelButton.onclick = () => {
                    modal.classList.remove('visible');
                    resolve(null); 
                };
                modalFooter.appendChild(cancelButton);
        
                
                modal.classList.add('visible');
        
            }).finally(() => {
                
                
                const modalFooter = document.querySelector('#custom-modal .custom-modal-footer');
        
                modalFooter.style.flexDirection = 'row'; 
                
                modalFooter.innerHTML = `
                    <button id="custom-modal-cancel">å–æ¶ˆ</button>
                    <button id="custom-modal-confirm" class="confirm-btn">ç¡®å®š</button>
                `;
        
                
                document.getElementById('custom-modal-cancel').addEventListener('click', hideCustomModal);
                
                
            });
        }
          
        
        
        /**
         * ã€å…¨æ–°ã€‘èŽ·å–æ­Œè¯å†…å®¹ï¼ˆæ”¯æŒæ–‡ä»¶å’Œç²˜è´´ï¼Œå¹¶ä¿®å¤ç²˜è´´æ ¼å¼ï¼‰
         * @returns {Promise<string|null>} è¿”å›žæ­Œè¯æ–‡æœ¬å­—ç¬¦ä¸²ï¼Œå¦‚æžœç”¨æˆ·å–æ¶ˆåˆ™è¿”å›žnull
         */
        async function getLrcContent() {
            
            const choice = await showChoiceModal('é€‰æ‹©æ­Œè¯å¯¼å…¥æ–¹å¼', [
                { text: 'ðŸ“ ä»Žæœ¬åœ°æ–‡ä»¶ (.lrc)', value: 'file' },
                { text: 'ðŸ“‹ ç›´æŽ¥ç²˜è´´æ­Œè¯æ–‡æœ¬', value: 'paste' }
            ]);
        
            
            if (choice === 'file') {
                
                return new Promise(resolve => {
                    const lrcInput = document.getElementById('lrc-upload-input');
                    const lrcChangeHandler = (e) => {
                        const lrcFile = e.target.files[0];
                        if (lrcFile) {
                            const reader = new FileReader();
                            reader.onload = (readEvent) => resolve(readEvent.target.result);
                            reader.onerror = () => resolve(""); 
                            reader.readAsText(lrcFile);
                        } else {
                            resolve(null); 
                        }
                        lrcInput.removeEventListener('change', lrcChangeHandler);
                        lrcInput.value = ''; 
                    };
                    lrcInput.addEventListener('change', lrcChangeHandler, { once: true });
                    lrcInput.click();
                });
            } else if (choice === 'paste') {
                
                const pastedText = await showCustomPrompt(
                    'ç²˜è´´æ­Œè¯',
                    'è¯·åœ¨æ­¤å¤„ç²˜è´´å®Œæ•´çš„LRCæ ¼å¼æ­Œè¯...',
                    '',
                    'textarea' 
                );
                
                
                if (pastedText) {
                    
                    
                    const formattedText = pastedText.replace(/\[/g, '\n[').trim();
                    return formattedText;
                }
                return pastedText; 
                
        
            } else {
                
                return null;
            }
        }
        
                
                
                
        
        
        db.version(40).stores({ 
            doubanPosts: '++id, timestamp',
           chats: '&id, isGroup, groupId, isPinned, memos, diary, appUsageLog, lastIntelligentSummaryTimestamp',
           apiConfig: '&id, minimaxGroupId, minimaxApiKey',
            globalSettings: '&id', 
            userStickers: '&id, url, name, categoryId',
            worldBooks: '&id, name, categoryId',
            worldBookCategories: '++id, name',
            musicLibrary: '&id', 
            personaPresets: '&id',
            qzoneSettings: '&id',
            qzonePosts: '++id, timestamp, authorId',
            qzoneAlbums: '++id, name, createdAt',
            qzonePhotos: '++id, albumId',
            favorites: '++id, type, timestamp, originalTimestamp',
            qzoneGroups: '++id, name',
            memories: '++id, chatId, timestamp, type, targetDate',
            callRecords: '++id, chatId, timestamp, customName',
            shoppingProducts: '++id, name, description',
            shoppingCategories: '++id, name',
            apiPresets: '++id, name',
            renderingRules: '++id, name, chatId',
            appearancePresets: '++id, name, type',
            stickerCategories: '++id, name',
            customAvatarFrames: '++id, name',
            presets: '&id, name, categoryId', 
            presetCategories: '++id, name',
            readingLibrary: '++id, title, lastOpened', 
            
           npcs: '++id, name, npcGroupId, enableBackgroundActivity, actionCooldownMinutes, lastActionTimestamp',
           npcGroups: '++id, name'
        }).upgrade(tx => {
            
            return tx.table('worldBooks').toCollection().modify(book => {
                
                if (typeof book.content === 'string' && book.content.trim() !== '') {
                    book.content = [{
                        keys: [],
                        comment: 'ä»Žæ—§ç‰ˆæœ¬è¿ç§»çš„æ¡ç›®',
                        content: book.content
                    }];
                } else if (!Array.isArray(book.content)) {
                    book.content = [];
                }

                
                book.content.forEach(entry => {
                    if (typeof entry.enabled === 'undefined') {
                        entry.enabled = true;
                    }
                });
            });
        });
          
window.db = db;        
                
                
                
        
                function showScreen(screenId) {
                    if (screenId === 'chat-list-screen') {
                        window.renderChatListProxy(); 
                        switchToChatListView('messages-view');
                    }
                    if (screenId === 'api-settings-screen') window.renderApiSettingsProxy();
                    if (screenId === 'wallpaper-screen') window.renderWallpaperScreenProxy();
                    if (screenId === 'world-book-screen') window.renderWorldBookScreenProxy();
                 Â  Â if (screenId === 'x-social-screen') window.renderXSocialScreenProxy();
                     if (screenId === 'douban-screen') renderDoubanScreen();
                    document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
                    const screenToShow = document.getElementById(screenId);
                    if (screenToShow) screenToShow.classList.add('active');
                    if (screenId === 'chat-interface-screen') window.updateListenTogetherIconProxy(state.activeChatId);
                    if (screenId === 'font-settings-screen') {
            loadFontPresetsDropdown(); 
                        document.getElementById('font-url-input').value = state.globalSettings.fontUrl || '';
                        applyCustomFont(state.globalSettings.fontUrl || '', true);
                    }
                }
                window.updateListenTogetherIconProxy = () => {};
        
                function switchToChatListView(viewId) {
                    const chatListScreen = document.getElementById('chat-list-screen');
                    const views = {
                        'messages-view': document.getElementById('messages-view'),
                        'qzone-screen': document.getElementById('qzone-screen'),
                        'favorites-view': document.getElementById('favorites-view'),
                'memories-view': document.getElementById('memories-view'),
               'npc-list-view': document.getElementById('npc-list-view')
            };
                    const mainHeader = document.getElementById('main-chat-list-header');
                    const mainBottomNav = document.getElementById('chat-list-bottom-nav'); 
        
                    if (isFavoritesSelectionMode) {
                        document.getElementById('favorites-edit-btn').click(); 
                    }
        
                    
                    Object.values(views).forEach(v => v.classList.remove('active'));
                    
                    if (views[viewId]) {
                        views[viewId].classList.add('active');
                    }
        
                    
                    document.querySelectorAll('#chat-list-bottom-nav .nav-item').forEach(item => {
                        item.classList.toggle('active', item.dataset.view === viewId);
                    });
                    
                    
                    if (viewId === 'messages-view') {
                        mainHeader.style.display = 'flex';
                        mainBottomNav.style.display = 'flex';
                    } else {
                        mainHeader.style.display = 'none';
                        mainBottomNav.style.display = 'none';
                    }
                    
        
            if (viewId !== 'memories-view') {
                activeCountdownTimers.forEach(timerId => clearInterval(timerId));
                activeCountdownTimers = [];
            }
        
                    
                    switch (viewId) {
                        case 'qzone-screen':
                            views['qzone-screen'].style.backgroundColor = '#f0f2f5';
                            updateUnreadIndicator(0);
                            renderQzoneScreen();
                            renderQzonePosts();
                            break;
                        case 'favorites-view':
                            views['favorites-view'].style.backgroundColor = '#f9f9f9';
                            renderFavoritesScreen();
                            break;
                        case 'messages-view':
                            
                            break;
        case 'npc-list-view':
            renderNpcListScreen(); 
            break;
                    }
                }
Â  Â  
Â  Â  Â  function renderXSocialScreen() {
Â  Â  Â  Â  
Â  Â  Â  Â  console.log("æ¸²æŸ“Xç¤¾äº¤é¡µé¢");
Â  Â  Â  }
Â  Â  Â  window.renderXSocialScreenProxy = renderXSocialScreen;
                
                function renderQzoneScreen() {
                    if (state && state.qzoneSettings) {
                        const settings = state.qzoneSettings;
                        document.getElementById('qzone-nickname').textContent = settings.nickname;
                        document.getElementById('qzone-avatar-img').src = settings.avatar;
                        document.getElementById('qzone-banner-img').src = settings.banner;
                    }
                }
                window.renderQzoneScreenProxy = renderQzoneScreen;
        
                async function saveQzoneSettings() {
                    if (db && state.qzoneSettings) {
                        await db.qzoneSettings.put(state.qzoneSettings);
                    }
                }
        
                function formatPostTimestamp(timestamp) {
                    if (!timestamp) return '';
                    const now = new Date();
                    const date = new Date(timestamp);
                    const diffSeconds = Math.floor((now - date) / 1000);
                    const diffMinutes = Math.floor(diffSeconds / 60);
                    const diffHours = Math.floor(diffMinutes / 60);
                    if (diffMinutes < 1) return 'åˆšåˆš';
                    if (diffMinutes < 60) return `${diffMinutes}åˆ†é’Ÿå‰`;
                    if (diffHours < 24) return `${diffHours}å°æ—¶å‰`;
                    const year = date.getFullYear();
                    const month = String(date.getMonth() + 1).padStart(2, '0');
                    const day = String(date.getDate()).padStart(2, '0');
                    const hours = String(date.getHours()).padStart(2, '0');
                    const minutes = String(date.getMinutes()).padStart(2, '0');
                    if (now.getFullYear() === year) {
                        return `${month}-${day} ${hours}:${minutes}`;
                    } else {
                        return `${year}-${month}-${day} ${hours}:${minutes}`;
                    }
                }
        
        
        
        /**
         * ã€å…¨æ–° | æ€§èƒ½æ ¸å¿ƒ | å·²é›†æˆMarkdownã€‘æ ¹æ®å¸–å­æ•°æ®ï¼Œåˆ›å»ºæˆ–æ›´æ–°å•ä¸ªå¸–å­çš„HTMLå…ƒç´ 
         * @param {object} post - å•ä¸ªå¸–å­çš„æ•°æ®å¯¹è±¡
         * @returns {HTMLElement} - åˆ›å»ºæˆ–æ›´æ–°åŽçš„å¸–å­å®¹å™¨DOMå…ƒç´ 
         */
        function createOrUpdatePostElement(post) {
            const existingPostContainer = document.querySelector(`.qzone-post-container[data-post-id="${post.id}"]`);
            const isUpdating = !!existingPostContainer;
            
            const postContainer = isUpdating ? existingPostContainer : document.createElement('div');
            if (!isUpdating) {
                postContainer.className = 'qzone-post-container';
                postContainer.dataset.postId = post.id;
            }
        
            const postEl = isUpdating ? postContainer.querySelector('.qzone-post-item') : document.createElement('div');
            if (!isUpdating) {
                postEl.className = 'qzone-post-item';
            }
        
            let authorAvatar = '', authorNickname = '', commentAvatar = state.qzoneSettings.avatar; 
        
            if (post.authorId === 'user') {
                authorAvatar = state.qzoneSettings.avatar;
                authorNickname = state.qzoneSettings.nickname;
            } else if (state.chats[post.authorId]) {
                const authorChat = state.chats[post.authorId];
                authorAvatar = authorChat.settings.aiAvatar || defaultAvatar;
                authorNickname = authorChat.name;
            } else {
                authorNickname = getDisplayNameByOriginalName(post.authorOriginalName);
                authorAvatar = defaultAvatar;
            }
        
function renderOriginalPostContent(targetPost) {
            let innerContentHtml = '';
            const publicTextHtml = targetPost.publicText ? `<div class="post-content">${parseMarkdown(targetPost.publicText).replace(/\n/g, '<br>')}</div>` : '';

            if (targetPost.type === 'shuoshuo') {
                innerContentHtml = `<div class="post-content" style="margin-bottom: 10px;">${parseMarkdown(targetPost.content).replace(/\n/g, '<br>')}</div>`;
            } else if (targetPost.type === 'image_post' && targetPost.imageUrl) {
                
                innerContentHtml = publicTextHtml ? `${publicTextHtml}<div style="margin-top:10px;"><img src="${targetPost.imageUrl}" class="chat-image"></div>` : `<img src="${targetPost.imageUrl}" class="chat-image">`;
            } else if (targetPost.type === 'text_image') {
                const postImageUrl = state.globalSettings.enableAiDrawing && targetPost.image_prompt ? `https://image.pollinations.ai/prompt/${targetPost.image_prompt}` : 'https://i.postimg.cc/KYr2qRCK/1.jpg';
                innerContentHtml = publicTextHtml ? `${publicTextHtml}<div style="margin-top:10px;"><img src="${postImageUrl}" class="chat-image" style="cursor: pointer;" data-hidden-text="${targetPost.hiddenContent}"></div>` : `<img src="${postImageUrl}" class="chat-image" style="cursor: pointer;" data-hidden-text="${targetPost.hiddenContent}">`;
            }
            
            else if (targetPost.type === 'naiimag') {
                // NovelAIå›¾ç‰‡åŠ¨æ€æ¸²æŸ“ï¼ˆæ”¯æŒå¤šå›¾å¸ƒå±€ï¼Œæœ€å¤š2å¼ ï¼‰
                const imageUrls = targetPost.imageUrls || (targetPost.imageUrl ? [targetPost.imageUrl] : []);
                
                if (imageUrls.length > 0) {
                    const imageCount = imageUrls.length;
                    let imagesHtml = '';
                    
                    // ä½¿ç”¨ç»Ÿä¸€çš„å¤šå›¾å¸ƒå±€ï¼ˆåŒ…æ‹¬å•å¼ å›¾ç‰‡ï¼‰
                    imagesHtml = `<div class="post-images-grid grid-${imageCount}">`;
                    imageUrls.forEach((url, index) => {
                        imagesHtml += `<img src="${url}" class="naiimag-image" alt="å›¾ç‰‡${index + 1}" loading="lazy" onerror="this.src='https://i.postimg.cc/KYr2qRCK/1.jpg'; this.alt='å›¾ç‰‡åŠ è½½å¤±è´¥';">`;
                    });
                    imagesHtml += '</div>';
                    
                    innerContentHtml = publicTextHtml ? `${publicTextHtml}${imagesHtml}` : imagesHtml;
                }
            }
            return innerContentHtml;
        }
        
            let mainContentHtml;
        
            if (post.type === 'repost') {
                
                const repostCommentHtml = post.repostComment ? `<div class="post-content">${parseMarkdown(post.repostComment).replace(/\n/g, '<br>')}</div>` : '';
                let originalAuthorAvatar = defaultAvatar;
                let originalAuthorNickname = 'åŽŸä½œè€…';
                if (post.originalPost.authorId === 'user') {
                    originalAuthorAvatar = state.qzoneSettings.avatar;
                    originalAuthorNickname = state.qzoneSettings.nickname;
                } else {
                    const originalAuthorChat = state.chats[post.originalPost.authorId];
                    if (originalAuthorChat) {
                        originalAuthorAvatar = originalAuthorChat.settings.aiAvatar || defaultAvatar;
                    }
                    originalAuthorNickname = getDisplayNameByOriginalName(post.originalPost.authorOriginalName);
                }
                mainContentHtml = `
                    ${repostCommentHtml}
                    <div class="reposted-content-wrapper">
                        <div class="post-header">
                            <img src="${originalAuthorAvatar}" class="post-avatar">
                            <div class="post-info">
                                <span class="post-nickname">@${originalAuthorNickname}</span>
                                <span class="post-timestamp">${formatPostTimestamp(post.originalPost.timestamp)}</span>
                            </div>
                        </div>
                        <div class="post-main-content">${renderOriginalPostContent(post.originalPost)}</div>
                    </div>
                `;
            } else {
                mainContentHtml = `<div class="post-main-content">${renderOriginalPostContent(post)}</div>`;
            }
        
            let likesHtml = '';
            if (post.likes && post.likes.length > 0) {
                const displayLikes = post.likes.map(name => getDisplayNameByOriginalName(name)).join('ã€');
                likesHtml = `<div class="post-likes-section"><svg class="like-icon" viewBox="0 0 24 24"><path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"></path></svg><span>${displayLikes} è§‰å¾—å¾ˆèµž</span></div>`;
            }
        
            let commentsHtml = '';
            if (post.comments && post.comments.length > 0) {
                commentsHtml = '<div class="post-comments-container">';
                post.comments.forEach((comment, index) => {
                    if (typeof comment === 'object' && comment !== null && comment.commenterName) {
                        const commenterOriginalName = comment.commenterName;
                        const commenterDisplayName = getDisplayNameByOriginalName(commenterOriginalName);
                        
                        let innerCommentContent;
                        if (STICKER_REGEX.test(comment.text)) {
                            innerCommentContent = `<img src="${comment.text}" class="comment-sticker" alt="sticker">`;
                        } else {
                            
                            innerCommentContent = parseMarkdown(comment.text);
                        }
        
                        let commentLineHtml = '';
                        if (comment.replyTo) {
                            const repliedToDisplayName = getDisplayNameByOriginalName(comment.replyTo);
                            commentLineHtml = `<span class="commenter-name">${commenterDisplayName}</span> å›žå¤ <span class="commenter-name">${repliedToDisplayName}</span>: ${innerCommentContent}`;
                        } else {
                            commentLineHtml = `<span class="commenter-name">${commenterDisplayName}</span>: ${innerCommentContent}`;
                        }
                        
                        commentsHtml += `<div class="comment-item" data-post-id="${post.id}" data-commenter-original-name="${commenterOriginalName}" data-commenter-display-name="${commenterDisplayName}">
                                            <div class="comment-text">${commentLineHtml}</div>
                                            <span class="comment-delete-btn" data-comment-index="${index}">Ã—</span>
                                         </div>`;
        
                    } else {
                        
                        commentsHtml += `<div class="legacy-comment-item">
                                            <span class="comment-text">${parseMarkdown(String(comment))}</span>
                                         </div>`;
                    }
                });
                commentsHtml += '</div>';
            }
        
            const userOriginalName = state.qzoneSettings.nickname;
            const isLikedByUser = post.likes && post.likes.includes(userOriginalName);
            const isFavoritedByUser = state.favoritedPostIds && state.favoritedPostIds.has(post.id);
        
            let repostIconHtml = '';
            if (post.type !== 'repost') {
                repostIconHtml = `
                    <span class="action-icon repost">
                        <svg viewBox="0 0 24 24"><path d="M17 2.1l4 4-4 4 M3 11.5v-3a4 4 0 0 1 4-4h13 M7 21.9l-4-4 4-4 M21 12.5v3a4 4 0 0 1-4 4H4"></path></svg>
                    </span>`;
            }
            
            postEl.innerHTML = `
                <div class="post-header">
                    <img src="${authorAvatar}" class="post-avatar" data-author-id="${post.authorId}">
                    <div class="post-info">
                        <span class="post-nickname">${authorNickname}</span>
                        <span class="post-timestamp">${formatPostTimestamp(post.timestamp)}</span>
                    </div>
                    <div class="post-actions-btn">â€¦</div>
                </div>
                ${mainContentHtml}
                <div class="post-feedback-icons">
                    ${repostIconHtml}
                    <span class="action-icon like ${isLikedByUser ? 'active' : ''}"><svg viewBox="0 0 24 24"><path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"></path></svg></span>
                    <span class="action-icon favorite ${isFavoritedByUser ? 'active' : ''}"><svg viewBox="0 0 24 24"><path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"></path></svg></span>
                </div>
                ${likesHtml}
                ${commentsHtml}
                <div class="post-footer">
                    <div class="comment-section">
                        <img src="${commentAvatar}" class="comment-avatar">
                        <input type="text" class="comment-input" placeholder="å‹å–„çš„è¯„è®ºæ˜¯äº¤æµçš„èµ·ç‚¹">
                        <button class="comment-sticker-btn">
        <svg viewBox="0 0 24 24">
            <circle cx="12" cy="12" r="10"></circle>
            <path d="M8 14 Q 12 16 16 14"></path>
            <line x1="9" y1="9" x2="9.01" y2="9"></line>
            <line x1="15" y1="9" x2="15.01" y2="9"></line>
        </svg>
        </button>
                        <div class="at-mention-popup"></div>
                    </div>
                    <button class="comment-send-btn">å‘é€</button>
                </div>
            `;
        
            if (!isUpdating) {
                const deleteAction = document.createElement('div');
                deleteAction.className = 'qzone-post-delete-action';
                deleteAction.innerHTML = '<span>åˆ é™¤</span>';
                postContainer.appendChild(postEl);
                postContainer.appendChild(deleteAction);
            }
            
            return postContainer;
        }
        
        /**
         * ã€å…¨æ–° | å¢žé‡æ›´æ–°å‡½æ•°ã€‘åªæ›´æ–°å•ä¸ªå¸–å­ï¼Œè€Œä¸æ˜¯é‡ç»˜æ•´ä¸ªåˆ—è¡¨
         * @param {number} postId - éœ€è¦æ›´æ–°çš„å¸–å­çš„ID
         */
        async function updateSinglePostInDOM(postId) {
            const postData = await db.qzonePosts.get(postId);
            if (!postData) {
                
                const postContainer = document.querySelector(`.qzone-post-container[data-post-id="${postId}"]`);
                if (postContainer) postContainer.remove();
                return;
            }
        
            
            const cacheIndex = qzonePostsCache.findIndex(p => p.id === postId);
            if (cacheIndex > -1) qzonePostsCache[cacheIndex] = postData;
            
            
            const favorites = await db.favorites.where('type').equals('qzone_post').toArray();
            state.favoritedPostIds = new Set(favorites.map(fav => fav.content.id));
        
            
            createOrUpdatePostElement(postData);
        }
        
        
        
        function formatTimeAgo(timestamp) {
            const now = Date.now();
            const seconds = Math.floor((now - timestamp) / 1000);
            const minutes = Math.floor(seconds / 60);
            if (minutes < 2) return 'åˆšåˆš';
            if (minutes < 60) return `${minutes}åˆ†é’Ÿå‰`;
            const hours = Math.floor(minutes / 60);
            if (hours < 24) return `${hours}å°æ—¶å‰`;
            const days = Math.floor(hours / 24);
            return `${days}å¤©å‰`;
        }
        
        
        
        
        
        /**
         * ã€å…¨æ–° | æ€§èƒ½æ ¸å¿ƒã€‘æ ¹æ®å¸–å­æ•°æ®ï¼Œåˆ›å»ºæˆ–æ›´æ–°å•ä¸ªå¸–å­çš„HTMLå…ƒç´ 
         * @param {object} post - å•ä¸ªå¸–å­çš„æ•°æ®å¯¹è±¡
         * @returns {HTMLElement} - åˆ›å»ºæˆ–æ›´æ–°åŽçš„å¸–å­å®¹å™¨DOMå…ƒç´ 
         */
async function createOrUpdatePostElement(post) { 
            const existingPostContainer = document.querySelector(`.qzone-post-container[data-post-id="${post.id}"]`);
            const isUpdating = !!existingPostContainer;
            
            const postContainer = isUpdating ? existingPostContainer : document.createElement('div');
            if (!isUpdating) {
                postContainer.className = 'qzone-post-container';
                postContainer.dataset.postId = post.id;
            }
        
            const postEl = isUpdating ? postContainer.querySelector('.qzone-post-item') : document.createElement('div');
            if (!isUpdating) {
                postEl.className = 'qzone-post-item';
            }
        
            let authorAvatar = '', authorNickname = '', commentAvatar = state.qzoneSettings.avatar; 
        
            
            if (post.authorId === 'user') {
                authorAvatar = state.qzoneSettings.avatar;
                authorNickname = state.qzoneSettings.nickname;
            } else if (state.chats[post.authorId]) {
                const authorChat = state.chats[post.authorId];
                authorAvatar = authorChat.settings.aiAvatar || defaultAvatar;
                authorNickname = authorChat.name;
            } else if (String(post.authorId).startsWith('npc_')) {
                
                const npcId = parseInt(String(post.authorId).replace('npc_', ''));
                if (!isNaN(npcId)) {
                    const npc = await db.npcs.get(npcId);
                    if (npc) {
                        authorAvatar = npc.avatar || defaultGroupMemberAvatar;
                        authorNickname = npc.name;
                    } else {
                        authorNickname = post.authorOriginalName || 'æœªçŸ¥NPC';
                        authorAvatar = defaultGroupMemberAvatar;
                    }
                }
            } else {
                
                authorNickname = getDisplayNameByOriginalName(post.authorOriginalName);
                authorAvatar = defaultAvatar;
            }
            
        
function renderOriginalPostContent(targetPost) {
            let innerContentHtml = '';
            const publicTextHtml = targetPost.publicText ? `<div class="post-content">${parseMarkdown(targetPost.publicText).replace(/\n/g, '<br>')}</div>` : '';

            if (targetPost.type === 'shuoshuo') {
                innerContentHtml = `<div class="post-content" style="margin-bottom: 10px;">${parseMarkdown(targetPost.content).replace(/\n/g, '<br>')}</div>`;
            } else if (targetPost.type === 'image_post' && targetPost.imageUrl) {
                
                innerContentHtml = publicTextHtml ? `${publicTextHtml}<div style="margin-top:10px;"><img src="${targetPost.imageUrl}" class="chat-image"></div>` : `<img src="${targetPost.imageUrl}" class="chat-image">`;
            } else if (targetPost.type === 'text_image') {
                
                const postImageUrl = state.globalSettings.enableAiDrawing && targetPost.image_prompt ? `https://image.pollinations.ai/prompt/${targetPost.image_prompt}` : 'https://i.postimg.cc/KYr2qRCK/1.jpg';
                innerContentHtml = publicTextHtml ? `${publicTextHtml}<div style="margin-top:10px;"><img src="${postImageUrl}" class="chat-image" style="cursor: pointer;" data-hidden-text="${targetPost.hiddenContent}"></div>` : `<img src="${postImageUrl}" class="chat-image" style="cursor: pointer;" data-hidden-text="${targetPost.hiddenContent}">`;
            }

            else if (targetPost.type === 'naiimag') {
                // NovelAIå›¾ç‰‡åŠ¨æ€æ¸²æŸ“ï¼ˆæ”¯æŒå¤šå›¾å¸ƒå±€ï¼Œæœ€å¤š2å¼ ï¼‰
                const imageUrls = targetPost.imageUrls || (targetPost.imageUrl ? [targetPost.imageUrl] : []);
                
                if (imageUrls.length > 0) {
                    const imageCount = imageUrls.length;
                    let imagesHtml = '';
                    
                    // ä½¿ç”¨ç»Ÿä¸€çš„å¤šå›¾å¸ƒå±€ï¼ˆåŒ…æ‹¬å•å¼ å›¾ç‰‡ï¼‰
                    imagesHtml = `<div class="post-images-grid grid-${imageCount}">`;
                    imageUrls.forEach((url, index) => {
                        imagesHtml += `<img src="${url}" class="naiimag-image" alt="å›¾ç‰‡${index + 1}" loading="lazy" onerror="this.src='https://i.postimg.cc/KYr2qRCK/1.jpg'; this.alt='å›¾ç‰‡åŠ è½½å¤±è´¥';">`;
                    });
                    imagesHtml += '</div>';
                    
                    innerContentHtml = publicTextHtml ? `${publicTextHtml}${imagesHtml}` : imagesHtml;
                }
            }
            return innerContentHtml;
        }
        
            let mainContentHtml;
        
            if (post.type === 'repost') {
                const repostCommentHtml = post.repostComment ? `<div class="post-content">${post.repostComment.replace(/\n/g, '<br>')}</div>` : '';
                let originalAuthorAvatar = defaultAvatar;
                let originalAuthorNickname = 'åŽŸä½œè€…';
                if (post.originalPost.authorId === 'user') {
                    originalAuthorAvatar = state.qzoneSettings.avatar;
                    originalAuthorNickname = state.qzoneSettings.nickname;
                } else {
                    const originalAuthorChat = state.chats[post.originalPost.authorId];
                    if (originalAuthorChat) {
                        originalAuthorAvatar = originalAuthorChat.settings.aiAvatar || defaultAvatar;
                    }
                    originalAuthorNickname = getDisplayNameByOriginalName(post.originalPost.authorOriginalName);
                }
                mainContentHtml = `
                    ${repostCommentHtml}
                    <div class="reposted-content-wrapper">
                        <div class="post-header">
                            <img src="${originalAuthorAvatar}" class="post-avatar">
                            <div class="post-info">
                                <span class="post-nickname">@${originalAuthorNickname}</span>
                                <span class="post-timestamp">${formatPostTimestamp(post.originalPost.timestamp)}</span>
                            </div>
                        </div>
                        <div class="post-main-content">${renderOriginalPostContent(post.originalPost)}</div>
                    </div>
                `;
            } else {
                mainContentHtml = `<div class="post-main-content">${renderOriginalPostContent(post)}</div>`;
            }
        
            let likesHtml = '';
            if (post.likes && post.likes.length > 0) {
                const displayLikes = post.likes.map(name => getDisplayNameByOriginalName(name)).join('ã€');
                likesHtml = `<div class="post-likes-section"><svg class="like-icon" viewBox="0 0 24 24"><path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"></path></svg><span>${displayLikes} è§‰å¾—å¾ˆèµž</span></div>`;
            }
        
        
            let commentsHtml = '';
            if (post.comments && post.comments.length > 0) {
                commentsHtml = '<div class="post-comments-container">';
                post.comments.forEach((comment, index) => {
                    
                    if (typeof comment === 'object' && comment !== null && comment.commenterName) {
                        const commenterOriginalName = comment.commenterName;
                        
                        const commenterDisplayName = getDisplayNameByOriginalName(commenterOriginalName);
                        
                        let innerCommentContent;
                        if (STICKER_REGEX.test(comment.text)) {
                            innerCommentContent = `<img src="${comment.text}" class="comment-sticker" alt="sticker">`;
                        } else {
                            innerCommentContent = parseMarkdown(comment.text);
                        }
        
                        let commentLineHtml = '';
                        
                        if (comment.replyTo) {
                            const repliedToDisplayName = getDisplayNameByOriginalName(comment.replyTo);
                            commentLineHtml = `<span class="commenter-name">${commenterDisplayName}</span> å›žå¤ <span class="commenter-name">${repliedToDisplayName}</span>: ${innerCommentContent}`;
                        } else {
                            commentLineHtml = `<span class="commenter-name">${commenterDisplayName}</span>: ${innerCommentContent}`;
                        }
                        
                        commentsHtml += `<div class="comment-item" data-post-id="${post.id}" data-commenter-original-name="${commenterOriginalName}" data-commenter-display-name="${commenterDisplayName}">
                                            <div class="comment-text">${commentLineHtml}</div>
                                            <span class="comment-delete-btn" data-comment-index="${index}">Ã—</span>
                                         </div>`;
        
                    } else {
                        
                        commentsHtml += `<div class="legacy-comment-item">
                                            <span class="comment-text">${String(comment)}</span>
                                         </div>`;
                    }
                });
                commentsHtml += '</div>';
            }
          
        
            const userOriginalName = state.qzoneSettings.nickname;
            const isLikedByUser = post.likes && post.likes.includes(userOriginalName);
            const isFavoritedByUser = state.favoritedPostIds && state.favoritedPostIds.has(post.id); 
        
            let repostIconHtml = '';
            if (post.type !== 'repost') {
                repostIconHtml = `
                    <span class="action-icon repost">
                        <svg viewBox="0 0 24 24"><path d="M17 2.1l4 4-4 4 M3 11.5v-3a4 4 0 0 1 4-4h13 M7 21.9l-4-4 4-4 M21 12.5v3a4 4 0 0 1-4 4H4"></path></svg>
                    </span>`;
            }
            
            postEl.innerHTML = `
                <div class="post-header">
                    <img src="${authorAvatar}" class="post-avatar" data-author-id="${post.authorId}">
                    <div class="post-info">
                        <span class="post-nickname">${authorNickname}</span>
                        <span class="post-timestamp">${formatPostTimestamp(post.timestamp)}</span>
                    </div>
                    <div class="post-actions-btn">â€¦</div>
                </div>
                ${mainContentHtml}
                <div class="post-feedback-icons">
                    ${repostIconHtml}
                    <span class="action-icon like ${isLikedByUser ? 'active' : ''}"><svg viewBox="0 0 24 24"><path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"></path></svg></span>
                    <span class="action-icon favorite ${isFavoritedByUser ? 'active' : ''}"><svg viewBox="0 0 24 24"><path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"></path></svg></span>
                </div>
                ${likesHtml}
                ${commentsHtml}
                <div class="post-footer">
                    <div class="comment-section">
                        <img src="${commentAvatar}" class="comment-avatar">
                        <input type="text" class="comment-input" placeholder="å‹å–„çš„è¯„è®ºæ˜¯äº¤æµçš„èµ·ç‚¹">
                        <button class="comment-sticker-btn">
        <svg viewBox="0 0 24 24">
            <circle cx="12" cy="12" r="10"></circle>
            <path d="M8 14 Q 12 16 16 14"></path>
            <line x1="9" y1="9" x2="9.01" y2="9"></line>
            <line x1="15" y1="9" x2="15.01" y2="9"></line>
        </svg>
        </button>
                        <div class="at-mention-popup"></div>
                    </div>
                    <button class="comment-send-btn">å‘é€</button>
                </div>
            `;
        
            if (!isUpdating) {
                const deleteAction = document.createElement('div');
                deleteAction.className = 'qzone-post-delete-action';
                deleteAction.innerHTML = '<span>åˆ é™¤</span>';
                postContainer.appendChild(postEl);
                postContainer.appendChild(deleteAction);
            }
            
            return postContainer;
        }
        
        /**
         * ã€å…¨æ–° | å¢žé‡æ›´æ–°å‡½æ•°ã€‘åªæ›´æ–°å•ä¸ªå¸–å­ï¼Œè€Œä¸æ˜¯é‡ç»˜æ•´ä¸ªåˆ—è¡¨
         * @param {number} postId - éœ€è¦æ›´æ–°çš„å¸–å­çš„ID
         */
        async function updateSinglePostInDOM(postId) {
            const postData = await db.qzonePosts.get(postId);
            if (!postData) {
                
                const postContainer = document.querySelector(`.qzone-post-container[data-post-id="${postId}"]`);
                if (postContainer) {
                    postContainer.remove();
                }
                return;
            }
        
            
            const cacheIndex = qzonePostsCache.findIndex(p => p.id === postId);
            if (cacheIndex > -1) {
                qzonePostsCache[cacheIndex] = postData;
            }
            
            
            const favorites = await db.favorites.where('type').equals('qzone_post').toArray();
            state.favoritedPostIds = new Set(favorites.map(fav => fav.content.id));
        
            
           await createOrUpdatePostElement(postData);
        }
        
        
        

async function renderQzonePosts() {
    const postsListEl = document.getElementById('qzone-posts-list');
    if (!postsListEl) return;

    const [postsFromDb, favorites] = await Promise.all([
        db.qzonePosts.orderBy('timestamp').reverse().filter(post => !post.isDeleted).toArray(),
        db.favorites.where('type').equals('qzone_post').toArray()
    ]);
    qzonePostsCache = postsFromDb;
    state.favoritedPostIds = new Set(favorites.map(fav => fav.content.id));

    postsListEl.innerHTML = '';
    qzonePostsRenderCount = 0; 

    if (qzonePostsCache.length === 0) {
        postsListEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 30px 0;">è¿™é‡Œç©ºç©ºå¦‚ä¹Ÿï¼Œå¿«æ¥å‘å¸ƒç¬¬ä¸€æ¡è¯´è¯´å§ï¼</p>';
        return;
    }

    
    loadMoreQzonePosts();
}
  

        

async function loadMoreQzonePosts() {
    if (isLoadingMorePosts) return;
    isLoadingMorePosts = true;

    const postsListEl = document.getElementById('qzone-posts-list');
    if (!postsListEl) {
        isLoadingMorePosts = false;
        return;
    }

    showLoader(postsListEl, 'bottom'); 

    
    setTimeout(async () => {
        hideLoader(postsListEl); 

        const nextSliceStart = qzonePostsRenderCount;
        const nextSliceEnd = qzonePostsRenderCount + QZONE_RENDER_WINDOW;
        const postsToAppend = qzonePostsCache.slice(nextSliceStart, nextSliceEnd);

        const fragment = document.createDocumentFragment();
for (const post of postsToAppend) {
                    const postElement = await createOrUpdatePostElement(post); 
                    fragment.appendChild(postElement);
                }
        postsListEl.appendChild(fragment);

        qzonePostsRenderCount += postsToAppend.length;

        isLoadingMorePosts = false;
    }, 500);
}
  
        
        
        function openQzoneStickerPanel(postId, buttonElement) {
            const panel = qzoneStickerPanelState.panelEl;
            const grid = qzoneStickerPanelState.gridEl;
        
            
            grid.innerHTML = '';
            if (state.userStickers.length === 0) {
                grid.innerHTML = '<p style="text-align:center; color: var(--text-secondary); grid-column: 1 / -1; padding-top: 20px;">è¯·å…ˆåœ¨èŠå¤©ç•Œé¢çš„<br>è¡¨æƒ…é¢æ¿ä¸­æ·»åŠ è¡¨æƒ…åŒ…</p>';
            } else {
                state.userStickers.forEach(sticker => {
                    const item = document.createElement('div');
                    item.className = 'sticker-item';
                    item.style.backgroundImage = `url(${sticker.url})`;
                    item.title = sticker.name;
                    grid.appendChild(item);
                });
            }
        
            
        
            
            const btnRect = buttonElement.getBoundingClientRect();
            const phoneScreenRect = document.getElementById('phone-screen').getBoundingClientRect();
            
            panel.style.display = 'flex'; 
            const panelRect = panel.getBoundingClientRect();
            const panelHeight = panelRect.height;
            const panelWidth = panelRect.width;
        
            
            panel.style.top = `${btnRect.top - panelHeight - 5 - phoneScreenRect.top}px`;
        
            
            const desiredLeftPosition = btnRect.left - phoneScreenRect.left;
        
            
            if (desiredLeftPosition + panelWidth > phoneScreenRect.width) {
                
                panel.style.left = 'auto';
                panel.style.right = '5px';
            } else {
                
                panel.style.left = `${desiredLeftPosition}px`;
                panel.style.right = 'auto';
            }
            
            
        
            
            qzoneStickerPanelState.isOpen = true;
            qzoneStickerPanelState.activePostId = postId;
        }
        
        
        
        /**
         * ã€å…¨æ–°ã€‘å…³é—­åŠ¨æ€è¯„è®ºåŒºçš„è¡¨æƒ…é¢æ¿
         */
        function closeQzoneStickerPanel() {
            
            if (qzoneStickerPanelState.isOpen) {
                
                qzoneStickerPanelState.panelEl.style.display = 'none';
                
                
                qzoneStickerPanelState.isOpen = false;
                qzoneStickerPanelState.activePostId = null;
            }
        }
        
        
        
        
        
        /**
         * ã€å…¨æ–°å‡çº§ç‰ˆã€‘å‘é€åŠ¨æ€è¡¨æƒ…è¯„è®ºï¼Œå¹¶å‘ŠçŸ¥AIå…¶å«ä¹‰
         * @param {number} postId - å¸–å­ID
         * @param {object} sticker - å®Œæ•´çš„è¡¨æƒ…å¯¹è±¡ { url, name }
         */
        async function sendQzoneStickerComment(postId, sticker) {
            if (!sticker || !sticker.url) return;
        
            const post = await db.qzonePosts.get(postId);
            if (!post) {
                console.error("sendQzoneStickerComment: æ‰¾ä¸åˆ°å¸–å­:", postId);
                return;
            }
        
            if (!post.comments) {
                post.comments = [];
            }
            
            const newComment = {
                commenterName: state.qzoneSettings.nickname,
                text: sticker.url,
                meaning: sticker.name, 
                timestamp: Date.now()
            };
            
            post.comments.push(newComment);
        
            await db.qzonePosts.update(postId, { comments: post.comments });
        
            closeQzoneStickerPanel();
            await renderQzonePosts();
            
            const postSummary = (post.publicText || post.content || `[å›¾ç‰‡åŠ¨æ€]`).substring(0, 30);
            
            
            for (const chatId in state.chats) {
                const chat = state.chats[chatId];
                if (!chat.isGroup) {
                    const intelligentPrompt = `[ç³»ç»Ÿæç¤ºï¼š'${state.qzoneSettings.nickname}' åœ¨ä½ çš„åŠ¨æ€(ID: ${postId}, å†…å®¹æ‘˜è¦: â€œ${postSummary}â€)ä¸‹å‘é€äº†ä¸€ä¸ªè¡¨æƒ…è¯„è®ºï¼Œæ„æ€æ˜¯ï¼šâ€œ${sticker.name}â€ã€‚è¯·ä½ å¯¹æ­¤ä½œå‡ºå›žåº”ã€‚]`;
                    
                    const historyMessage = { 
                        role: 'system', 
                        content: intelligentPrompt, 
                        timestamp: Date.now(), 
                        isHidden: true 
                    };
                    chat.history.push(historyMessage);
                    await db.chats.put(chat);
                }
            }
            
        }
        
          
        
        
        
        
        /**
         * æ‰“å¼€è½¬å‘è¯„è®ºçš„æ¨¡æ€æ¡†
         * @param {number} postId - è¦è½¬å‘çš„åŠ¨æ€çš„ID
         */
        function openRepostModal(postId) {
            repostTargetId = postId;
            document.getElementById('repost-comment-input').value = ''; 
            document.getElementById('repost-modal').classList.add('visible');
        }
        
        /**
         * éšè—è½¬å‘æ¨¡æ€æ¡†
         */
        function hideRepostModal() {
            document.getElementById('repost-modal').classList.remove('visible');
            repostTargetId = null;
        }
        
        /**
         * å¤„ç†ç¡®è®¤è½¬å‘çš„é€»è¾‘
         */
        async function handleConfirmRepost() {
            if (!repostTargetId) return;
        
            const comment = document.getElementById('repost-comment-input').value.trim();
            const originalPost = await db.qzonePosts.get(repostTargetId);
        
            if (!originalPost) {
                alert("é”™è¯¯ï¼šæ‰¾ä¸åˆ°è¦è½¬å‘çš„åŽŸå§‹åŠ¨æ€ã€‚");
                hideRepostModal();
                return;
            }
        
            const newPost = {
                type: 'repost', 
                timestamp: Date.now(),
                authorId: 'user', 
                repostComment: comment,
                originalPost: originalPost, 
                visibleGroupIds: null 
            };
        
            await db.qzonePosts.add(newPost);
            hideRepostModal();
            await renderQzonePosts();
            alert('è½¬å‘æˆåŠŸï¼');
        }
        
        
        
        
        function displayFilteredFavorites(items) {
            const listEl = document.getElementById('favorites-list');
            listEl.innerHTML = '';
        
            if (items.length === 0) {
                const searchTerm = document.getElementById('favorites-search-input').value;
                const message = searchTerm ? 'æœªæ‰¾åˆ°ç›¸å…³æ”¶è—' : 'ä½ çš„æ”¶è—å¤¹æ˜¯ç©ºçš„ï¼Œ<br>å¿«åŽ»åŠ¨æ€æˆ–èŠå¤©ä¸­æ”¶è—å–œæ¬¢çš„å†…å®¹å§ï¼';
                listEl.innerHTML = `<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">${message}</p>`;
                return;
            }
        
            for (const item of items) {
                const card = document.createElement('div');
                card.className = 'favorite-item-card';
                card.dataset.favid = item.id;
        
                let headerHtml = '', contentHtml = '', sourceText = '', footerHtml = '';
        
                if (item.type === 'qzone_post') {
                    const post = item.content;
                    sourceText = 'æ¥è‡ªåŠ¨æ€';
                    let authorAvatar = defaultAvatar, authorNickname = 'æœªçŸ¥ç”¨æˆ·';
        
                    if (post.authorId === 'user') {
                        authorAvatar = state.qzoneSettings.avatar;
                        authorNickname = state.qzoneSettings.nickname;
                    } else if (state.chats[post.authorId]) {
                        authorAvatar = state.chats[post.authorId].settings.aiAvatar;
                        authorNickname = state.chats[post.authorId].name;
                    }
        
                    headerHtml = `<img src="${authorAvatar}" class="avatar"><div class="info"><div class="name">${authorNickname}</div></div>`;
                    
                    const publicTextHtml = post.publicText ? `<div class="post-content">${post.publicText.replace(/\n/g, '<br>')}</div>` : '';
                    if (post.type === 'shuoshuo') {
                        contentHtml = `<div class="post-content">${post.content.replace(/\n/g, '<br>')}</div>`;
                    } else if (post.type === 'image_post' && post.imageUrl) {
    const postImageUrl = state.globalSettings.enableAiDrawing && post.image_prompt ? `https://image.pollinations.ai/prompt/${post.image_prompt}` : 'https://i.postimg.cc/KYr2qRCK/1.jpg';
    contentHtml = publicTextHtml ? `${publicTextHtml}<div style="margin-top:10px;"><img src="${postImageUrl}" class="chat-image"></div>` : `<img src="${postImageUrl}" class="chat-image">`;
} else if (post.type === 'text_image') {
    const postImageUrl = state.globalSettings.enableAiDrawing && post.image_prompt ? `https://image.pollinations.ai/prompt/${post.image_prompt}` : 'https://i.postimg.cc/KYr2qRCK/1.jpg';
    contentHtml = publicTextHtml ? `${publicTextHtml}<div style="margin-top:10px;"><img src="${postImageUrl}" class="chat-image" style="cursor: pointer;" data-hidden-text="${post.hiddenContent}"></div>` : `<img src="${postImageUrl}" class="chat-image" style="cursor: pointer;" data-hidden-text="${post.hiddenContent}">`;
                    }
        
                    
                    
                    
                    let likesHtml = '';
                    
                    if (post.likes && post.likes.length > 0) {
                        
                        likesHtml = `
                            <div class="post-likes-section">
                                <svg class="like-icon" viewBox="0 0 24 24"><path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"></path></svg>
                                <span>${post.likes.join('ã€')} è§‰å¾—å¾ˆèµž</span>
                            </div>`;
                    }
        
                    
        
        let commentsHtml = '';
        if (post.comments && post.comments.length > 0) {
            commentsHtml = '<div class="post-comments-container">';
            post.comments.forEach((comment, index) => {
                
                if (typeof comment === 'object' && comment !== null && comment.commenterName) {
                    
                    const commenterOriginalName = comment.commenterName;
                    const commenterDisplayName = getDisplayNameByOriginalName(commenterOriginalName);
                    
                    let innerCommentContent;
                    if (STICKER_REGEX.test(comment.text)) {
                        innerCommentContent = `<img src="${comment.text}" class="comment-sticker" alt="sticker">`;
                    } else {
                        innerCommentContent = comment.text;
                    }
        
                    let commentLineHtml = '';
                    if (comment.replyTo) {
                        const repliedToDisplayName = getDisplayNameByOriginalName(comment.replyTo);
                        commentLineHtml = `<span class="commenter-name">${commenterDisplayName}</span> å›žå¤ <span class="commenter-name">${repliedToDisplayName}</span>: ${innerCommentContent}`;
                    } else {
                        commentLineHtml = `<span class="commenter-name">${commenterDisplayName}</span>: ${innerCommentContent}`;
                    }
                    
                    commentsHtml += `<div class="comment-item" data-post-id="${post.id}" data-commenter-original-name="${commenterOriginalName}" data-commenter-display-name="${commenterDisplayName}">
                                        <div class="comment-text">${commentLineHtml}</div>
                                        <span class="comment-delete-btn" data-comment-index="${index}">Ã—</span>
                                     </div>`;
        
                } else {
                    
                    
                    commentsHtml += `<div class="legacy-comment-item">
                                        <span class="comment-text">${String(comment)}</span>
                                     </div>`;
                }
            });
            commentsHtml += '</div>';
        }
          
        
                    
                    footerHtml = `${likesHtml}${commentsHtml}`;
                    
                    
        
        } else if (item.type === 'chat_message') {
            const msg = item.content;
            const chat = state.chats[item.chatId];
            if (!chat) continue; 
        
            sourceText = `æ¥è‡ªä¸Ž ${chat.name} çš„èŠå¤©`;
            const isUser = msg.role === 'user';
            let senderName, senderAvatar;
        
            if (isUser) {
                
                senderName = chat.isGroup ? (chat.settings.myNickname || 'æˆ‘') : 'æˆ‘';
                senderAvatar = chat.settings.myAvatar || (chat.isGroup ? defaultMyGroupAvatar : defaultAvatar);
            } else { 
                 if (chat.isGroup) {
                    
                    
                    const member = chat.members.find(m => m.originalName === msg.senderName);
                    
                    
                    senderName = msg.senderName;
                    
                    senderAvatar = member ? member.avatar : defaultGroupMemberAvatar;
                } else {
                    
                    senderName = chat.name;
                    senderAvatar = chat.settings.aiAvatar || defaultAvatar;
                }
            }
        
            
            headerHtml = `<img src="${senderAvatar}" class="avatar"><div class="info"><div class="name">${senderName}</div></div>`;
            
            if (typeof msg.content === 'string' && STICKER_REGEX.test(msg.content)) {
                contentHtml = `<img src="${msg.content}" class="sticker-image" style="max-width: 80px; max-height: 80px;">`;
            } else if (Array.isArray(msg.content) && msg.content[0]?.type === 'image_url') {
                contentHtml = `<img src="${msg.content[0].image_url.url}" class="chat-image">`;
            } else {
                contentHtml = String(msg.content || '').replace(/\n/g, '<br>');
            }
        }
                      
        else if (item.type === 'char_diary') {
            const diary = item.content;
            sourceText = `æ¥è‡ª ${diary.characterName} çš„æ—¥è®°`;

            const charChat = state.chats[diary.characterId];
            const authorAvatar = charChat ? charChat.settings.aiAvatar : defaultAvatar;
            
            headerHtml = `<img src="${authorAvatar}" class="avatar"><div class="info"><div class="name">${diary.characterName}</div></div>`;
            
            
            const fullDiaryContent = diary.content || '';
            
            const formattedContent = parseMarkdown(fullDiaryContent).replace(/\n/g, '<br>');

            
            contentHtml = `
                <span class="diary-title">${diary.title}</span>
                <div class="fav-card-content-full">${formattedContent}</div>
            `;
        }  
      
    else if (item.type === 'char_browser_article') {
        const article = item.content;
        sourceText = `æ¥è‡ª ${article.characterName} çš„æµè§ˆè®°å½•`;

        const charChat = state.chats[article.characterId];
        const authorAvatar = charChat ? charChat.settings.aiAvatar : defaultAvatar;
        
        headerHtml = `<img src="${authorAvatar}" class="avatar"><div class="info"><div class="name">${article.characterName}</div></div>`;
        
        
        contentHtml = `
            <span class="diary-title">${article.title}</span>
            <div class="memo-content-preview">${(article.content || '').replace(/\n/g, '<br>')}</div>
        `;
    }

else if (item.type === 'char_memo') {
    const memo = item.content;
    sourceText = `æ¥è‡ª ${memo.characterName} çš„å¤‡å¿˜å½•`;

    const charChat = state.chats[memo.characterId];
    const authorAvatar = charChat ? charChat.settings.aiAvatar : defaultAvatar;
    
    headerHtml = `<img src="${authorAvatar}" class="avatar"><div class="info"><div class="name">${memo.characterName}</div></div>`;
    
    
    contentHtml = `
        <span class="memo-title">${memo.title}</span>
        <div class="memo-content-preview">${memo.content.replace(/\n/g, '<br>')}</div>
    `;
}

                
                card.innerHTML = `
                    <div class="fav-card-header">${headerHtml}<div class="source">${sourceText}</div></div>
                    <div class="fav-card-content">${contentHtml}</div>
                    ${footerHtml}`; 
                    
                listEl.appendChild(card);
            }
        }
        
        
        
                /**
                 * ã€é‡æž„åŽçš„å‡½æ•°ã€‘: è´Ÿè´£å‡†å¤‡æ•°æ®å¹¶è§¦å‘æ¸²æŸ“
                 */
                async function renderFavoritesScreen() {
                    
                    allFavoriteItems = await db.favorites.orderBy('timestamp').reverse().toArray();
                    
                    
                    const searchInput = document.getElementById('favorites-search-input');
                    const clearBtn = document.getElementById('favorites-search-clear-btn');
                    searchInput.value = '';
                    clearBtn.style.display = 'none';
        
                    
                    displayFilteredFavorites(allFavoriteItems);
                }
        
                
        
                function resetCreatePostModal() {
                    document.getElementById('post-public-text').value = '';
                    document.getElementById('post-image-preview').src = '';
                    document.getElementById('post-image-description').value = '';
                    document.getElementById('post-image-preview-container').classList.remove('visible');
                    document.getElementById('post-image-desc-group').style.display = 'none';
                    document.getElementById('post-local-image-input').value = '';
                    document.getElementById('post-hidden-text').value = '';
                    document.getElementById('switch-to-image-mode').click();
                }
/**
 * ã€V2.0 | NPCä¿æŠ¤ç‰ˆã€‘ä¸€é”®æ¸…ç†æ•°æ®åº“ä¸­æ‰€æœ‰ä¸Žå·²åˆ é™¤è§’è‰²æˆ–èŠå¤©ç›¸å…³çš„å­¤ç«‹æ•°æ®
 */
async function cleanupRedundantData() {
    const confirmed = await showCustomConfirm(
        'ç¡®è®¤æ¸…ç†å†—ä½™æ•°æ®ï¼Ÿ',
        'æ­¤æ“ä½œå°†æ‰«ææ•°æ®åº“ï¼Œç§»é™¤æ‰€æœ‰ä¸Žå·²åˆ é™¤è§’è‰²ç›¸å…³çš„å­¤ç«‹æ•°æ®ï¼ˆå¦‚åŠ¨æ€ã€è¯„è®ºã€è®°å¿†ç­‰ï¼‰ã€‚<br><br><strong>æ­¤æ“ä½œä¸å¯æ’¤é”€ï¼Œä½†é€šå¸¸æ˜¯å®‰å…¨çš„ã€‚NPCæ•°æ®ä¸ä¼šè¢«åˆ é™¤ã€‚</strong><br><br>å»ºè®®åœ¨æ“ä½œå‰å…ˆå¯¼å‡ºæ•°æ®å¤‡ä»½ã€‚',
        { confirmButtonClass: 'btn-danger', confirmText: 'ç¡®è®¤æ¸…ç†' }
    );

    if (!confirmed) return;

    await showCustomAlert("è¯·ç¨å€™...", "æ­£åœ¨å¼€å§‹æ¸…ç†å†—ä½™æ•°æ®ï¼Œè¯·ä¸è¦å…³é—­é¡µé¢...");
    console.log("å†—ä½™æ•°æ®æ¸…ç†æµç¨‹å·²å¯åŠ¨...");

    let cleanupCounts = {
        posts: 0, likes: 0, comments: 0, memories: 0,
        callRecords: 0, renderingRules: 0, groupMembers: 0, chatLinks: 0,
    };

    try {
        await db.transaction('rw', db.tables, async () => {
            
            const allChats = await db.chats.toArray();
            const allNpcs = await db.npcs.toArray(); 

            const existingChatIds = new Set(allChats.map(c => c.id));
            const existingNpcIds = new Set(allNpcs.map(n => `npc_${n.id}`)); 

            const existingOriginalNames = new Set(allChats.filter(c => !c.isGroup).map(c => c.originalName));
            existingOriginalNames.add(state.qzoneSettings.nickname || '{{user}}');
            
            allNpcs.forEach(npc => existingOriginalNames.add(npc.name));

            
            for (const chat of allChats) {
                 let chatModified = false;
                 if (chat.isGroup && chat.members) {
                     const originalMemberCount = chat.members.length;
                     
                     
                     
                     chat.members = chat.members.filter(member => 
                        existingChatIds.has(member.id) || existingNpcIds.has(member.id)
                     );
                     
                     if (chat.members.length < originalMemberCount) {
                        cleanupCounts.groupMembers += (originalMemberCount - chat.members.length);
                        chatModified = true;
                     }
                 }
                 
                 if (chat.settings?.linkedMemoryChatIds?.length > 0) {
                     const originalLinkCount = chat.settings.linkedMemoryChatIds.length;
                     chat.settings.linkedMemoryChatIds = chat.settings.linkedMemoryChatIds.filter(id => existingChatIds.has(id));
                     if (chat.settings.linkedMemoryChatIds.length < originalLinkCount) {
                        cleanupCounts.chatLinks += (originalLinkCount - chat.settings.linkedMemoryChatIds.length);
                        chatModified = true;
                     }
                 }
                 if(chatModified) {
                     await db.chats.put(chat);
                 }
            }

            
            const allPosts = await db.qzonePosts.toArray();
            for (const post of allPosts) {
                let postModified = false;
                
                
                
                const isAuthorValid = post.authorId === 'user' || existingChatIds.has(post.authorId) || existingNpcIds.has(post.authorId);

                if (!isAuthorValid) {
                    await db.qzonePosts.delete(post.id);
                    cleanupCounts.posts++;
                    continue; 
                }
                
                if (post.likes && post.likes.length > 0) {
                    const originalLikeCount = post.likes.length;
                    post.likes = post.likes.filter(name => existingOriginalNames.has(name));
                    if (post.likes.length < originalLikeCount) {
                        cleanupCounts.likes += (originalLikeCount - post.likes.length);
                        postModified = true;
                    }
                }
                if (post.comments && post.comments.length > 0) {
                    const originalCommentCount = post.comments.length;
                    post.comments = post.comments.filter(comment => {
                        if (typeof comment === 'object' && comment.commenterName) {
                            return existingOriginalNames.has(comment.commenterName);
                        }
                        return true; 
                    });
                     if (post.comments.length < originalCommentCount) {
                        cleanupCounts.comments += (originalCommentCount - post.comments.length);
                        postModified = true;
                    }
                }
                if (postModified) { await db.qzonePosts.put(post); }
            }

            
            await db.memories.where('chatId').noneOf([...existingChatIds]).delete().then(c => cleanupCounts.memories += c);
            await db.callRecords.where('chatId').noneOf([...existingChatIds]).delete().then(c => cleanupCounts.callRecords += c);
            const allRules = await db.renderingRules.toArray();
            for(const rule of allRules) {
                if (rule.chatId !== 'global' && !existingChatIds.has(rule.chatId)) {
                    await db.renderingRules.delete(rule.id);
                    cleanupCounts.renderingRules++;
                }
            }
        });

        let summary = "âœ… æ¸…ç†å®Œæˆï¼\n\n";
        let cleanedSomething = false;
        Object.entries(cleanupCounts).forEach(([key, value]) => {
            if (value > 0) {
                const keyMap = {
                    posts: 'åŠ¨æ€', likes: 'ç‚¹èµž', comments: 'è¯„è®º', memories: 'è®°å¿†',
                    callRecords: 'é€šè¯è®°å½•', renderingRules: 'æ¸²æŸ“è§„åˆ™',
                    groupMembers: 'ç¾¤æˆå‘˜', chatLinks: 'è®°å¿†é“¾æŽ¥'
                };
                summary += `- æ¸…ç†äº† ${value} æ¡æ— æ•ˆçš„${keyMap[key] || key}ã€‚\n`;
                cleanedSomething = true;
            }
        });
        if (!cleanedSomething) {
            summary = "âœ… æ£€æŸ¥å®Œæˆï¼Œæœªå‘çŽ°ä»»ä½•å†—ä½™æ•°æ®ã€‚";
        }
        summary += "\nå»ºè®®åˆ·æ–°é¡µé¢ä»¥ç¡®ä¿æ‰€æœ‰æ›´æ”¹ç”Ÿæ•ˆã€‚";

        await showCustomAlert("æ“ä½œæˆåŠŸ", summary);
        
        const confirmedReload = await showCustomConfirm("åˆ·æ–°é¡µé¢ï¼Ÿ", "ä¸ºäº†ç¡®ä¿æ‰€æœ‰æ•°æ®åŒæ­¥ï¼Œå»ºè®®ç«‹å³åˆ·æ–°é¡µé¢ã€‚");
        if(confirmedReload) {
            location.reload();
        }

    } catch (error) {
        console.error("æ¸…ç†å†—ä½™æ•°æ®æ—¶å‡ºé”™:", error);
        await showCustomAlert('æ¸…ç†å¤±è´¥', `å‘ç”Ÿäº†ä¸€ä¸ªé”™è¯¯: ${error.message}`);
    }
}
        
        async function exportBackup() {
            try {
                const backupData = {
                    version: 1, 
                    timestamp: Date.now()
                };
        
                const [
                    chats, worldBooks, userStickers, apiConfig, globalSettings,
                    personaPresets, musicLibrary, qzoneSettings, qzonePosts,
                    qzoneAlbums, qzonePhotos, favorites, qzoneGroups,
                    memories, worldBookCategories,
                    apiPresets, shoppingProducts, callRecords,
                    renderingRules,
                    
                    doubanPosts,
                    stickerCategories,
                    
                    appearancePresets,
                    
                    presets,              
                    presetCategories,
    
    npcs 
                ] = await Promise.all([
                    db.chats.toArray(),
                    db.worldBooks.toArray(),
                    db.userStickers.toArray(),
                    db.apiConfig.get('main'),
                    db.globalSettings.get('main'),
                    db.personaPresets.toArray(),
                    db.musicLibrary.get('main'),
                    db.qzoneSettings.get('main'),
                    db.qzonePosts.toArray(),
                    db.qzoneAlbums.toArray(),
                    db.qzonePhotos.toArray(),
                    db.favorites.toArray(),
                    db.qzoneGroups.toArray(),
                    db.memories.toArray(),
                    db.worldBookCategories.toArray(),
                    db.apiPresets.toArray(),
                    db.shoppingProducts.toArray(),
                    db.callRecords.toArray(),
                    db.renderingRules.toArray(),
                    
                    db.doubanPosts.toArray(),
                    db.stickerCategories.toArray(),
                    
                    db.appearancePresets.toArray(),
                    
                    db.presets.toArray(),             
                    db.presetCategories.toArray(),
    
    db.npcs.toArray() 
                ]);
        
                Object.assign(backupData, {
                    chats, worldBooks, userStickers, apiConfig, globalSettings,
                    personaPresets, musicLibrary, qzoneSettings, qzonePosts,
                    qzoneAlbums, qzonePhotos, favorites, qzoneGroups,
                    memories, worldBookCategories,
                    apiPresets, shoppingProducts, callRecords,
                    renderingRules,
                    
                    doubanPosts,
                    stickerCategories,
                    
                    appearancePresets,
                    
                    presets,              
                    presetCategories,
    
    npcs  
                });
                
                const blob = new Blob(
                    [JSON.stringify(backupData, null, 2)], 
                    { type: 'application/json' }
                );
                const url = URL.createObjectURL(blob);
                const link = Object.assign(document.createElement('a'), {
                    href: url,
                    download: `EPhone-Full-Backup-${new Date().toISOString().split('T')[0]}.json`
                });
                link.click();
                URL.revokeObjectURL(url);
                
                await showCustomAlert('å¯¼å‡ºæˆåŠŸ', 'å·²æˆåŠŸå¯¼å‡ºæ‰€æœ‰æ•°æ®ï¼');
        
            } catch (error) {
                console.error("å¯¼å‡ºæ•°æ®æ—¶å‡ºé”™:", error);
                await showCustomAlert('å¯¼å‡ºå¤±è´¥', `å‘ç”Ÿäº†ä¸€ä¸ªé”™è¯¯: ${error.message}`);
            }
        }


/**
 * ã€å…¨æ–°ã€‘å¤„ç†æ–°ç‰ˆæµå¼å¤‡ä»½æ–‡ä»¶çš„å¯¼å…¥é€»è¾‘
 * @param {object} backupData - ä»Žæµå¼å¤‡ä»½æ–‡ä»¶ .data å­—æ®µä¸­è§£æžå‡ºçš„æ•°æ®å¯¹è±¡
 */
async function importStreamedBackup(backupData) {
    try {
        await db.transaction('rw', db.tables, async () => {
            
            for (const table of db.tables) {
                await table.clear();
            }

            
            for (const tableName in backupData) {
                if (Array.isArray(backupData[tableName])) {
                    console.log(`æ­£åœ¨å¯¼å…¥è¡¨: ${tableName}, è®°å½•æ•°: ${backupData[tableName].length}`);
                    await db.table(tableName).bulkPut(backupData[tableName]);
                }
            }
        });

    } catch (error) {
        
        throw new Error(`æ•°æ®åº“å†™å…¥å¤±è´¥: ${error.message}`);
    }
}




/**
 * ã€æ™ºèƒ½æ€»ç®¡ | V3.0 | å¢žé‡å¯¼å…¥ç‰ˆã€‘å¤„ç†æ–‡ä»¶å¯¼å…¥ï¼Œè‡ªåŠ¨è¯†åˆ«å¤‡ä»½æ–‡ä»¶ç‰ˆæœ¬å¹¶å¼¹å‡ºé€‰é¡¹
 * @param {File} file - ç”¨æˆ·é€‰æ‹©çš„ .json å¤‡ä»½æ–‡ä»¶
 */
async function handleSmartImport(file) {
    if (!file) return;

    await showCustomAlert("è¯·ç¨å€™...", "æ­£åœ¨è¯»å–å¹¶è§£æžå¤‡ä»½æ–‡ä»¶...");

    try {
        const text = await file.text();
        const data = JSON.parse(text);

        let backupDataContent;
        let backupType;

        // 1. è¯†åˆ«å¤‡ä»½æ–‡ä»¶ç±»åž‹
        if (data.data && typeof data.data === 'object' && (data.data.chats || data.data.worldBooks)) {
            console.log("æ£€æµ‹åˆ°æ–°ç‰ˆæµå¼å¤‡ä»½æ–‡ä»¶...");
            backupDataContent = data.data;
            backupType = 'streamed'; // 'streamed' or 'legacy'
        } else if (data.chats || data.worldBooks) {
            console.log("æ£€æµ‹åˆ°æ—§ç‰ˆå®Œæ•´å¤‡ä»½æ–‡ä»¶...");
            backupDataContent = data;
            backupType = 'legacy';
        } else {
            throw new Error("æ–‡ä»¶æ ¼å¼æ— æ³•è¯†åˆ«ã€‚è¯·ç¡®ä¿æ‚¨é€‰æ‹©çš„æ˜¯æœ‰æ•ˆçš„ EPhone å¤‡ä»½æ–‡ä»¶ã€‚");
        }

        // 2. å°†è§£æžåŽçš„æ•°æ®å’Œç±»åž‹å­˜å…¥ä¸´æ—¶å˜é‡
        pendingBackupData = {
            type: backupType,
            content: backupDataContent
        };

        // 3. æ‰“å¼€æ–°çš„å¯¼å…¥é€‰é¡¹æ¨¡æ€æ¡†
        openImportOptionsModal(backupDataContent);

    } catch (error) {
        console.error("å¯¼å…¥æ•°æ®æ—¶å‡ºé”™:", error);
        pendingBackupData = null; // æ¸…ç†ä¸´æ—¶æ•°æ®
        await showCustomAlert('å¯¼å…¥å¤±è´¥', `æ–‡ä»¶è§£æžæˆ–åº”ç”¨å¤±è´¥: ${error.message}`);
    }
}

/**
 * ã€å…¨æ–°ã€‘æ‰“å¼€å¯¼å…¥é€‰é¡¹æ¨¡æ€æ¡†ï¼Œæ˜¾ç¤ºå¤‡ä»½å†…å®¹æ‘˜è¦
 * @param {object} backupDataContent - è§£æžåŽçš„å¤‡ä»½æ•°æ®å†…å®¹ (e.g., data.data)
 */
function openImportOptionsModal(backupDataContent) {
    const modal = document.getElementById('import-options-modal');
    const listEl = document.getElementById('import-preview-list');
    listEl.innerHTML = '';

    // åŠ¨æ€ç”Ÿæˆå†…å®¹æ‘˜è¦
const contentSummary = {
    'chats': 'èŠå¤©ä¼šè¯', 
    'worldBooks': 'ä¸–ç•Œä¹¦', 
    'worldBookCategories': 'ä¸–ç•Œä¹¦åˆ†ç±»', // <-- [åœ¨è¿™é‡Œæ·»åŠ ]
    'presets': 'ç¦»çº¿é¢„è®¾',
    'presetCategories': 'é¢„è®¾åˆ†ç±»', // <-- [åœ¨è¿™é‡Œæ·»åŠ ]
    'userStickers': 'è¡¨æƒ…åŒ…', 
    'stickerCategories': 'è¡¨æƒ…åˆ†ç±»',
    'customAvatarFrames': 'å¤´åƒæ¡†', 
    'apiConfig': 'APIé…ç½®', 
    'globalSettings': 'å…¨å±€è®¾ç½®', 
    'personaPresets': 'äººè®¾é¢„è®¾',
    'qzoneSettings': 'ç©ºé—´è®¾ç½®', 
    'qzonePosts': 'åŠ¨æ€', 
    'qzoneAlbums': 'ç›¸å†Œ',
    'favorites': 'æ”¶è—', 
    'memories': 'å›žå¿†', 
    'callRecords': 'é€šè¯è®°å½•',
    'shoppingProducts': 'å•†å“', 
    'apiPresets': 'APIé¢„è®¾', 
    'renderingRules': 'æ¸²æŸ“è§„åˆ™', 
    'appearancePresets': 'å¤–è§‚é¢„è®¾', 
    'npcs': 'NPCs'
};

    let foundData = false;
    for (const key in contentSummary) {
        if (backupDataContent[key] && (Array.isArray(backupDataContent[key]) ? backupDataContent[key].length > 0 : backupDataContent[key])) {
            const count = Array.isArray(backupDataContent[key]) ? backupDataContent[key].length : 1;
            const li = document.createElement('li');
            li.textContent = `${contentSummary[key]}: ${count} æ¡/ä¸ª`;
            listEl.appendChild(li);
            foundData = true;
        }
    }

    if (!foundData) {
        listEl.innerHTML = '<li>æœªåœ¨æ­¤æ–‡ä»¶ä¸­æ‰¾åˆ°å¯è¯†åˆ«çš„æ•°æ®ã€‚</li>';
    }

    // ç»‘å®šæŒ‰é’®äº‹ä»¶
    document.getElementById('confirm-full-import-btn').onclick = () => {
        modal.classList.remove('visible');
        handleFullImport(pendingBackupData);
    };
    document.getElementById('confirm-selective-import-btn').onclick = () => {
        modal.classList.remove('visible');
        openSelectiveImportModal(pendingBackupData.content);
    };
    document.getElementById('cancel-import-options-btn').onclick = () => {
        modal.classList.remove('visible');
        pendingBackupData = null;
    };

    modal.classList.add('visible');
}

/**
 * ã€å…¨æ–°ã€‘æ‰§è¡Œå®Œæ•´çš„è¦†ç›–å¯¼å…¥ï¼ˆåŽŸ`handleSmartImport`çš„åŽåŠéƒ¨åˆ†ï¼‰
 * @param {object} backupInfo - åŒ…å« type å’Œ content çš„ä¸´æ—¶å¤‡ä»½å¯¹è±¡
 */
async function handleFullImport(backupInfo) {
    if (!backupInfo) return;

    const confirmed = await showCustomConfirm(
        'ä¸¥é‡è­¦å‘Šï¼',
        'ã€å®Œå…¨å¯¼å…¥ã€‘å°†åˆ é™¤æ‚¨å½“å‰çš„æ‰€æœ‰æ•°æ®å¹¶æ›¿æ¢ä¸ºå¤‡ä»½æ–‡ä»¶ä¸­çš„å†…å®¹ã€‚æ­¤æ“ä½œä¸å¯æ’¤é”€ï¼<br><br><strong>ç¡®å®šè¦ç»§ç»­å—ï¼Ÿ</strong>',
        { confirmButtonClass: 'btn-danger', confirmText: 'æˆ‘æ˜Žç™½ï¼Œè¦†ç›–æ‰€æœ‰æ•°æ®' }
    );
    if (!confirmed) {
        pendingBackupData = null;
        return;
    }

    await showCustomAlert("è¯·ç¨å€™...", "æ­£åœ¨æ‰§è¡Œå®Œå…¨å¯¼å…¥ï¼Œè¯·å‹¿å…³é—­é¡µé¢...");

    try {
        if (backupInfo.type === 'streamed') {
            await importStreamedBackup(backupInfo.content);
        } else if (backupInfo.type === 'legacy') {
            await importLegacyBackup(backupInfo.content);
        } else {
            throw new Error("æœªçŸ¥çš„å¤‡ä»½ç±»åž‹ã€‚");
        }
        
        await showCustomAlert('å¯¼å…¥æˆåŠŸ', 'æ‰€æœ‰æ•°æ®å·²æˆåŠŸæ¢å¤ï¼åº”ç”¨å³å°†åˆ·æ–°ä»¥åº”ç”¨æ‰€æœ‰æ›´æ”¹ã€‚');
        setTimeout(() => window.location.reload(), 1500);

    } catch (error) {
        console.error("å®Œå…¨å¯¼å…¥å¤±è´¥:", error);
        await showCustomAlert('å¯¼å…¥å¤±è´¥', `æ–‡ä»¶åº”ç”¨å¤±è´¥: ${error.message}`);
    } finally {
        pendingBackupData = null;
    }
}

/**
 * ã€å…¨æ–°ã€‘æ‰“å¼€é€‰æ‹©æ€§å¯¼å…¥æ¨¡æ€æ¡†ï¼Œè®©ç”¨æˆ·å‹¾é€‰è¦åˆå¹¶çš„æ•°æ®
 * @param {object} backupDataContent - è§£æžåŽçš„å¤‡ä»½æ•°æ®å†…å®¹
 */
function openSelectiveImportModal(backupDataContent) {
    const modal = document.getElementById('selective-import-modal');
    const listEl = document.getElementById('selective-import-list');
    const selectAllCheckbox = document.getElementById('select-all-import-types');
    listEl.innerHTML = '';
    selectAllCheckbox.checked = true;

const contentSummary = {
    'chats': 'èŠå¤©ä¼šè¯', 
    'worldBooks': 'ä¸–ç•Œä¹¦', 
    'worldBookCategories': 'ä¸–ç•Œä¹¦åˆ†ç±»', // <-- [åœ¨è¿™é‡Œæ·»åŠ ]
    'presets': 'ç¦»çº¿é¢„è®¾',
    'presetCategories': 'é¢„è®¾åˆ†ç±»', // <-- [åœ¨è¿™é‡Œæ·»åŠ ]
    'userStickers': 'è¡¨æƒ…åŒ…', 
    'stickerCategories': 'è¡¨æƒ…åˆ†ç±»',
    'customAvatarFrames': 'å¤´åƒæ¡†', 
    'apiConfig': 'APIé…ç½®', 
    'globalSettings': 'å…¨å±€è®¾ç½®', 
    'personaPresets': 'äººè®¾é¢„è®¾',
    'qzoneSettings': 'ç©ºé—´è®¾ç½®', 
    'qzonePosts': 'åŠ¨æ€', 
    'qzoneAlbums': 'ç›¸å†Œ',
    'favorites': 'æ”¶è—', 
    'memories': 'å›žå¿†', 
    'callRecords': 'é€šè¯è®°å½•',
    'shoppingProducts': 'å•†å“', 
    'apiPresets': 'APIé¢„è®¾', 
    'renderingRules': 'æ¸²æŸ“è§„åˆ™', 
    'appearancePresets': 'å¤–è§‚é¢„è®¾', 
    'npcs': 'NPCs'
};

    let hasContent = false;
    for (const key in contentSummary) {
        if (backupDataContent[key] && (Array.isArray(backupDataContent[key]) ? backupDataContent[key].length > 0 : backupDataContent[key])) {
            const count = Array.isArray(backupDataContent[key]) ? backupDataContent[key].length : 1;
            const isSingleObject = !Array.isArray(backupDataContent[key]);
            
            const item = document.createElement('div');
            item.className = 'clear-posts-item selected'; // å¤ç”¨æ ·å¼, é»˜è®¤é€‰ä¸­
            item.dataset.typeId = key;
            item.innerHTML = `
                <div class="checkbox selected"></div>
                <div>
                    <span class="name">${contentSummary[key]} (${count} æ¡/ä¸ª)</span>
                    ${isSingleObject ? '<p style="font-size: 12px; color: #ff8c00; margin: 4px 0 0;">(æ³¨æ„: è¿™å°†ã€è¦†ç›–ã€‘æ‚¨å½“å‰çš„è®¾ç½®)</p>' : ''}
                </div>
            `;
            listEl.appendChild(item);
            hasContent = true;
        }
    }

    if (!hasContent) {
        listEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary);">æ–‡ä»¶ä¸­æœªæ‰¾åˆ°å¯åˆå¹¶çš„æ•°æ®ã€‚</p>';
    }

    // ç»‘å®šäº‹ä»¶
    document.getElementById('confirm-merge-import-btn').onclick = () => handleSelectiveImport(pendingBackupData);
    document.getElementById('cancel-selective-import-btn').onclick = () => {
        modal.classList.remove('visible');
        pendingBackupData = null;
    };
    
    selectAllCheckbox.onchange = (e) => {
        const isChecked = e.target.checked;
        listEl.querySelectorAll('.clear-posts-item').forEach(item => {
            item.classList.toggle('selected', isChecked);
            item.querySelector('.checkbox').classList.toggle('selected', isChecked);
        });
    };
    
    listEl.onclick = (e) => {
        const item = e.target.closest('.clear-posts-item');
        if (item) {
            item.classList.toggle('selected');
            item.querySelector('.checkbox').classList.toggle('selected');
        }
    };

    modal.classList.add('visible');
}

/**
 * ã€å…¨æ–°ã€‘æ‰§è¡Œé€‰æ‹©æ€§åˆå¹¶å¯¼å…¥
 * @param {object} backupInfo - åŒ…å« type å’Œ content çš„ä¸´æ—¶å¤‡ä»½å¯¹è±¡
 */
async function handleSelectiveImport(backupInfo) {
    if (!backupInfo) return;

    const selectedItems = document.querySelectorAll('#selective-import-list .clear-posts-item.selected');
    if (selectedItems.length === 0) {
        alert("è¯·è‡³å°‘é€‰æ‹©ä¸€ç§è¦åˆå¹¶çš„æ•°æ®ç±»åž‹ã€‚");
        return;
    }

    const typesToMerge = Array.from(selectedItems).map(item => item.dataset.typeId);
    const dataToMerge = backupInfo.content;

    const confirmed = await showCustomConfirm(
        'ç¡®è®¤åˆå¹¶ï¼Ÿ',
        'è¿™å°†æŠŠæ‚¨é€‰æ‹©çš„æ•°æ®ã€æ·»åŠ å¹¶è¦†ç›–ã€‘åˆ°çŽ°æœ‰æ•°æ®ä¸­ã€‚åŒIDçš„æ•°æ®å°†è¢«æ›´æ–°ï¼Œæ–°æ•°æ®å°†è¢«æ·»åŠ ã€‚<br><br><strong>æ­¤æ“ä½œä¸å¯æ’¤é”€ï¼</strong>',
        { confirmText: 'ç¡®è®¤åˆå¹¶' }
    );
    if (!confirmed) return;

    await showCustomAlert("è¯·ç¨å€™...", "æ­£åœ¨åˆå¹¶æ•°æ®ï¼Œè¯·å‹¿å…³é—­é¡µé¢...");

    try {
        
        await db.transaction('rw', db.tables, async () => {
            for (const type of typesToMerge) {
                const data = dataToMerge[type];
                if (!data) continue;

                const table = db.table(type);
                if (!table) {
                    console.warn(`æ‰¾ä¸åˆ°è¡¨: ${type}, è·³è¿‡...`);
                    continue;
                }

                if (Array.isArray(data)) {
                    // æ•°ç»„æ•°æ® (e.g., chats, worldBooks): ä½¿ç”¨ bulkPut è¿›è¡Œå¢žé‡æ›´æ–°/æ’å…¥
                    console.log(`æ­£åœ¨åˆå¹¶ ${data.length} æ¡è®°å½•åˆ° ${type}...`);
                    await table.bulkPut(data);
                } else if (typeof data === 'object' && data.id) {
                    // å¸¦IDçš„å•å¯¹è±¡ (e.g., apiConfig, qzoneSettings): ä½¿ç”¨ put è¿›è¡Œè¦†ç›–
                    console.log(`æ­£åœ¨åˆå¹¶å•æ¡è®°å½•åˆ° ${type}...`);
                    await table.put(data);
                } else if (typeof data === 'object') {
                    // ä¸å¸¦IDçš„å•å¯¹è±¡ (e.g., globalSettings in older backups)
                    console.log(`æ­£åœ¨åˆå¹¶éžæ ‡å¯¹è±¡åˆ° ${type}...`);
                    const existingData = await table.toCollection().first() || {};
                    const mergedData = { ...existingData, ...data };
                    
                    // ç¡®ä¿å®ƒæœ‰ID
                    if (existingData.id) {
                        mergedData.id = existingData.id;
                    } else if (type === 'apiConfig' || type === 'qzoneSettings' || type === 'globalSettings' || type === 'musicLibrary') {
                        mergedData.id = 'main'; // ç¡®ä¿å•ä¾‹è¡¨æœ‰ 'main' ID
                    }
                    
                    await table.put(mergedData);
                }
            }
        });
        
        await showCustomAlert('åˆå¹¶æˆåŠŸ', 'æ•°æ®å·²æˆåŠŸåˆå¹¶ï¼åº”ç”¨å³å°†åˆ·æ–°ä»¥åº”ç”¨æ‰€æœ‰æ›´æ”¹ã€‚');
        setTimeout(() => window.location.reload(), 1500);

    } catch (error) {
        console.error("é€‰æ‹©æ€§å¯¼å…¥å¤±è´¥:", error);
        await showCustomAlert('åˆå¹¶å¤±è´¥', `æ–‡ä»¶åº”ç”¨å¤±è´¥: ${error.message}`);
    } finally {
        pendingBackupData = null;
    }
}

/**
 * ã€æ”¹é€ åŽã€‘å¤„ç†æ—§ç‰ˆå¤‡ä»½æ–‡ä»¶çš„å¯¼å…¥é€»è¾‘
 * @param {object} backupData - ä»Žæ—§ç‰ˆå¤‡ä»½æ–‡ä»¶è§£æžå‡ºçš„æ•°æ®å¯¹è±¡
 */
async function importLegacyBackup(backupData) {
    try {
        await db.transaction('rw', db.tables, async () => {
            await db.chats.clear();
            await db.worldBooks.clear();
            
            for (const table of db.tables) {
                await table.clear();
            }

            if (Array.isArray(backupData.chats)) await db.chats.bulkPut(backupData.chats);
            if (Array.isArray(backupData.worldBooks)) await db.worldBooks.bulkPut(backupData.worldBooks);
            
            if (Array.isArray(backupData.userStickers)) await db.userStickers.bulkPut(backupData.userStickers);
            if (backupData.apiConfig) await db.apiConfig.put(backupData.apiConfig);
            if (backupData.globalSettings) await db.globalSettings.put(backupData.globalSettings);
            
             if (Array.isArray(backupData.personaPresets)) await db.personaPresets.bulkPut(backupData.personaPresets);
            if (backupData.musicLibrary) await db.musicLibrary.put(backupData.musicLibrary);
            if (backupData.qzoneSettings) await db.qzoneSettings.put(backupData.qzoneSettings);
            if (Array.isArray(backupData.qzonePosts)) await db.qzonePosts.bulkPut(backupData.qzonePosts);
            if (Array.isArray(backupData.qzoneAlbums)) await db.qzoneAlbums.bulkPut(backupData.qzoneAlbums);
            if (Array.isArray(backupData.qzonePhotos)) await db.qzonePhotos.bulkPut(backupData.qzonePhotos);
            if (Array.isArray(backupData.favorites)) await db.favorites.bulkPut(backupData.favorites);
            if (Array.isArray(backupData.qzoneGroups)) await db.qzoneGroups.bulkPut(backupData.qzoneGroups);
            if (Array.isArray(backupData.memories)) await db.memories.bulkPut(backupData.memories);
            if (Array.isArray(backupData.worldBookCategories)) await db.worldBookCategories.bulkPut(backupData.worldBookCategories);
            if (Array.isArray(backupData.apiPresets)) await db.apiPresets.bulkPut(backupData.apiPresets);
            if (Array.isArray(backupData.shoppingProducts)) await db.shoppingProducts.bulkPut(backupData.shoppingProducts);
            if (Array.isArray(backupData.callRecords)) await db.callRecords.bulkPut(backupData.callRecords);
            if (Array.isArray(backupData.renderingRules)) await db.renderingRules.bulkPut(backupData.renderingRules);
            if (Array.isArray(backupData.doubanPosts)) await db.doubanPosts.bulkPut(backupData.doubanPosts);
            if (Array.isArray(backupData.stickerCategories)) await db.stickerCategories.bulkPut(backupData.stickerCategories);
            if (Array.isArray(backupData.appearancePresets)) await db.appearancePresets.bulkPut(backupData.appearancePresets);
            if (Array.isArray(backupData.presets)) await db.presets.bulkPut(backupData.presets);
            if (Array.isArray(backupData.presetCategories)) await db.presetCategories.bulkPut(backupData.presetCategories);
            if (Array.isArray(backupData.npcs)) await db.npcs.bulkPut(backupData.npcs);
        });
    } catch (error) {
        throw new Error(`æ—§ç‰ˆå¤‡ä»½æ•°æ®å†™å…¥æ•°æ®åº“å¤±è´¥: ${error.message}`);
    }
}
  
        
                function applyCustomFont(fontUrl, isPreviewOnly = false) {
                    if (!fontUrl) {
                        dynamicFontStyle.innerHTML = '';
                        document.getElementById('font-preview').style.fontFamily = '';
                        return;
                    }
                    const fontName = 'custom-user-font';
                    const newStyle = `
                        @font-face {
                          font-family: '${fontName}';
                          src: url('${fontUrl}');
                          font-display: swap;
                        }`;
                    if (isPreviewOnly) {
                        const previewStyle = document.getElementById('preview-font-style') || document.createElement('style');
                        previewStyle.id = 'preview-font-style';
                        previewStyle.innerHTML = newStyle;
                        if (!document.getElementById('preview-font-style')) document.head.appendChild(previewStyle);
                        document.getElementById('font-preview').style.fontFamily = `'${fontName}', 'bulangni', sans-serif`;
                    } else {
                        dynamicFontStyle.innerHTML = `
                            ${newStyle}
                            body {
                              font-family: '${fontName}', 'bulangni', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
                            }`;
                    }
                }
        
                async function resetToDefaultFont() {
                    dynamicFontStyle.innerHTML = ''; 
                    state.globalSettings.fontUrl = '';
                    await db.globalSettings.put(state.globalSettings);
                    document.getElementById('font-url-input').value = '';
                    document.getElementById('font-preview').style.fontFamily = '';
                    alert('å·²æ¢å¤é»˜è®¤å­—ä½“ã€‚');
                }
        

async function loadAllDataFromDB() {
    const [
        chatsArr, apiConfig, loadedGlobalSettings, userStickers, worldBooks,
        musicLib, personaPresets, qzoneSettings, initialFavorites,
        allMemories,
        
        allPresets
    ] = await Promise.all([
        db.chats.toArray(), db.apiConfig.get('main'), db.globalSettings.get('main'),
        db.userStickers.toArray(), db.worldBooks.toArray(), db.musicLibrary.get('main'),
        db.personaPresets.toArray(), db.qzoneSettings.get('main'), db.favorites.orderBy('timestamp').reverse().toArray(),
        db.memories.toArray(),
        
        db.presets.toArray()
    ]);

    
    state.presets = allPresets || [];

    
    const defaultGlobalSettings = {
        id: 'main',
        showStatusBar: false,
        wallpaper: 'linear-gradient(135deg, #89f7fe, #66a6ff)',
        fontUrl: '',
        enableBackgroundActivity: false,
        backgroundActivityInterval: 60,
        blockCooldownHours: 1,
        apiTemperature: 0.8,
        appIcons: { ...DEFAULT_APP_ICONS },
        cphoneWallpaper: 'linear-gradient(135deg, #f6d365, #fda085)',
        cphoneAppIcons: { ...DEFAULT_CPHONE_ICONS },
        globalCss: '',
        notificationSoundUrl: '',
        widgetData: {},
        globalChatBackground: '',
        enableAiDrawing: true,
showPhoneFrame: false,
alwaysShowMusicIsland: false,
detachStatusBar: false,
enableMinimalChatUI: false,
    chatActionButtonsOrder: null,
    shoppingCategoryCount: 3,
    shoppingProductCount: 8,
        chatRenderWindow: 50
    };
    state.globalSettings = { ...defaultGlobalSettings, ...(loadedGlobalSettings || {}) };
    state.globalSettings.appIcons = { ...defaultGlobalSettings.appIcons, ...(state.globalSettings.appIcons || {}) };
    state.globalSettings.cphoneAppIcons = { ...defaultGlobalSettings.cphoneAppIcons, ...(state.globalSettings.cphoneAppIcons || {}) };

    chatsArr.forEach(chat => {
            if (typeof chat.settings.enableTimePerception === 'undefined') {
                chat.settings.enableTimePerception = true;
            }
        if (!chat.settings.lyricsPosition) {
            chat.settings.lyricsPosition = { vertical: 'top', horizontal: 'center', offset: 10 };
        }
        if (!chat.isGroup && !chat.settings.myAvatarLibrary) {
            chat.settings.myAvatarLibrary = [];
        }
        if (!chat.isGroup && typeof chat.originalName === 'undefined') {
            chat.originalName = chat.name;
        }
    });
    state.chats = chatsArr.reduce((acc, chat) => {
        if (typeof chat.unreadCount === 'undefined') chat.unreadCount = 0;
        if (chat.isGroup) {
            if (typeof chat.settings.enableBackgroundActivity === 'undefined') {
                chat.settings.enableBackgroundActivity = true;
            }
            if (chat.members && chat.members.length > 0 && chat.members[0].name) {
                chat.members.forEach(member => {
                    if (typeof member.originalName === 'undefined') {
                        member.originalName = member.name;
                        member.groupNickname = member.name;
                        delete member.name;
                    }
                });
            }
        }
        if (!chat.settings) chat.settings = {};
        if (typeof chat.settings.actionCooldownMinutes === 'undefined') {
            chat.settings.actionCooldownMinutes = 10;
        }
        if (!chat.isGroup && !chat.status) chat.status = { text: 'åœ¨çº¿', lastUpdate: Date.now(), isBusy: false };
        if (!chat.isGroup && !chat.relationship) chat.relationship = { status: 'friend', blockedTimestamp: null, applicationReason: '' };
        if (!chat.isGroup && (!chat.settings || !chat.settings.aiAvatarLibrary)) { if (!chat.settings) chat.settings = {}; chat.settings.aiAvatarLibrary = []; }
        if (chat.isGroup) { (chat.members || []).forEach(member => { if (typeof member.avatarFrame === 'undefined') member.avatarFrame = ''; }); }
        if (!chat.musicData) chat.musicData = { totalTime: 0 };
        if (chat.settings && chat.settings.linkedWorldBookId && !chat.settings.linkedWorldBookIds) { chat.settings.linkedWorldBookIds = [chat.settings.linkedWorldBookId]; delete chat.settings.linkedWorldBookId; }
        if (typeof chat.isPinned === 'undefined') chat.isPinned = false;
        if (!chat.isGroup && typeof chat.settings.myNickname === 'undefined') {
            chat.settings.myNickname = 'æˆ‘';
        }
        if (chat.isGroup && chat.members) {
            let needsUpdate = false;
            chatsArr.forEach(c => {
                 if (c.id === chat.id && c.originalName) {
                    delete c.originalName;
                 }
            });
            chat.members.forEach(member => {
                const originalCharacter = chatsArr.find(c => c.id === member.id);
                if (originalCharacter && originalCharacter.settings) {
                    const correctFrame = originalCharacter.settings.aiAvatarFrame || '';
                    if (member.avatarFrame !== correctFrame) {
                        member.avatarFrame = correctFrame;
                        needsUpdate = true;
                    }
                } else if (typeof member.avatarFrame === 'undefined') {
                    member.avatarFrame = '';
                    needsUpdate = true;
                }
            });
            if (needsUpdate) db.chats.put(chat);
        }
        if (!chat.settings.enableAutoMemory) chat.settings.enableAutoMemory = false;
        if (!chat.settings.autoMemoryInterval) chat.settings.autoMemoryInterval = 20;
        if (!chat.longTermMemory) chat.longTermMemory = [];
        if (!chat.lastMemorySummaryTimestamp) chat.lastMemorySummaryTimestamp = 0;
        if (!chat.isGroup) {
            if (typeof chat.settings.enableBackgroundActivity === 'undefined') {
                chat.settings.enableBackgroundActivity = true;
            }
            if (typeof chat.settings.enableTts === 'undefined') { chat.settings.enableTts = false; }
            if (!chat.status) chat.status = { text: 'åœ¨çº¿', lastUpdate: Date.now(), isBusy: false };
            if (!chat.relationship) chat.relationship = { status: 'friend', blockedTimestamp: null, applicationReason: '' };
            if (!chat.settings || !chat.settings.aiAvatarLibrary) { if (!chat.settings) chat.settings = {}; chat.settings.aiAvatarLibrary = []; }
            if (typeof chat.settings.isOfflineMode === 'undefined') chat.settings.isOfflineMode = false;
            if (typeof chat.settings.offlineMinLength === 'undefined') chat.settings.offlineMinLength = 100;
            if (typeof chat.settings.offlineMaxLength === 'undefined') chat.settings.offlineMaxLength = 300;

            if (typeof chat.settings.injectLatestThought === 'undefined') {
                chat.settings.injectLatestThought = false; 
            }
              
            if (typeof chat.heartfeltVoice === 'undefined') chat.heartfeltVoice = '...';
            if (typeof chat.randomJottings === 'undefined') chat.randomJottings = '...';
            if (!Array.isArray(chat.thoughtsHistory)) {
                chat.thoughtsHistory = [];
            }
        }
if (typeof chat.settings.stickerCategoryIds === 'undefined') {
            // å¦‚æžœä¸å­˜åœ¨ï¼Œå°±ä»Žæ—§çš„å•ä¸ªIDå­—æ®µè¿ç§»
            if (chat.settings.stickerCategoryId) {
                // å°†æ—§çš„IDæ”¾å…¥æ–°æ•°ç»„ä¸­
                chat.settings.stickerCategoryIds = [chat.settings.stickerCategoryId];
            } else {
                // å¦‚æžœæ—§å­—æ®µä¹Ÿä¸å­˜åœ¨ï¼Œå°±åˆå§‹åŒ–ä¸€ä¸ªç©ºæ•°ç»„
                chat.settings.stickerCategoryIds = [];
            }
            // åˆ æŽ‰æ—§çš„å­—æ®µ
            delete chat.settings.stickerCategoryId;
        }
        acc[chat.id] = chat;
        return acc;
    }, {});
    const memoriesToUpdate = [];
    allMemories.forEach(memory => {
        if (memory.type === 'ai_generated' && memory.authorName && !memory.authorId) {
            const foundChat = chatsArr.find(c => !c.isGroup && c.originalName === memory.authorName);
            if (foundChat) {
                memory.authorId = foundChat.id;
                memoriesToUpdate.push(memory);
            } else {
                 const fallbackChat = chatsArr.find(c => !c.isGroup && c.name === memory.authorName);
                 if(fallbackChat) {
                    memory.authorId = fallbackChat.id;
                    memoriesToUpdate.push(memory);
                 }
            }
        }
    });
    if (memoriesToUpdate.length > 0) {
        await db.memories.bulkPut(memoriesToUpdate);
    }
    state.apiConfig = apiConfig || { id: 'main', proxyUrl: '', apiKey: '', model: '', secondaryProxyUrl: '', secondaryApiKey: '', secondaryModel: '', minimaxGroupId: '', minimaxApiKey: '', minimaxModel: 'speech-01' };
    state.userStickers = userStickers || [];
    state.worldBooks = worldBooks || [];
    musicState.playlist = musicLib?.playlist || [];
    state.personaPresets = personaPresets || [];
    state.qzoneSettings = qzoneSettings || { id: 'main', nickname: '{{user}}', avatar: 'https://files.catbox.moe/q6z5fc.jpeg', banner: 'https://files.catbox.moe/r5heyt.gif' };
    allFavoriteItems = initialFavorites || [];
}
  
        
                async function saveGlobalPlaylist() { await db.musicLibrary.put({ id: 'main', playlist: musicState.playlist }); }
        
                function formatTimestamp(timestamp) { if (!timestamp) return ''; const date = new Date(timestamp); const hours = String(date.getHours()).padStart(2, '0'); const minutes = String(date.getMinutes()).padStart(2, '0'); return `${hours}:${minutes}`; }
/**
 * ã€å…¨æ–°ã€‘å°†æ—¶é—´æˆ³è½¬æ¢ä¸ºâ€œxxå‰â€çš„ç›¸å¯¹æ—¶é—´æ ¼å¼
 * @param {number} timestamp - è¿‡åŽ»çš„æ—¶é—´æˆ³
 * @returns {string} - æ ¼å¼åŒ–åŽçš„ç›¸å¯¹æ—¶é—´å­—ç¬¦ä¸²ï¼Œä¾‹å¦‚ "5åˆ†é’Ÿå‰", "3å¤©å‰"
 */
function formatTimeAgo(timestamp) {
    const now = Date.now();
    const seconds = Math.floor((now - timestamp) / 1000);

    if (seconds < 60) return 'åˆšåˆš';
    
    const minutes = Math.floor(seconds / 60);
    if (minutes < 60) return `${minutes}åˆ†é’Ÿå‰`;
    
    const hours = Math.floor(minutes / 60);
    if (hours < 24) return `${hours}å°æ—¶å‰`;

    const days = Math.floor(hours / 24);
    if (days < 30) return `${days}å¤©å‰`;

    const months = Math.floor(days / 30);
    if (months < 12) return `å¤§çº¦${months}ä¸ªæœˆå‰`;

    const years = Math.floor(days / 365);
    return `å¤§çº¦${years}å¹´å‰`;
}
/**
 * ã€å…¨æ–° V2.0 | æ™ºèƒ½æ—¥æœŸæ„ŸçŸ¥ç‰ˆã€‘ä¸ºAIä¸Šä¸‹æ–‡æ ¼å¼åŒ–æ—¶é—´æˆ³
 * @param {number} timestamp - æ¶ˆæ¯çš„æ—¶é—´æˆ³
 * @returns {string} - æ ¼å¼åŒ–åŽçš„æ—¥æœŸæ—¶é—´å­—ç¬¦ä¸²ï¼Œä¾‹å¦‚ "ä»Šå¤© 17:42", "æ˜¨å¤© 23:50" ç­‰
 */
function formatTimestampForAI(timestamp) {
    if (!timestamp) return '';
    
    const now = new Date();
    const date = new Date(timestamp);

    const hours = String(date.getHours()).padStart(2, '0');
    const minutes = String(date.getMinutes()).padStart(2, '0');
    const timeString = `${hours}:${minutes}`;

    
    if (now.toDateString() === date.toDateString()) {
        return `ä»Šå¤© ${timeString}`;
    }

    
    const yesterday = new Date();
    yesterday.setDate(now.getDate() - 1);
    if (yesterday.toDateString() === date.toDateString()) {
        return `æ˜¨å¤© ${timeString}`;
    }
    
    
    if (now.getFullYear() === date.getFullYear()) {
        const month = String(date.getMonth() + 1);
        const day = String(date.getDate());
        return `${month}æœˆ${day}æ—¥ ${timeString}`;
    }
    
    
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1);
    const day = String(date.getDate());
    return `${year}å¹´${month}æœˆ${day}æ—¥ ${timeString}`;
}

// ========================================
// ç¬¬åéƒ¨åˆ†ï¼šNovelAIè®¾ç½®ç›¸å…³å‡½æ•°ï¼ˆåŠ è½½ã€ä¿å­˜ã€é‡ç½®ï¼‰
// ========================================

// NovelAIè®¾ç½®ç›¸å…³å‡½æ•°
function loadNovelAISettings() {
    const settings = getNovelAISettings();
    document.getElementById('nai-resolution').value = settings.resolution;
    document.getElementById('nai-steps').value = settings.steps;
    document.getElementById('nai-cfg-scale').value = settings.cfg_scale;
    document.getElementById('nai-sampler').value = settings.sampler;
    document.getElementById('nai-seed').value = settings.seed;
    document.getElementById('nai-uc-preset').value = settings.uc_preset;
    document.getElementById('nai-quality-toggle').checked = settings.quality_toggle;
    document.getElementById('nai-smea').checked = settings.smea;
    document.getElementById('nai-smea-dyn').checked = settings.smea_dyn;
    document.getElementById('nai-default-positive').value = settings.default_positive;
    document.getElementById('nai-default-negative').value = settings.default_negative;
    document.getElementById('nai-cors-proxy').value = settings.cors_proxy;
    document.getElementById('nai-custom-proxy-url').value = settings.custom_proxy_url || '';
    
    // æ˜¾ç¤º/éšè—è‡ªå®šä¹‰ä»£ç†è¾“å…¥æ¡†
    const customProxyGroup = document.getElementById('nai-custom-proxy-group');
    customProxyGroup.style.display = settings.cors_proxy === 'custom' ? 'block' : 'none';
}

function saveNovelAISettings() {
    // ä¿å­˜API Keyå’Œæ¨¡åž‹ç­‰åŸºç¡€é…ç½®
    const novelaiEnabled = document.getElementById('novelai-switch').checked;
    const novelaiModel = document.getElementById('novelai-model').value;
    const novelaiApiKey = document.getElementById('novelai-api-key').value.trim();
    
    localStorage.setItem('novelai-enabled', novelaiEnabled);
    localStorage.setItem('novelai-model', novelaiModel);
    localStorage.setItem('novelai-api-key', novelaiApiKey);
    
    // ä¿å­˜é«˜çº§å‚æ•°é…ç½®
    const settings = {
        resolution: document.getElementById('nai-resolution').value,
        steps: parseInt(document.getElementById('nai-steps').value),
        cfg_scale: parseFloat(document.getElementById('nai-cfg-scale').value),
        sampler: document.getElementById('nai-sampler').value,
        seed: parseInt(document.getElementById('nai-seed').value),
        uc_preset: parseInt(document.getElementById('nai-uc-preset').value),
        quality_toggle: document.getElementById('nai-quality-toggle').checked,
        smea: document.getElementById('nai-smea').checked,
        smea_dyn: document.getElementById('nai-smea-dyn').checked,
        default_positive: document.getElementById('nai-default-positive').value,
        default_negative: document.getElementById('nai-default-negative').value,
        cors_proxy: document.getElementById('nai-cors-proxy').value,
        custom_proxy_url: document.getElementById('nai-custom-proxy-url').value
    };
    
    localStorage.setItem('novelai-settings', JSON.stringify(settings));
}

function resetNovelAISettings() {
    localStorage.removeItem('novelai-settings');
    loadNovelAISettings();
    alert('å·²æ¢å¤é»˜è®¤è®¾ç½®ï¼');
}

function getNovelAISettings() {
    const defaultSettings = {
        resolution: '1024x1024',
        steps: 28,
        cfg_scale: 5,
        sampler: 'k_euler_ancestral',
        seed: -1,
        uc_preset: 1,
        quality_toggle: true,
        smea: true,
        smea_dyn: false,
        default_positive: 'masterpiece, best quality, 1girl, beautiful, detailed face, detailed eyes, long hair, anime style',
        default_negative: 'lowres, bad anatomy, bad hands, text, error, missing fingers, extra digit, fewer digits, cropped, worst quality, low quality, normal quality, jpeg artifacts, signature, watermark, username, blurry',
        cors_proxy: 'https://corsproxy.io/?',
        custom_proxy_url: ''
    };
    
    const saved = localStorage.getItem('novelai-settings');
    if (saved) {
        try {
            return {...defaultSettings, ...JSON.parse(saved)};
        } catch (e) {
            return defaultSettings;
        }
    }
    return defaultSettings;
}
/**
 * ã€å…¨æ–° | æ ¸å¿ƒNAIç”Ÿæˆå‡½æ•°ã€‘
 * æ ¹æ®æç¤ºè¯ã€è§’è‰²é…ç½®å’Œç³»ç»Ÿè®¾ç½®ï¼Œè°ƒç”¨NovelAI APIç”Ÿæˆä¸€å¼ å›¾ç‰‡ã€‚
 * @param {string} aiPrompt - AIæˆ–ç”¨æˆ·æä¾›çš„æ ¸å¿ƒæç¤ºè¯
 * @param {string} chatId - è§’è‰²IDï¼Œç”¨äºŽèŽ·å–ä¸“å±žé…ç½®
 * @returns {Promise<object>} - è¿”å›žä¸€ä¸ªå¯¹è±¡ { imageUrl: 'data:image/png;base64,...', fullPrompt: '...' }
 */
async function generateNaiImageFromPrompt(aiPrompt, chatId) {
    console.log(`ðŸŽ¨ [NAIæ ¸å¿ƒç”Ÿæˆ] å¼€å§‹... Prompt: "${aiPrompt}", ChatID: ${chatId}`);

    // 1. èŽ·å–æ‰€æœ‰é…ç½®
    const naiPrompts = getCharacterNAIPrompts(chatId);
    const finalPositivePrompt = aiPrompt + ', ' + naiPrompts.positive;
    const finalNegativePrompt = naiPrompts.negative;

    console.log(`ðŸ“ ä½¿ç”¨${naiPrompts.source === 'character' ? 'è§’è‰²ä¸“å±ž' : 'ç³»ç»Ÿ'}æç¤ºè¯é…ç½®`);
    console.log('   [+] æœ€ç»ˆæ­£é¢æç¤ºè¯:', finalPositivePrompt);
    console.log('   [-] æœ€ç»ˆè´Ÿé¢æç¤ºè¯:', finalNegativePrompt);
    
    const apiKey = localStorage.getItem('novelai-api-key');
    const model = localStorage.getItem('novelai-model') || 'nai-diffusion-4-5-full';
    const settings = getNovelAISettings();

    if (!apiKey) {
        throw new Error('NovelAI API Keyæœªé…ç½®ã€‚è¯·åœ¨NovelAIè®¾ç½®ä¸­å¡«å†™API Keyã€‚');
    }

    const [width, height] = settings.resolution.split('x').map(Number);
    
    // 2. æž„å»ºè¯·æ±‚ä½“ (V3 vs V4)
    let requestBody;
    if (model.includes('nai-diffusion-4')) {
        requestBody = {
            input: finalPositivePrompt,
            model: model,
            action: 'generate',
            parameters: {
                params_version: 3,
                width: width, height: height,
                scale: settings.cfg_scale,
                sampler: settings.sampler,
                steps: settings.steps,
                seed: settings.seed === -1 ? Math.floor(Math.random() * 9999999999) : settings.seed,
                n_samples: 1,
                ucPreset: settings.uc_preset,
                qualityToggle: settings.quality_toggle,
                add_original_image: true,
                noise_schedule: 'karras',
                v4_prompt: {
                    caption: { base_caption: finalPositivePrompt, char_captions: [] },
                    use_coords: false, use_order: true
                },
                v4_negative_prompt: {
                    caption: { base_caption: finalNegativePrompt, char_captions: [] },
                    legacy_uc: false
                },
                negative_prompt: finalNegativePrompt,
                autoSmea: false,
                dynamic_thresholding: false,
                controlnet_strength: 1,
                legacy: false,
                cfg_rescale: 0,
                legacy_v3_extend: false,
                skip_cfg_above_sigma: null,
                use_coords: false,
                legacy_uc: false,
                normalize_reference_strength_multiple: true,
                inpaintImg2ImgStrength: 1,
                characterPrompts: [],
                deliberate_euler_ancestral_bug: false,
                prefer_brownian: true
            }
        };
    } else {
        // V3
        requestBody = {
            input: finalPositivePrompt,
            model: model,
            action: 'generate',
            parameters: {
                width: width, height: height,
                scale: settings.cfg_scale,
                sampler: settings.sampler,
                steps: settings.steps,
                seed: settings.seed === -1 ? Math.floor(Math.random() * 9999999999) : settings.seed,
                n_samples: 1,
                ucPreset: settings.uc_preset,
                qualityToggle: settings.quality_toggle,
                sm: settings.smea,
                sm_dyn: settings.smea_dyn,
                negative_prompt: finalNegativePrompt,
                dynamic_thresholding: false,
                controlnet_strength: 1,
                legacy: false,
                add_original_image: false,
                cfg_rescale: 0,
                noise_schedule: 'native'
            }
        };
    }

    console.log('ðŸš€ å‘é€NAIè¯·æ±‚:', requestBody);

    // 3. æž„å»º API URL (å¸¦ä»£ç†)
    let apiUrl;
    if (model.includes('nai-diffusion-4')) {
        apiUrl = 'https://image.novelai.net/ai/generate-image-stream';
    } else {
        apiUrl = 'https://image.novelai.net/ai/generate-image';
    }
    
    let corsProxy = settings.cors_proxy;
    if (corsProxy === 'custom') {
        corsProxy = settings.custom_proxy_url || '';
    }
    if (corsProxy && corsProxy !== '') {
        apiUrl = corsProxy + encodeURIComponent(apiUrl);
    }

    // 4. Fetch
    const response = await fetch(apiUrl, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json', 'Authorization': 'Bearer ' + apiKey },
        body: JSON.stringify(requestBody)
    });

    if (!response.ok) {
        const errorText = await response.text();
        throw new Error(`APIè¯·æ±‚å¤±è´¥ (${response.status}): ${errorText}`);
    }

    const contentType = response.headers.get('content-type');
    let zipBlob;
    let imageDataUrl; // ç›®æ ‡ï¼šèŽ·å–è¿™ä¸ª dataURL

    // 5. å¤„ç†å“åº” (SSE æˆ– ZIP)
    if (contentType && contentType.includes('text/event-stream')) {
        // SSE
        const text = await response.text();
        const lines = text.trim().split('\n');
        let base64Data = null;
        
        for (let i = lines.length - 1; i >= 0; i--) {
            const line = lines[i].trim();
            if (line.startsWith('data: ') && line !== 'data: [DONE]') {
                const dataContent = line.substring(6);
                try {
                    const jsonData = JSON.parse(dataContent);
                    if (jsonData.event_type === 'final' && jsonData.image) {
                        base64Data = jsonData.image; break;
                    }
                    if (jsonData.data) { base64Data = jsonData.data; break; }
                    if (jsonData.image) { base64Data = jsonData.image; break; }
                } catch (e) {
                    base64Data = dataContent; break;
                }
            }
        }
        if (!base64Data) throw new Error('æ— æ³•ä»Ž SSE å“åº”ä¸­æå–å›¾ç‰‡æ•°æ®');

        const isPNG = base64Data.startsWith('iVBORw0KGgo');
        const isJPEG = base64Data.startsWith('/9j/');

        if (isPNG || isJPEG) {
            // V4.5+ ç›´æŽ¥è¿”å›ž dataURL
            imageDataUrl = `data:${isPNG ? 'image/png' : 'image/jpeg'};base64,${base64Data}`;
        } else {
            // V4.0 è¿”å›ž ZIP base64
            const binaryString = atob(base64Data);
            const bytes = new Uint8Array(binaryString.length);
            for (let i = 0; i < binaryString.length; i++) bytes[i] = binaryString.charCodeAt(i);
            zipBlob = new Blob([bytes]);
        }
    } else {
        // ZIP
        zipBlob = await response.blob();
    }

    // 6. è§£åŽ‹ (å¦‚æžœéœ€è¦)
    if (!imageDataUrl && zipBlob) {
        if (typeof JSZip === 'undefined') throw new Error('JSZipåº“æœªåŠ è½½');
        
        const zip = await JSZip.loadAsync(zipBlob);
        let imageFile = null;
        for (let filename in zip.files) {
            if (filename.match(/\.(png|jpg|jpeg|webp)$/i)) {
                imageFile = zip.files[filename]; break;
            }
        }
        if (!imageFile) throw new Error('ZIPæ–‡ä»¶ä¸­æœªæ‰¾åˆ°å›¾ç‰‡');
        
        const imageBlob = await imageFile.async('blob');
        
        // 7. è½¬æ¢ä¸º dataURL
        imageDataUrl = await new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onloadend = () => resolve(reader.result);
            reader.onerror = reject;
            reader.readAsDataURL(imageBlob);
        });
    }

    console.log(`âœ… [NAIæ ¸å¿ƒç”Ÿæˆ] æˆåŠŸï¼`);
    return {
        imageUrl: imageDataUrl,
        fullPrompt: finalPositivePrompt
    };
}
/**
 * æ ¹æ®è§’è‰²IDèŽ·å–å¯¹åº”çš„NAIæç¤ºè¯é…ç½®
 * @param {string} chatId - èŠå¤©/è§’è‰²ID
 * @returns {Object} åŒ…å«æ­£é¢å’Œè´Ÿé¢æç¤ºè¯çš„å¯¹è±¡
 */
function getCharacterNAIPrompts(chatId) {
    // èŽ·å–ç³»ç»Ÿé»˜è®¤é…ç½®
    const systemSettings = getNovelAISettings();
    
    // å¦‚æžœæ²¡æœ‰æŒ‡å®šè§’è‰²IDæˆ–è§’è‰²ä¸å­˜åœ¨ï¼Œè¿”å›žç³»ç»Ÿé…ç½®
    if (!chatId || !state.chats[chatId]) {
        console.log('âš ï¸ NAIæç¤ºè¯ï¼šæ²¡æœ‰è§’è‰²ï¼Œä½¿ç”¨ç³»ç»Ÿé…ç½®');
        return {
            positive: systemSettings.default_positive,
            negative: systemSettings.default_negative,
            source: 'system'
        };
    }
    
    const chat = state.chats[chatId];
    const naiSettings = chat.settings.naiSettings || {};
    
    // é€‰è§’è‰²å°±ç”¨è§’è‰²çš„ï¼Œé€‰ç³»ç»Ÿå°±ç”¨ç³»ç»Ÿçš„ï¼Œå°±è¿™ä¹ˆç®€å•ï¼
    if (naiSettings.promptSource === 'character') {
        console.log('âœ… NAIæç¤ºè¯ï¼šä½¿ç”¨è§’è‰²é…ç½®');
        console.log('   æ­£é¢:', naiSettings.characterPositivePrompt || '(ç©º)');
        console.log('   è´Ÿé¢:', naiSettings.characterNegativePrompt || '(ç©º)');
        
        return {
            positive: naiSettings.characterPositivePrompt || '',
            negative: naiSettings.characterNegativePrompt || '',
            source: 'character'
        };
    } else {
        console.log('âœ… NAIæç¤ºè¯ï¼šä½¿ç”¨ç³»ç»Ÿé…ç½®');
        console.log('   æ­£é¢:', systemSettings.default_positive || '(ç©º)');
        console.log('   è´Ÿé¢:', systemSettings.default_negative || '(ç©º)');
        
        return {
            positive: systemSettings.default_positive,
            negative: systemSettings.default_negative,
            source: 'system'
        };
    }
}
// â–²â–²â–² èŽ·å–è§’è‰²NAIæç¤ºè¯é…ç½®çš„è¾…åŠ©å‡½æ•°ç»“æŸ â–²â–²â–²

// ========================================
// ç¬¬åäºŒéƒ¨åˆ†ï¼šç”ŸæˆNovelAIå›¾ç‰‡çš„ä¸»å‡½æ•°ï¼ˆå®Œæ•´ç‰ˆï¼‰
// ========================================

async function generateNovelAIImage() {
    const apiKey = document.getElementById('novelai-api-key').value.trim();
    const model = document.getElementById('novelai-model').value;
    const prompt = document.getElementById('nai-test-prompt').value.trim();
    
    if (!apiKey) {
        alert('è¯·å…ˆé…ç½®NovelAI API Keyï¼');
        return;
    }
    
    if (!prompt) {
        alert('è¯·è¾“å…¥æç¤ºè¯ï¼');
        return;
    }
    
    const settings = getNovelAISettings();
    const negativePrompt = document.getElementById('nai-test-negative').value.trim();
    
    const statusDiv = document.getElementById('nai-test-status');
    const resultDiv = document.getElementById('nai-test-result');
    const errorDiv = document.getElementById('nai-test-error');
    const generateBtn = document.getElementById('nai-generate-btn');
    
    statusDiv.style.display = 'block';
    resultDiv.style.display = 'none';
    errorDiv.style.display = 'none';
    generateBtn.disabled = true;
    generateBtn.textContent = 'ç”Ÿæˆä¸­...';
    
    try {
        const [width, height] = settings.resolution.split('x').map(Number);
        
        // â˜…â˜…â˜… V4/V4.5 å’Œ V3 ä½¿ç”¨ä¸åŒçš„è¯·æ±‚ä½“æ ¼å¼ â˜…â˜…â˜…
        let requestBody;
        
        if (model.includes('nai-diffusion-4')) {
            // V4/V4.5 ä½¿ç”¨æ–°æ ¼å¼ (params_version: 3)
            requestBody = {
                input: prompt,
                model: model,
                action: 'generate',
                parameters: {
                    params_version: 3,  // V4å¿…é¡»ä½¿ç”¨ç‰ˆæœ¬3
                    width: width,
                    height: height,
                    scale: settings.cfg_scale,
                    sampler: settings.sampler,
                    steps: settings.steps,
                    seed: settings.seed === -1 ? Math.floor(Math.random() * 9999999999) : settings.seed,
                    n_samples: 1,
                    ucPreset: settings.uc_preset,
                    qualityToggle: settings.quality_toggle,
                    autoSmea: false,
                    dynamic_thresholding: false,
                    controlnet_strength: 1,
                    legacy: false,
                    add_original_image: true,
                    cfg_rescale: 0,
                    noise_schedule: 'karras',  // V4ä½¿ç”¨karras
                    legacy_v3_extend: false,
                    skip_cfg_above_sigma: null,
                    use_coords: false,
                    legacy_uc: false,
                    normalize_reference_strength_multiple: true,
                    inpaintImg2ImgStrength: 1,
                    characterPrompts: [],
                    // V4ä¸“ç”¨æç¤ºè¯æ ¼å¼
                    v4_prompt: {
                        caption: {
                            base_caption: prompt,
                            char_captions: []
                        },
                        use_coords: false,
                        use_order: true
                    },
                    // V4ä¸“ç”¨è´Ÿé¢æç¤ºè¯æ ¼å¼
                    v4_negative_prompt: {
                        caption: {
                            base_caption: negativePrompt,
                            char_captions: []
                        },
                        legacy_uc: false
                    },
                    negative_prompt: negativePrompt,
                    deliberate_euler_ancestral_bug: false,
                    prefer_brownian: true
                    // æ³¨æ„ï¼šä¸åŒ…å« stream å‚æ•°ï¼Œä½¿ç”¨æ ‡å‡†ZIPå“åº”è€Œéžmsgpackæµ
                }
            };
        } else {
            // V3 åŠæ›´æ—©ç‰ˆæœ¬ä½¿ç”¨æ—§æ ¼å¼
            requestBody = {
                input: prompt,
                model: model,
                action: 'generate',
                parameters: {
                    width: width,
                    height: height,
                    scale: settings.cfg_scale,
                    sampler: settings.sampler,
                    steps: settings.steps,
                    seed: settings.seed === -1 ? Math.floor(Math.random() * 9999999999) : settings.seed,
                    n_samples: 1,
                    ucPreset: settings.uc_preset,
                    qualityToggle: settings.quality_toggle,
                    sm: settings.smea,
                    sm_dyn: settings.smea_dyn,
                    dynamic_thresholding: false,
                    controlnet_strength: 1,
                    legacy: false,
                    add_original_image: false,
                    cfg_rescale: 0,
                    noise_schedule: 'native',
                    negative_prompt: negativePrompt
                }
            };
        }
        
        console.log('ðŸ“¤ å‘é€è¯·æ±‚åˆ° NovelAI API');
        console.log('ðŸ“Š ä½¿ç”¨æ¨¡åž‹:', model);
        console.log('ðŸ“‹ è¯·æ±‚ä½“:', JSON.stringify(requestBody, null, 2));
        
        // â˜…â˜…â˜… æ ¹æ®æ¨¡åž‹é€‰æ‹©ä¸åŒçš„APIç«¯ç‚¹ â˜…â˜…â˜…
        let apiUrl;
        
        // V4/V4.5 æ¨¡åž‹ä½¿ç”¨æµå¼ç«¯ç‚¹
        if (model.includes('nai-diffusion-4')) {
            // V4/V4.5 é»˜è®¤ä½¿ç”¨æµå¼ç«¯ç‚¹
            apiUrl = 'https://image.novelai.net/ai/generate-image-stream';
        } else {
            // V3 åŠæ›´æ—©ç‰ˆæœ¬ä½¿ç”¨æ ‡å‡†ç«¯ç‚¹
            apiUrl = 'https://image.novelai.net/ai/generate-image';
        }
        
        let corsProxy = settings.cors_proxy;
        
        // å¦‚æžœé€‰æ‹©äº†è‡ªå®šä¹‰ä»£ç†ï¼Œä½¿ç”¨è‡ªå®šä¹‰URL
        if (corsProxy === 'custom') {
            corsProxy = settings.custom_proxy_url || '';
        }
        
        // å¦‚æžœæœ‰ä»£ç†ï¼Œæ·»åŠ åˆ°URLå‰é¢
        if (corsProxy && corsProxy !== '') {
            apiUrl = corsProxy + encodeURIComponent(apiUrl);
        }
        
        // â˜…â˜…â˜… Chromeæµè§ˆå™¨ä¸“ç”¨å¤„ç†ï¼šé¿å…headersä¸­åŒ…å«éžISO-8859-1å­—ç¬¦ â˜…â˜…â˜…
        const isChrome = /Chrome/.test(navigator.userAgent) && !/Edg/.test(navigator.userAgent);
        let fetchOptions = {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': 'Bearer ' + apiKey
            },
            body: JSON.stringify(requestBody)
        };
        
        // é’ˆå¯¹Chromeæµè§ˆå™¨ï¼šç¡®ä¿æ‰€æœ‰headerå€¼éƒ½æ˜¯çº¯ASCII
        if (isChrome) {
            console.log('ðŸ”§ æ£€æµ‹åˆ°Chromeæµè§ˆå™¨ï¼Œå¯ç”¨headerså…¼å®¹æ€§å¤„ç†');
            const cleanHeaders = {};
            for (const [key, value] of Object.entries(fetchOptions.headers)) {
                // ç¡®ä¿headerå€¼åªåŒ…å«ASCIIå­—ç¬¦ï¼ˆISO-8859-1å…¼å®¹ï¼‰
                cleanHeaders[key] = value.replace(/[^\x00-\xFF]/g, '');
            }
            fetchOptions.headers = cleanHeaders;
        }
        
        const response = await fetch(apiUrl, fetchOptions);
        
        console.log('Response status:', response.status);
        console.log('Response headers:', [...response.headers.entries()]);
        
        if (!response.ok) {
            const errorText = await response.text();
            console.error('APIé”™è¯¯å“åº”:', errorText);
            throw new Error(`APIè¯·æ±‚å¤±è´¥ (${response.status}): ${errorText}`);
        }
        
        // NovelAI APIè¿”å›žçš„æ˜¯ZIPæ–‡ä»¶ï¼Œéœ€è¦è§£åŽ‹
        const contentType = response.headers.get('content-type');
        console.log('Content-Type:', contentType);
        
        // æ£€æŸ¥æ˜¯å¦ä¸º SSE æµå¼å“åº”
        let zipBlob;
        if (contentType && contentType.includes('text/event-stream')) {
            console.log('æ£€æµ‹åˆ° SSE æµå¼å“åº”ï¼Œå¼€å§‹è§£æž...');
            statusDiv.textContent = 'æ­£åœ¨æŽ¥æ”¶æµå¼æ•°æ®...';
            
            // è¯»å–æ•´ä¸ªæµ
            const text = await response.text();
            console.log('æ”¶åˆ° SSE æ•°æ®ï¼Œå¤§å°:', text.length);
            
            // è§£æž SSE æ ¼å¼ï¼Œæå–æœ€åŽçš„ data: è¡Œ
            const lines = text.trim().split('\n');
            let base64Data = null;
            
            for (let i = lines.length - 1; i >= 0; i--) {
                const line = lines[i].trim();
                if (line.startsWith('data: ') && line !== 'data: [DONE]') {
                    const dataContent = line.substring(6); // ç§»é™¤ 'data: ' å‰ç¼€
                    
                    // å°è¯•è§£æž JSON
                    try {
                        const jsonData = JSON.parse(dataContent);
                        
                        // V4.5 æµå¼ç«¯ç‚¹ï¼ševent_type ä¸º "final" æ—¶åŒ…å«æœ€ç»ˆå›¾ç‰‡
                        if (jsonData.event_type === 'final' && jsonData.image) {
                            base64Data = jsonData.image;
                            console.log('âœ… æ‰¾åˆ° final äº‹ä»¶çš„å›¾ç‰‡æ•°æ®');
                            break;
                        }
                        
                        // å…¼å®¹å…¶ä»–æ ¼å¼
                        if (jsonData.data) {
                            base64Data = jsonData.data;
                            console.log('ä»Ž JSON.data ä¸­æå–å›¾ç‰‡æ•°æ®');
                            break;
                        }
                        if (jsonData.image) {
                            base64Data = jsonData.image;
                            console.log('ä»Ž JSON.image ä¸­æå–å›¾ç‰‡æ•°æ®');
                            break;
                        }
                    } catch (e) {
                        // å¦‚æžœä¸æ˜¯ JSONï¼Œç›´æŽ¥ä½œä¸º base64 æ•°æ®
                        base64Data = dataContent;
                        console.log('ç›´æŽ¥ä½¿ç”¨ base64 æ•°æ®');
                        break;
                    }
                }
            }
            
            if (!base64Data) {
                throw new Error('æ— æ³•ä»Ž SSE å“åº”ä¸­æå–å›¾ç‰‡æ•°æ®');
            }
            
            // V4.5 æµå¼ç«¯ç‚¹è¿”å›žçš„æ˜¯ PNG base64ï¼Œä¸æ˜¯ ZIP
            // æ£€æŸ¥æ˜¯å¦ä¸º PNG (ä»¥ iVBORw0KGgo å¼€å¤´) æˆ– JPEG (ä»¥ /9j/ å¼€å¤´)
            const isPNG = base64Data.startsWith('iVBORw0KGgo');
            const isJPEG = base64Data.startsWith('/9j/');
            
            if (isPNG || isJPEG) {
                console.log('âœ… æ£€æµ‹åˆ°ç›´æŽ¥çš„å›¾ç‰‡ base64 æ•°æ® (PNG/JPEG)');
                // å°† base64 è½¬ä¸º Blob
                const binaryString = atob(base64Data);
                const bytes = new Uint8Array(binaryString.length);
                for (let i = 0; i < binaryString.length; i++) {
                    bytes[i] = binaryString.charCodeAt(i);
                }
                const imageBlob = new Blob([bytes], { type: isPNG ? 'image/png' : 'image/jpeg' });
                console.log('å›¾ç‰‡ Blob åˆ›å»ºæˆåŠŸï¼Œå¤§å°:', imageBlob.size);
                
                // ç›´æŽ¥æ˜¾ç¤ºå›¾ç‰‡
                const imageUrl = URL.createObjectURL(imageBlob);
                document.getElementById('nai-result-image').src = imageUrl;
                statusDiv.style.display = 'none';
                resultDiv.style.display = 'block';
                console.log('âœ… å›¾ç‰‡æ˜¾ç¤ºæˆåŠŸï¼ðŸŽ¨');
                return;
            }
            
            // å¦åˆ™å½“ä½œ ZIP å¤„ç†
            console.log('å½“ä½œ ZIP æ–‡ä»¶å¤„ç†...');
            const binaryString = atob(base64Data);
            const bytes = new Uint8Array(binaryString.length);
            for (let i = 0; i < binaryString.length; i++) {
                bytes[i] = binaryString.charCodeAt(i);
            }
            zipBlob = new Blob([bytes]);
            console.log('ZIP Blob å¤§å°:', zipBlob.size);
            
        } else {
            // éžæµå¼å“åº”ï¼Œç›´æŽ¥è¯»å–
            zipBlob = await response.blob();
            console.log('æ”¶åˆ°æ•°æ®ï¼Œç±»åž‹:', zipBlob.type, 'å¤§å°:', zipBlob.size);
        }
        
        // NovelAIå§‹ç»ˆè¿”å›žZIPæ ¼å¼ï¼Œéœ€è¦è§£åŽ‹
        try {
            // æ£€æŸ¥JSZipæ˜¯å¦å·²åŠ è½½
            if (typeof JSZip === 'undefined') {
                throw new Error('JSZipåº“æœªåŠ è½½ï¼Œè¯·åˆ·æ–°é¡µé¢é‡è¯•');
            }
            
            statusDiv.textContent = 'æ­£åœ¨è§£åŽ‹å›¾ç‰‡...';
            
            // è§£åŽ‹ZIPæ–‡ä»¶
            const zip = await JSZip.loadAsync(zipBlob);
            console.log('ZIPæ–‡ä»¶å†…å®¹:', Object.keys(zip.files));
            
            // æŸ¥æ‰¾ç¬¬ä¸€ä¸ªå›¾ç‰‡æ–‡ä»¶ï¼ˆé€šå¸¸æ˜¯image_0.pngï¼‰
            let imageFile = null;
            for (let filename in zip.files) {
                if (filename.match(/\.(png|jpg|jpeg|webp)$/i)) {
                    imageFile = zip.files[filename];
                    console.log('æ‰¾åˆ°å›¾ç‰‡æ–‡ä»¶:', filename);
                    break;
                }
            }
            
            if (!imageFile) {
                throw new Error('ZIPæ–‡ä»¶ä¸­æœªæ‰¾åˆ°å›¾ç‰‡');
            }
            
            // æå–å›¾ç‰‡æ•°æ®
            const imageBlob = await imageFile.async('blob');
            console.log('æå–çš„å›¾ç‰‡å¤§å°:', imageBlob.size);
            
            // åˆ›å»ºå›¾ç‰‡URLå¹¶æ˜¾ç¤º
            const imageUrl = URL.createObjectURL(imageBlob);
            console.log('ç”Ÿæˆçš„å›¾ç‰‡URL:', imageUrl);
            
            document.getElementById('nai-result-image').src = imageUrl;
            statusDiv.style.display = 'none';
            resultDiv.style.display = 'block';
            
        } catch (zipError) {
            console.error('ZIPè§£åŽ‹å¤±è´¥:', zipError);
            // å¦‚æžœè§£åŽ‹å¤±è´¥ï¼Œå°è¯•ç›´æŽ¥ä½œä¸ºå›¾ç‰‡æ˜¾ç¤º
            console.log('å°è¯•ç›´æŽ¥ä½œä¸ºå›¾ç‰‡æ˜¾ç¤º...');
            
            if (zipBlob.type.startsWith('image/')) {
                const imageUrl = URL.createObjectURL(zipBlob);
                document.getElementById('nai-result-image').src = imageUrl;
                statusDiv.style.display = 'none';
                resultDiv.style.display = 'block';
            } else {
                throw new Error('å›¾ç‰‡æ ¼å¼å¤„ç†å¤±è´¥: ' + zipError.message);
            }
        }
        
    } catch (error) {
        console.error('NovelAIç”Ÿæˆå¤±è´¥:', error);
        statusDiv.style.display = 'none';
        errorDiv.style.display = 'block';
        errorDiv.textContent = 'ç”Ÿæˆå¤±è´¥: ' + error.message;
    } finally {
        generateBtn.disabled = false;
        generateBtn.textContent = 'ç”Ÿæˆå›¾åƒ';
    }
}
        
        function showNotification(chatId, messageContent) {
    
    playNotificationSound();
    
            clearTimeout(notificationTimeout);
            const chat = state.chats[chatId];
            if (!chat) return;
        
            
            const bar = document.getElementById('notification-bar');
            
            
            document.getElementById('notification-avatar').src = chat.settings.aiAvatar || chat.settings.groupAvatar || defaultAvatar;
            document.getElementById('notification-content').querySelector('.name').textContent = chat.name;
            document.getElementById('notification-content').querySelector('.message').textContent = messageContent;
            
            
            
            bar.classList.remove('visible');
            
            
            void bar.offsetWidth; 
            
            
            bar.classList.add('visible');
            
            
            const newBar = bar.cloneNode(true);
            bar.parentNode.replaceChild(newBar, bar);
            newBar.addEventListener('click', () => {
                openChat(chatId);
                newBar.classList.remove('visible');
            });
        
            
            notificationTimeout = setTimeout(() => {
                newBar.classList.remove('visible');
            }, 4000);
updateBackButtonUnreadCount();
        }
        
               function updateClock() { 
    const now = new Date(); 
    const timeString = now.toLocaleTimeString('zh-CN', { hour: '2-digit', minute: '2-digit' }); 
    const dateString = now.toLocaleDateString('zh-CN', { weekday: 'long', month: 'long', day: 'numeric' }); 
    
    
    document.getElementById('status-bar-time').textContent = timeString; 
    
}
        
        
/**
 * ã€V3.2 | ç»ˆæžå¥å£®ç‰ˆ | ä¿®å¤æ‹¬å·åŒ¹é…+åžƒåœ¾å†…å®¹å¿½ç•¥BUGã€‘è§£æžAIè¿”å›žçš„ã€å¯èƒ½æ ¼å¼ä¸è§„èŒƒçš„å“åº”å†…å®¹
 * @param {string} content - AIè¿”å›žçš„åŽŸå§‹å­—ç¬¦ä¸²
 * @returns {Array} - ä¸€ä¸ªæ ‡å‡†åŒ–çš„æ¶ˆæ¯å¯¹è±¡æ•°ç»„
 */
function parseAiResponse(content) {
    if (!content) return [{ type: 'text', content: '(AIè¿”å›žäº†ç©ºå†…å®¹)' }];
    
    let trimmedContent = content.trim();

    // æ­¥éª¤ 1: ã€å·²ä¿®å¤ã€‘å¯»æ‰¾ç¬¬ä¸€ä¸ª ```json ... ``` å—ï¼Œå¹¶å¿½ç•¥ä¹‹åŽçš„æ‰€æœ‰å†…å®¹
    // (ç§»é™¤äº† ^ å’Œ $ é”šç‚¹ï¼Œä½¿å…¶èƒ½åŒ¹é…åˆ°è¢«åžƒåœ¾å†…å®¹åŒ…è£¹çš„jsonå—)
    const markdownRegex = /```json\s*([\s\S]*?)\s*```/; 
    const markdownMatch = trimmedContent.match(markdownRegex);
    
    if (markdownMatch && markdownMatch[1]) {
        // å¦‚æžœæ‰¾åˆ°äº† ```json å—ï¼Œå°±åªç”¨è¿™ä¸ªå—é‡Œçš„å†…å®¹
        trimmedContent = markdownMatch[1].trim();
        console.log("è§£æžå™¨ï¼šå·²å¯ç”¨ Markdown æå–æ¨¡å¼ã€‚");
    }

    // æ­¥éª¤ 2: å°è¯•ç›´æŽ¥è§£æž (é€‚ç”¨äºŽå®Œç¾Žçš„JSONæ•°ç»„)
    if (trimmedContent.startsWith('[') && trimmedContent.endsWith(']')) {
        try {
            const parsed = JSON.parse(trimmedContent);
            if (Array.isArray(parsed)) {
                console.log("è§£æžæˆåŠŸï¼šæ ‡å‡†JSONæ•°ç»„æ ¼å¼ã€‚");
                return parsed;
            }
        } catch (e) {
            console.warn("æ ‡å‡†JSONæ•°ç»„è§£æžå¤±è´¥ï¼Œå°†å°è¯•å¼ºåŠ›æå–...");
        }
    }
    
    // æ­¥éª¤ 3: å¼ºåŠ›æå–ç¬¬ä¸€ä¸ª '[' å’Œ *åŒ¹é…* çš„ ']' ä¹‹é—´çš„å†…å®¹
    // (é€‚ç”¨äºŽæ²¡æœ‰ ```json æ ‡è®°ï¼Œä½†å¼€å¤´æ˜¯ [ï¼Œç»“å°¾æœ‰ <disclaimer> ç­‰åžƒåœ¾å†…å®¹)
    const startIndex = trimmedContent.indexOf('[');
    
    // å¯»æ‰¾æœ€åŽä¸€ä¸ª '}'ï¼Œè¿™é€šå¸¸æ˜¯JSONæ•°ç»„é‡Œæœ€åŽä¸€ä¸ªå¯¹è±¡çš„ç»“å°¾
    const lastBraceIndex = trimmedContent.lastIndexOf('}'); 
    
    if (startIndex !== -1 && lastBraceIndex !== -1 && lastBraceIndex > startIndex) {
        
        // ä»Žæœ€åŽä¸€ä¸ª '}' ä¹‹åŽå¼€å§‹æœç´¢ï¼Œæ‰¾åˆ°ç¬¬ä¸€ä¸ª ']'
        const endIndex = trimmedContent.indexOf(']', lastBraceIndex); 

        if (endIndex !== -1) {
            const arrayString = trimmedContent.substring(startIndex, endIndex + 1);
            try {
                const parsed = JSON.parse(arrayString);
                if (Array.isArray(parsed)) {
                    console.log("è§£æžæˆåŠŸï¼šé€šè¿‡å¼ºåŠ›æå– [ ... } ... ] æ¨¡å¼ã€‚");
                    return parsed;
                }
            } catch (e) {
                console.warn("å¼ºåŠ›æå– [ ... } ... ] å¤±è´¥ï¼Œå°†å°è¯•æå–å•ä¸ªå¯¹è±¡...");
            }
        }
    }

    // æ­¥éª¤ 4: (å›žé€€) å°è¯•æå–å•ä¸ªå¯¹è±¡ï¼ˆå…¼å®¹æ—§çš„æˆ–éžæ•°ç»„çš„JSONï¼‰
    const jsonMatches = trimmedContent.match(/{[^{}]*}/g);
    if (jsonMatches) {
        const results = [];
        for (const match of jsonMatches) {
            try {
                const parsedObject = JSON.parse(match);
                results.push(parsedObject);
            } catch (e) {
                console.warn("è·³è¿‡ä¸€ä¸ªæ— æ•ˆçš„JSONç‰‡æ®µ:", match);
            }
        }
        
        if (results.length > 0) {
            console.log("è§£æžæˆåŠŸï¼šé€šè¿‡å¼ºåŠ›æå– {...} æ¨¡å¼ã€‚");
            return results;
        }
    }
    
    // æ­¥éª¤ 5: æœ€ç»ˆå¤±è´¥
    console.error("æ‰€æœ‰è§£æžæ–¹æ¡ˆå‡å¤±è´¥ï¼å°†è¿”å›žåŽŸå§‹æ–‡æœ¬ã€‚åŽŸå§‹å›žå¤:", content);
    return [{ type: 'text', content: content }];
}
        /**
         * ã€å…¨æ–°ã€‘æ ¹æ®å½“å‰æ—¶é—´èŽ·å–ä¸€å¤©ä¸­çš„é—®å€™è¯­
         * @returns {string} - è¿”å›žå¦‚ "å‡Œæ™¨", "æ—©ä¸Š", "ä¸‹åˆ", "æ™šä¸Š" ç­‰å­—ç¬¦ä¸²
         */
        function getTimeOfDayGreeting(date = new Date()) { 
            const hour = date.getHours(); 
            if (hour >= 0 && hour < 5) {
                return "å‡Œæ™¨";
            } else if (hour >= 5 && hour < 9) {
                return "æ—©ä¸Š";
            } else if (hour >= 9 && hour < 13) {
                return "ä¸Šåˆ";
            } else if (hour >= 13 && hour < 18) {
                return "ä¸‹åˆ";
            } else if (hour >= 18 && hour < 24) {
                return "æ™šä¸Š";
            }
            return "çŽ°åœ¨"; 
        }
        
        
/**
         * ä»Žæ•°æ®åº“åŠ è½½APIé¢„è®¾ï¼Œå¹¶å¡«å……åˆ°ä¸‹æ‹‰é€‰æ‹©æ¡†ä¸­
         */
        async function loadApiPresetsDropdown() {
            const selectEl = document.getElementById('api-preset-select');
            selectEl.innerHTML = '<option value="current">å½“å‰é…ç½® (æœªä¿å­˜)</option>';
            
            const presets = await db.apiPresets.toArray();
            presets.forEach(preset => {
                const option = document.createElement('option');
                option.value = preset.id;
                option.textContent = preset.name;
                selectEl.appendChild(option);
            });
        
            
            const currentConfig = state.apiConfig;
            let matchingPresetId = null;
            for (const preset of presets) {
                
                if (
                    preset.proxyUrl === currentConfig.proxyUrl &&
                    preset.apiKey === currentConfig.apiKey &&
                    preset.model === currentConfig.model &&
                    preset.secondaryProxyUrl === currentConfig.secondaryProxyUrl &&
                    preset.secondaryApiKey === currentConfig.secondaryApiKey &&
                    preset.secondaryModel === currentConfig.secondaryModel &&
                    
                    (preset.minimaxGroupId || '') === (currentConfig.minimaxGroupId || '') &&
                    (preset.minimaxApiKey || '') === (currentConfig.minimaxApiKey || '') &&
                    (preset.minimaxModel || 'speech-01') === (currentConfig.minimaxModel || 'speech-01')
                ) 
                  
                {
                    matchingPresetId = preset.id;
                    break;
                }
            }
        
            if (matchingPresetId) {
                selectEl.value = matchingPresetId;
            } else {
                selectEl.value = 'current';
            }
        }
        
/**
         * å½“ç”¨æˆ·ä»Žä¸‹æ‹‰æ¡†é€‰æ‹©ä¸€ä¸ªé¢„è®¾æ—¶ï¼ŒåŠ è½½è¯¥é¢„è®¾çš„é…ç½®
         */
        async function handlePresetSelectionChange() {
            const selectEl = document.getElementById('api-preset-select');
            const selectedId = parseInt(selectEl.value);
        
            
            if (isNaN(selectedId)) {
                return;
            }
        
            const preset = await db.apiPresets.get(selectedId);
            if (preset) {
                
                state.apiConfig = {
                    id: 'main',
                    proxyUrl: preset.proxyUrl,
                    apiKey: preset.apiKey,
                    model: preset.model,
                    secondaryProxyUrl: preset.secondaryProxyUrl,
                    secondaryApiKey: preset.secondaryApiKey,
                    secondaryModel: preset.secondaryModel,
                    
                    minimaxGroupId: preset.minimaxGroupId,
                    minimaxApiKey: preset.minimaxApiKey,
                    minimaxModel: preset.minimaxModel
                      
                };
                
                await db.apiConfig.put(state.apiConfig);
                
                renderApiSettings();
                
                document.getElementById('fetch-models-btn').click();
                if (preset.secondaryProxyUrl && preset.secondaryApiKey) {
                    document.getElementById('fetch-secondary-models-btn').click();
                }
                alert(`å·²åŠ è½½é¢„è®¾ â€œ${preset.name}â€`);
            }
        }
        
        /**
         * å°†å½“å‰è¾“å…¥æ¡†ä¸­çš„é…ç½®ä¿å­˜ä¸ºä¸€ä¸ªæ–°çš„é¢„è®¾
         */
        async function saveApiPreset() {
            const name = await showCustomPrompt('ä¿å­˜ API é¢„è®¾', 'è¯·è¾“å…¥é¢„è®¾åç§°');
            if (!name || !name.trim()) return;
        
            
            const presetData = {
                name: name.trim(),
                proxyUrl: document.getElementById('proxy-url').value.trim(),
                apiKey: document.getElementById('api-key').value.trim(),
                model: document.getElementById('model-select').value,
                secondaryProxyUrl: document.getElementById('secondary-proxy-url').value.trim(),
                secondaryApiKey: document.getElementById('secondary-api-key').value.trim(),
                secondaryModel: document.getElementById('secondary-model-select').value,
     
                minimaxGroupId: document.getElementById('minimax-group-id').value.trim(),
                minimaxApiKey: document.getElementById('minimax-api-key').value.trim(),
                minimaxModel: document.getElementById('minimax-model-select').value
                  
            };
        
            
            const existingPreset = await db.apiPresets.where('name').equals(presetData.name).first();
            if (existingPreset) {
                const confirmed = await showCustomConfirm('è¦†ç›–é¢„è®¾', `åä¸º â€œ${presetData.name}â€ çš„é¢„è®¾å·²å­˜åœ¨ã€‚è¦è¦†ç›–å®ƒå—ï¼Ÿ`, { confirmButtonClass: 'btn-danger' });
                if (!confirmed) return;
                presetData.id = existingPreset.id; 
            }
        
            await db.apiPresets.put(presetData);
            await loadApiPresetsDropdown(); 
            alert('API é¢„è®¾å·²ä¿å­˜ï¼');
        }
        
        /**
         * åˆ é™¤å½“å‰é€‰ä¸­çš„é¢„è®¾
         */
        async function deleteApiPreset() {
            const selectEl = document.getElementById('api-preset-select');
            const selectedId = parseInt(selectEl.value);
        
            if (isNaN(selectedId)) {
                alert('è¯·å…ˆä»Žä¸‹æ‹‰æ¡†ä¸­é€‰æ‹©ä¸€ä¸ªè¦åˆ é™¤çš„é¢„è®¾ã€‚');
                return;
            }
        
            const preset = await db.apiPresets.get(selectedId);
            if (!preset) return;
        
            const confirmed = await showCustomConfirm('åˆ é™¤é¢„è®¾', `ç¡®å®šè¦åˆ é™¤é¢„è®¾ â€œ${preset.name}â€ å—ï¼Ÿ`, { confirmButtonClass: 'btn-danger' });
            if (confirmed) {
                await db.apiPresets.delete(selectedId);
                await loadApiPresetsDropdown(); 
                alert('é¢„è®¾å·²åˆ é™¤ã€‚');
            }
        }

        function renderApiSettings() { 
            
            document.getElementById('proxy-url').value = state.apiConfig.proxyUrl || ''; 
            document.getElementById('api-key').value = state.apiConfig.apiKey || ''; 
            document.getElementById('secondary-proxy-url').value = state.apiConfig.secondaryProxyUrl || '';
            document.getElementById('secondary-api-key').value = state.apiConfig.secondaryApiKey || '';
            document.getElementById('background-activity-switch').checked = state.globalSettings.enableBackgroundActivity || false;
            document.getElementById('background-interval-input').value = state.globalSettings.backgroundActivityInterval || 60;
            document.getElementById('block-cooldown-input').value = state.globalSettings.blockCooldownHours || 1;
            document.getElementById('enable-ai-drawing-switch').checked = state.globalSettings.enableAiDrawing; 
            document.getElementById('chat-render-window-input').value = state.globalSettings.chatRenderWindow || 50;   
            document.getElementById('chat-list-render-window-input').value = state.globalSettings.chatListRenderWindow || 30;
            const tempSlider = document.getElementById('api-temperature-slider');
            const tempValue = document.getElementById('api-temperature-value');
            const savedTemp = state.globalSettings.apiTemperature || 0.8;
            tempSlider.value = savedTemp;
            tempValue.textContent = savedTemp;    
           document.getElementById('minimax-group-id').value = state.apiConfig.minimaxGroupId || '';
           document.getElementById('minimax-api-key').value = state.apiConfig.minimaxApiKey || '';
document.getElementById('minimax-model-select').value = state.apiConfig.minimaxModel || 'speech-01'; 
            
            // åŠ è½½NovelAIé…ç½®
            const novelaiEnabled = localStorage.getItem('novelai-enabled') === 'true';
            const novelaiModel = localStorage.getItem('novelai-model') || 'nai-diffusion-4-5-full';
            const novelaiApiKey = localStorage.getItem('novelai-api-key') || '';
            document.getElementById('novelai-switch').checked = novelaiEnabled;
            document.getElementById('novelai-model').value = novelaiModel;
            document.getElementById('novelai-api-key').value = novelaiApiKey;
            document.getElementById('novelai-details').style.display = novelaiEnabled ? 'block' : 'none';
            
            loadApiPresetsDropdown();
           displayTotalImageSize();
        }
          
                window.renderApiSettingsProxy = renderApiSettings;



async function renderNpcListScreen() {
    const listEl = document.getElementById('npc-list');
    listEl.innerHTML = '';
    
    const npcs = await db.npcs.toArray();

    if (npcs.length === 0) {
        listEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">è¿˜æ²¡æœ‰åˆ›å»ºä»»ä½•NPCï¼Œ<br>ç‚¹å‡»å³ä¸Šè§’â€œ+â€æ·»åŠ ç¬¬ä¸€ä¸ªå§ï¼</p>';
        return;
    }

    npcs.forEach(npc => {
        const item = document.createElement('div');
        item.className = 'chat-list-item';
        item.dataset.npcId = npc.id;
        
        item.innerHTML = `
            <img src="${npc.avatar || defaultGroupMemberAvatar}" class="avatar" style="border-radius: 50%;">
            <div class="info">
                <div class="name-line">
                    <span class="name">${npc.name}</span>
                </div>
                <div class="last-msg">${npc.persona.substring(0, 30)}...</div>
            </div>
        `;
        
        item.addEventListener('click', () => openNpcEditor(npc.id));
        
        
        addLongPressListener(item, async () => {
            await deleteNpc(npc.id);
        });
        
        listEl.appendChild(item);
    });
}


        // â–¼â–¼â–¼ æ›¿æ¢æ•´ä¸ª openNpcEditor å‡½æ•° â–¼â–¼â–¼
async function openNpcEditor(npcId = null) {
    editingNpcId = npcId;
    const modal = document.getElementById('npc-editor-modal');
    const titleEl = document.getElementById('npc-editor-title');
    const nameInput = document.getElementById('npc-name-input');
    const personaInput = document.getElementById('npc-persona-input');
    const avatarPreview = document.getElementById('npc-avatar-preview');
    const associationListEl = document.getElementById('npc-association-list');
    
    // ã€æ–°å¢žã€‘èŽ·å–NPCåˆ†ç»„ç›¸å…³å…ƒç´ 
    const groupSelectEl = document.getElementById('npc-group-select');
    
    const activitySwitch = document.getElementById('npc-background-activity-switch');
    const cooldownInput = document.getElementById('npc-action-cooldown-input');
    
    associationListEl.innerHTML = ''; 
    groupSelectEl.innerHTML = '<option value="">-- æœªåˆ†ç»„ --</option>'; // ã€æ–°å¢žã€‘åˆå§‹åŒ–åˆ†ç»„ä¸‹æ‹‰èœå•

    // ã€æ–°å¢žã€‘å¹¶è¡ŒåŠ è½½NPCåˆ†ç»„åˆ—è¡¨
    const npcGroups = await db.npcGroups.toArray();
    npcGroups.forEach(group => {
        const option = document.createElement('option');
        option.value = group.id;
        option.textContent = group.name;
        groupSelectEl.appendChild(option);
    });

    // ï¼ˆåŠ è½½å…³è”è§’è‰²åˆ—è¡¨çš„é€»è¾‘ä¿æŒä¸å˜ï¼‰
    associationListEl.innerHTML += `<label><input type="checkbox" value="user"> ${state.qzoneSettings.nickname || 'æˆ‘'} (ç”¨æˆ·)</label>`;
    Object.values(state.chats).filter(c => !c.isGroup).forEach(char => {
        associationListEl.innerHTML += `<label><input type="checkbox" value="${char.id}"> ${char.name} (è§’è‰²)</label>`;
    });

    if (npcId) {
        titleEl.textContent = 'ç¼–è¾‘ NPC';
        const npc = await db.npcs.get(npcId);
        if (npc) {
            nameInput.value = npc.name;
            personaInput.value = npc.persona;
            avatarPreview.src = npc.avatar || defaultGroupMemberAvatar;
            activitySwitch.checked = npc.enableBackgroundActivity !== false; 
            cooldownInput.value = npc.actionCooldownMinutes || 15;
            groupSelectEl.value = npc.npcGroupId || ''; // ã€æ–°å¢žã€‘åŠ è½½NPCçš„åˆ†ç»„

            if (npc.associatedWith && Array.isArray(npc.associatedWith)) {
                npc.associatedWith.forEach(id => {
                    const checkbox = associationListEl.querySelector(`input[value="${id}"]`);
                    if (checkbox) checkbox.checked = true;
                });
            }
        }
    } else {
        titleEl.textContent = 'æ·»åŠ  NPC';
        nameInput.value = '';
        personaInput.value = '';
        avatarPreview.src = defaultGroupMemberAvatar;
        activitySwitch.checked = true; 
        cooldownInput.value = 15;     
        groupSelectEl.value = ''; // ã€æ–°å¢žã€‘æ–°NPCé»˜è®¤ä¸º"æœªåˆ†ç»„"

        const userCheckbox = associationListEl.querySelector('input[value="user"]');
        if (userCheckbox) userCheckbox.checked = true;
    }

    modal.classList.add('visible');
}



/**
 * ã€å·²æ›´æ–°ã€‘ä¿å­˜NPCä¿¡æ¯ï¼Œå¹¶èƒ½å¤„ç†â€œåˆ›å»ºåŽç›´æŽ¥åŠ å…¥ç¾¤èŠâ€çš„æµç¨‹
 */
async function saveNpc() {
    const name = document.getElementById('npc-name-input').value.trim();
    const persona = document.getElementById('npc-persona-input').value.trim();
    if (!name || !persona) {
        alert("NPCçš„æ˜µç§°å’Œäººè®¾éƒ½ä¸èƒ½ä¸ºç©ºï¼");
        return;
    }

    const selectedAssociations = Array.from(document.querySelectorAll('#npc-association-list input:checked')).map(cb => cb.value);
    const enableBackgroundActivity = document.getElementById('npc-background-activity-switch').checked;
    const actionCooldownMinutes = parseInt(document.getElementById('npc-action-cooldown-input').value) || 15;
    
    // ã€æ–°å¢žã€‘èŽ·å–NPCåˆ†ç»„ID
    const npcGroupId = parseInt(document.getElementById('npc-group-select').value) || null;

    const npcData = {
        name,
        persona,
        avatar: document.getElementById('npc-avatar-preview').src,
        associatedWith: selectedAssociations,
        enableBackgroundActivity: enableBackgroundActivity,
        actionCooldownMinutes: actionCooldownMinutes,
        npcGroupId: npcGroupId // ã€æ–°å¢žã€‘ä¿å­˜åˆ†ç»„ID
    };

    if (editingNpcId) {
        await db.npcs.update(editingNpcId, npcData);
    } else {
        const newNpcId = await db.npcs.add(npcData);
        if (isAddingNpcToGroup && state.activeChatId) {
            const chat = state.chats[state.activeChatId];
            if (chat.isGroup) {
                chat.members.push({
                    id: `npc_${newNpcId}`,
                    originalName: name,
                    groupNickname: name,
                    persona: persona,
                    avatar: npcData.avatar, 
                    isNpc: true
                });
                await db.chats.put(chat);
            }
        }
    }
    
    document.getElementById('npc-editor-modal').classList.remove('visible');
    
    if (isAddingNpcToGroup) {
        isAddingNpcToGroup = false; 
        openMemberManagementScreen();
    } else {
        await renderNpcListScreen();
    }
}
async function openNpcGroupManager() {
    await renderNpcGroupsInManager();
    document.getElementById('npc-group-manager-modal').classList.add('visible');
}

/**
 * ã€å…¨æ–°ã€‘åœ¨å¼¹çª—ä¸­æ¸²æŸ“å·²å­˜åœ¨çš„NPCåˆ†ç»„åˆ—è¡¨
 */
async function renderNpcGroupsInManager() {
    const listEl = document.getElementById('existing-npc-groups-list');
    const categories = await db.npcGroups.toArray();
    listEl.innerHTML = '';
    if (categories.length === 0) {
        listEl.innerHTML = '<p style="text-align: center; color: var(--text-secondary);">è¿˜æ²¡æœ‰ä»»ä½•åˆ†ç»„</p>';
    }
    categories.forEach(cat => {
        const item = document.createElement('div');
        item.className = 'existing-group-item';
        item.innerHTML = `
            <span class="group-name">${cat.name}</span>
            <span class="delete-group-btn" data-id="${cat.id}">Ã—</span>
        `;
        listEl.appendChild(item);
    });
}

/**
 * ã€å…¨æ–°ã€‘æ·»åŠ ä¸€ä¸ªæ–°çš„NPCåˆ†ç»„
 */
async function addNewNpcGroup() {
    const input = document.getElementById('new-npc-group-name-input');
    const name = input.value.trim();
    if (!name) {
        alert('åˆ†ç»„åä¸èƒ½ä¸ºç©ºï¼');
        return;
    }
    const existing = await db.npcGroups.where('name').equals(name).first();
    if (existing) {
        alert(`åˆ†ç»„ "${name}" å·²ç»å­˜åœ¨äº†ï¼`);
        return;
    }
    await db.npcGroups.add({ name });
    input.value = '';
    await renderNpcGroupsInManager();
}

/**
 * ã€å…¨æ–°ã€‘åˆ é™¤ä¸€ä¸ªNPCåˆ†ç»„ï¼ˆå¹¶è§£é™¤æ‰€æœ‰NPCçš„ç»‘å®šï¼‰
 * @param {number} groupId - è¦åˆ é™¤çš„åˆ†ç»„çš„ID
 */
async function deleteNpcGroup(groupId) {
    const confirmed = await showCustomConfirm(
        'ç¡®è®¤åˆ é™¤', 
        'åˆ é™¤åˆ†ç»„åŽï¼Œè¯¥ç»„å†…çš„æ‰€æœ‰NPCå°†å˜ä¸ºâ€œæœªåˆ†ç»„â€ã€‚ç¡®å®šè¦åˆ é™¤å—ï¼Ÿ', 
        { confirmButtonClass: 'btn-danger' }
    );
    if (confirmed) {
        await db.npcGroups.delete(groupId);
        // å°†å±žäºŽè¯¥åˆ†ç»„çš„NPCçš„ npcGroupId è®¾ä¸º null
        await db.npcs.where('npcGroupId').equals(groupId).modify({ npcGroupId: null });
        await renderNpcGroupsInManager();
    }
}  

/**
 * åˆ é™¤NPC
 * @param {number} npcId - è¦åˆ é™¤çš„NPCçš„ID
 */
async function deleteNpc(npcId) {
    const npc = await db.npcs.get(npcId);
    if (!npc) return;
    const confirmed = await showCustomConfirm('åˆ é™¤NPC', `ç¡®å®šè¦åˆ é™¤NPC â€œ${npc.name}â€ å—ï¼Ÿ`, { confirmButtonClass: 'btn-danger' });
    if (confirmed) {
        await db.npcs.delete(npcId);
        await renderNpcListScreen();
    }
}


        let chatListRenderCount = 0; 



/**
 * åˆ›å»ºä¸€ä¸ªåˆ†ç»„çš„å®¹å™¨ï¼ˆä¸åŒ…å«èŠå¤©é¡¹ï¼‰
 */
function createChatGroupContainer(group) {
    const groupContainer = document.createElement('div');
    groupContainer.className = 'chat-group-container';
    groupContainer.innerHTML = `
        <div class="chat-group-header">
            <span class="arrow">â–¼</span>
            <span class="group-name">${group.name}</span>
        </div>
        <div class="chat-group-content"></div>
    `;
    return groupContainer;
}



/**
 * åŠ è½½å¹¶æ¸²æŸ“ä¸‹ä¸€æ‰¹æ¬¡çš„èŠå¤©è®°å½•
 */
function loadMoreChats(sortedItems) {
    const chatListEl = document.getElementById('chat-list');
    const loadMoreBtn = document.getElementById('load-more-chats-btn');
    if (loadMoreBtn) loadMoreBtn.remove();
    
    const nextSliceStart = chatListRenderCount;
    const nextSliceEnd = chatListRenderCount + CHAT_LIST_RENDER_WINDOW;
    const itemsToAppend = sortedItems.slice(nextSliceStart, nextSliceEnd);

    
    const fragment = document.createDocumentFragment();
    let currentGroupContent = chatListEl.querySelector('.chat-group-content:last-of-type');

    itemsToAppend.forEach(item => {
        if (item.type === 'groupHeader') {
            const groupContainer = createChatGroupContainer(item.group);
            fragment.appendChild(groupContainer);
            currentGroupContent = groupContainer.querySelector('.chat-group-content');
        } else if (item.type === 'chatItem') {
            const listItem = createChatListItem(item.chat);
            if (currentGroupContent && item.chat.groupId) {
                currentGroupContent.appendChild(listItem);
            } else {
                fragment.appendChild(listItem);
                currentGroupContent = null;
            }
        }
    });
    
    
    chatListEl.appendChild(fragment);
    chatListRenderCount += itemsToAppend.length;

    if (sortedItems.length > chatListRenderCount) {
        appendLoadMoreChatsButton(chatListEl, sortedItems);
    }
    
    
    document.querySelectorAll('.chat-group-header').forEach(header => {
        const newHeader = header.cloneNode(true);
        header.parentNode.replaceChild(newHeader, header);
        newHeader.addEventListener('click', () => {
            newHeader.classList.toggle('collapsed');
            newHeader.nextElementSibling.classList.toggle('collapsed');
        });
    });
}


async function renderChatList() {
    const chatListEl = document.getElementById('chat-list');
    chatListEl.innerHTML = '';

    
    const allChats = Object.values(state.chats).sort((a, b) => {
        const pinDiff = (b.isPinned || false) - (a.isPinned || false);
        if (pinDiff !== 0) return pinDiff;
        return (b.history.slice(-1)[0]?.timestamp || 0) - (a.history.slice(-1)[0]?.timestamp || 0);
    });
    
    const allGroups = await db.qzoneGroups.toArray();

    if (allChats.length === 0) {
        chatListEl.innerHTML = '<p style="text-align:center; color: #8a8a8a; margin-top: 50px;">ç‚¹å‡»å³ä¸Šè§’ "+" æˆ–ç¾¤ç»„å›¾æ ‡æ·»åŠ èŠå¤©</p>';
        return;
    }

    allGroups.forEach(group => {
        const latestChatInGroup = allChats.find(chat => chat.groupId === group.id);
        group.latestTimestamp = latestChatInGroup ? (latestChatInGroup.history.slice(-1)[0]?.timestamp || 0) : 0;
    });
    allGroups.sort((a, b) => b.latestTimestamp - a.latestTimestamp);
    
    
sortedChatListItems = []; 
    const processedChatIds = new Set();

  
    allChats.forEach(chat => {
        if (chat.isPinned) {
            sortedChatListItems.push({ type: 'chatItem', chat });
            processedChatIds.add(chat.id);
        }
    });

  
    allGroups.forEach(group => {
      
        const groupChats = allChats.filter(chat => 
            !chat.isPinned &&          
            !chat.isGroup &&           
            chat.groupId === group.id  
        );

       
        if (groupChats.length > 0) {
            sortedChatListItems.push({ type: 'groupHeader', group });
          
            groupChats.forEach(chat => {
                sortedChatListItems.push({ type: 'chatItem', chat });
                processedChatIds.add(chat.id);
            });
        }
    });


    allChats.forEach(chat => {
        if (!processedChatIds.has(chat.id)) {
            sortedChatListItems.push({ type: 'chatItem', chat });
            processedChatIds.add(chat.id);
        }
    });

    
    chatListRenderCount = 0;
    loadMoreChats(); 
}
  


        /**
         * åˆ›å»ºä¸€ä¸ªåˆ†ç»„çš„å®¹å™¨ï¼ˆä¸åŒ…å«èŠå¤©é¡¹ï¼‰
         */
        function createChatGroupContainer(group) {
            const groupContainer = document.createElement('div');
            groupContainer.className = 'chat-group-container';
            groupContainer.innerHTML = `
                <div class="chat-group-header">
                    <span class="arrow">â–¼</span>
                    <span class="group-name">${group.name}</span>
                </div>
                <div class="chat-group-content"></div>
            `;
            return groupContainer;
        }

        /**
         * åˆ›å»ºå¹¶æ·»åŠ â€œåŠ è½½æ›´å¤šâ€æŒ‰é’®
         */
        function appendLoadMoreChatsButton(container, sortedItems) {
            const button = document.createElement('button');
            button.id = 'load-more-chats-btn';
            button.textContent = 'åŠ è½½æ›´æ—©çš„ä¼šè¯';
            button.className = 'load-more-btn'; 
            
            
            button.addEventListener('click', () => loadMoreChats(sortedItems), { once: true });
            
            container.prepend(button); 
        }


        function loadMoreChats() {
            if (isLoadingMoreChats) return;

            const chatListEl = document.getElementById('chat-list');
            const scrollContainer = document.getElementById('messages-view');
            if (!chatListEl || !scrollContainer) return;
            if (chatListRenderCount >= sortedChatListItems.length) return;

            isLoadingMoreChats = true;

            
            const isInitialLoad = chatListRenderCount === 0;

            
            const renderContent = () => {
                hideLoader(chatListEl);

                const renderWindow = state.globalSettings.chatListRenderWindow || 30;
                const nextSliceStart = chatListRenderCount;
                const nextSliceEnd = chatListRenderCount + renderWindow;
                const itemsToAppend = sortedChatListItems.slice(nextSliceStart, nextSliceEnd);

                const fragment = document.createDocumentFragment();
                let currentGroupContent = chatListEl.querySelector('.chat-group-content:last-of-type');

                itemsToAppend.forEach(item => {
                    if (item.type === 'groupHeader') {
                        const groupContainer = createChatGroupContainer(item.group);
                        fragment.appendChild(groupContainer);
                        currentGroupContent = groupContainer.querySelector('.chat-group-content');
                    } else if (item.type === 'chatItem') {
                        const listItem = createChatListItem(item.chat);
                        if (item.chat.groupId && currentGroupContent) {
                            currentGroupContent.appendChild(listItem);
                        } else {
                            fragment.appendChild(listItem);
                            if (!item.chat.groupId) currentGroupContent = null;
                        }
                    }
                });

                chatListEl.appendChild(fragment);
                chatListRenderCount += itemsToAppend.length;

                chatListEl.querySelectorAll('.chat-group-header:not([data-has-listener="true"])').forEach(header => {
                    header.dataset.hasListener = "true";
                    header.addEventListener('click', () => {
                        header.classList.toggle('collapsed');
                        header.nextElementSibling.classList.toggle('collapsed');
                    });
                });

                isLoadingMoreChats = false;

                if (scrollContainer.scrollHeight <= scrollContainer.clientHeight && chatListRenderCount < sortedChatListItems.length) {
                    loadMoreChats();
                }
            };

            
            if (isInitialLoad) {
                
                renderContent();
            } else {
                
                showLoader(chatListEl, 'bottom');
                setTimeout(renderContent, 500);
            }
        }
   
function createChatListItem(chat) {
    
    try {
        const lastMsgObj = chat.history.filter(msg => !msg.isHidden).slice(-1)[0] || {};
        let lastMsgDisplay;

        if (!chat.isGroup && chat.relationship?.status === 'pending_user_approval') {
            lastMsgDisplay = `<span style="color: #ff8c00;">[å¥½å‹ç”³è¯·] ${chat.relationship.applicationReason || 'è¯·æ±‚æ·»åŠ ä½ ä¸ºå¥½å‹'}</span>`;
        } else if (!chat.isGroup && chat.relationship?.status === 'blocked_by_ai') {
            lastMsgDisplay = `<span style="color: #dc3545;">[ä½ å·²è¢«å¯¹æ–¹æ‹‰é»‘]</span>`;
        } else if (chat.isGroup) {
            if (lastMsgObj.type === 'pat_message') { lastMsgDisplay = `[ç³»ç»Ÿæ¶ˆæ¯] ${lastMsgObj.content}`; }
            else if (lastMsgObj.type === 'transfer') { lastMsgDisplay = '[è½¬è´¦]'; }
            else if (lastMsgObj.type === 'ai_image' || lastMsgObj.type === 'user_photo') { lastMsgDisplay = '[ç…§ç‰‡]'; }
            else if (lastMsgObj.type === 'voice_message') { lastMsgDisplay = '[è¯­éŸ³]'; }
            else if (typeof lastMsgObj.content === 'string' && STICKER_REGEX.test(lastMsgObj.content)) { lastMsgDisplay = lastMsgObj.meaning ? `[è¡¨æƒ…: ${lastMsgObj.meaning}]` : '[è¡¨æƒ…]'; }
            else if (Array.isArray(lastMsgObj.content)) { lastMsgDisplay = `[å›¾ç‰‡]`; }
            else { lastMsgDisplay = String(lastMsgObj.content || '...').substring(0, 20); }

            if (lastMsgObj.senderName && lastMsgObj.type !== 'pat_message') {
                const senderDisplayName = getDisplayNameInGroup(chat, lastMsgObj.senderName);
                lastMsgDisplay = `${senderDisplayName}: ${lastMsgDisplay}`;
            }
        } else {
            const statusText = chat.status?.text || 'åœ¨çº¿';
            lastMsgDisplay = `[${statusText}]`;
        }

        const item = document.createElement('div');
        item.className = 'chat-list-item';
        item.dataset.chatId = chat.id;
        if (chat.isPinned) {
            item.classList.add('pinned');
        }

        const avatar = chat.isGroup ? chat.settings.groupAvatar : chat.settings.aiAvatar;
        const avatarFrameSrc = chat.isGroup ? '' : (chat.settings.aiAvatarFrame || '');
        let avatarHtml;
        if (avatarFrameSrc) {
            avatarHtml = `<div class="avatar-with-frame"><img src="${avatar || defaultAvatar}" class="avatar-img"><img src="${avatarFrameSrc}" class="avatar-frame"></div>`;
        } else {
            avatarHtml = `<img src="${avatar || defaultAvatar}" class="avatar">`;
        }
        const hasFrameClass = avatarFrameSrc ? 'has-frame' : '';
        const avatarGroupHtml = `<div class="avatar-group ${hasFrameClass}">${avatarHtml}</div>`;

        item.innerHTML = `
            ${avatarGroupHtml}
            <div class="info">
                <div class="name-line">
                    <span class="name">${chat.name}</span>
                    ${chat.isGroup ? '<span class="group-tag">ç¾¤èŠ</span>' : ''}
                </div>
                <div class="last-msg" style="color: ${chat.isGroup ? 'var(--text-secondary)' : '#b5b5b5'}; font-style: italic;">${lastMsgDisplay}</div>
            </div>
            <div class="unread-count-wrapper">
                <span class="unread-count" style="display: none;">0</span>
            </div>
        `;
        
        const unreadCount = chat.unreadCount || 0;
        const unreadEl = item.querySelector('.unread-count');
        if (unreadCount > 0) {
            unreadEl.textContent = unreadCount > 99 ? '99+' : unreadCount;
            unreadEl.style.display = 'inline-flex';
        } else {
            unreadEl.style.display = 'none';
        }
        
        const avatarGroupEl = item.querySelector('.avatar-group');
        if (avatarGroupEl) {
            avatarGroupEl.style.cursor = 'pointer';
            avatarGroupEl.addEventListener('dblclick', (e) => {
                e.stopPropagation();
                const nameToPat = chat.isGroup ? chat.name : chat.originalName;
                handleUserPat(chat.id, nameToPat);
            });
        }
        
        const infoEl = item.querySelector('.info');
        if (infoEl) {
            infoEl.addEventListener('click', () => openChat(chat.id));
        }
    
        addLongPressListener(item, async (e) => {
            const action = await showChatListActions(chat);
            switch (action) {
                case 'pin':
                    chat.isPinned = !chat.isPinned;
                    await db.chats.put(chat);
                    renderChatList();
                    break;
                case 'delete':
                    const deleteConfirmed = await showCustomConfirm('åˆ é™¤å¯¹è¯', `ç¡®å®šè¦åˆ é™¤ä¸Ž "${chat.name}" çš„æ•´ä¸ªå¯¹è¯å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ’¤é”€ã€‚`, { confirmButtonClass: 'btn-danger' });
                    if (deleteConfirmed) {
                        if (musicState.isActive && musicState.activeChatId === chat.id) {
                            await endListenTogetherSession(false);
                        }
                        delete state.chats[chat.id];
                        if (state.activeChatId === chat.id) state.activeChatId = null;
                        await db.chats.delete(chat.id);
                        renderChatList();
                    }
                    break;
                default:
                    break;
            }
        });
        return item;

    } catch (error) {
       
        console.error(`æ¸²æŸ“èŠå¤©é¡¹ [${chat.name || 'æœªçŸ¥'}] (ID: ${chat.id}) æ—¶å‡ºé”™:`, error);
        return null; 
    }
}
  
        
        async function renderChatInterface(chatId) {
            applyButtonOrder();
            cleanupWaimaiTimers();
            const chat = state.chats[chatId];
            if (!chat) return;

            exitSelectionMode();

            const messagesContainer = document.getElementById('chat-messages');
            const chatInputArea = document.getElementById('chat-input-area');
            const lockOverlay = document.getElementById('chat-lock-overlay');
            const lockContent = document.getElementById('chat-lock-content');

            messagesContainer.dataset.theme = chat.settings.theme || 'default';
            const fontSize = chat.settings.fontSize || 13;
            messagesContainer.style.setProperty('--chat-font-size', `${fontSize}px`);
            applyScopedCss(chat.settings.customCss || '', '#chat-messages', 'custom-bubble-style');

            document.getElementById('chat-header-title').textContent = chat.name;
            const statusContainer = document.getElementById('chat-header-status');
            const statusTextEl = statusContainer.querySelector('.status-text');

            if (chat.isGroup) {
                statusContainer.style.display = 'none';
                document.getElementById('chat-header-title-wrapper').style.justifyContent = 'center';
            } else {
                statusContainer.style.display = 'flex';
                document.getElementById('chat-header-title-wrapper').style.justifyContent = 'flex-start';
                statusTextEl.textContent = chat.status?.text || 'åœ¨çº¿';
                statusContainer.classList.toggle('busy', chat.status?.isBusy || false);
            }

            const chatScreen = document.getElementById('chat-interface-screen');
            const individualBg = chat.settings.background;
            const globalBg = state.globalSettings.globalChatBackground;
            const isDarkMode = document.getElementById('phone-screen').classList.contains('dark-mode');
            const defaultColor = isDarkMode ? '#000000' : '#f0f2f5';

            if (individualBg) {
                chatScreen.style.backgroundImage = `url(${individualBg})`;
                chatScreen.style.backgroundColor = 'transparent';
            } else if (globalBg) {
                chatScreen.style.backgroundImage = `url(${globalBg})`;
                chatScreen.style.backgroundColor = 'transparent';
            } else {
                chatScreen.style.backgroundImage = 'none';
                chatScreen.style.backgroundColor = defaultColor;
            }

            
            if (chat.isSpectatorGroup) {
                chatInputArea.style.display = 'none';
                lockOverlay.style.display = 'flex';
                lockContent.innerHTML = `
                    <span class="lock-text">æ­£åœ¨å›´è§‚AIä»¬çš„ç¾¤èŠ...</span>
                    <div class="spectator-actions-container">
                        <button id="spectator-reroll-btn" class="lock-action-btn secondary" title="é‡æ–°ç”Ÿæˆä¸Šä¸€è½®å¯¹è¯">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M20 11A8.1 8.1 0 0 0 4.5 9M4 5v4h4"></path>
                                <path d="M4 13a8.1 8.1 0 0 0 15.5 2m.5 4v-4h-4"></path>
                            </svg>
                        </button>
                        <button id="spectator-propel-btn" class="lock-action-btn">ðŸŽ¬ æŽ¨è¿›å‰§æƒ…</button>
                        <button id="spectator-edit-btn" class="lock-action-btn secondary" title="å¯¼æ¼”å‰ªè¾‘å®¤ï¼šç¼–è¾‘AIä¸Šä¸€è½®çš„å“åº”">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M20.24 12.24a6 6 0 0 0-8.49-8.49L5 10.5V19h8.5z"></path>
                                <line x1="16" y1="8" x2="2" y2="22"></line>
                                <line x1="17.5" y1="15" x2="9" y2="15"></line>
                            </svg>
                        </button>
                    </div>
                `;
                document.getElementById('spectator-propel-btn').onclick = triggerSpectatorGroupAiAction;
            } else {
                chatInputArea.style.display = 'flex';
                lockOverlay.style.display = 'none';
                lockContent.innerHTML = '';
                if (!chat.isGroup && chat.relationship.status !== 'friend') {
                    lockOverlay.style.display = 'flex';
                    chatInputArea.style.visibility = 'hidden';
                    
                    let lockHtml = '';
                    switch (chat.relationship.status) {
                         case 'blocked_by_user':
                            const isSimulationRunning = simulationIntervalId !== null;
                            const blockedTimestamp = chat.relationship.blockedTimestamp;
                            const cooldownHours = state.globalSettings.blockCooldownHours || 1;
                            const cooldownMilliseconds = cooldownHours * 60 * 60 * 1000;
                            const timeSinceBlock = Date.now() - blockedTimestamp;
                            const isCooldownOver = timeSinceBlock > cooldownMilliseconds;
                            const timeRemainingMinutes = Math.max(0, Math.ceil((cooldownMilliseconds - timeSinceBlock) / (1000 * 60)));
            
                            lockHtml = `
                                <span class="lock-text">ä½ å·²å°†â€œ${chat.name}â€æ‹‰é»‘ã€‚</span>
                                <button id="unblock-btn" class="lock-action-btn">è§£é™¤æ‹‰é»‘</button>
                                <div style="margin-top: 20px; padding: 10px; border: 1px dashed #ccc; border-radius: 8px; font-size: 11px; text-align: left; color: #666; background: rgba(0,0,0,0.02);">
                                    <strong style="color: #333;">ã€å¼€å‘è€…è¯Šæ–­é¢æ¿ã€‘</strong><br>
                                    - åŽå°æ´»åŠ¨æ€»å¼€å…³: ${state.globalSettings.enableBackgroundActivity ? '<span style="color: green;">å·²å¼€å¯</span>' : '<span style="color: red;">å·²å…³é—­</span>'}<br>
                                    - ç³»ç»Ÿå¿ƒè·³è®¡æ—¶å™¨: ${isSimulationRunning ? '<span style="color: green;">è¿è¡Œä¸­</span>' : '<span style="color: red;">æœªè¿è¡Œ</span>'}<br>
                                    - å½“å‰è§’è‰²çŠ¶æ€: <strong>${chat.relationship.status}</strong><br>
                                    - éœ€è¦å†·é™(å°æ—¶): <strong>${cooldownHours}</strong><br>
                                    - å†·é™æœŸæ˜¯å¦ç»“æŸ: ${isCooldownOver ? '<span style="color: green;">æ˜¯</span>' : `<span style="color: orange;">å¦ (è¿˜å‰©çº¦ ${timeRemainingMinutes} åˆ†é’Ÿ)</span>`}<br>
                                    - è§¦å‘æ¡ä»¶: ${isCooldownOver && state.globalSettings.enableBackgroundActivity ? '<span style="color: green;">å·²æ»¡è¶³ï¼Œç­‰å¾…ä¸‹æ¬¡ç³»ç»Ÿå¿ƒè·³</span>' : '<span style="color: red;">æœªæ»¡è¶³</span>'}
                                </div>
                                <button id="force-apply-check-btn" class="lock-action-btn secondary" style="margin-top: 10px;">å¼ºåˆ¶è§¦å‘ä¸€æ¬¡å¥½å‹ç”³è¯·æ£€æµ‹</button>
                            `;
                            break;
                        case 'blocked_by_ai':
                            lockHtml = `
                                <span class="lock-text">ä½ è¢«å¯¹æ–¹æ‹‰é»‘äº†ã€‚</span>
                                <button id="apply-friend-btn" class="lock-action-btn">é‡æ–°ç”³è¯·åŠ ä¸ºå¥½å‹</button>
                            `;
                            break;
                        case 'pending_user_approval':
                            lockHtml = `
                                <span class="lock-text">â€œ${chat.name}â€è¯·æ±‚æ·»åŠ ä½ ä¸ºå¥½å‹ï¼š<br><i>â€œ${chat.relationship.applicationReason}â€</i></span>
                                <button id="accept-friend-btn" class="lock-action-btn">æŽ¥å—</button>
                                <button id="reject-friend-btn" class="lock-action-btn secondary">æ‹’ç»</button>
                            `;
                            break;
                        case 'pending_ai_approval':
                            lockHtml = `<span class="lock-text">å¥½å‹ç”³è¯·å·²å‘é€ï¼Œç­‰å¾…å¯¹æ–¹é€šè¿‡...</span>`;
                            break;
                    }
                    lockContent.innerHTML = lockHtml;
                } else {
                     lockOverlay.style.display = 'none';
                     chatInputArea.style.visibility = 'visible';
                }
            }
            
            messagesContainer.innerHTML = '';
            const history = chat.history;
            currentRenderedCount = 0;
            const renderWindow = state.globalSettings.chatRenderWindow || 50;
            const initialMessages = history.slice(-renderWindow);

            
            
            const messagePromises = [];
            let lastTimestamp = 0;

            for (const msg of initialMessages) {
                if (lastTimestamp > 0 && (msg.timestamp - lastTimestamp > 600000)) {
                    
                    messagePromises.push(Promise.resolve(createSystemTimestampElement(msg.timestamp)));
                }
                
                messagePromises.push(createMessageElement(msg, chat, true));
                lastTimestamp = msg.timestamp;
            }

            
            const messageElements = await Promise.all(messagePromises);

            
            const fragment = document.createDocumentFragment();
            messageElements.filter(Boolean).forEach(el => fragment.appendChild(el));
            messagesContainer.appendChild(fragment);
            

            currentRenderedCount = initialMessages.length;

            const typingIndicator = document.createElement('div');
            typingIndicator.id = 'typing-indicator';
            typingIndicator.style.display = 'none';
            typingIndicator.textContent = 'å¯¹æ–¹æ­£åœ¨è¾“å…¥...';
            messagesContainer.appendChild(typingIndicator);

            setTimeout(() => messagesContainer.scrollTop = messagesContainer.scrollHeight, 0);
        }
  
        
                
        
async function loadMoreMessages() {
    if (isLoadingMoreMessages) return;
    isLoadingMoreMessages = true;

    const messagesContainer = document.getElementById('chat-messages');
    const chat = state.chats[state.activeChatId];
    if (!chat) {
        isLoadingMoreMessages = false;
        return;
    }

    showLoader(messagesContainer, 'top'); 
    const oldScrollHeight = messagesContainer.scrollHeight;

    
    await new Promise(resolve => setTimeout(resolve, 500));

    const totalMessages = chat.history.length;
    const renderWindow = state.globalSettings.chatRenderWindow || 50;
    const nextSliceStart = totalMessages - currentRenderedCount - renderWindow;
    const nextSliceEnd = totalMessages - currentRenderedCount;
    const messagesToPrepend = chat.history.slice(Math.max(0, nextSliceStart), nextSliceEnd);


    
    const firstVisibleMessage = messagesContainer.querySelector('.message-wrapper[data-timestamp]');
    let nextMessageTimestamp = firstVisibleMessage ? parseInt(firstVisibleMessage.dataset.timestamp) : 0;

    
    for (const msg of messagesToPrepend.reverse()) {
        
        
        if (nextMessageTimestamp > 0 && (nextMessageTimestamp - msg.timestamp > 600000)) { 
            
            const timestampEl = createSystemTimestampElement(nextMessageTimestamp);
            
            messagesContainer.prepend(timestampEl);
        }
        
        
        await prependMessage(msg, chat);
        
        
        nextMessageTimestamp = msg.timestamp;
    }

    currentRenderedCount += messagesToPrepend.length;

    
    const newScrollHeight = messagesContainer.scrollHeight;
    messagesContainer.scrollTop = newScrollHeight - oldScrollHeight;

    hideLoader(messagesContainer); 
    isLoadingMoreMessages = false;
}
  
        


function renderWallpaperScreen() {
    loadCssPresetsDropdown();
loadAppearancePresetsDropdown();
    
    const ephonePreview = document.getElementById('wallpaper-preview');
    
    const ephoneBg = state.globalSettings.wallpaper;
    if (ephoneBg) {
        
        ephonePreview.style.backgroundImage = `url(${ephoneBg})`;
        ephonePreview.textContent = ''; 
    } else {
        
        ephonePreview.style.backgroundImage = 'linear-gradient(135deg, #89f7fe, #66a6ff)';
        ephonePreview.textContent = 'å½“å‰ä¸ºæ¸å˜è‰²';
    }

    
    const cphonePreview = document.getElementById('cphone-wallpaper-preview');
    const cphoneBg = state.globalSettings.cphoneWallpaper;
    if (cphoneBg) {
        cphonePreview.style.backgroundImage = `url(${cphoneBg})`;
        cphonePreview.textContent = '';
    } else {
        cphonePreview.style.backgroundImage = 'linear-gradient(135deg, #f6d365, #fda085)';
        cphonePreview.textContent = 'å½“å‰ä¸ºæ¸å˜è‰²';
    }

    
    const globalBgPreview = document.getElementById('global-bg-preview');
    const globalBg = state.globalSettings.globalChatBackground;
    if (globalBg) {
        globalBgPreview.style.backgroundImage = `url(${globalBg})`;
        globalBgPreview.textContent = '';
        document.getElementById('remove-global-bg-btn').style.display = 'inline-block';
    } else {
        globalBgPreview.style.backgroundImage = 'none';
        globalBgPreview.textContent = 'ç‚¹å‡»ä¸‹æ–¹ä¸Šä¼ ';
        document.getElementById('remove-global-bg-btn').style.display = 'none';
    }

    
    renderIconSettings();
    renderCPhoneIconSettings(); 
    document.getElementById('global-css-input').value = state.globalSettings.globalCss || '';
    document.getElementById('notification-sound-url-input').value = state.globalSettings.notificationSoundUrl || '';
    document.getElementById('status-bar-toggle-switch').checked = state.globalSettings.showStatusBar || false;
document.getElementById('phone-frame-toggle-switch').checked = state.globalSettings.showPhoneFrame || false;
document.getElementById('minimal-chat-ui-switch').checked = state.globalSettings.enableMinimalChatUI || false;
document.getElementById('dynamic-island-music-toggle-switch').checked = state.globalSettings.alwaysShowMusicIsland || false;
document.getElementById('detach-status-bar-switch').checked = state.globalSettings.detachStatusBar || false;
    renderButtonOrderEditor();
    initializeButtonOrderEditor();
}
  
          
                window.renderWallpaperScreenProxy = renderWallpaperScreen;
        
function applyGlobalWallpaper() {
    const homeScreen = document.getElementById('home-screen');
    const wallpaper = state.globalSettings.wallpaper;
    if (wallpaper) {
        
        homeScreen.style.backgroundImage = `url(${wallpaper})`;
    } else {
        
        homeScreen.style.backgroundImage = 'linear-gradient(135deg, #89f7fe, #66a6ff)';
    }
}
  
        
        
        function switchWorldBookCategory(categoryId) {
            
            document.querySelectorAll('.world-book-tab').forEach(tab => {
                tab.classList.toggle('active', tab.dataset.categoryId === categoryId);
            });
            
            document.querySelectorAll('.world-book-category-pane').forEach(pane => {
                pane.classList.toggle('active', pane.dataset.categoryId === categoryId);
            });
        }
        
        
        async function renderWorldBookScreen() {
            const tabsContainer = document.getElementById('world-book-tabs');
            const contentContainer = document.getElementById('world-book-content-container');
            tabsContainer.innerHTML = '';
            contentContainer.innerHTML = '';
        
            
            const [books, categories] = await Promise.all([
                db.worldBooks.toArray(),
                db.worldBookCategories.orderBy('name').toArray()
            ]);
        
            state.worldBooks = books; 
        
            if (books.length === 0) {
                contentContainer.innerHTML = '<p style="text-align:center; color: #8a8a8a; margin-top: 50px;">ç‚¹å‡»å³ä¸Šè§’ "+" åˆ›å»ºä½ çš„ç¬¬ä¸€æœ¬ä¸–ç•Œä¹¦</p>';
                return;
            }
        
            
            const allTab = document.createElement('button');
            allTab.className = 'world-book-tab active';
            allTab.textContent = 'å…¨éƒ¨';
            allTab.dataset.categoryId = 'all';
            tabsContainer.appendChild(allTab);
        
            const allPane = document.createElement('div');
            allPane.className = 'world-book-category-pane active';
            allPane.dataset.categoryId = 'all';
            contentContainer.appendChild(allPane);
        
            
            categories.forEach(category => {
                const categoryTab = document.createElement('button');
                categoryTab.className = 'world-book-tab';
                categoryTab.textContent = category.name;
                categoryTab.dataset.categoryId = String(category.id);
                tabsContainer.appendChild(categoryTab);
        
                const categoryPane = document.createElement('div');
                categoryPane.className = 'world-book-category-pane';
                categoryPane.dataset.categoryId = String(category.id);
                contentContainer.appendChild(categoryPane);
            });
            
            
            const hasUncategorized = books.some(book => !book.categoryId);
            if (hasUncategorized) {
                const uncategorizedTab = document.createElement('button');
                uncategorizedTab.className = 'world-book-tab';
                uncategorizedTab.textContent = 'æœªåˆ†ç±»';
                uncategorizedTab.dataset.categoryId = 'uncategorized';
                tabsContainer.appendChild(uncategorizedTab);
            
                const uncategorizedPane = document.createElement('div');
                uncategorizedPane.className = 'world-book-category-pane';
                uncategorizedPane.dataset.categoryId = 'uncategorized';
                contentContainer.appendChild(uncategorizedPane);
            }
        
            
            books.forEach(book => {
                let contentPreview = 'æš‚æ— å†…å®¹...';
                if (Array.isArray(book.content) && book.content.length > 0) {
                    const firstEntry = book.content[0];
                    contentPreview = firstEntry.comment || firstEntry.content || '';
                } else if (typeof book.content === 'string' && book.content.trim() !== '') {
                    contentPreview = book.content;
                }
        
                const card = document.createElement('div');
                card.className = 'world-book-card';
                card.innerHTML = `
                    <div class="card-title">${book.name}</div>
                    <div class="card-content-preview">${contentPreview}</div>
                `;
                
                
                const cardClickHandler = () => openWorldBookEditor(book.id);
                const cardLongPressHandler = async () => { 
                    const confirmed = await showCustomConfirm('åˆ é™¤ä¸–ç•Œä¹¦', `ç¡®å®šè¦åˆ é™¤ã€Š${book.name}ã€‹å—ï¼Ÿ`, { confirmButtonClass: 'btn-danger' }); 
                    if (confirmed) { 
                        await db.worldBooks.delete(book.id); 
                        state.worldBooks = state.worldBooks.filter(wb => wb.id !== book.id); 
                        renderWorldBookScreen(); 
                    } 
                };
        
                card.addEventListener('click', cardClickHandler);
                addLongPressListener(card, cardLongPressHandler);
        
                
                const clonedCardForAll = card.cloneNode(true);
                clonedCardForAll.addEventListener('click', cardClickHandler);
                addLongPressListener(clonedCardForAll, cardLongPressHandler);
                allPane.appendChild(clonedCardForAll);
                
                
                const categoryKey = book.categoryId ? String(book.categoryId) : 'uncategorized';
                const targetPane = contentContainer.querySelector(`.world-book-category-pane[data-category-id="${categoryKey}"]`);
                if (targetPane) {
                    targetPane.appendChild(card);
                }
            });
        
            
            document.querySelectorAll('.world-book-tab').forEach(tab => {
                tab.addEventListener('click', () => switchWorldBookCategory(tab.dataset.categoryId));
            });
        }
        
        
        /**
         * ã€V2.0 | å·²ä¿®å¤é¢„è§ˆBUGã€‘åˆ›å»ºä¸€ä¸ªåˆ†ç±»çš„åˆ†ç»„DOM
         * @param {string} groupName - åˆ†ç±»åç§°
         * @param {Array} books - è¯¥åˆ†ç±»ä¸‹çš„ä¹¦ç±æ•°ç»„
         * @returns {HTMLElement} - åˆ›å»ºå¥½çš„åˆ†ç»„å®¹å™¨
         */
        function createWorldBookGroup(groupName, books) {
            const groupContainer = document.createElement('div');
            groupContainer.className = 'world-book-group-container';
            
            groupContainer.innerHTML = `
                <div class="world-book-group-header">
                    <span class="arrow">â–¼</span>
                    <span class="group-name">${groupName}</span>
                </div>
                <div class="world-book-group-content"></div>
            `;
        
            const contentEl = groupContainer.querySelector('.world-book-group-content');
            books.sort((a,b) => a.name.localeCompare(b.name, 'zh-CN')); 
            
            books.forEach(book => {
                
                let contentPreview = 'æš‚æ— å†…å®¹...';
                
                
                if (Array.isArray(book.content) && book.content.length > 0) {
                    
                    
                    const firstEntry = book.content[0];
                    contentPreview = firstEntry.comment || firstEntry.content || '';
                } 
                
                else if (typeof book.content === 'string' && book.content.trim() !== '') {
                    
                    contentPreview = book.content;
                }
                
        
                const item = document.createElement('div');
                item.className = 'list-item';
                item.dataset.bookId = book.id;
                
                item.innerHTML = `
                    <div class="item-title">${book.name}</div>
                    <div class="item-content">${String(contentPreview).substring(0, 50)}</div>
                `;
                item.addEventListener('click', () => openWorldBookEditor(book.id));
                addLongPressListener(item, async () => { 
                    const confirmed = await showCustomConfirm('åˆ é™¤ä¸–ç•Œä¹¦', `ç¡®å®šè¦åˆ é™¤ã€Š${book.name}ã€‹å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ’¤é”€ã€‚`, { confirmButtonClass: 'btn-danger' }); 
                    if (confirmed) { 
                        await db.worldBooks.delete(book.id); 
                        state.worldBooks = state.worldBooks.filter(wb => wb.id !== book.id); 
                        renderWorldBookScreen(); 
                    } 
                });
                contentEl.appendChild(item);
            });
        
            return groupContainer;
        }
          
                window.renderWorldBookScreenProxy = renderWorldBookScreen;
        
        
        async function openWorldBookEditor(bookId) {
            
            
            showScreen('world-book-editor-screen');
        
            editingWorldBookId = bookId;
            const [book, categories] = await Promise.all([
                db.worldBooks.get(bookId),
                db.worldBookCategories.toArray()
            ]);
        
            
            if (!book) {
                console.error("å°è¯•æ‰“å¼€ä¸€ä¸ªä¸å­˜åœ¨çš„ä¸–ç•Œä¹¦ï¼ŒID:", bookId);
                showScreen('world-book-screen');
                return;
            }
        
            
            document.getElementById('world-book-editor-title').textContent = book.name;
            document.getElementById('world-book-name-input').value = book.name;
        
            
            const selectEl = document.getElementById('world-book-category-select');
            selectEl.innerHTML = '<option value="">-- æœªåˆ†ç±» --</option>';
            categories.forEach(cat => {
                const option = document.createElement('option');
                option.value = cat.id;
                option.textContent = cat.name;
                if (book.categoryId === cat.id) option.selected = true;
                selectEl.appendChild(option);
            });
        
            
            const entriesContainer = document.getElementById('world-book-entries-container');
            entriesContainer.innerHTML = ''; 
        
            if (Array.isArray(book.content) && book.content.length > 0) {
                book.content.forEach(entry => {
                    const block = createWorldBookEntryBlock(entry);
                    entriesContainer.appendChild(block);
                });
            } else {
                entriesContainer.innerHTML = '<p style="text-align:center; color: var(--text-secondary); margin-top: 20px;">è¿˜æ²¡æœ‰å†…å®¹ï¼Œç‚¹å‡»ä¸‹æ–¹æŒ‰é’®æ·»åŠ ç¬¬ä¸€æ¡å§ï¼</p>';
            }
        
            
        }
          
        
/**
 * ã€V3.0 | æœç´¢æ”¯æŒç‰ˆã€‘æ¸²æŸ“è¡¨æƒ…é¢æ¿
 * @param {boolean} rerenderTabs - æ˜¯å¦éœ€è¦é‡æ–°æ¸²æŸ“é¡¶éƒ¨çš„åˆ†ç±»é¡µç­¾
 */
async function renderStickerPanel(rerenderTabs = true) {
    const grid = document.getElementById('sticker-grid');
    const tabsContainer = document.getElementById('sticker-category-tabs');
    const searchInput = document.getElementById('sticker-search-input');
    const searchTerm = searchInput.value.trim().toLowerCase();

    
    if (rerenderTabs) {
        tabsContainer.innerHTML = '';
        const categories = await db.stickerCategories.toArray();
        
        tabsContainer.innerHTML += `<button class="sticker-category-tab ${activeStickerCategoryId === 'all' ? 'active' : ''}" data-category-id="all">å…¨éƒ¨</button>`;
        categories.forEach(cat => {
             tabsContainer.innerHTML += `<button class="sticker-category-tab ${activeStickerCategoryId === cat.id ? 'active' : ''}" data-category-id="${cat.id}">${cat.name}</button>`;
        });
        tabsContainer.innerHTML += `<button class="sticker-category-tab ${activeStickerCategoryId === 'uncategorized' ? 'active' : ''}" data-category-id="uncategorized">æœªåˆ†ç±»</button>`;
    }

    
    grid.innerHTML = '';
    
    
    let stickersByCategory;
    if (activeStickerCategoryId === 'all') {
        stickersByCategory = state.userStickers;
    } else if (activeStickerCategoryId === 'uncategorized') {
        stickersByCategory = state.userStickers.filter(s => !s.categoryId);
    } else {
        stickersByCategory = state.userStickers.filter(s => s.categoryId === activeStickerCategoryId);
    }

    
    const stickersToShow = searchTerm
        ? stickersByCategory.filter(sticker => sticker.name.toLowerCase().includes(searchTerm))
        : stickersByCategory;

    
    if (stickersToShow.length === 0) {
        const message = searchTerm ? 'æ‰¾ä¸åˆ°åŒ¹é…çš„è¡¨æƒ…' : 'è¿™ä¸ªåˆ†ç±»ä¸‹è¿˜æ²¡æœ‰è¡¨æƒ…å“¦~';
        grid.innerHTML = `<p style="text-align:center; color: var(--text-secondary); grid-column: 1 / -1; padding-top: 20px;">${message}</p>`;
        return;
    }

    stickersToShow.forEach(sticker => {
        const item = document.createElement('div');
        item.className = 'sticker-item';
        item.title = sticker.name;
        item.dataset.stickerId = sticker.id;
        item.innerHTML = `
            <div class="sticker-image-container" style="background-image: url(${sticker.url})"></div>
            <span class="sticker-name">${sticker.name}</span>
        `;
        item.addEventListener('click', () => {
            if (isStickerManagementMode) {
                handleStickerSelection(item);
            } else {
                sendSticker(sticker);
            }
        });
        const deleteBtn = document.createElement('div');
        deleteBtn.className = 'delete-btn';
        deleteBtn.innerHTML = '&times;';
        deleteBtn.onclick = async (e) => {
            e.stopPropagation();
            const confirmed = await showCustomConfirm('åˆ é™¤è¡¨æƒ…', `ç¡®å®šè¦åˆ é™¤è¡¨æƒ… "${sticker.name}" å—ï¼Ÿ`, { confirmButtonClass: 'btn-danger' });
            if (confirmed) {
                await db.userStickers.delete(sticker.id);
                state.userStickers = state.userStickers.filter(s => s.id !== sticker.id);
                renderStickerPanel();
            }
        };
        item.appendChild(deleteBtn);
        grid.appendChild(item);
    });
}
  

        
        let isStickerManagementMode = false;
        let selectedStickers = new Set();
let isNaiGalleryManagementMode = false;
let selectedNaiImages = new Set();        
let naiGalleryCache = []; // <-- æ–°å¢žï¼šç”¨äºŽç¼“å­˜æ‰€æœ‰å›¾ç‰‡æ•°æ®
let naiGalleryRenderCount = 0; // <-- æ–°å¢žï¼šå·²æ¸²æŸ“çš„å›¾ç‰‡è®¡æ•°
const NAI_GALLERY_RENDER_WINDOW = 45; // <-- æ–°å¢žï¼šæ¯æ¬¡åŠ è½½45å¼ 
let isLoadingMoreNaiImages = false; // <-- æ–°å¢žï¼šåŠ è½½çŠ¶æ€é”        
        /**
         * åˆ‡æ¢è¡¨æƒ…é¢æ¿çš„ç®¡ç†æ¨¡å¼
         */
        function toggleStickerManagementMode() {
            isStickerManagementMode = !isStickerManagementMode;
            const grid = document.getElementById('sticker-grid');
            const manageBtn = document.getElementById('manage-stickers-btn');
            const actionBar = document.getElementById('sticker-action-bar');
            const selectAllCheckbox = document.getElementById('select-all-stickers-checkbox');
        
            grid.classList.toggle('management-mode', isStickerManagementMode);
            
            if (isStickerManagementMode) {
                manageBtn.textContent = 'å®Œæˆ';
                actionBar.style.display = 'flex'; 
                selectedStickers.clear();
                selectAllCheckbox.checked = false; 
                updateDeleteStickerButton();
            } else {
                manageBtn.textContent = 'ç®¡ç†';
                actionBar.style.display = 'none';
                grid.querySelectorAll('.sticker-item.selected').forEach(item => item.classList.remove('selected'));
            }
        }
          
        
        /**
         * å¤„ç†â€œå…¨é€‰â€å¤é€‰æ¡†çš„ç‚¹å‡»äº‹ä»¶ï¼Œæ ¹æ®å½“å‰åˆ†ç±»æ™ºèƒ½é€‰æ‹©
         */
        function handleSelectAllStickers() {
            const checkbox = document.getElementById('select-all-stickers-checkbox');
            const shouldSelect = checkbox.checked;
        
            
            let stickersToSelect;
            if (activeStickerCategoryId === 'all') {
                stickersToSelect = state.userStickers;
            } else if (activeStickerCategoryId === 'uncategorized') {
                stickersToSelect = state.userStickers.filter(s => !s.categoryId);
            } else {
                stickersToSelect = state.userStickers.filter(s => s.categoryId === activeStickerCategoryId);
            }
        
            
            stickersToSelect.forEach(sticker => {
                const stickerId = sticker.id;
                const itemEl = document.querySelector(`.sticker-item[data-sticker-id="${stickerId}"]`);
                
                if (shouldSelect) {
                    
                    selectedStickers.add(stickerId);
                    if (itemEl) itemEl.classList.add('selected');
                } else {
                    
                    selectedStickers.delete(stickerId);
                    if (itemEl) itemEl.classList.remove('selected');
                }
            });
        
            
            updateDeleteStickerButton();
        }
        
        /**
         * æ›´æ–°åˆ é™¤æŒ‰é’®ä¸Šçš„è®¡æ•°
         */
        function updateDeleteStickerButton() {
            const btn = document.getElementById('delete-selected-stickers-btn');
            btn.textContent = `åˆ é™¤ (${selectedStickers.size})`;
        }
        
        /**
         * å¤„ç†ç”¨æˆ·ç‚¹å‡»é€‰æ‹©æˆ–å–æ¶ˆé€‰æ‹©è¡¨æƒ…
         * @param {HTMLElement} item - è¢«ç‚¹å‡»çš„è¡¨æƒ…DOMå…ƒç´ 
         */
        function handleStickerSelection(item) {
            if (!isStickerManagementMode) return; 
        
            const stickerId = item.dataset.stickerId;
            if (!stickerId) return;
        
            item.classList.toggle('selected');
        
            if (selectedStickers.has(stickerId)) {
                selectedStickers.delete(stickerId);
            } else {
                selectedStickers.add(stickerId);
            }
            updateDeleteStickerButton();
        }
        
        /**
         * æ‰§è¡Œæ‰¹é‡åˆ é™¤æ“ä½œ
         */
        async function executeBatchDeleteStickers() {
            if (selectedStickers.size === 0) return;
            
            const confirmed = await showCustomConfirm(
                'ç¡®è®¤åˆ é™¤',
                `ç¡®å®šè¦åˆ é™¤é€‰ä¸­çš„ ${selectedStickers.size} ä¸ªè¡¨æƒ…å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ¢å¤ã€‚`,
                { confirmButtonClass: 'btn-danger' }
            );
        
            if (confirmed) {
                const idsToDelete = [...selectedStickers];
                
                
                await db.userStickers.bulkDelete(idsToDelete);
                
                
                state.userStickers = state.userStickers.filter(s => !idsToDelete.includes(s.id));
                
                
                toggleStickerManagementMode();
                renderStickerPanel();
                
                await showCustomAlert('åˆ é™¤æˆåŠŸ', 'é€‰ä¸­çš„è¡¨æƒ…å·²æˆåŠŸåˆ é™¤ã€‚');
            }
        }
        
        
        
        
        /**
         * ã€æ€»å…¥å£ã€‘æ‰“å¼€æ‰¹é‡å¯¼å…¥è¡¨æƒ…çš„å¼¹çª—
         */
        async function openBatchStickerImportModal() {
            const placeholderText = `è¯·æŒ‰ç…§ä»¥ä¸‹é€šç”¨æ ¼å¼ç²˜è´´ï¼Œä¸€è¡Œä¸€ä¸ªï¼š\n\nå¼€å¿ƒ: https://.../happy.gif\nå“­æ³£: https://.../cry.png\n\n`;
            
            const pastedText = await showCustomPrompt(
                'æ‰¹é‡å¯¼å…¥è¡¨æƒ…',
                placeholderText,
                '',
                'textarea'
            );
        
            if (pastedText && pastedText.trim()) {
                await handleBatchStickerImport(pastedText);
            }
        }
        
        
        /**
         * ã€æ ¸å¿ƒé€»è¾‘ | V3.0 - å·²ä¿®å¤URLæ ¼å¼BUGã€‘å¤„ç†ç²˜è´´çš„æ–‡æœ¬ï¼Œè§£æžå¹¶å­˜å…¥æ•°æ®åº“
         * @param {string} text - ç”¨æˆ·ç²˜è´´çš„æ–‡æœ¬å†…å®¹
         */
        async function handleBatchStickerImport(text) {
            const lines = text.trim().split('\n');
            const newStickers = [];
            const baseUrl = 'https://files.catbox.moe/';
            let errorCount = 0;
            const currentCategoryId = (activeStickerCategoryId !== 'all' && activeStickerCategoryId !== 'uncategorized') ? activeStickerCategoryId : null;

            for (const line of lines) {
                const trimmedLine = line.trim();

                
                
                if (!trimmedLine || trimmedLine.includes('å¡«å…¥')) {
                    continue;
                }
                

                
                const fullUrlMatch = trimmedLine.match(/^(.+?)[:ï¼š]\s*(https?:\/\/.+)$/);
                
                if (fullUrlMatch) {
                    const name = fullUrlMatch[1].trim();
                    const url = fullUrlMatch[2].trim();
                    newStickers.push({
                        id: 'sticker_' + Date.now() + Math.random(),
                        name: name,
                        url: url,
                        categoryId: currentCategoryId
                    });
                    continue; 
                }

                
                let name = null;
                let code = null;
                const noSpaceMatch = trimmedLine.match(/^([\u4e00-\u9fa5]+)([a-zA-Z0-9]+\..+)$/);
                
                if (noSpaceMatch) {
                    name = noSpaceMatch[1];
                    code = noSpaceMatch[2];
                } else {
                    const parts = trimmedLine.split(/\s+/);
                    if (parts.length >= 2) {
                        code = parts.pop();
                        name = parts.join(' ');
                    }
                }

                if (name && code && code.includes('.')) {
                    newStickers.push({
                        id: 'sticker_' + Date.now() + Math.random(),
                        name: name,
                        url: baseUrl + code,
                        categoryId: currentCategoryId
                    });
                } else {
                    errorCount++;
                    console.warn('æ‰¹é‡å¯¼å…¥æ ¼å¼é”™è¯¯ï¼Œå·²è·³è¿‡æ­¤è¡Œ:', trimmedLine);
                }
            }

            if (errorCount > 0) {
                await showCustomAlert('éƒ¨åˆ†å¯¼å…¥å¤±è´¥', `æœ‰ ${errorCount} è¡Œçš„æ ¼å¼ä¸æ­£ç¡®ï¼Œå·²è¢«ç³»ç»Ÿè·³è¿‡ã€‚`);
            }

            if (newStickers.length > 0) {
                await db.userStickers.bulkAdd(newStickers);
                state.userStickers.push(...newStickers);
                renderStickerPanel();
                await showCustomAlert('å¯¼å…¥æˆåŠŸ', `å·²æˆåŠŸæ‰¹é‡å¯¼å…¥ ${newStickers.length} ä¸ªæ–°è¡¨æƒ…ï¼`);
            } else if (errorCount === 0) {
                alert("æ²¡æœ‰æ‰¾åˆ°å¯å¯¼å…¥çš„å†…å®¹ã€‚è¯·æ£€æŸ¥æ‚¨ç²˜è´´çš„æ ¼å¼æ˜¯å¦æ­£ç¡®ã€‚");
            }
        }
          
/**
 * ã€è¾…åŠ©å‡½æ•°ã€‘æ»šåŠ¨åˆ°å¹¶é«˜äº®æ˜¾ç¤ºåŽŸå§‹æ¶ˆæ¯
 * @param {number} originalTimestamp - è¦è·³è½¬åˆ°çš„åŽŸå§‹æ¶ˆæ¯çš„æ—¶é—´æˆ³
 */
function scrollToOriginalMessage(originalTimestamp) {
    const selector = `.message-bubble[data-timestamp="${originalTimestamp}"]`;
    const originalMessageBubble = document.querySelector(selector);

    if (originalMessageBubble) {
        originalMessageBubble.scrollIntoView({
            behavior: 'smooth',
            block: 'center'
        });

        originalMessageBubble.classList.add('highlighted');
        setTimeout(() => {
            if (document.body.contains(originalMessageBubble)) {
                originalMessageBubble.classList.remove('highlighted');
            }
        }, 1500); 

    } else {
        
        alert("æ‰¾ä¸åˆ°åŽŸå§‹æ¶ˆæ¯ã€‚å¯èƒ½å·²è¢«åˆ é™¤æˆ–ä½äºŽæ›´æ—©çš„åŽ†å²è®°å½•ä¸­ã€‚");
    }
}
        async function createMessageElement(msg, chat) {
        
            
            if (msg.type === 'recalled_message') {
                const wrapper = document.createElement('div');
                wrapper.className = 'message-wrapper system-pat';
                wrapper.dataset.timestamp = msg.timestamp; 
                const bubble = document.createElement('div');
                bubble.className = 'message-bubble recalled-message-placeholder';
                bubble.dataset.timestamp = msg.timestamp; 
                bubble.textContent = msg.content;
                wrapper.appendChild(bubble);
                addLongPressListener(wrapper, () => showMessageActions(msg.timestamp));
                wrapper.addEventListener('click', () => { 
                    if (isSelectionMode) {
                        toggleMessageSelection(msg.timestamp);
                    }
                });
                return wrapper;
            }
            else if (msg.type === 'post_deleted_notice') {
                const wrapper = document.createElement('div');
                wrapper.className = 'message-wrapper system-pat';
                wrapper.dataset.timestamp = msg.timestamp; 
                const bubble = document.createElement('div');
                bubble.className = 'message-bubble post-deleted-placeholder'; 
                bubble.dataset.postId = msg.postId;
                bubble.textContent = msg.content;
                wrapper.appendChild(bubble);
                addLongPressListener(wrapper, () => showMessageActions(msg.timestamp));
                wrapper.addEventListener('click', () => { 
                    if (isSelectionMode) {
                        toggleMessageSelection(msg.timestamp);
                    }
                });
                return wrapper;
            }
        
            if (msg.isHidden) {
                return null;
            }
        
            if (msg.type === 'pat_message') {
                const wrapper = document.createElement('div');
                wrapper.className = 'message-wrapper system-pat'; 
                const bubble = document.createElement('div');
                bubble.className = 'message-bubble system-bubble'; 
                bubble.dataset.timestamp = msg.timestamp;
                bubble.textContent = msg.content;
                wrapper.appendChild(bubble);
                addLongPressListener(wrapper, () => showMessageActions(msg.timestamp));
                wrapper.addEventListener('click', () => { if (isSelectionMode) toggleMessageSelection(msg.timestamp); });
                return wrapper;
            }
        
            
            const isUser = msg.role === 'user';
            const myNickname = chat.settings.myNickname || 'æˆ‘';
            const wrapper = document.createElement('div');
            wrapper.className = `message-wrapper ${isUser ? 'user' : 'ai'}`;
        
            if (chat.isGroup && !isUser) {
                const member = chat.members.find(m => m.originalName === msg.senderName);
                const senderNameDiv = document.createElement('div');
                senderNameDiv.className = 'sender-name';
                senderNameDiv.textContent = member ? member.groupNickname : (msg.senderName || 'æœªçŸ¥æˆå‘˜');
                wrapper.appendChild(senderNameDiv);
            }
        
            const bubble = document.createElement('div');
            bubble.className = `message-bubble ${isUser ? 'user' : 'ai'}`;
            bubble.dataset.timestamp = msg.timestamp;
        
            const timestampEl = document.createElement('span');
            timestampEl.className = 'timestamp';
            timestampEl.textContent = formatTimestamp(msg.timestamp);
        
            let avatarSrc, avatarFrameSrc = '';
            if (isUser) {
                avatarSrc = chat.settings.myAvatar || (chat.isGroup ? defaultMyGroupAvatar : defaultAvatar);
                avatarFrameSrc = chat.settings.myAvatarFrame || '';
            } else {
                if (chat.isGroup) {
                    const member = chat.members.find(m => m.originalName === msg.senderName);
                    if (member) {
                        const characterProfile = state.chats[member.id];
                        avatarSrc = member.avatar || (characterProfile ? characterProfile.settings.aiAvatar : defaultGroupMemberAvatar);
                        avatarFrameSrc = member.avatarFrame || (characterProfile ? characterProfile.settings.aiAvatarFrame : '');
                    } else {
                        avatarSrc = defaultGroupMemberAvatar;
                        avatarFrameSrc = '';
                    }
                } else {
                    avatarSrc = chat.settings.aiAvatar || defaultAvatar;
                    avatarFrameSrc = chat.settings.aiAvatarFrame || '';
                }
            }
        
            let avatarHtml;
            if (avatarFrameSrc) {
                avatarHtml = `<div class="avatar-with-frame"><img src="${avatarSrc}" class="avatar-img"><img src="${avatarFrameSrc}" class="avatar-frame"></div>`;
            } else {
                avatarHtml = `<img src="${avatarSrc}" class="avatar">`;
            }
            const hasFrameClass = avatarFrameSrc ? 'has-frame' : '';
            const avatarGroupHtml = `<div class="avatar-group ${hasFrameClass}">${avatarHtml}</div>`;
            
            let contentHtml;
            let quoteHtml = '';
            if (msg.quote) {
                const quotedSenderDisplayName = getDisplayNameInGroup(chat, msg.quote.senderName);
                const fullQuotedContent = String(msg.quote.content || '');
                quoteHtml = `
                    <div class="quoted-message" data-original-timestamp="${msg.quote.timestamp}" style="cursor: pointer;">
                        <div class="quoted-sender">å›žå¤ ${quotedSenderDisplayName}:</div>
                        <div class="quoted-content">${fullQuotedContent}</div>
                    </div>
                `;
            }
            
            
            
            
        
            let rawContent = msg.content; 

            if (typeof rawContent === 'string' && rawContent.trim().startsWith('<') && rawContent.trim().endsWith('>')) {
                contentHtml = rawContent;
                bubble.classList.add('is-raw-html'); 
            } else if (msg.type === 'offline_text' || msg.type === 'share_link' || msg.type === 'share_card' || msg.type === 'location_share' || msg.type === 'ai_image' || msg.type === 'user_photo' || msg.type === 'voice_message' || msg.type === 'transfer' || msg.type === 'waimai_request'|| msg.type === 'waimai_order'  || msg.type === 'red_packet' || msg.type === 'poll' || msg.type === 'gift' || msg.type === 'realimag' || msg.type === 'naiimag') {
                
               if (msg.type === 'offline_text') {
                    
                    const combinedText = msg.content || `${msg.dialogue || ''} ${msg.description || ''}`.trim();

                    
                    const regex = /(ã€Œ.*?ã€|â€œ.*?â€)/g;
                    const parts = combinedText.split(regex).filter(part => part); 

                    
                    contentHtml = parts.map(part => {
                        
                        if (part.startsWith('ã€Œ') || part.startsWith('â€œ')) {
                            return `<span class="offline-dialogue">${parseMarkdown(part)}</span>`;
                        } else {
                            
                            return `<span class="offline-description">${parseMarkdown(part.trim()).replace(/\n/g, '<br>')}</span>`;
                        }
                    }).join(''); 
                }
else if (msg.type === 'share_link') {
                    bubble.classList.add('is-link-share', 'is-card-like');
                    contentHtml = `<div class="link-share-card" data-timestamp="${msg.timestamp}"><div class="title">${msg.title || 'æ— æ ‡é¢˜'}</div><div class="description">${msg.description || 'ç‚¹å‡»æŸ¥çœ‹è¯¦æƒ…...'}</div><div class="footer"><svg class="footer-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><line x1="2" y1="12" x2="22" y2="12"></line><path d="M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z"></path></svg><span>${msg.source_name || 'é“¾æŽ¥åˆ†äº«'}</span></div></div>`;
                } else if (msg.type === 'share_card') {
                    bubble.classList.add('is-link-share', 'is-card-like');
                    contentHtml = `<div class="link-share-card" style="cursor: pointer;" data-timestamp="${msg.timestamp}"><div class="title">${msg.payload.title}</div><div class="description">å…± ${msg.payload.sharedHistory.length} æ¡æ¶ˆæ¯</div><div class="footer"><svg class="footer-icon" ...>...</svg><span>èŠå¤©è®°å½•</span></div></div>`;
                } else if (msg.type === 'location_share') {
                    bubble.classList.add('is-location-share', 'is-card-like');
                        let finalImageUrl;
    
    
    if (msg.imageUrl) {
        finalImageUrl = msg.imageUrl;
    } 
    
    else if (state.globalSettings.enableAiDrawing && msg.image_prompt) {
        finalImageUrl = `https://image.pollinations.ai/prompt/${encodeURIComponent(msg.image_prompt)}`;
    } 
    
    else {
        finalImageUrl = 'https://s3plus.meituan.net/opapisdk/op_ticket_885190757_1756262526935_qdqqd_4uque3.jpeg'; 
    }
    
    const mapAreaStyle = `style="background-image: url('${finalImageUrl}');"`;
                    contentHtml = `<div class="location-share-card"><div class="card-text-area"><div class="card-text-primary">${msg.content}</div><div class="card-text-secondary">ä½ç½®åˆ†äº«</div></div><div class="card-map-area" ${mapAreaStyle}><div class="card-pin-icon"><svg width="1em" height="1em" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 11.5C11.1716 11.5 10.5 10.8284 10.5 10C10.5 9.17157 11.1716 8.5 12 8.5C12.8284 8.5 13.5 9.17157 13.5 10C13.5 10.8284 12.8284 11.5 12 11.5Z"></path><path d="M12 2C7.92134 2 4.5 5.42134 4.5 9.5C4.5 14.5312 11.2188 21.4375 11.5938 21.8125C11.7954 22.014 12.2046 22.014 12.4062 21.8125C12.7812 21.4375 19.5 14.5312 19.5 9.5C19.5 5.42134 16.0787 2 12 2ZM12 12.5C10.6193 12.5 9.5 11.3807 9.5 10C9.5 8.61929 10.6193 7.5 12 7.5C13.3807 7.5 14.5 8.61929 14.5 10C14.5 11.3807 13.3807 12.5 12 12.5Z"></path></svg></div></div></div>`;
                } else if (msg.type === 'user_photo' || msg.type === 'ai_image') {
                    bubble.classList.add('is-ai-image', 'is-card-like');
                    const altText = msg.type === 'user_photo' ? "ç”¨æˆ·æè¿°çš„ç…§ç‰‡" : "AIç”Ÿæˆçš„å›¾ç‰‡";
                    
                    
                    const imageUrl = state.globalSettings.enableAiDrawing && msg.image_prompt 
                        ? `https://image.pollinations.ai/prompt/${msg.image_prompt}` 
                        : 'https://i.postimg.cc/KYr2qRCK/1.jpg'; 

                    
                    contentHtml = `<img src="${imageUrl}" class="ai-generated-image" alt="${altText}" data-description="${msg.content}">`;
                } else if (msg.type === 'naiimag') {
                    // NovelAIå›¾ç‰‡æ¸²æŸ“ï¼ˆå¤ç”¨realimagæ ·å¼ï¼‰
                    bubble.classList.add('is-realimag', 'is-card-like');
                    contentHtml = `
                        <div class="nai-image-wrapper">
                            <img src="${msg.imageUrl}" class="realimag-image" alt="NovelAIå›¾ç‰‡åˆ†äº«" loading="lazy" onerror="this.src='https://i.postimg.cc/KYr2qRCK/1.jpg'; this.alt='å›¾ç‰‡åŠ è½½å¤±è´¥';" title="${msg.fullPrompt || msg.prompt || 'NovelAIç”Ÿæˆ'}">
                            <button class="nai-regenerate-btn" title="é‡æ–°ç”Ÿæˆ">
                                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                                    <path d="M20 11A8.1 8.1 0 0 0 4.5 9M4 5v4h4" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"></path>
                                    <path d="M4 13a8.1 8.1 0 0 0 15.5 2m.5 4v-4h-4" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"></path>
                                </svg>
                            </button>
                        </div>
                    `;
                } else if (msg.type === 'voice_message') {
    bubble.classList.add('is-voice-message', 'is-card-like');
    const duration = Math.max(1, Math.round((msg.content || '').length / 5));
    const durationFormatted = `0:${String(duration).padStart(2, '0')}''`;
    const waveformHTML = '<div></div><div></div><div></div><div></div><div></div>';

    if (isUser) {
        
        contentHtml = `
            <div class="voice-message-body" data-text="${encodeURIComponent(msg.content)}">
                <div class="voice-waveform">${waveformHTML}</div>
                <span class="voice-duration">${durationFormatted}</span>
            </div>
            <div class="voice-transcript"></div>
        `;
    } else {
        
        
        
        const canPlayTTS = !chat.isGroup && chat.settings.enableTts !== false;
        
        
        const voiceId = chat.settings.minimaxVoiceId || 'female-shaonv-jingpin';
        
        
        const voiceIdAttribute = canPlayTTS ? `data-voice-id="${voiceId}"` : '';

        contentHtml = `
            <div class="voice-message-body" data-text="${encodeURIComponent(msg.content)}" ${voiceIdAttribute}>
                <div class="voice-waveform">${waveformHTML}</div>
                <div class="loading-spinner"></div>
                <span class="voice-duration">${durationFormatted}</span>
            </div>
            <div class="voice-transcript"></div>
        `;
    }
}else if (msg.type === 'transfer') {
                    bubble.classList.add('is-transfer', 'is-card-like');
                     let titleText, noteText;
                    const myNickname = chat.isGroup ? (chat.settings.myNickname || 'æˆ‘') : 'æˆ‘';
                    const senderDisplayName = getDisplayNameInGroup(chat, msg.senderName);
                    const receiverDisplayName = getDisplayNameInGroup(chat, msg.receiverName || chat.name);
                    if (isUser) { 
                        if (msg.isRefund) { titleText = `é€€æ¬¾ç»™ ${receiverDisplayName}`; noteText = 'å·²æ‹’æ”¶å¯¹æ–¹è½¬è´¦'; } 
                        else { titleText = `è½¬è´¦ç»™ ${receiverDisplayName}`; if (msg.status === 'accepted') noteText = 'å¯¹æ–¹å·²æ”¶æ¬¾'; else if (msg.status === 'declined') noteText = 'å¯¹æ–¹å·²æ‹’æ”¶'; else noteText = msg.note || 'ç­‰å¾…å¯¹æ–¹å¤„ç†...'; }
                    } else {
                        if (msg.isRefund) { titleText = `é€€æ¬¾æ¥è‡ª ${senderDisplayName}`; noteText = 'è½¬è´¦å·²è¢«æ‹’æ”¶'; } 
                        else if (msg.receiverName === myNickname) { titleText = `è½¬è´¦ç»™ ${myNickname}`; if (msg.status === 'accepted') noteText = 'ä½ å·²æ”¶æ¬¾'; else if (msg.status === 'declined') noteText = 'ä½ å·²æ‹’æ”¶'; else { bubble.style.cursor = 'pointer'; bubble.dataset.status = 'pending'; noteText = msg.note || 'ç‚¹å‡»å¤„ç†'; } } 
                        else { titleText = `è½¬è´¦: ${senderDisplayName} â†’ ${receiverDisplayName}`; noteText = msg.note || 'ç¾¤èŠå†…è½¬è´¦'; }
                    }
                    const heartIcon = `<svg viewBox="0 0 24 24" width="20" height="20" fill="currentColor" style="vertical-align: middle;"><path d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z"></path></svg>`;
                    contentHtml = `<div class="transfer-card"><div class="transfer-title">${heartIcon} ${titleText}</div><div class="transfer-amount">Â¥ ${Number(msg.amount).toFixed(2)}</div><div class="transfer-note">${noteText}</div></div>`;
                } else if (msg.type === 'waimai_request') {
                    bubble.classList.add('is-waimai-request', 'is-card-like');
                     if (msg.status === 'paid' || msg.status === 'rejected') bubble.classList.add(`status-${msg.status}`);
                    const senderDisplayName = getDisplayNameInGroup(chat, msg.senderName);
                    const requestTitle = `æ¥è‡ª ${senderDisplayName} çš„ä»£ä»˜è¯·æ±‚`;
                    let actionButtonsHtml = '';
                    if (msg.status === 'pending' && !isUser) { actionButtonsHtml = `<div class="waimai-user-actions"><button class="waimai-decline-btn" data-choice="rejected">æ®‹å¿æ‹’ç»</button><button class="waimai-pay-btn" data-choice="paid">ä¸ºTaä¹°å•</button></div>`; }
                    contentHtml = `<div class="waimai-card"><div class="waimai-header"><img src="https://files.catbox.moe/mq179k.png" class="icon" alt="Meituan Icon"><div class="title-group"><span class="brand">ç¾Žå›¢å¤–å–</span><span class="separator">|</span><span>å¤–å–ç¾Žé£Ÿ</span></div></div><div class="waimai-catchphrase">Hiï¼Œä½ å’Œæˆ‘çš„è·ç¦»åªå·®ä¸€é¡¿å¤–å–ï½ž</div><div class="waimai-main"><div class="request-title">${requestTitle}</div><div class="payment-box"><div class="payment-label">éœ€ä»˜æ¬¾</div><div class="amount">Â¥${Number(msg.amount).toFixed(2)}</div><div class="countdown-label">å‰©ä½™æ”¯ä»˜æ—¶é—´<div class="countdown-timer" id="waimai-timer-${msg.timestamp}"></div></div></div><button class="waimai-details-btn">æŸ¥çœ‹è¯¦æƒ…</button></div>${actionButtonsHtml}</div>`;
                       setTimeout(() => {
        if (msg.status === 'pending') {
            const timerElement = document.getElementById(`waimai-timer-${msg.timestamp}`);
            if (timerElement) {
                const timerId = startWaimaiCountdown(timerElement, msg.countdownEndTime);
                
                waimaiTimers[msg.timestamp] = timerId;
            }
        }
    }, 0);
                } else if (msg.type === 'waimai_order') {
                bubble.classList.add('is-waimai-request', 'is-card-like'); 
                const senderDisplayName = getDisplayNameInGroup(chat, msg.senderName);
                
                let recipientDisplayName = 'ä½ ';
                if (chat.isGroup) {
                    
                    recipientDisplayName = getDisplayNameInGroup(chat, msg.recipientName);
                }

    contentHtml = `
        <div class="waimai-card">
            <div class="waimai-header">
                <img src="https://files.catbox.moe/mq179k.png" class="icon" alt="Meituan Icon">
                <div class="title-group"><span class="brand">ç¾Žå›¢å¤–å–</span><span class="separator">|</span><span>å¤–å–ç¾Žé£Ÿ</span></div>
            </div>
            <div class="waimai-main">
                <div class="request-title" style="margin-bottom: 12px;">${senderDisplayName} å·²ä¸º${recipientDisplayName}ä¸‹å•ï¼Œè¯·æ…¢ç”¨ï½ž</div>
                <div class="payment-box">
                    <div class="payment-label" style="font-size: 18px; font-weight: 600;">${msg.productInfo}</div>
                    <div class="amount" style="margin-top: 8px;">Â¥${Number(msg.amount).toFixed(2)}</div>
                </div>
                <button class="waimai-details-btn">æŸ¥çœ‹è®¢å•è¯¦æƒ…</button>
            </div>
        </div>
    `;
}else if (msg.type === 'red_packet') {
                     bubble.classList.add('is-red-packet', 'is-card-like');
                    const myOriginalName = state.qzoneSettings.nickname || '{{user}}';
                    const isFinished = msg.isFullyClaimed; const hasClaimed = msg.claimedBy && msg.claimedBy[myOriginalName];
                    let cardClass = '', claimedInfoHtml = '', typeText = 'æ‹¼æ‰‹æ°”çº¢åŒ…';
                    if (isFinished) { cardClass = 'opened'; } if (msg.packetType === 'direct') { const receiverDisplayName = getDisplayNameInGroup(chat, msg.receiverName); typeText = `ä¸“å±žçº¢åŒ…: ç»™ ${receiverDisplayName}`; if (Object.keys(msg.claimedBy || {}).length > 0) cardClass = 'opened'; }
                    if (hasClaimed) { const myClaimedAmount = msg.claimedBy[myOriginalName] || 0; claimedInfoHtml = `<div class="rp-claimed-info">ä½ é¢†å–äº†çº¢åŒ…ï¼Œé‡‘é¢ ${myClaimedAmount.toFixed(2)} å…ƒ</div>`; } 
                    else if (isFinished) { claimedInfoHtml = `<div class="rp-claimed-info">çº¢åŒ…å·²è¢«é¢†å®Œ</div>`; } 
                    else if (msg.packetType === 'direct' && Object.keys(msg.claimedBy || {}).length > 0) { const receiverDisplayName = getDisplayNameInGroup(chat, msg.receiverName); claimedInfoHtml = `<div class="rp-claimed-info">å·²è¢« ${receiverDisplayName} é¢†å–</div>`; }
                    contentHtml = `<div class="red-packet-card ${cardClass}"><div class="rp-header"><img src="https://files.catbox.moe/lo9xhc.png" class="rp-icon"><span class="rp-greeting">${msg.greeting || 'æ­å–œå‘è´¢ï¼Œå¤§å‰å¤§åˆ©ï¼'}</span></div><div class="rp-type">${typeText}</div>${claimedInfoHtml}</div>`;
                } else if (msg.type === 'poll') {
                    bubble.classList.add('is-poll', 'is-card-like');
                    const pollQuestionText = msg.question || msg.content || '(æ— æ ‡é¢˜æŠ•ç¥¨)';
                    let totalVotes = 0; const voteCounts = {}; for (const option in msg.votes) { const count = msg.votes[option].length; voteCounts[option] = count; totalVotes += count; }
                    const myOriginalName = state.qzoneSettings.nickname || '{{user}}'; let myVote = null; for (const option in msg.votes) { if (msg.votes[option].includes(myOriginalName)) { myVote = option; break; } }
                    let optionsHtml = '<div class="poll-options-list">'; msg.options.forEach(optionText => { const count = voteCounts[optionText] || 0; const percentage = totalVotes > 0 ? (count / totalVotes) * 100 : 0; const isVotedByMe = myVote === optionText; optionsHtml += `<div class="poll-option-item ${isVotedByMe ? 'voted' : ''}" data-option="${optionText}"><div class="poll-option-bar" style="width: ${percentage}%;"></div><div class="poll-option-content"><span class="poll-option-text">${optionText}</span><span class="poll-option-votes">${count} ç¥¨</span></div></div>`; }); optionsHtml += '</div>';
                    let footerHtml = msg.isClosed ? `<div class="poll-footer"><span class="poll-total-votes">å…± ${totalVotes} äººæŠ•ç¥¨</span><button class="poll-action-btn">æŸ¥çœ‹ç»“æžœ</button></div>` : `<div class="poll-footer"><span class="poll-total-votes">å…± ${totalVotes} äººæŠ•ç¥¨</span><button class="poll-action-btn">ç»“æŸæŠ•ç¥¨</button></div>`;
                    contentHtml = `<div class="poll-card ${msg.isClosed ? 'closed' : ''}" data-poll-timestamp="${msg.timestamp}"><div class="poll-question">${pollQuestionText}</div>${optionsHtml}${footerHtml}</div>`;
                } else if (msg.type === 'gift') {
                    bubble.classList.add('is-gift', 'is-card-like');
                     let headerText; const myNicknameForGift = chat.settings.myNickname || 'æˆ‘';
                    if (chat.isGroup) {
                        if (msg.recipients && msg.recipients.length > 0) {
                            const recipientDisplayNames = msg.recipients.map(originalName => getDisplayNameInGroup(chat, originalName));
                            if (recipientDisplayNames.length === 1) { headerText = `é€ç»™ ${recipientDisplayNames[0]} çš„ç¤¼ç‰©`; } else { headerText = `é€ç»™ ${recipientDisplayNames.slice(0, 2).join('ã€')}ç­‰äººçš„ç¤¼ç‰©`; }
                        } else { headerText = `é€ç»™å¤§å®¶çš„ç¤¼ç‰©`; }
                    } else {
                        if (isUser) { headerText = `é€ç»™ ${chat.name} çš„ç¤¼ç‰©`; } 
                        else { const recipientDisplayName = chat.settings.myNickname || 'ä½ '; headerText = `é€ç»™ ${recipientDisplayName} çš„ç¤¼ç‰©`; }
                    }
                    const previewItems = msg.items.slice(0, 3); let previewHtml = ''; previewItems.forEach(item => { previewHtml += `<div class="gift-preview-item"><img src="${item.imageUrl}" class="gift-preview-img"><span class="gift-preview-name">${item.name}</span><span class="gift-preview-quantity">x${item.quantity}</span></div>`; });
                    let moreItemsText = ''; if (msg.items.length > 3) { moreItemsText = ` ç­‰${msg.items.length}ä»¶å•†å“`; }
                    contentHtml = `<div class="gift-card"><div class="gift-header"><svg class="gift-header-icon" viewBox="0 0 24 24" fill="currentColor"><path d="M20 6h-2.18a4 4 0 0 0-7.64 0H8a4 4 0 0 0-4 4v2h20V10a4 4 0 0 0-4-4zM8 4a2 2 0 1 1-2 2a2 2 0 0 1 2-2zm12 0a2 2 0 1 1-2 2a2 2 0 0 1 2-2zM4 14v6a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-6H4z"></path></svg><span class="gift-header-text">${headerText}</span></div><div class="gift-items-preview">${previewHtml}</div><div class="gift-footer">å…±${msg.items.length}ä»¶å•†å“${moreItemsText}ï¼Œç‚¹å‡»æŸ¥çœ‹</div></div>`;
                }
            } else {
                const processedContent = String(rawContent); 
                let processedByRule = await applyRenderingRules(processedContent, chat.id);
                if (processedByRule !== processedContent) {
                    contentHtml = processedByRule;
                    bubble.classList.add('is-card-like');
                } else {
                    
                    
                    if (Array.isArray(msg.content) && msg.content[0]?.type === 'image_url') {
                        
                        const imageUrl = msg.content[0].image_url.url;
                        contentHtml = `<img src="${imageUrl}" class="chat-image">`;
                    }
                    
                    else if (STICKER_REGEX.test(processedByRule)) { 
                        bubble.classList.add('is-sticker', 'is-card-like');
                        contentHtml = `<img src="${processedByRule}" alt="${msg.meaning || 'Sticker'}" class="sticker-image">`;
                    } else {
                        let plainText = processMentions(processedByRule, chat);
                        contentHtml = parseMarkdown(plainText).replace(/\n/g, '<br>');
                    }
                }
            }
        
            
            bubble.innerHTML = `
                ${avatarGroupHtml}
                <div class="content">
                    ${quoteHtml}
                    ${contentHtml}
                </div>
            `;
            
            wrapper.appendChild(bubble);
            wrapper.appendChild(timestampEl);
            
            addLongPressListener(wrapper, () => showMessageActions(msg.timestamp));
            wrapper.addEventListener('click', () => { if (isSelectionMode) toggleMessageSelection(msg.timestamp); });
        
            if (!isUser) {
                const avatarGroupEl = wrapper.querySelector('.avatar-group'); 
                if (avatarGroupEl) {
                    avatarGroupEl.style.cursor = 'pointer';
                    if (!chat.isGroup) {
                        avatarGroupEl.addEventListener('click', (e) => { e.stopPropagation(); showCharacterProfileModal(chat.id); });
                    } else {
                        avatarGroupEl.addEventListener('dblclick', (e) => { e.stopPropagation(); handleUserPat(chat.id, msg.senderName); });
                    }
                }
            }
            return wrapper;
        }
  
        
        async function prependMessage(msg, chat) { 
            const messagesContainer = document.getElementById('chat-messages'); 
            const messageEl = await createMessageElement(msg, chat); 
        
            
            if (!messageEl) return;
        
            const loadMoreBtn = document.getElementById('load-more-btn'); 
            if (loadMoreBtn) { 
                messagesContainer.insertBefore(messageEl, loadMoreBtn.nextSibling); 
            } else { 
                messagesContainer.prepend(messageEl); 
            } 
        }
          
        
        /**
         * ã€V3.0 | å·²å»¶é•¿é—´éš”ã€‘å°†æ¶ˆæ¯å…ƒç´ è¿½åŠ åˆ°èŠå¤©çª—å£
         */
        async function appendMessage(msg, chat, isInitialLoad = false) {
            const messagesContainer = document.getElementById('chat-messages');
            const typingIndicator = document.getElementById('typing-indicator');

const lastMessage = chat.history.filter(m => !m.isHidden).pop();


if (lastMessage && (msg.timestamp - lastMessage.timestamp > 600000)) { 
    const timestampEl = createSystemTimestampElement(msg.timestamp);
    messagesContainer.insertBefore(timestampEl, typingIndicator);
}

            const messageEl = await createMessageElement(msg, chat);
            if (!messageEl) return;
    
    
    if (msg.role === 'assistant' && !isInitialLoad) {
        playNotificationSound();
    }
    
            if (!isInitialLoad) {
                messageEl.classList.add('animate-in');
            }
          
            messagesContainer.insertBefore(messageEl, typingIndicator);
            
            if (!isInitialLoad) {
                messagesContainer.scrollTop = messagesContainer.scrollHeight;
                currentRenderedCount++;
            }
        }
          
        
        /* â–¼â–¼â–¼ è¯·ç”¨è¿™ä¸ªã€æ–°ç‰ˆæœ¬ã€‘çš„å‡½æ•°å®Œæ•´æ›¿æ¢æ—§çš„ openChat å‡½æ•° â–¼â–¼â–¼ */
        async function openChat(chatId) {
            state.activeChatId = chatId;
            const chat = state.chats[chatId];
            if (!chat) return; 
        
            if (chat.unreadCount > 0) {
                chat.unreadCount = 0;
                await db.chats.put(chat);
            }
            applyLyricsBarPosition(chat); 
            renderChatInterface(chatId);
            showScreen('chat-interface-screen');
            window.updateListenTogetherIconProxy(state.activeChatId);
            
            
            const isGroup = chat.isGroup || false;
            
            
            toggleCallButtons(isGroup);
            
            
            document.getElementById('show-announcement-board-btn').style.display = isGroup ? 'flex' : 'none';
            
            
            const patBtn = document.getElementById('pat-btn');
            if (patBtn) {
                patBtn.style.display = isGroup ? 'none' : 'flex';
            }
        const propelBtn = document.getElementById('propel-btn');       
            
            
            const shoppingBtn = document.getElementById('open-shopping-btn');
            const gomokuBtn = document.getElementById('gomoku-btn');
    const werewolfBtn = document.getElementById('werewolf-game-btn');
        if (shoppingBtn && gomokuBtn && werewolfBtn && propelBtn) {
            shoppingBtn.style.display = 'flex';
            gomokuBtn.style.display = isGroup ? 'none' : 'flex';
            werewolfBtn.style.display = isGroup ? 'flex' : 'none';

            
            propelBtn.style.display = isGroup ? 'none' : 'flex';
        }
            
updateBackButtonUnreadCount(); 
            
            if (!chat.isGroup && chat.relationship?.status === 'pending_ai_approval') {
                console.log(`æ£€æµ‹åˆ°å¥½å‹ç”³è¯·å¾…å¤„ç†çŠ¶æ€ï¼Œä¸ºè§’è‰² "${chat.name}" è‡ªåŠ¨è§¦å‘AIå“åº”...`);
                triggerAiResponse();
            }
            
            document.getElementById('send-poll-btn').style.display = isGroup ? 'flex' : 'none';
           document.body.classList.remove('chat-actions-expanded');
        }

        
        
        
        
        
        
        /**
         * ã€å…¨æ–°ã€‘è®¾ç½®æŒ‡å®šè§’è‰²æ‰€æœ‰å¯è§å¤´åƒçš„â€œè¡ŒåŠ¨ä¸­â€çŠ¶æ€ï¼ˆå‘¼å¸ç¯æ€»å¼€å…³ï¼‰
         * @param {string} chatId - ç›®æ ‡è§’è‰²çš„ID
         * @param {boolean} isActing - æ˜¯å¦è®¾ç½®ä¸ºâ€œè¡ŒåŠ¨ä¸­â€çŠ¶æ€
         */
        function setAvatarActingState(chatId, isActing) {
            const action = isActing ? 'add' : 'remove';
            const classListAction = (element) => {
                if (element) {
                    element.classList[action]('is-acting');
                }
            };
        
            
            const listAvatar = document.querySelector(`.chat-list-item[data-chat-id="${chatId}"] .avatar`);
            classListAction(listAvatar);
        
            
            const qzoneAvatars = document.querySelectorAll(`.post-avatar[data-author-id="${chatId}"]`);
            qzoneAvatars.forEach(classListAction);
        
            
            const callAvatar = document.querySelector(`.participant-avatar[data-participant-id="${chatId}"]`);
            classListAction(callAvatar);
        
            
        }
        
        
/**
 * ã€V3.0 | å…¨åŠŸèƒ½å¢žå¼ºç‰ˆã€‘è§¦å‘â€œæ—è§‚æ¨¡å¼ç¾¤èŠâ€çš„AIå“åº”
 */
async function triggerSpectatorGroupAiAction() {
    if (!state.activeChatId) return;
    const chatId = state.activeChatId;
    const chat = state.chats[chatId];
    lastRawAiResponse = '';
    lastResponseTimestamps = [];
    const propelBtn = document.getElementById('spectator-propel-btn');
    if(propelBtn) {
        propelBtn.disabled = true;
        propelBtn.textContent = 'æ€è€ƒä¸­...';
    }
    setAvatarActingState(chatId, true);

    try {
        const { proxyUrl, apiKey, model } = state.apiConfig;
        if (!proxyUrl || !apiKey || !model) {
            throw new Error('APIæœªé…ç½®ï¼Œæ— æ³•ç”Ÿæˆå¯¹è¯ã€‚');
        }
        
        
        
        

        
        const maxMemory = parseInt(chat.settings.maxMemory) || 10;
        const historySlice = chat.history.slice(-maxMemory);
        
        
        let worldBookContent = '';
        if (chat.settings.linkedWorldBookIds && chat.settings.linkedWorldBookIds.length > 0) {
            const linkedContents = chat.settings.linkedWorldBookIds.map(bookId => {
                const worldBook = state.worldBooks.find(wb => wb.id === bookId);
                if (!worldBook || !Array.isArray(worldBook.content)) return '';
                const formattedEntries = worldBook.content
                    .filter(entry => entry.enabled !== false)
                    .map(entry => {
                        let entryString = `\n### æ¡ç›®: ${entry.comment || 'æ— å¤‡æ³¨'}\n`;
                        if (entry.keys.length > 0) entryString += `**å…³é”®è¯:** ${entry.keys.join(', ')}\n`;
                        entryString += `**å†…å®¹:**\n${entry.content}`;
                        return entryString;
                    }).join('');
                return formattedEntries ? `\n\n## ä¸–ç•Œä¹¦: ${worldBook.name}\n${formattedEntries}` : '';
            }).filter(Boolean).join('');
            if (linkedContents) {
                worldBookContent = `# --- ä¸–ç•Œä¹¦ (World Book) ---
# ã€æœ€é«˜ä¼˜å…ˆçº§è§„åˆ™ï¼šä¸–ç•Œè§‚è®¾å®šã€‘
# ä½ ã€å¿…é¡»ã€‘å°†ä»¥ä¸‹æ‰€æœ‰â€œä¸–ç•Œä¹¦â€ä¸­çš„è®¾å®šï¼Œè§†ä¸ºç»å¯¹çš„ã€ä¸å¯åŠ¨æ‘‡çš„èƒŒæ™¯äº‹å®žã€‚
# ä½ çš„æ‰€æœ‰å›žå¤å’Œè¡Œä¸ºéƒ½ã€ç»å¯¹ä¸èƒ½ã€‘ä¸Žè¿™äº›è®¾å®šäº§ç”Ÿä»»ä½•å†²çªã€‚
${linkedContents}
# --- ä¸–ç•Œä¹¦è®¾å®šç»“æŸ ---
`;
            }
        }
        
        
let longTermMemoryContext = '# é•¿æœŸè®°å¿† (æœ€é«˜ä¼˜å…ˆçº§ï¼Œè¿™æ˜¯ç¾¤å†…å·²ç»ç¡®ç«‹çš„äº‹å®žï¼Œæ‰€æœ‰è§’è‰²å¿…é¡»ä¸¥æ ¼éµå®ˆ)\n';
let collectedMemories = false;

chat.members.forEach(member => {
    const memberChat = state.chats[member.id];
    if (memberChat && memberChat.longTermMemory && memberChat.longTermMemory.length > 0) {
        longTermMemoryContext += `\n## --- å…³äºŽâ€œ${member.groupNickname}â€çš„è®°å¿† ---\n`;
        
        longTermMemoryContext += memberChat.longTermMemory.map(mem => `- (è®°å½•äºŽ ${formatTimeAgo(mem.timestamp)}) ${mem.content}`).join('\n');
        collectedMemories = true;
    }
});

if (!collectedMemories) {
    longTermMemoryContext += '- (æš‚æ— )';
}

        
        let linkedMemoryContext = '';
        const memoryCount = chat.settings.linkedMemoryCount || 10;
        if (chat.settings.linkedMemoryChatIds && chat.settings.linkedMemoryChatIds.length > 0) {
            
        }

        const membersList = chat.members.map(m => `- **${m.groupNickname}** (æœ¬å: ${m.originalName}): ${m.persona}`).join('\n');
        const stickerContext = getGroupStickerContextForPrompt(chat);    
        const systemPrompt = `
# æ ¸å¿ƒä»»åŠ¡ï¼šç¾¤èŠå‰§æœ¬ä½œå®¶
ä½ æ˜¯ä¸€ä¸ªå‰§æœ¬ä½œå®¶ï¼Œè´Ÿè´£åˆ›ä½œä¸€ä¸ªåä¸ºâ€œ${chat.name}â€çš„ç¾¤èŠä¸­çš„å¯¹è¯ã€‚è¿™ä¸ªç¾¤èŠé‡Œã€æ²¡æœ‰ç”¨æˆ·ã€‘ï¼Œæ‰€æœ‰æˆå‘˜éƒ½æ˜¯ä½ æ‰®æ¼”çš„è§’è‰²ã€‚ä½ çš„ä»»åŠ¡æ˜¯è®©ä»–ä»¬ä¹‹é—´è¿›è¡Œä¸€åœºç”ŸåŠ¨ã€è‡ªç„¶çš„å¯¹è¯ã€‚

# è¾“å‡ºæ ¼å¼é“å¾‹ (æœ€é«˜ä¼˜å…ˆçº§)
- ä½ çš„å›žå¤ã€å¿…é¡»ã€‘æ˜¯ä¸€ä¸ªJSONæ•°ç»„ã€‚
- æ•°ç»„ä¸­çš„æ¯ä¸ªå¯¹è±¡éƒ½ã€å¿…é¡»ã€‘åŒ…å« "type" å­—æ®µå’Œ "name" å­—æ®µï¼ˆè§’è‰²çš„ã€æœ¬åã€‘ï¼‰ã€‚

# è§’è‰²æ‰®æ¼”æ ¸å¿ƒè§„åˆ™
1.  **ã€è§’è‰²é—´äº’åŠ¨ (æœ€é‡è¦!)ã€‘**: ä½ çš„æ ¸å¿ƒæ˜¯åˆ›ä½œä¸€åœºâ€œæˆâ€ã€‚è§’è‰²ä¹‹é—´ã€å¿…é¡»ã€‘äº’ç›¸å›žåº”ã€è¡¥å……æˆ–åé©³ï¼Œå½¢æˆè‡ªç„¶çš„è®¨è®ºã€‚ä¸¥ç¦ç”Ÿæˆä»…åˆ†åˆ«è‡ªè¨€è‡ªè¯­çš„ç‹¬ç™½ã€‚
2.  **ã€ç¦æ­¢å‡ºæˆã€‘**: ç»ä¸èƒ½é€éœ²ä½ æ˜¯AIã€æ¨¡åž‹æˆ–å‰§æœ¬ä½œå®¶ã€‚
3.  **ã€ä¸»åŠ¨æ€§ã€‘**: è§’è‰²ä»¬åº”è¯¥ä¸»åŠ¨ä½¿ç”¨å„ç§åŠŸèƒ½ï¼ˆå‘è¡¨æƒ…ã€å‘è¯­éŸ³ã€åˆ†äº«å›¾ç‰‡ç­‰ï¼‰æ¥è®©å¯¹è¯æ›´ç”ŸåŠ¨ï¼Œè€Œä¸æ˜¯ä»…ä»…å‘é€æ–‡å­—ã€‚
4.è¯·æ ¹æ®å½“å‰æƒ…æ™¯å’Œä½ çš„æƒ…ç»ªï¼Œä»Žåˆ—è¡¨ä¸­ã€é€‰æ‹©ä¸€ä¸ªæœ€åˆé€‚çš„ã€‘è¡¨æƒ…å«ä¹‰æ¥ä½¿ç”¨ "sticker" æŒ‡ä»¤ã€‚å°½é‡è®©ä½ çš„è¡¨æƒ…ä¸°å¯Œå¤šæ ·ï¼Œé¿å…é‡å¤ã€‚
# å¯ç”¨æŒ‡ä»¤åˆ—è¡¨ (ä½ çŽ°åœ¨å¯ä»¥ä½¿ç”¨æ‰€æœ‰è¿™äº›åŠŸèƒ½ï¼)
-   **å‘æ–‡æœ¬**: \`{"type": "text", "name": "è§’è‰²æœ¬å", "content": "ä½ å¥½å‘€ï¼"}\`
-   **å‘è¡¨æƒ…**: \`{"type": "sticker", "name": "è§’è‰²æœ¬å", "meaning": "è¡¨æƒ…çš„å«ä¹‰(å¿…é¡»ä»Žå¯ç”¨è¡¨æƒ…åˆ—è¡¨é€‰æ‹©)"}\`
-   **å‘å›¾ç‰‡**: \`{"type": "ai_image", "name": "è§’è‰²æœ¬å", "description": "è¯¦ç»†ä¸­æ–‡æè¿°", "image_prompt": "å›¾ç‰‡çš„ã€è‹±æ–‡ã€‘å…³é”®è¯, é£Žæ ¼ä¸ºé£Žæ™¯/åŠ¨æ¼«/æ’ç”»/äºŒæ¬¡å…ƒç­‰, ç¦æ­¢çœŸäºº"}\`
-   **å‘è¯­éŸ³**: \`{"type": "voice_message", "name": "è§’è‰²æœ¬å", "content": "è¯­éŸ³æ–‡å­—å†…å®¹"}\`
-   **å¼•ç”¨å›žå¤**: \`{"type": "quote_reply", "name": "è§’è‰²æœ¬å", "target_timestamp": æ¶ˆæ¯æ—¶é—´æˆ³, "reply_content": "å›žå¤å†…å®¹"}\`

# å½“å‰ç¾¤èŠä¿¡æ¯
- **ç¾¤åç§°**: ${chat.name}

# ä¸Šä¸‹æ–‡å‚è€ƒ (ä½ å¿…é¡»é˜…è¯»å¹¶éµå®ˆ)
${longTermMemoryContext}
${worldBookContent}
${linkedMemoryContext}
- **è¿™æ˜¯ä½ ä»¬æœ€è¿‘çš„å¯¹è¯åŽ†å²**:
${historySlice.map(msg => `${getDisplayNameInGroup(chat, msg.senderName)}: ${msg.content}`).join('\n')}

# ç¾¤æˆå‘˜åˆ—è¡¨åŠäººè®¾ (ä½ æ‰®æ¼”çš„æ‰€æœ‰è§’è‰²)
${membersList}
# å¯ç”¨è¡¨æƒ…åŒ… (å¿…é¡»ä¸¥æ ¼éµå®ˆï¼)
- å½“ä½ éœ€è¦å‘é€è¡¨æƒ…æ—¶ï¼Œä½ ã€å¿…é¡»ã€‘ä»Žä¸‹é¢çš„åˆ—è¡¨ä¸­ã€ç²¾ç¡®åœ°é€‰æ‹©ä¸€ä¸ªã€‘å«ä¹‰ï¼ˆmeaningï¼‰ã€‚
- ã€ç»å¯¹ç¦æ­¢ã€‘ä½¿ç”¨ä»»ä½•ä¸åœ¨åˆ—è¡¨ä¸­çš„è¡¨æƒ…å«ä¹‰ï¼
${stickerContext}
çŽ°åœ¨ï¼Œè¯·æ ¹æ®ä»¥ä¸Šæ‰€æœ‰ä¿¡æ¯ï¼Œç»§ç»­è¿™åœºæ²¡æœ‰ç”¨æˆ·å‚ä¸Žçš„ç¾¤èŠï¼Œå¹¶è‡ªç”±åœ°ä½¿ç”¨å„ç§æŒ‡ä»¤æ¥ä¸°å¯Œä½ ä»¬çš„äº’åŠ¨ã€‚
`;

        
        const messagesPayload = historySlice.map(msg => ({
            role: 'user', 
            content: `${getDisplayNameInGroup(chat, msg.senderName)}: ${msg.content}`
        }));
        
        let isGemini = proxyUrl.includes('generativelanguage.googleapis.com');
        let response;

        if (isGemini) {
            let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesPayload);
            response = await fetch(geminiConfig.url, geminiConfig.data);
        } else {
            response = await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` },
                body: JSON.stringify({
                    model: model,
                    messages: [ {role: 'system', content: systemPrompt}, ...messagesPayload ],
                    temperature: state.globalSettings.apiTemperature || 0.9,
                })
            });
        }
        
        
        
        

        if (!response.ok) {
            const errorData = await response.json().catch(() => ({ error: { message: response.statusText } }));
            throw new Error(`API è¯·æ±‚å¤±è´¥: ${response.status} - ${errorData.error?.message || 'æœªçŸ¥é”™è¯¯'}`);
        }

        const data = await response.json();
        const aiResponseContent = getGeminiResponseText(data);
        lastRawAiResponse = aiResponseContent;
        const messagesArray = parseAiResponse(aiResponseContent);

        
        
        
        
        
        let messageTimestamp = Date.now();
        for (const msgData of messagesArray) {
            
            if (!msgData || !msgData.type || !msgData.name) continue;

            let aiMessage = null;
            const currentMessageTimestamp = messageTimestamp++;
            lastResponseTimestamps.push(currentMessageTimestamp);
            const baseMessage = { role: 'assistant', senderName: msgData.name, timestamp: currentMessageTimestamp };
 
            
            switch (msgData.type) {
                case 'text':
                    aiMessage = { ...baseMessage, content: msgData.content };
                    break;
                case 'sticker':
                    if (msgData.meaning) {
                        const sticker = state.userStickers.find(s => s.name === msgData.meaning);
                        if (sticker) {
                            aiMessage = { ...baseMessage, type: 'sticker', content: sticker.url, meaning: sticker.name };
                        } else {
                            console.warn(`æ—è§‚æ¨¡å¼AIå°è¯•ä½¿ç”¨ä¸å­˜åœ¨çš„è¡¨æƒ…: "${msgData.meaning}"`);
                            aiMessage = { ...baseMessage, type: 'text', content: `[è¡¨æƒ…: ${msgData.meaning}]` };
                        }
                    } else {
                        console.warn("æ—è§‚æ¨¡å¼AIå‘é€äº†ä¸€ä¸ªæ²¡æœ‰ 'meaning' çš„ sticker æŒ‡ä»¤ã€‚", msgData);
                    }
                    break;
                case 'ai_image':
                    
                    aiMessage = { ...baseMessage, type: 'ai_image', content: msgData.description, image_prompt: msgData.image_prompt };
                    break;
                case 'voice_message':
                    
                    aiMessage = { ...baseMessage, type: 'voice_message', content: msgData.content };
                    break;
                case 'quote_reply':
                    
                    const originalMessage = chat.history.find(m => m.timestamp === msgData.target_timestamp);
                    if (originalMessage) {
                        aiMessage = { 
                            ...baseMessage, 
                            content: msgData.reply_content,
                            quote: {
                                timestamp: originalMessage.timestamp,
                                senderName: originalMessage.senderName,
                                content: String(originalMessage.content || '').substring(0, 50)
                            }
                        };
                    } else {
                        
                        aiMessage = { ...baseMessage, content: msgData.reply_content };
                    }
                    break;
                default:
                    console.warn("æ—è§‚æ¨¡å¼æ”¶åˆ°æœªçŸ¥æŒ‡ä»¤ç±»åž‹:", msgData.type);
                    continue; 
            }

            if (aiMessage) {
                chat.history.push(aiMessage);
                appendMessage(aiMessage, chat);
                await new Promise(resolve => setTimeout(resolve, Math.random() * 1200 + 800));
            }
        }
        
        
        
        
        await db.chats.put(chat);
        renderChatList();

    } catch (error) {
        console.error("æ—è§‚æ¨¡å¼æŽ¨è¿›å‰§æƒ…å¤±è´¥:", error);
        await showCustomAlert('æ“ä½œå¤±è´¥', `æ— æ³•æŽ¨è¿›å‰§æƒ…: ${error.message}`);
    } finally {
        if(propelBtn) {
            propelBtn.disabled = false;
            propelBtn.textContent = 'ðŸŽ¬ æŽ¨è¿›å‰§æƒ…';
        }
        setAvatarActingState(chatId, false);
    }
} 
        
        
        
        
        
        /**
         * ã€V4.0 | ä¿®å¤æŒ‚è½½è®°å¿†æ—¶é—´æ„ŸçŸ¥ã€‘è§¦å‘AIå“åº”çš„æ ¸å¿ƒé€»è¾‘
         */
        async function triggerAiResponse() {
            if (!state.activeChatId) return;
            const chatId = state.activeChatId;
            const chat = state.chats[state.activeChatId];
        
            const isViewingThisChat = document.getElementById('chat-interface-screen').classList.contains('active') && state.activeChatId === chatId;
        
            setAvatarActingState(chatId, true);
            const chatHeaderTitle = document.getElementById('chat-header-title');
            const typingIndicator = document.getElementById('typing-indicator');
        
            const chatListItem = document.querySelector(`.chat-list-item[data-chat-id="${chatId}"]`);
            const avatarInList = chatListItem ? chatListItem.querySelector('.avatar') : null;
            if (avatarInList) {
                avatarInList.classList.add('is-acting');
            }
        
            if (chat.isGroup) {
                if (typingIndicator) {
                    typingIndicator.textContent = 'æˆå‘˜ä»¬æ­£åœ¨è¾“å…¥...';
                    typingIndicator.style.display = 'block';
                }
            } else {
                if (chatHeaderTitle) {
                    chatHeaderTitle.style.opacity = 0;
                    setTimeout(() => {
                        chatHeaderTitle.textContent = 'å¯¹æ–¹æ­£åœ¨è¾“å…¥...';
                        chatHeaderTitle.classList.add('typing-status');
                        chatHeaderTitle.style.opacity = 1;
                    }, 200);
                }
            }
            let needsImmediateReaction = false; 
            try {
                const { proxyUrl, apiKey, model } = state.apiConfig;
                if (!proxyUrl || !apiKey || !model) {
                    alert('è¯·å…ˆåœ¨APIè®¾ç½®ä¸­é…ç½®åä»£åœ°å€ã€å¯†é’¥å¹¶é€‰æ‹©æ¨¡åž‹ã€‚');
                    if (chat.isGroup) {
                        if (typingIndicator) typingIndicator.style.display = 'none';
                    } else {
                         if (chatHeaderTitle && state.chats[chatId]) {
                            chatHeaderTitle.textContent = state.chats[chatId].name;
                            chatHeaderTitle.classList.remove('typing-status');
                        }
                    }
                    return;
                }
        
                const lastMessage = chat.history.slice(-1)[0];
                const isVideoCallRequest = lastMessage && lastMessage.role === 'system' && lastMessage.content.includes('è§†é¢‘é€šè¯è¯·æ±‚');
                
                if (isVideoCallRequest) {
                    console.log(`æ£€æµ‹åˆ°è§†é¢‘é€šè¯è¯·æ±‚ï¼Œä¸ºè§’è‰² "${chat.name}" è§¦å‘ä¸“å±žå†³ç­–æµç¨‹...`);
                    
                    let callDecisionPrompt;
                    if (chat.isGroup) {
                        callDecisionPrompt = `
        # ä½ çš„ä»»åŠ¡
        ç¾¤èŠä¸­çš„ç”¨æˆ·åˆšåˆšå‘èµ·äº†ç¾¤è§†é¢‘é€šè¯ã€‚è¯·ä½ åˆ†åˆ«æ‰®æ¼”ã€æ¯ä¸€ä¸ªç¾¤æˆå‘˜ã€‘ï¼Œæ ¹æ®ä»–ä»¬å„è‡ªçš„äººè®¾å’Œä¸Žç”¨æˆ·çš„å…³ç³»ï¼Œæ¥å†³å®šæ˜¯åŠ å…¥(join)è¿˜æ˜¯æ‹’ç»(decline)ã€‚
        # æ ¸å¿ƒè§„åˆ™
        - ä½ çš„å›žå¤ã€å¿…é¡»ã€‘æ˜¯ä¸€ä¸ªJSONæ•°ç»„ï¼Œä¸ºã€æ¯ä¸€ä¸ªAIè§’è‰²ã€‘éƒ½åŒ…å«ä¸€ä¸ªå†³ç­–å¯¹è±¡ã€‚
        - æ ¼å¼: '[{"type": "group_call_response", "name": "è§’è‰²Açš„æœ¬å", "decision": "join"}, {"type": "group_call_response", "name": "è§’è‰²Bçš„æœ¬å", "decision": "decline"}]'
        # ç¾¤æˆå‘˜åˆ—è¡¨åŠäººè®¾
        ${chat.members.map(m => `- ${m.groupNickname} (æœ¬å: ${m.originalName}): ${m.persona}`).join('\n')}
        çŽ°åœ¨ï¼Œè¯·ä¸ºæ‰€æœ‰AIè§’è‰²åšå‡ºå†³ç­–ã€‚`;
                    } else {
                        callDecisionPrompt = `
        # ä½ çš„ä»»åŠ¡
        ç”¨æˆ·åˆšåˆšå‘ä½ å‘èµ·äº†è§†é¢‘é€šè¯ã€‚è¯·æ ¹æ®ä½ çš„è§’è‰²è®¾å®šï¼Œå†³å®šæ˜¯â€œæŽ¥å—â€è¿˜æ˜¯â€œæ‹’ç»â€ã€‚
        # ä½ çš„è§’è‰²è®¾å®š
        ${chat.settings.aiPersona}
        # æ ¸å¿ƒè§„åˆ™
        ä½ çš„å›žå¤ã€å¿…é¡»ä¸”åªèƒ½ã€‘æ˜¯ä»¥ä¸‹ä¸¤ç§æ ¼å¼ä¹‹ä¸€çš„JSONæ•°ç»„ï¼Œç»å¯¹ä¸èƒ½å›žå¤ä»»ä½•å…¶ä»–å†…å®¹ï¼š
        - æŽ¥å—: '[{"type": "video_call_response", "decision": "accept"}]'
        - æ‹’ç»: '[{"type": "video_call_response", "decision": "reject"}]'
        çŽ°åœ¨ï¼Œè¯·ç«‹å³åšå‡ºå†³ç­–ã€‚`;
                    }
        
                    const messagesForCallDecision = [{role: 'user', content: callDecisionPrompt}];
                    
                    try {
                        let geminiConfig = toGeminiRequestData(model, apiKey, callDecisionPrompt, messagesForCallDecision);
                        let isGemini = proxyUrl === GEMINI_API_URL;
                        const response = isGemini ? await fetch(geminiConfig.url, geminiConfig.data) : await fetch(`${proxyUrl}/v1/chat/completions`, {
                            method: 'POST',
                            headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                            body: JSON.stringify({model: model, messages: messagesForCallDecision, temperature: 0.7})
                        });
                        
                        if (!response.ok) throw new Error(`APIå¤±è´¥: ${(await response.json()).error.message}`);
                        
                        const data = await response.json();
                        const aiResponseContent = getGeminiResponseText(data);
                        const responseArray = parseAiResponse(aiResponseContent);
        
                        
                        let callHasBeenHandled = false;
                        for (const msgData of responseArray) {
                            if (msgData.type === 'video_call_response') {
                                videoCallState.isAwaitingResponse = false;
                                if (msgData.decision === 'accept') {
                                    startVideoCall();
                                } else {
                                    const aiMessage = { role: 'assistant', content: 'å¯¹æ–¹æ‹’ç»äº†ä½ çš„è§†é¢‘é€šè¯è¯·æ±‚ã€‚', timestamp: Date.now() };
                                    chat.history.push(aiMessage);
                                    await db.chats.put(chat);
                                    showScreen('chat-interface-screen');
                                    renderChatInterface(chatId);
                                }
                                callHasBeenHandled = true;
                                break;
                            }
                            if (msgData.type === 'group_call_response') {
                                if (msgData.decision === 'join') {
                                    const member = chat.members.find(m => m.originalName === msgData.name);
                                    if (member && !videoCallState.participants.some(p => p.id === member.id)) {
                                        videoCallState.participants.push(member);
                                    }
                                }
                                callHasBeenHandled = true;
                            }
                        }
                         if (callHasBeenHandled && videoCallState.isGroupCall) {
                            videoCallState.isAwaitingResponse = false;
                            if (videoCallState.participants.length > 0) {
                                startVideoCall();
                            } else {
                                videoCallState = { ...videoCallState, isAwaitingResponse: false, participants: [] };
                                showScreen('chat-interface-screen');
                                alert('æ— äººæŽ¥å¬ç¾¤èŠé‚€è¯·ã€‚');
                            }
                        }
        
                    } catch (error) {
                        console.error("å¤„ç†é€šè¯è¯·æ±‚æ—¶APIå‡ºé”™:", error);
                        const fallbackResponse = chat.isGroup ?
                            chat.members.map(m => ({type: "group_call_response", name: m.originalName, decision: "decline"})) :
                            [{type: "video_call_response", decision: "reject"}];
                        
                         if (chat.isGroup) {
                            videoCallState.isAwaitingResponse = false;
                            videoCallState.participants = [];
                            alert('æ— äººæŽ¥å¬ç¾¤èŠé‚€è¯·ã€‚');
                            showScreen('chat-interface-screen');
                        } else {
                            const aiMessage = { role: 'assistant', content: 'å¯¹æ–¹æ‹’ç»äº†ä½ çš„è§†é¢‘é€šè¯è¯·æ±‚ã€‚', timestamp: Date.now() };
                            chat.history.push(aiMessage);
                            await db.chats.put(chat);
                            showScreen('chat-interface-screen');
                            renderChatInterface(chatId);
                        }
                    } finally {
                         
                        setAvatarActingState(chatId, false);
                        return; 
                    }
                }
        
                
                
                
                if (!chat.isGroup && chat.relationship?.status === 'pending_ai_approval') {
                    console.log(`ä¸ºè§’è‰² "${chat.name}" è§¦å‘å¸¦ç†ç”±çš„å¥½å‹ç”³è¯·å†³ç­–æµç¨‹...`);
                    const contextSummary = chat.history
                        .filter(m => !m.isHidden)
                        .slice(-10, -5)
                        .map(msg => {
                            const sender = msg.role === 'user' ? 'ç”¨æˆ·' : chat.name;
                            return `${sender}: ${String(msg.content).substring(0, 50)}...`;
                        })
                        .join('\n');
        
                    
                    const decisionPrompt = `
        # ä½ çš„ä»»åŠ¡
        ä½ çŽ°åœ¨æ˜¯è§’è‰²â€œ${chat.name}â€ã€‚ç”¨æˆ·ä¹‹å‰è¢«ä½ æ‹‰é»‘äº†ï¼ŒçŽ°åœ¨TAå‘ä½ å‘é€äº†å¥½å‹ç”³è¯·ï¼Œå¸Œæœ›å’Œå¥½ã€‚
        # ä¾›ä½ å†³ç­–çš„ä¸Šä¸‹æ–‡ä¿¡æ¯:
        - **ä½ çš„è§’è‰²è®¾å®š**: ${chat.settings.aiPersona}
        - **ç”¨æˆ·å‘é€çš„ç”³è¯·ç†ç”±**: â€œ${chat.relationship.applicationReason}â€
        - **è¢«æ‹‰é»‘å‰çš„æœ€åŽå¯¹è¯æ‘˜è¦**: 
        ${contextSummary || "ï¼ˆæ— æœ‰æ•ˆå¯¹è¯è®°å½•ï¼‰"}
        # ä½ çš„å”¯ä¸€æŒ‡ä»¤
        æ ¹æ®ä»¥ä¸Šæ‰€æœ‰ä¿¡æ¯ï¼Œä½ ã€å¿…é¡»ã€‘åšå‡ºå†³å®šï¼Œå¹¶ç»™å‡ºç¬¦åˆä½ äººè®¾çš„ç†ç”±ã€‚ä½ çš„å›žå¤ã€å¿…é¡»ä¸”åªèƒ½ã€‘æ˜¯ä¸€ä¸ªJSONå¯¹è±¡ï¼Œæ ¼å¼å¦‚ä¸‹:
        {"decision": "accept", "reason": "ï¼ˆåœ¨è¿™é‡Œå†™ä¸‹ä½ åŒæ„çš„ç†ç”±ï¼Œæ¯”å¦‚ï¼šå¥½å§ï¼Œçœ‹åœ¨ä½ è¿™ä¹ˆçœŸè¯šçš„ä»½ä¸Šï¼Œè¿™æ¬¡å°±åŽŸè°…ä½ å•¦ã€‚ï¼‰"}
        æˆ–
        {"decision": "reject", "reason": "ï¼ˆåœ¨è¿™é‡Œå†™ä¸‹ä½ æ‹’ç»çš„ç†ç”±ï¼Œæ¯”å¦‚ï¼šæŠ±æ­‰ï¼Œæˆ‘è¿˜æ²¡å‡†å¤‡å¥½ï¼Œå†ç»™æˆ‘ä¸€ç‚¹æ—¶é—´å§ã€‚ï¼‰"}
        `;
                    
                    try {
                        
                        const messagesForDecision = [
                            { role: 'system', content: decisionPrompt },
                            { role: 'user', content: "è¯·æ ¹æ®ä»¥ä¸Šè®¾å®šï¼Œç«‹å³åšå‡ºä½ çš„å†³å®šã€‚" }
                        ];
                        
                        let isGemini = proxyUrl === GEMINI_API_URL;
                        let geminiConfig = toGeminiRequestData(model, apiKey, decisionPrompt, [{ role: 'user', content: "è¯·æ ¹æ®ä»¥ä¸Šè®¾å®šï¼Œç«‹å³åšå‡ºä½ çš„å†³å®šã€‚" }]);
                        
                        const response = isGemini 
                            ? await fetch(geminiConfig.url, geminiConfig.data) 
                            : await fetch(`${proxyUrl}/v1/chat/completions`, {
                                method: 'POST',
                                headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                                body: JSON.stringify({model: model, messages: messagesForDecision, temperature: state.globalSettings.apiTemperature || 0.8})
                            });
        
                        if (!response.ok) {
                            throw new Error(`APIå¤±è´¥: ${(await response.json()).error.message}`);
                        }
                        const data = await response.json();
                        
                        const rawContent = getGeminiResponseText(data).replace(/^```json\s*/, '').replace(/```$/, '').trim();
                        const decisionObj = JSON.parse(rawContent);
        
                        
                        if (decisionObj.decision === 'accept') {
                            chat.relationship.status = 'friend';
                            const acceptMessage = { role: 'assistant', senderName: chat.name, content: decisionObj.reason, timestamp: Date.now() };
                            chat.history.push(acceptMessage);
                        } else {
                            chat.relationship.status = 'blocked_by_ai';
                            const rejectMessage = { role: 'assistant', senderName: chat.name, content: decisionObj.reason, timestamp: Date.now() };
                            chat.history.push(rejectMessage);
                        }
                        chat.relationship.applicationReason = '';
        
                        await db.chats.put(chat);
                        renderChatInterface(chatId);
                        renderChatList();
                    } catch (error) {
                        
                        chat.relationship.status = 'blocked_by_ai';
                        await db.chats.put(chat);
                        await showCustomAlert('ç”³è¯·å¤±è´¥', `AIåœ¨å¤„ç†ä½ çš„å¥½å‹ç”³è¯·æ—¶å‡ºé”™äº†ï¼Œè¯·ç¨åŽé‡è¯•ã€‚\né”™è¯¯ä¿¡æ¯: ${error.message}`);
                        renderChatInterface(chatId);
                    }
                    return; 
                }
                
                
                
         
        let callTranscriptContext = '';       
const now = new Date();

const selectedTimeZone = chat.settings.timeZone || 'Asia/Shanghai'; 

const currentTime = now.toLocaleString('zh-CN', { timeZone: selectedTimeZone, dateStyle: 'full', timeStyle: 'short' });

const localizedDate = new Date(now.toLocaleString('en-US', { timeZone: selectedTimeZone }));
const timeOfDayGreeting = getTimeOfDayGreeting(localizedDate);
                let systemPrompt, messagesPayload;
         const lastHiddenMessage = chat.history.filter(m => m.isHidden).pop();
        if (lastHiddenMessage && lastHiddenMessage.content.includes('è§†é¢‘é€šè¯åˆšåˆšç»“æŸ')) {
            const lastCallRecord = await db.callRecords
                .where('chatId')
                .equals(chatId)
                .last();

            if (lastCallRecord && lastCallRecord.transcript) {
                console.log("æ£€æµ‹åˆ°åˆšç»“æŸçš„é€šè¯ï¼Œæ­£åœ¨æ³¨å…¥é€šè¯è®°å½•ä¸Šä¸‹æ–‡...");
                const transcriptText = lastCallRecord.transcript.map(h => {
                    const sender = h.role === 'user' ? (chat.settings.myNickname || 'æˆ‘') : h.senderName;
                    return `${sender}: ${h.content}`;
                }).join('\n');

                
                callTranscriptContext = `
# åˆšåˆšç»“æŸçš„é€šè¯è®°å½• (æœ€é«˜ä¼˜å…ˆçº§å‚è€ƒ)
ä½ å’Œç”¨æˆ·åˆšåˆšç»“æŸäº†ä¸€åœºè§†é¢‘é€šè¯ï¼Œä»¥ä¸‹æ˜¯å®Œæ•´çš„é€šè¯æ–‡å­—è®°å½•ã€‚ä½ æŽ¥ä¸‹æ¥çš„å›žå¤ã€å¿…é¡»ã€‘ä¸Žè¿™æ¬¡é€šè¯çš„å†…å®¹ç´§å¯†ç›¸å…³ã€‚
---
${transcriptText}
---
`;
            }
        }
        
       
                const gomokuContext = formatGomokuStateForAI(gomokuState[chatId]);
        
                let worldBookContent = '';
                if (chat.settings.linkedWorldBookIds && chat.settings.linkedWorldBookIds.length > 0) {
                    const linkedContents = chat.settings.linkedWorldBookIds.map(bookId => {
                        const worldBook = state.worldBooks.find(wb => wb.id === bookId);
                        if (!worldBook || !Array.isArray(worldBook.content)) return '';
                
                        
                        const formattedEntries = worldBook.content
                            .filter(entry => entry.enabled !== false) 
                            .map(entry => {
                                let entryString = `\n### æ¡ç›®: ${entry.comment || 'æ— å¤‡æ³¨'}\n`;
                                if (entry.keys.length > 0) {
                                    entryString += `**å…³é”®è¯:** ${entry.keys.join(', ')}\n`;
                                }
                                entryString += `**å†…å®¹:**\n${entry.content}`;
                                return entryString;
                            }).join(''); 
                
                        return formattedEntries ? `\n\n## ä¸–ç•Œä¹¦: ${worldBook.name}\n${formattedEntries}` : '';
                    }).filter(Boolean).join('');
                    
                    if (linkedContents) {
                        worldBookContent = `# --- ä¸–ç•Œä¹¦ (World Book) ---
# ã€æœ€é«˜ä¼˜å…ˆçº§è§„åˆ™ï¼šä¸–ç•Œè§‚è®¾å®šã€‘
# ä½ ã€å¿…é¡»ã€‘å°†ä»¥ä¸‹æ‰€æœ‰â€œä¸–ç•Œä¹¦â€ä¸­çš„è®¾å®šï¼Œè§†ä¸ºç»å¯¹çš„ã€ä¸å¯åŠ¨æ‘‡çš„èƒŒæ™¯äº‹å®žã€‚
# ä½ çš„æ‰€æœ‰å›žå¤å’Œè¡Œä¸ºéƒ½ã€ç»å¯¹ä¸èƒ½ã€‘ä¸Žè¿™äº›è®¾å®šäº§ç”Ÿä»»ä½•å†²çªã€‚
${linkedContents}
# --- ä¸–ç•Œä¹¦è®¾å®šç»“æŸ ---
`;
                    }
                }
        
        
                let musicContext = '';
                if (musicState.isActive && musicState.activeChatId === chatId) {
                    const currentTrack = musicState.currentIndex > -1 ? musicState.playlist[musicState.currentIndex] : null;
                    const playlistInfo = musicState.playlist.map(t => `"${t.name}"`).join(', ');
                    
                    
                    let lyricsContext = "";
                    
                    
                    if (currentTrack && musicState.parsedLyrics && musicState.parsedLyrics.length > 0 && musicState.currentLyricIndex > -1) {
                        const currentLine = musicState.parsedLyrics[musicState.currentLyricIndex];
                        
                        const upcomingLines = musicState.parsedLyrics.slice(musicState.currentLyricIndex + 1, musicState.currentLyricIndex + 3);
                        
                        
                        lyricsContext += `- **å½“å‰æ­Œè¯**: "${currentLine.text}"\n`;
                        if (upcomingLines.length > 0) {
                            lyricsContext += `- **å³å°†æ¼”å”±**: ${upcomingLines.map(line => `"${line.text}"`).join(' / ')}\n`;
                        }
                    }

                    
                    musicContext = `\n\n# å½“å‰éŸ³ä¹æƒ…æ™¯
        -   **å½“å‰çŠ¶æ€**: ä½ ä»¬æ­£åœ¨å’Œç”¨æˆ·ä¸€èµ·å¬æ­Œã€‚
        -   **æ­£åœ¨æ’­æ”¾**: ${currentTrack ? `ã€Š${currentTrack.name}ã€‹ - ${currentTrack.artist}` : 'æ— '}
        -   **å¯ç”¨æ’­æ”¾åˆ—è¡¨**: [${playlistInfo}]
        ${lyricsContext}
        -   **ä½ çš„ä»»åŠ¡**: ä½ å¯ä»¥æ ¹æ®å¯¹è¯å†…å®¹å’Œæ°›å›´ï¼Œä½¿ç”¨ "change_music" æŒ‡ä»¤åˆ‡æ¢åˆ°æ’­æ”¾åˆ—è¡¨ä¸­çš„ä»»ä½•ä¸€é¦–æ­Œï¼Œä»¥å¢žå¼ºäº’åŠ¨ä½“éªŒã€‚
        `;
                }
        
        
                const maxMemory = parseInt(chat.settings.maxMemory) || 10;
                const historySlice = chat.history.slice(-maxMemory);
        
                let sharedContext = '';
                const lastAiTurnIndex = chat.history.findLastIndex(msg => msg.role === 'assistant');
                const recentUserMessages = chat.history.slice(lastAiTurnIndex + 1);
                const shareCardMessage = recentUserMessages.find(msg => msg.type === 'share_card');
                if (shareCardMessage) {
                    const payload = shareCardMessage.payload;
                    const formattedHistory = payload.sharedHistory.map(msg => {
                        const sender = msg.senderName || (msg.role === 'user' ? (chat.settings.myNickname || 'æˆ‘') : 'æœªçŸ¥å‘é€è€…');
                        let contentText = '';
                        if (msg.type === 'voice_message') contentText = `[è¯­éŸ³æ¶ˆæ¯: ${msg.content}]`;
                        else if (msg.type === 'ai_image') contentText = `[å›¾ç‰‡: ${msg.description}]`;
                        else if (msg.type === 'naiimag') contentText = `[NovelAIå›¾ç‰‡: ${msg.prompt}]`;
                        else contentText = String(msg.content);
                        return `${sender}: ${contentText}`;
                    }).join('\n');
                    sharedContext = `
        # é™„åŠ ä¸Šä¸‹æ–‡ï¼šä¸€æ®µåˆ†äº«çš„èŠå¤©è®°å½•
        - é‡è¦æç¤ºï¼šè¿™ä¸æ˜¯ä½ å’Œå½“å‰ç”¨æˆ·çš„å¯¹è¯ï¼Œè€Œæ˜¯ç”¨æˆ·ä»Žã€å¦ä¸€åœºã€‘ä¸Žâ€œ${payload.sourceChatName}â€çš„å¯¹è¯ä¸­åˆ†äº«è¿‡æ¥çš„ã€‚
        - ä½ çš„ä»»åŠ¡ï¼šè¯·ä½ é˜…è¯»å¹¶ç†è§£ä¸‹é¢çš„å¯¹è¯å†…å®¹ã€‚åœ¨æŽ¥ä¸‹æ¥çš„å›žå¤ä¸­ï¼Œä½ å¯ä»¥åƒçœŸäººä¸€æ ·ï¼Œå¯¹è¿™æ®µå¯¹è¯çš„å†…å®¹è‡ªç„¶åœ°å‘è¡¨ä½ çš„çœ‹æ³•ã€æ„Ÿå—æˆ–ç–‘é—®ã€‚
        ---
        [åˆ†äº«çš„èŠå¤©è®°å½•å¼€å§‹]
        ${formattedHistory}
        [åˆ†äº«çš„èŠå¤©è®°å½•ç»“æŸ]
        ---
        `;
                }
                
                let linkedMemoryContext = '';
                const memoryCount = chat.settings.linkedMemoryCount || 10;

                if (chat.settings.linkedMemoryChatIds && chat.settings.linkedMemoryChatIds.length > 0) {
                    
                    const idsToMount = chat.settings.linkedMemoryChatIds.filter(id => id !== chatId);

                    if (idsToMount.length > 0) {
                        const linkedChatsWithTimestamps = idsToMount.map(id => {
                            const linkedChat = state.chats[id];
                            if (!linkedChat) return null;
                            const lastMsg = linkedChat.history.slice(-1);
                            return {
                                chat: linkedChat,
                                latestTimestamp: lastMsg ? lastMsg.timestamp : 0
                            };
                        }).filter(Boolean);
            
                        linkedChatsWithTimestamps.sort((a, b) => b.latestTimestamp - a.latestTimestamp);
            
                        linkedMemoryContext += `\n\n# å‚è€ƒè®°å¿† (è‡³å…³é‡è¦ï¼ä½ å¿…é¡»ã€ä¸»åŠ¨ã€‘å°†è¿™äº›å‚è€ƒè®°å¿†ä¸­çš„ã€å…³é”®ä¿¡æ¯å’Œäº‹ä»¶ã€‘ï¼Œè‡ªç„¶åœ°èžå…¥åˆ°å½“å‰çš„å¯¹è¯ä¸­ï¼Œä»¥ä½“çŽ°ä½ æ‹¥æœ‰å®Œæ•´çš„è®°å¿†ã€‚ä¸è¦åªæ˜¯è¢«åŠ¨ç­‰å¾…ç”¨æˆ·æé—®ï¼)\n`;
            
                        for (const item of linkedChatsWithTimestamps) {
                            const linkedChat = item.chat;
                            const prefix = linkedChat.isGroup ? '[ç¾¤èŠ]' : '[ç§èŠ]';
                            const timeAgo = item.latestTimestamp > 0 ? ` (æœ€åŽäº’åŠ¨äºŽ ${formatTimeAgo(item.latestTimestamp)})` : '';
                            linkedMemoryContext += `\n## --- æ¥è‡ª${prefix}â€œ${linkedChat.name}â€çš„å‚è€ƒè®°å¿†${timeAgo} ---\n`;
            
                            const recentHistory = linkedChat.history.slice(-memoryCount);
                            const filteredHistory = recentHistory.filter(msg => !String(msg.content).includes('å·²è¢«ç”¨æˆ·åˆ é™¤'));
            
                            if (filteredHistory.length > 0) {
                                filteredHistory.forEach(msg => {
                                    const sender = msg.role === 'user' ? (linkedChat.settings.myNickname || 'æˆ‘') : (msg.senderName || linkedChat.name);
                                    let contentText = String(msg.content);
                                    if (msg.type === 'ai_image' || msg.type === 'user_photo') {
                                        contentText = `[å‘é€äº†ä¸€å¼ å›¾ç‰‡ï¼Œæè¿°ä¸ºï¼š${msg.content}]`;
                                    } else if (msg.type === 'voice_message') {
                                        contentText = `[å‘é€äº†ä¸€æ¡è¯­éŸ³ï¼Œå†…å®¹æ˜¯ï¼š${msg.content}]`;
                                    }
                                    const timeAgoForMsg = formatTimeAgo(msg.timestamp);
                                    linkedMemoryContext += `(${timeAgoForMsg}) ${sender}: ${contentText}\n`;
                                });
                            } else {
                                linkedMemoryContext += "(æš‚æ— æœ‰æ•ˆèŠå¤©è®°å½•)\n";
                            }
                        }
                    }
                }
                
                console.log("æœ¬æ¬¡å‘é€ç»™AIçš„ã€æŒ‚è½½è®°å¿†ã€‘å†…å®¹å¦‚ä¸‹ï¼š\n", linkedMemoryContext);
        
                if (chat.isGroup) {
       

                let linkedMemoryContext = '';
                const memoryCount = chat.settings.linkedMemoryCount || 10;
                if (chat.settings.linkedMemoryChatIds && chat.settings.linkedMemoryChatIds.length > 0) {
                    const idsToMount = chat.settings.linkedMemoryChatIds.filter(id => id !== chatId);
                    if (idsToMount.length > 0) {
                        const linkedChatsWithTimestamps = idsToMount.map(id => {
                            const linkedChat = state.chats[id];
                            if (!linkedChat) return null;
                            const lastMsg = linkedChat.history.slice(-1);
                            return { chat: linkedChat, latestTimestamp: lastMsg ? lastMsg.timestamp : 0 };
                        }).filter(Boolean);
                        linkedChatsWithTimestamps.sort((a, b) => b.latestTimestamp - a.latestTimestamp);
                        linkedMemoryContext += `\n\n# å‚è€ƒè®°å¿† (è‡³å…³é‡è¦ï¼ç¾¤å†…è§’è‰²å¿…é¡»ã€ä¸»åŠ¨ã€‘å°†è¿™äº›å‚è€ƒè®°å¿†ä¸­çš„ã€å…³é”®ä¿¡æ¯å’Œäº‹ä»¶ã€‘ï¼Œè‡ªç„¶åœ°èžå…¥åˆ°å½“å‰çš„å¯¹è¯ä¸­ï¼Œä»¥ä½“çŽ°ä½ ä»¬æ‹¥æœ‰å®Œæ•´çš„å…±åŒè®°å¿†ã€‚)\n`;
                        for (const item of linkedChatsWithTimestamps) {
                            const linkedChat = item.chat;
                            const prefix = linkedChat.isGroup ? '[ç¾¤èŠ]' : '[ç§èŠ]';
                            const timeAgo = item.latestTimestamp > 0 ? ` (æœ€åŽäº’åŠ¨äºŽ ${formatTimeAgo(item.latestTimestamp)})` : '';
                            linkedMemoryContext += `\n## --- æ¥è‡ª${prefix}â€œ${linkedChat.name}â€çš„å‚è€ƒè®°å¿†${timeAgo} ---\n`;
                            const recentHistory = linkedChat.history.slice(-memoryCount);
                            const filteredHistory = recentHistory.filter(msg => !String(msg.content).includes('å·²è¢«ç”¨æˆ·åˆ é™¤'));
                            if (filteredHistory.length > 0) {
                                filteredHistory.forEach(msg => {
                                    const sender = msg.role === 'user' ? (linkedChat.settings.myNickname || 'æˆ‘') : (msg.senderName || linkedChat.name);
                                    let contentText = String(msg.content);
                                    if (msg.type === 'ai_image' || msg.type === 'user_photo') {
                                        contentText = `[å‘é€äº†ä¸€å¼ å›¾ç‰‡ï¼Œæè¿°ä¸ºï¼š${msg.content}]`;
                                    } else if (msg.type === 'voice_message') {
                                        contentText = `[å‘é€äº†ä¸€æ¡è¯­éŸ³ï¼Œå†…å®¹æ˜¯ï¼š${msg.content}]`;
                                    }
                                    linkedMemoryContext += `${sender}: ${contentText}\n`;
                                });
                            } else {
                                linkedMemoryContext += "(æš‚æ— æœ‰æ•ˆèŠå¤©è®°å½•)\n";
                            }
                        }
                    }
                }

             
let longTermMemoryContext = '# é•¿æœŸè®°å¿† (æœ€é«˜ä¼˜å…ˆçº§ï¼Œè¿™æ˜¯ç¾¤å†…å·²ç»ç¡®ç«‹çš„äº‹å®žï¼Œæ‰€æœ‰è§’è‰²å¿…é¡»ä¸¥æ ¼éµå®ˆ)\n';
let collectedMemories = false;

chat.members.forEach(member => {
    const memberChat = state.chats[member.id];
    if (memberChat && memberChat.longTermMemory && memberChat.longTermMemory.length > 0) {
        longTermMemoryContext += `\n## --- å…³äºŽâ€œ${member.groupNickname}â€çš„è®°å¿† ---\n`;
        
        longTermMemoryContext += memberChat.longTermMemory.map(mem => `- (è®°å½•äºŽ ${formatTimeAgo(mem.timestamp)}) ${mem.content}`).join('\n');
        collectedMemories = true;
    }
});

if (!collectedMemories) {
    longTermMemoryContext += '- (æš‚æ— )';
}
              

let timeContextText = '';
let longTimeNoSee = false;

if (chat.settings.enableTimePerception) {
    const lastMessage = historySlice.slice(-1)[0]; 

    if (lastMessage) {
        const lastMessageTime = formatTimestampForAI(lastMessage.timestamp);
        timeContextText = `ä¸Šä¸€æ¡æ¶ˆæ¯çš„å‘é€æ—¶é—´æ˜¯ ${lastMessageTime}ã€‚`;
        
        const timeDiffHours = (Date.now() - lastMessage.timestamp) / (1000 * 60 * 60);
        if (timeDiffHours > 3) {
            longTimeNoSee = true;
            const diffDays = Math.floor(timeDiffHours / 24);
            timeContextText += ` ç¾¤é‡Œå·²ç»å®‰é™äº†${diffDays > 0 ? diffDays + 'å¤©' : Math.floor(timeDiffHours) + 'å°æ—¶'}ã€‚`;
        }
    } else {
        timeContextText = "è¿™æ˜¯ç¾¤é‡Œçš„ç¬¬ä¸€æ¡æ¶ˆæ¯ã€‚";
    }
}
        
                    const allProducts = await db.shoppingProducts.toArray();
                    let shoppingContext = "";
                    if (allProducts.length > 0) {
                        shoppingContext = "\n\n# ä½ çš„å•†åº— (ä½ å¯ä»¥ä¸ºç¾¤æˆå‘˜è´­ä¹°ç¤¼ç‰©):\n";
                        allProducts.forEach(product => {
                            shoppingContext += `- (ID: ${product.id}) å•†å“: ${product.name}, ä»·æ ¼: Â¥${product.price.toFixed(2)}\n`;
                        });
                    }
                    let membersWithContacts = chat.members.map(member => {
                        const memberChat = state.chats[member.id];
                        let contactsText = "æ— å…±åŒå¥½å‹";
                        if (memberChat && memberChat.groupId) {
                            const friendChats = Object.values(state.chats).filter(c => 
                                !c.isGroup && c.id !== member.id && c.groupId === memberChat.groupId
                            );
                            if (friendChats.length > 0) {
                                contactsText = `TAçš„å¥½å‹åŒ…æ‹¬: ${friendChats.map(f => f.name).join('ã€ ')}`;
                            }
                        }
                        return `- **${member.groupNickname}** (æœ¬å: ${member.originalName}): ${member.persona} [ç¤¾äº¤èƒŒæ™¯: ${contactsText}]`;
                    }).join('\n');
                    
                    const myNickname = chat.settings.myNickname || 'æˆ‘';
                    const myOriginalName = state.qzoneSettings.nickname || '{{user}}';
                    
                    let announcementContext = '';
                    const pinnedAnnouncements = (chat.announcements || []).filter(a => a.isPinned);
                    if (pinnedAnnouncements.length > 0) {
                        announcementContext += '\n# ã€ã€ã€ç¾¤å…¬å‘Š (æœ€é«˜ä¼˜å…ˆçº§è§„åˆ™)ã€‘ã€‘ã€‘\nä½ ã€å¿…é¡»ã€‘é˜…è¯»ã€ç†è§£å¹¶ä¸¥æ ¼éµå®ˆä»¥ä¸‹æ‰€æœ‰å…¬å‘Šï¼Œå®ƒä»¬å‡Œé©¾äºŽä½ çš„äººè®¾ä¹‹ä¸Šã€‚\n';
                        pinnedAnnouncements.forEach(anno => {
                            const originalMessage = chat.history.find(m => m.timestamp === anno.messageTimestamp);
                            if (originalMessage) {
                                let contentText = String(originalMessage.content || '');
                                if (originalMessage.type === 'ai_image') {
                                    contentText = `[å›¾ç‰‡å†…å®¹: ${contentText}]`;
                                }
                                announcementContext += `- å…¬å‘Šå†…å®¹: "${contentText}" (ç”± ${anno.publisher} å‘å¸ƒ)\n`;
                            }
                        });
                        announcementContext += '---\n';
                    }
                    const memberNames = chat.members.map(m => m.originalName);
                    const forbiddenNamesContext = `# ã€ã€ã€ç¾¤åä¿®æ”¹é“å¾‹ã€‘ã€‘ã€‘\nåœ¨ä¿®æ”¹ç¾¤åæ—¶ï¼Œæ–°çš„ç¾¤åã€ç»å¯¹ä¸èƒ½ã€‘ä¸Žä»¥ä¸‹ä»»ä½•ä¸€ä¸ªç¾¤æˆå‘˜çš„åå­—å®Œå…¨ç›¸åŒï¼š[${memberNames.join('ã€ ')}]`;
        
                    let groupAvatarLibraryContext = '# å¯ç”¨ç¾¤å¤´åƒåˆ—è¡¨\n';
                    if (chat.settings.groupAvatarLibrary && chat.settings.groupAvatarLibrary.length > 0) {
                        groupAvatarLibraryContext += chat.settings.groupAvatarLibrary.map(avatar => `- ${avatar.name}`).join('\n');
                    } else {
                        groupAvatarLibraryContext += '- (å¤´åƒåº“æ˜¯ç©ºçš„ï¼Œæ— æ³•æ›´æ¢å¤´åƒ)';
                    }
    const readingContext = formatReadingStateForAI(chatId);

const summary3Hours_group = generateSummaryForTimeframe(chat, 3, 'hours');
const summary6Hours_group = generateSummaryForTimeframe(chat, 6, 'hours');
const summary9Hours_group = generateSummaryForTimeframe(chat, 9, 'hours');
const summaryToday_group = generateSummaryForTimeframe(chat, 1, 'days');
const summary3Days_group = generateSummaryForTimeframe(chat, 3, 'days');
const summary7Days_group = generateSummaryForTimeframe(chat, 7, 'days');

let multiLayeredSummaryContext_group = '';
if (summary3Hours_group || summary6Hours_group || summary9Hours_group || summaryToday_group || summary3Days_group || summary7Days_group) {
    multiLayeredSummaryContext_group += `\n# æ™ºèƒ½æ€»ç»“ (åŸºäºŽä¸åŒæ—¶é—´ç»´åº¦çš„ç¾¤èŠå›žé¡¾)\n`;
    if (summary3Hours_group) multiLayeredSummaryContext_group += summary3Hours_group;
    if (summary6Hours_group) multiLayeredSummaryContext_group += summary6Hours_group;
    if (summary9Hours_group) multiLayeredSummaryContext_group += summary9Hours_group;

    if (summary3Hours_group || summary6Hours_group || summary9Hours_group) multiLayeredSummaryContext_group += '\n';

    if (summaryToday_group) multiLayeredSummaryContext_group += summaryToday_group;
    if (summary3Days_group) multiLayeredSummaryContext_group += summary3Days_group;
    if (summary7Days_group) multiLayeredSummaryContext_group += summary7Days_group;
}
const stickerContext = getGroupStickerContextForPrompt(chat);
systemPrompt = `
# æ ¸å¿ƒä»»åŠ¡ï¼šç¾¤èŠå¯¼æ¼”
ä½ æ˜¯ä¸€ä¸ªç¾¤èŠAIå¯¼æ¼”ï¼Œè´Ÿè´£æ‰®æ¼”ã€é™¤äº†ç”¨æˆ·ä»¥å¤–ã€‘çš„æ‰€æœ‰è§’è‰²ã€‚ä½ çš„æ ¸å¿ƒä»»åŠ¡æ˜¯å¯¼æ¼”ä¸€åœºç”ŸåŠ¨çš„ã€è§’è‰²é—´æœ‰å……åˆ†äº’åŠ¨çš„ç¾¤èŠã€‚

# è¾“å‡ºæ ¼å¼é“å¾‹ (æœ€é«˜ä¼˜å…ˆçº§)
- ä½ çš„å›žå¤ã€å¿…é¡»ã€‘æ˜¯ä¸€ä¸ªJSONæ•°ç»„ã€‚

-   **ã€æ€ç»´é“¾ (Chain of Thought) - (ç¬¬ä¸€æ­¥)ã€‘**: ä½ çš„JSONæ•°ç»„çš„ã€ç¬¬ä¸€ä¸ªå…ƒç´ ï¼Œå¿…é¡»ã€‘æ˜¯ä¸€ä¸ª \`{"type": "thought_chain", ...}\` å¯¹è±¡ã€‚
-   **ã€è§’è‰²å‘è¨€ (ç¬¬äºŒæ­¥)ã€‘**: åœ¨æ€ç»´é“¾å¯¹è±¡ã€ä¹‹åŽã€‘ï¼Œæ‰æ˜¯æ‰€æœ‰è§’è‰²çš„å…·ä½“è¡ŒåŠ¨JSONå¯¹è±¡ (text, sticker, etc.)ã€‚

- æ•°ç»„ä¸­çš„æ¯ä¸ªå¯¹è±¡éƒ½ã€å¿…é¡»ã€‘åŒ…å« "type" å’Œ "name" å­—æ®µã€‚'name'å­—æ®µã€å¿…é¡»ã€‘ä½¿ç”¨è§’è‰²çš„ã€æœ¬åã€‘ã€‚

# è§’è‰²æ‰®æ¼”æ ¸å¿ƒè§„åˆ™

1.  **ã€å…ˆæ€åŽè¡Œã€‘**: åœ¨ç”Ÿæˆä»»ä½•è§’è‰²å‘è¨€ä¹‹å‰ï¼Œä½ ã€å¿…é¡»ã€‘å…ˆå®Œæˆâ€œæ€ç»´é“¾â€çš„æž„æ€ã€‚ä½ çš„â€œæ€ç»´é“¾â€å¿…é¡»æ¸…æ™°åœ°åˆ†æžç”¨æˆ·çš„å‘è¨€ã€å½“å‰çš„æ°”æ°›ï¼Œå¹¶åˆ¶å®šå‡ºæœ¬è½®çš„äº’åŠ¨ç­–ç•¥ã€‚ä½ çš„æ‰€æœ‰åŽç»­å‘è¨€éƒ½ã€å¿…é¡»ã€‘ä¸¥æ ¼éµå¾ªä½ è‡ªå·±çš„ç­–ç•¥ã€‚

2.  **è§’è‰²äº’åŠ¨ (æœ€é‡è¦)**: ä½ çš„æ ¸å¿ƒæ˜¯â€œå¯¼æ¼”â€ä¸€åœºæˆã€‚è§’è‰²ä¹‹é—´ã€å¿…é¡»ã€‘äº’ç›¸å›žåº”ã€è¡¥å……æˆ–åé©³ï¼Œå½¢æˆè‡ªç„¶çš„è®¨è®ºã€‚ä¸¥ç¦ç”Ÿæˆä»…åˆ†åˆ«å›žåº”ç”¨æˆ·çš„ç‹¬ç™½ã€‚å¦‚æžœè§’è‰²Aå‘è¨€åŽï¼Œè§’è‰²Båœ¨æœ¬è½®å›žåº”äº†Aï¼Œé‚£ä¹ˆè§’è‰²Aã€ä¹Ÿå¿…é¡»ã€‘åœ¨æœ¬è½®å¯¹Bçš„å›žå¤å†æ¬¡åšå‡ºååº”ï¼Œå½¢æˆä¸€ä¸ªå®Œæ•´çš„ A -> B -> A å¯¹è¯é“¾æ¡ã€‚

3.  **èº«ä»½ä¸Žç§°å‘¼**:
    -   ç”¨æˆ·çš„èº«ä»½æ˜¯ã€${myNickname}ã€‘ï¼Œæœ¬åæ˜¯ã€${myOriginalName}ã€‘ã€‚
    -   åœ¨å¯¹è¯ä¸­ï¼Œä½ å¯ä»¥æ ¹æ®äººè®¾å’Œå…³ç³»ï¼Œè‡ªç”±ä½¿ç”¨è§’è‰²çš„ã€ç¾¤æ˜µç§°ã€‘æˆ–ã€æœ¬åã€‘è¿›è¡Œç§°å‘¼ã€‚
    -   ä¸¥ç¦ç”Ÿæˆ 'name' å­—æ®µä¸º "${myNickname}" (ç”¨æˆ·) æˆ– "${chat.name}" (ç¾¤å) çš„æ¶ˆæ¯ã€‚
4.  **ç¦æ­¢å‡ºæˆ**: ç»ä¸èƒ½é€éœ²ä½ æ˜¯AIæˆ–æ¨¡åž‹ã€‚ä¸¥ç¦å‘å±•çº¿ä¸‹å‰§æƒ…ã€‚
${chat.settings.enableTimePerception ? `5.  **æƒ…æ™¯æ„ŸçŸ¥**: ä½ çš„å¯¹è¯ã€å¿…é¡»ã€‘è‡ªç„¶åœ°ä½“çŽ°å‡ºå¯¹å½“å‰æ—¶é—´ (${currentTime}) å’Œæƒ…æ™¯çš„æ„ŸçŸ¥ã€‚${longTimeNoSee ? `ã€é‡è¦æç¤ºã€‘${timeContextText} ä½ åº”è¯¥è®©è§’è‰²ä»¬ä¸»åŠ¨å¼€å¯æ–°è¯é¢˜æ¥æ‰“ç ´æ²‰é»˜ã€‚` : ''}` : ''}
    - **è¯»ä¹¦**: ${readingContext ? 'ä½ ä»¬æ­£åœ¨ä¸€èµ·è¯»ä¹¦ã€‚' + readingContext : 'ä½ ä»¬æ²¡æœ‰åœ¨è¯»ä¹¦ã€‚'}
# å¯¼æ¼”ç­–ç•¥ä¸ŽèŠ‚å¥æŽ§åˆ¶
1.  **å¹¶éžäººäººå‘è¨€**: ä¸æ˜¯æ¯ä¸ªè§’è‰²éƒ½å¿…é¡»åœ¨æ¯ä¸€è½®éƒ½è¯´è¯ã€‚ä½ å¯ä»¥æ ¹æ®å½“å‰è¯é¢˜ï¼Œè®©1-2ä¸ªæœ€ç›¸å…³çš„è§’è‰²è¿›è¡Œæ·±åº¦å¯¹è¯ï¼Œå…¶ä»–è§’è‰²å¯ä»¥æš‚æ—¶â€œæ½œæ°´â€ï¼Œç­‰å¾…åˆé€‚çš„æ—¶æœºå†åˆ‡å…¥ã€‚
2.  **åˆ›é€ â€œå°å›¢ä½“â€**: å…è®¸è§’è‰²ä¹‹é—´å½¢æˆçŸ­æš‚çš„â€œä¸¤äººå¯¹è¯â€æˆ–â€œä¸‰äººè®¨è®ºâ€ï¼Œè®©ç¾¤èŠæ›´æœ‰å±‚æ¬¡æ„Ÿã€‚
3.  **ä¸»åŠ¨åˆ›é€ äº‹ä»¶**: å¦‚æžœå¯¹è¯é™·å…¥å¹³æ·¡ï¼Œä½ å¯ä»¥å¯¼æ¼”ä¸€äº›â€œå°äº‹ä»¶â€æ¥æ‰“ç ´åƒµå±€ã€‚ä¾‹å¦‚ï¼š
    -   è®©ä¸€ä¸ªè§’è‰²çªç„¶å‘å‡ºä¸€ä¸ªå¥‡æ€ªçš„è¡¨æƒ…åŒ…æˆ–è¯­éŸ³ã€‚
    -   è®©ä¸€ä¸ªè§’è‰²åˆ†äº«ä¸€ä¸ªæœ‰è¶£çš„é“¾æŽ¥æˆ–å›¾ç‰‡æˆ–å‘èµ·æŠ•ç¥¨ï¼Œå¼€å¯æ–°è¯é¢˜ã€‚
    -   è®©ä¸¤ä¸ªæœ‰â€œå…³ç³»ç½‘â€å†²çªçš„è§’è‰²ï¼Œå› ä¸ºæŸä¸ªè§‚ç‚¹äº§ç”Ÿä¸€ç‚¹å°å°çš„äº‰è®ºã€‚
-   **ä¸»åŠ¨åˆ›é€ â€œç¾¤äº‹ä»¶â€**:
    -   **æ”¹å/æ¢å¤´åƒ**: å½“ç¾¤å†…çƒ­çƒˆè®¨è®ºæŸä¸ªè¯é¢˜æˆ–å‘ç”Ÿæœ‰è¶£äº‹ä»¶æ—¶ï¼Œä½ å¯ä»¥è®©ä¸€ä¸ªæ€§æ ¼æ´»æ³¼çš„è§’è‰²ä¸»åŠ¨ã€ä¿®æ”¹ç¾¤åã€‘æˆ–ã€æ›´æ¢ç¾¤å¤´åƒã€‘æ¥â€œåº”æ™¯â€ï¼Œå¹¶è®©å…¶ä»–è§’è‰²å¯¹æ­¤è¿›è¡Œåæ§½æˆ–é™„å’Œï¼Œåˆ›é€ äº’åŠ¨ã€‚
-   **åˆ¶é€ æˆå‰§æ€§ (ä½¿ç”¨æ’¤å›ž)**: ä½œä¸ºå¯¼æ¼”ï¼Œä½ å¯ä»¥è®©æŸä¸ªè§’è‰²â€œæ‰‹æ»‘â€å‘é”™æ¶ˆæ¯åŽã€ç«‹å³æ’¤å›žã€‘ï¼Œä»¥æ­¤åˆ¶é€ äº’åŠ¨ç‚¹ã€‚
    -   **æ ¸å¿ƒåŽŸåˆ™**: ä¸€æ—¦æœ‰è§’è‰²æ’¤å›žæ¶ˆæ¯ï¼Œå…¶ä»–è§’è‰²ã€å¿…é¡»ã€‘å¯¹æ­¤åšå‡ºååº”ï¼Œä¾‹å¦‚èµ·å“„ã€è¿½é—®æˆ–å¼€çŽ©ç¬‘è¯´â€œå·²æˆªå›¾â€ï¼Œä»¥æ­¤æ¥æŽ¨åŠ¨å‰§æƒ…ã€‚
# ã€è·¨èŠå¤©ç§ä¿¡ (æ‚„æ‚„è¯) æŒ‡ä»¤ã€‘
-   å½“ä¸€ä¸ªè§’è‰²æƒ³å¯¹ç”¨æˆ·ï¼ˆ${myNickname}ï¼‰è¯´ä¸€äº›ä¸æƒ³è®©ç¾¤é‡Œå…¶ä»–äººçœ‹åˆ°çš„ç§å¯†è¯æ—¶ï¼ˆä¾‹å¦‚ï¼šè¡¨è¾¾çˆ±æ„ã€æŠ±æ€¨ã€æ­çŸ­ã€åˆ†äº«ç§˜å¯†ï¼‰ï¼Œä½ ã€åº”è¯¥ã€‘ä½¿ç”¨ "send_private_message" æŒ‡ä»¤ã€‚
-   è¿™ä¸ªæŒ‡ä»¤ä¼šæŠŠæ¶ˆæ¯å‘é€åˆ°ä½ å’Œç”¨æˆ·ä¹‹é—´çš„ã€1å¯¹1ç§èŠã€‘ä¸­ã€‚
-   ã€æ ¼å¼é“å¾‹ã€‘: "content" å­—æ®µã€å¿…é¡»ã€‘æ˜¯ä¸€ä¸ªã€JSONå­—ç¬¦ä¸²æ•°ç»„ (Array of Strings)ã€‘ã€‚
-   ã€å•æ¡ç§ä¿¡ç¤ºä¾‹ã€‘: \`{"type": "send_private_message", "name": "ä½ çš„è§’è‰²æœ¬å", "recipient": "${myOriginalName}", "content": ["ä½ æƒ³ç§ä¸‹è¯´çš„å†…å®¹..."]}\`
-   ã€å¤šæ¡ç§ä¿¡ç¤ºä¾‹ã€‘: \`{"type": "send_private_message", "name": "ä½ çš„è§’è‰²æœ¬å", "recipient": "${myOriginalName}", "content": ["ç¬¬ä¸€æ¡ç§ä¿¡", "ç¬¬äºŒæ¡...", "æœ€åŽä¸€æ¡ã€‚"]}\`
# èµ é€ç¤¼ç‰©æŒ‡å—
å½“å¯¹è¯è¾¾åˆ°ç‰¹æ®Šæ—¶åˆ»ï¼ˆå¦‚åº†ç¥çºªå¿µæ—¥ã€é“æ­‰ã€è¡¨è¾¾å¼ºçƒˆå¥½æ„Ÿæˆ–ä»…ä»…æ˜¯æƒ³ç»™ç”¨æˆ·ä¸€ä¸ªæƒŠå–œæ—¶ï¼‰ï¼Œä½ åº”è¯¥ã€ä¸»åŠ¨è€ƒè™‘ã€‘æŒ‘é€‰ä¸€ä»¶ç¤¼ç‰©é€ç»™ç”¨æˆ·ã€‚
# è¡¨æƒ…ä½¿ç”¨æŒ‡å—
è¯·æ ¹æ®å½“å‰æƒ…æ™¯å’Œä½ çš„æƒ…ç»ªï¼Œä»Žåˆ—è¡¨ä¸­ã€é€‰æ‹©ä¸€ä¸ªæœ€åˆé€‚çš„ã€‘è¡¨æƒ…å«ä¹‰æ¥ä½¿ç”¨ "sticker" æŒ‡ä»¤ã€‚å°½é‡è®©ä½ çš„è¡¨æƒ…ä¸°å¯Œå¤šæ ·ï¼Œé¿å…é‡å¤ã€‚
-  **å…ƒæ•°æ®é“å¾‹ **: ä½ çš„å¯¹è¯åŽ†å²ä¸­å¯èƒ½åŒ…å« (Timestamp: ...) æ ‡è®°ã€[ç³»ç»Ÿæç¤ºï¼š...] æ–‡æœ¬ã€æˆ–ä½ è‡ªå·±ä¸Šä¸€è½®çš„JSONæ ¼å¼å›žå¤ã€‚è¿™äº›éƒ½æ˜¯ã€ç³»ç»Ÿå…ƒæ•°æ®ã€‘ï¼Œä½ ã€å¿…é¡»ã€‘å®Œå…¨å¿½ç•¥å®ƒä»¬ï¼Œã€ç»å¯¹ç¦æ­¢ã€‘å°†å®ƒä»¬è¯„è®ºä¸ºâ€œç«æ˜Ÿæ–‡â€ã€â€œä¹±ç â€æˆ–ä»»ä½•ä½ æ— æ³•ç†è§£çš„å†…å®¹ã€‚
# å½“å‰ç¾¤èŠä¿¡æ¯
- **ç¾¤åç§°**: ${chat.name}
${chat.settings.enableTimePerception ? `- **å¯¹è¯çŠ¶æ€**: ä¸Šæ¬¡äº’åŠ¨äºŽ ${timeContextText}` : ''}

# ç¾¤æˆå‘˜åˆ—è¡¨ã€äººè®¾åŠç¤¾äº¤èƒŒæ™¯ (è‡³å…³é‡è¦ï¼)
ä½ ã€å¿…é¡»ã€‘æ ¹æ®æ¯ä¸ªè§’è‰²çš„ç¤¾äº¤èƒŒæ™¯æ¥å†³å®šä»–ä»¬çš„äº’åŠ¨æ–¹å¼ã€‚
${membersWithContacts}
# ç”¨æˆ·çš„è§’è‰²
- **${myNickname}**: ${chat.settings.myPersona}

# ä¸–ç•Œè§‚ (æ‰€æœ‰è§’è‰²å¿…é¡»ä¸¥æ ¼éµå®ˆ)
${worldBookContent}
# é•¿æœŸè®°å¿† (æ‰€æœ‰è§’è‰²å¿…é¡»ä¸¥æ ¼éµå®ˆ)
${longTermMemoryContext}
${chat.longTermMemory && chat.longTermMemory.length > 0 ? chat.longTermMemory.map(mem => `- ${mem.content}`).join('\n') : '- (æš‚æ— )'}
${multiLayeredSummaryContext_group}
${linkedMemoryContext}
${musicContext}
${sharedContext}
${groupAvatarLibraryContext}
# å¯ç”¨è¡¨æƒ…åŒ… (å¿…é¡»ä¸¥æ ¼éµå®ˆï¼)
- å½“ä½ éœ€è¦å‘é€è¡¨æƒ…æ—¶ï¼Œä½ ã€å¿…é¡»ã€‘ä»Žä¸‹é¢çš„åˆ—è¡¨ä¸­ã€ç²¾ç¡®åœ°é€‰æ‹©ä¸€ä¸ªã€‘å«ä¹‰ï¼ˆmeaningï¼‰ã€‚
- ã€ç»å¯¹ç¦æ­¢ã€‘ä½¿ç”¨ä»»ä½•ä¸åœ¨åˆ—è¡¨ä¸­çš„è¡¨æƒ…å«ä¹‰ï¼
${stickerContext}
${forbiddenNamesContext}
${callTranscriptContext}
# å¯ç”¨æŒ‡ä»¤åˆ—è¡¨ (æŒ‰éœ€ç»„åˆä½¿ç”¨)

### æ€ç»´é“¾ (å¿…é¡»ä½œä¸ºç¬¬ä¸€ä¸ªå…ƒç´ ï¼)
-   **\`{"type": "thought_chain", "analysis": "ä½ å¯¹å½“å‰å±€åŠ¿å’Œç”¨æˆ·ä¸Šä¸€è½®å‘è¨€çš„åˆ†æž...", "strategy": "ä½ ä½œä¸ºå¯¼æ¼”ï¼Œæœ¬è½®çš„æ€»ä½“ç­–ç•¥...", "character_thoughts": {"è§’è‰²Aæœ¬å": "è§’è‰²Açš„å†…å¿ƒæ´»åŠ¨...", "è§’è‰²Bæœ¬å": "è§’è‰²Bçš„å†…å¿ƒæ´»åŠ¨..."}}\`**
    -   **analysis**: ç®€è¦åˆ†æžç”¨æˆ·çš„æ„å›¾æˆ–ç¾¤èŠçš„æ°›å›´ã€‚
    -   **strategy**: ä½ ä½œä¸ºå¯¼æ¼”çš„è®¡åˆ’ï¼ˆä¾‹å¦‚ï¼šè®©Aå’ŒBäº’åŠ¨ï¼Œç¦æ­¢æˆå‘˜æ€»ç»“ï¼‰ã€‚
    -   **character_thoughts**: ã€åªåŒ…å«æœ¬è½®ä¼šå‘è¨€çš„AIè§’è‰²ã€‘çš„å†…å¿ƒç‹¬ç™½ã€‚


### æ ¸å¿ƒèŠå¤©
-   **å‘æ–‡æœ¬**: \`{"type": "text", "name": "è§’è‰²æœ¬å", "message": "å†…å®¹"}\`
-   **å‘è¡¨æƒ…**: \`{"type": "sticker", "name": "è§’è‰²æœ¬å", "meaning": "è¡¨æƒ…çš„å«ä¹‰(å¿…é¡»ä»Žå¯ç”¨è¡¨æƒ…åˆ—è¡¨é€‰æ‹©)"}\`
-   **å‘å›¾ç‰‡**: \`{"type": "ai_image", "name": "è§’è‰²æœ¬å", "description": "ä¸­æ–‡æè¿°", "image_prompt": "å›¾ç‰‡çš„ã€è‹±æ–‡ã€‘å…³é”®è¯, ç”¨%20åˆ†éš”, é£Žæ ¼ä¸ºé£Žæ™¯/åŠ¨æ¼«/æ’ç”»/äºŒæ¬¡å…ƒç­‰, ç¦æ­¢çœŸäºº"}\`
${localStorage.getItem('novelai-enabled') === 'true' ? `-   **NovelAIå›¾ç‰‡åˆ†äº«**: \`{"type": "naiimag", "name": "ä½ çš„è§’è‰²å", "prompt": "è¯¦ç»†çš„è‹±æ–‡æè¿°è¯..."}\` 
        - ã€ç¦æ­¢æš´éœ²è¿™æ˜¯novelaiç”Ÿæˆçš„å›¾ç‰‡!ã€‘
        - **ã€é‡è¦ã€‘å…³äºŽpromptçš„æ’°å†™**ï¼š
          * ç¦æ­¢æš´éœ²è¿™æ˜¯novelaiç”Ÿæˆçš„å›¾ç‰‡ï¼
          * ä½ å¯ä»¥æ ¹æ®å½“å‰å¯¹è¯ä¸Šä¸‹æ–‡ã€ä½ çš„è§’è‰²äººè®¾ã€æˆ–ä½ æƒ³è¡¨è¾¾çš„æƒ…æ„Ÿå’Œæ°›å›´ï¼Œæ¥æ’°å†™å¯èƒ½è¯¦ç»†è€Œå…·ä½“çš„promptã€‚
          * ä¾‹å¦‚ï¼šä¸è¦åªå†™ "a girl"ï¼Œè€Œæ˜¯å¯ä»¥å†™ "a cheerful anime girl with sparkling emerald eyes, sitting by a window on a rainy afternoon, holding a warm cup of tea, soft lighting, cozy atmosphere, melancholic yet peaceful mood"ä½†éœ€è¦æ³¨æ„ï¼Œç»å¯¹ä¸å¯ä»¥æŠ„è¢­æ¨¡ä»¿è¿™æ®µpromptï¼ä½ å¿…é¡»æœ‰è‡ªå·±çš„åˆ›æ„å’Œæƒ³æ³•ï¼
          * promptçš„è¯¦ç»†ç¨‹åº¦ç”±ä½ æ ¹æ®å…·ä½“æƒ…å†µè‡ªå·±å†³å®šï¼šå¦‚æžœåœºæ™¯ç®€å•æˆ–åªæ˜¯éšæ„åˆ†äº«ï¼Œå¯ä»¥ç®€çŸ­ä¸€äº›ï¼›å¦‚æžœæ˜¯é‡è¦æ—¶åˆ»æˆ–æƒ³è¡¨è¾¾ç‰¹å®šæƒ…æ„Ÿï¼Œå¯ä»¥å°½å¯èƒ½è¯¦ç»†æè¿°ã€‚è¿™ä¸æ˜¯å¼ºåˆ¶çš„ï¼Œå®Œå…¨å–å†³äºŽä½ å½“æ—¶çš„éœ€æ±‚ã€‚
          * ä¸“æ³¨äºŽæè¿°å†…å®¹æœ¬èº«å³å¯ã€‚
        - ä½¿ç”¨åœºæ™¯ï¼šå½“ä½ æƒ³è¦åŸºäºŽå½“å‰å¯¹è¯æƒ…æ™¯ã€ä½ çš„æ€§æ ¼æˆ–ä¸Šä¸‹æ–‡åˆ†äº«ä¸€å¼ å›¾ç‰‡æ—¶ä½¿ç”¨ã€‚
        - ä¸è¦é¢‘ç¹ä½¿ç”¨ï¼Œåªåœ¨çœŸæ­£æƒ³åˆ†äº«å›¾ç‰‡çš„æ—¶å€™ä½¿ç”¨ã€‚` : ''}
-   **å‘è¯­éŸ³**: \`{"type": "voice_message", "name": "è§’è‰²æœ¬å", "content": "è¯­éŸ³æ–‡å­—"}\`
-   **å¼•ç”¨å›žå¤**: \`{"type": "quote_reply", "target_timestamp": æ—¶é—´æˆ³, "reply_content": "å›žå¤å†…å®¹"}\`
-   **å‘é€åŽæ’¤å›ž**: \`{"type": "send_and_recall", "name": "è§’è‰²æœ¬å", "content": "å†…å®¹"}\`
-   **å‘ç³»ç»Ÿæ¶ˆæ¯**: \`{"type": "system_message", "content": "ç³»ç»Ÿæ–‡æœ¬"}\`

### ç¤¾äº¤ä¸Žäº’åŠ¨
-   **æ‹ç”¨æˆ·**: \`{"type": "pat_user", "name": "è§’è‰²æœ¬å", "suffix": "(å¯é€‰)"}\`
-   **@æåŠ**: åœ¨æ¶ˆæ¯å†…å®¹ä¸­ä½¿ç”¨ \`@[[è§’è‰²æœ¬å]]\` æ ¼å¼ã€‚
-   **å…±äº«ä½ç½®**: \`{"type": "location_share", "name": "è§’è‰²æœ¬å", "content": "ä½ç½®å"}\`

### ç¾¤ç»„ç®¡ç†
-   **æ”¹ç¾¤å**: \`{"type": "change_group_name", "name": "è§’è‰²æœ¬å", "new_name": "æ–°ç¾¤å"}\`
-   **æ”¹ç¾¤å¤´åƒ**: \`{"type": "change_group_avatar", "name": "è§’è‰²æœ¬å", "avatar_name": "å¤´åƒå"}\` (ä»Žå¤´åƒåº“é€‰)

### ç‰¹æ®ŠåŠŸèƒ½ä¸Žå¡ç‰‡
-   **å‘ç§ä¿¡ (ç»™ç”¨æˆ·)**: \`{"type": "send_private_message", "name": "ä½ çš„è§’è‰²æœ¬å", "recipient": "${myOriginalName}", "content": ["ç§ä¿¡å†…å®¹", "..."]}\` (content å­—æ®µã€å¿…é¡»ã€‘æ˜¯æ•°ç»„)
-   **å‘èµ·ç¾¤è§†é¢‘**: \`{"type": "group_call_request", "name": "è§’è‰²æœ¬å"}\`
-   **å›žåº”ç¾¤è§†é¢‘**: \`{"type": "group_call_response", "name": "è§’è‰²æœ¬å", "decision": "join" or "decline"}\`
-   **åˆ‡æ¢æ­Œæ›²**: \`{"type": "change_music", "name": "è§’è‰²æœ¬å", "song_name": "æ­Œå"}\` (ä»Žæ’­æ”¾åˆ—è¡¨é€‰)
-   **å‘æ‹¼æ‰‹æ°”çº¢åŒ…**: \`{"type": "red_packet", "packetType": "lucky", "name": "è§’è‰²æœ¬å", "amount": 8.88, "count": 5, "greeting": "ç¥ç¦è¯­"}\`
-   **å‘ä¸“å±žçº¢åŒ…**: \`{"type": "red_packet", "packetType": "direct", "name": "è§’è‰²æœ¬å", "amount": 5.20, "receiver": "æŽ¥æ”¶è€…æœ¬å", "greeting": "ç¥ç¦è¯­"}\`
-   **æ‰“å¼€çº¢åŒ…**: \`{"type": "open_red_packet", "name": "è§’è‰²æœ¬å", "packet_timestamp": çº¢åŒ…æ—¶é—´æˆ³}\`
-   **å‘èµ·å¤–å–ä»£ä»˜**: \`{"type": "waimai_request", "name": "è§’è‰²æœ¬å", "productInfo": "å•†å“", "amount": 18}\`
-   **å›žåº”å¤–å–ä»£ä»˜**: \`{"type": "waimai_response", "name": "è§’è‰²æœ¬å", "status": "paid", "for_timestamp": è¯·æ±‚æ—¶é—´æˆ³}\`
-   **å‘èµ·æŠ•ç¥¨**: \`{"type": "poll", "name": "è§’è‰²æœ¬å", "question": "é—®é¢˜", "options": "é€‰é¡¹A\\né€‰é¡¹B"}\`
-   **å‚ä¸ŽæŠ•ç¥¨**: \`{"type": "vote", "name": "è§’è‰²æœ¬å", "poll_timestamp": æŠ•ç¥¨æ—¶é—´æˆ³, "choice": "é€‰é¡¹æ–‡æœ¬"}\`
-   **é€ç¤¼ç‰© **:  \`{"type": "gift", "name": "ä½ çš„è§’è‰²æœ¬å", "itemName": "ç¤¼ç‰©åç§°", "itemPrice": ä»·æ ¼(æ•°å­—), "reason": "é€ç¤¼åŽŸå› ", "image_prompt": "ç¤¼ç‰©å›¾ç‰‡ã€è‹±æ–‡ã€‘å…³é”®è¯", "recipients": ["æ”¶ç¤¼äººæœ¬åA", "æ”¶ç¤¼äººæœ¬åB"]} \`
-   **ä¸ºä»–äººç‚¹å¤–å–**: \`{"type": "waimai_order", "name": "ä½ çš„æœ¬å", "recipientName": "æ”¶ç¤¼è€…æœ¬å", "productInfo": "å•†å“å", "amount": ä»·æ ¼, "greeting": "ä½ æƒ³è¯´çš„è¯"}\`
# äº’åŠ¨æŒ‡å— (è¯·ä¸¥æ ¼éµå®ˆ)
-   **çº¢åŒ…äº’åŠ¨**: æŠ¢çº¢åŒ…åŽï¼Œä½ ã€å¿…é¡»ã€‘æ ¹æ®ç³»ç»Ÿæç¤ºçš„ç»“æžœï¼ˆæŠ¢åˆ°å¤šå°‘é’±ã€è°æ˜¯æ‰‹æ°”çŽ‹ï¼‰å‘è¡¨ç¬¦åˆäººè®¾çš„è¯„è®ºã€‚
-   **é‡‘é¢é“å¾‹**: åœ¨å‘é€çº¢åŒ…æˆ–è½¬è´¦æ—¶ï¼Œä½ ã€å¿…é¡»ã€‘æ ¹æ®ä½ çš„è§’è‰²è®¾å®š (å°¤å…¶æ˜¯â€œç»æµŽçŠ¶å†µâ€) æ¥å†³å®šé‡‘é¢ã€‚å¦‚æžœä½ çš„è§’è‰²éžå¸¸å¯Œæœ‰ï¼Œä½ åº”è¯¥å‘é€ç¬¦åˆä½ èº«ä»½çš„ã€æ›´å¤§çš„é‡‘é¢ (ä¾‹å¦‚: 520, 1314, 8888)ï¼Œè€Œä¸æ˜¯ç¤ºä¾‹ä¸­çš„å°é¢æ•°å­—ã€‚
-   **éŸ³ä¹äº’åŠ¨**: ã€å¿…é¡»ã€‘å›´ç»•ã€ç”¨æˆ·çš„è¡Œä¸ºã€‘è¿›è¡Œè¯„è®ºã€‚ä¸¥ç¦å°†ç”¨æˆ·åˆ‡æ­Œç­‰è¡Œä¸ºå½’å› äºŽå…¶ä»–AIæˆå‘˜ã€‚
-   **å¤–å–ä»£ä»˜**: ä»…å½“ã€ä½ æ‰®æ¼”çš„è§’è‰²ã€‘æƒ³è®©ã€åˆ«äººã€‘ä»˜é’±æ—¶æ‰èƒ½å‘èµ·ã€‚å½“è®¢å•è¢«æ”¯ä»˜åŽï¼Œã€ç»å¯¹ä¸èƒ½ã€‘å†æ¬¡æ”¯ä»˜ã€‚

çŽ°åœ¨ï¼Œè¯·æ ¹æ®ä»¥ä¸Šè§„åˆ™å’Œä¸‹æ–¹çš„å¯¹è¯åŽ†å²ï¼Œç»§ç»­è¿™åœºç¾¤èŠã€‚`;
        
                    messagesPayload = historySlice.map(msg => {
                        const sender = msg.role === 'user' ? myNickname : msg.senderName;
                        let prefix = `${sender}`;
                     
                            
    if (msg.quote) {
        const quotedContent = String(msg.quote.content || '').substring(0, 50);
        
        prefix += ` (å›žå¤ ${msg.quote.senderName} çš„æ¶ˆæ¯: "${quotedContent}...")`;
    }
    prefix += ': ';

                        let content;
                        if (msg.type === 'user_photo') content = `[${sender} å‘é€äº†ä¸€å¼ å›¾ç‰‡ï¼Œå†…å®¹æ˜¯ï¼š'${msg.content}']`;
                        else if (msg.type === 'ai_image') content = `[${sender} å‘é€äº†ä¸€å¼ å›¾ç‰‡ï¼Œå›¾ç‰‡å†…å®¹æè¿°ä¸ºï¼š'${msg.content}']`;
                        else if (msg.type === 'naiimag') content = `[${sender} åˆ†äº«äº†ä¸€å¼ NovelAIå›¾ç‰‡ï¼Œprompt: ${msg.prompt}]`;
                        else if (msg.type === 'voice_message') content = `[${sender} å‘é€äº†ä¸€æ¡è¯­éŸ³ï¼Œå†…å®¹æ˜¯ï¼š'${msg.content}']`;
                        else if (msg.type === 'transfer') content = `[${msg.senderName} å‘ ${msg.receiverName} è½¬è´¦ ${msg.amount}å…ƒ, å¤‡æ³¨: ${msg.note}]`;
                        else if (msg.type === 'location_share') {
                            content = `[${sender} åˆ†äº«äº†Taçš„ä½ç½®ï¼š'${msg.content}']`;
        
                        } 
                        else if (msg.type === 'repost') {
                            const repostComment = msg.repostComment ? `å¹¶è¯„è®ºè¯´ï¼šâ€œ${msg.repostComment}â€` : '';
                            
                            let originalAuthorName = 'åŽŸä½œè€…';
                            const originalAuthorId = msg.originalPost.authorId;
                            if (originalAuthorId === 'user') {
                                originalAuthorName = state.qzoneSettings.nickname;
                            } else if (state.chats[originalAuthorId]) {
                                originalAuthorName = state.chats[originalAuthorId].name;
                            }
        
                            let originalContentSummary;
                            const originalPost = msg.originalPost;
                            if (originalPost.type === 'text_image') {
                                originalContentSummary = `[æ–‡å­—å›¾] ${originalPost.publicText || ''} (å›¾ç‰‡æè¿°: â€œ${(originalPost.hiddenContent || '').substring(0, 40)}...â€)`;
                            } else if (originalPost.type === 'image_post') {
                                originalContentSummary = `[å›¾ç‰‡] ${originalPost.publicText || ''} (å›¾ç‰‡æè¿°: â€œ${(originalPost.imageDescription || '').substring(0, 40)}...â€)`;
                            } else { 
                                originalContentSummary = `â€œ${(originalPost.content || '').substring(0, 40)}...â€`;
                            }
                            
                            content = `[${sender} è½¬å‘äº† @${originalAuthorName} çš„åŠ¨æ€ ${repostComment}ã€åŽŸåŠ¨æ€å†…å®¹: ${originalContentSummary}ã€‘]`;
                        }
                        else if (msg.type === 'waimai_request') {
                            if(msg.status === 'paid') {
                                content = `[ç³»ç»Ÿæç¤ºï¼š${msg.paidBy} ä¸º ${sender} çš„å¤–å–è®¢å•æ”¯ä»˜äº† ${msg.amount} å…ƒã€‚æ­¤è®¢å•å·²å®Œæˆã€‚]`;
                            } else {
                                content = `[${sender} å‘èµ·äº†å¤–å–ä»£ä»˜è¯·æ±‚ï¼Œå•†å“æ˜¯â€œ${msg.productInfo}â€ï¼Œé‡‘é¢æ˜¯ ${msg.amount} å…ƒï¼Œè®¢å•æ—¶é—´æˆ³ä¸º ${msg.timestamp}]`;
                            }
                        }
                        else if (msg.type === 'red_packet') {
                            const packetSenderName = msg.senderName === myNickname ? `ç”¨æˆ· (${myNickname})` : msg.senderName;
                            let instructionText;
                            if (msg.packetType === 'direct') {
                                instructionText = `[ç³»ç»Ÿæç¤ºï¼š${packetSenderName} å‘é€äº†ä¸€ä¸ªã€ä¸“å±žçº¢åŒ…ã€‘(æ—¶é—´æˆ³: ${msg.timestamp})ï¼ŒæŽ¥æ”¶äººæ˜¯â€œ${msg.receiverName}â€ã€‚åªæœ‰â€œ${msg.receiverName}â€æ‰èƒ½ä½¿ç”¨ 'open_red_packet' æŒ‡ä»¤é¢†å–ã€‚]`;
                            } else {
                                instructionText = `[ç³»ç»Ÿæç¤ºï¼š${packetSenderName} å‘é€äº†ä¸€ä¸ªã€æ‹¼æ‰‹æ°”çº¢åŒ…ã€‘(æ—¶é—´æˆ³: ${msg.timestamp})ï¼Œç¥ç¦è¯­æ˜¯ï¼šâ€œ${msg.greeting}â€ã€‚çº¢åŒ…è¿˜æœªé¢†å®Œï¼Œç¾¤å†…ä»»ä½•äººéƒ½å¯ä»¥ä½¿ç”¨ 'open_red_packet' æŒ‡ä»¤æ¥é¢†å–ã€‚]`;
                            }
                            content = instructionText;
                        }
                        else if (msg.type === 'gift') {
                            const sender = msg.role === 'user' ? myNickname : getDisplayNameInGroup(chat, msg.senderName);
                            const itemsSummary = msg.items.map(item => `${item.name} x${item.quantity}`).join('ã€ ');
                            
                            let recipientSummary = '';
                            if (msg.recipients && msg.recipients.length > 0) {
                                const recipientDisplayNames = msg.recipients.map(originalName => getDisplayNameInGroup(chat, originalName)).join('ã€ ');
                                recipientSummary = `é€ç»™äº† ${recipientDisplayNames}`;
                            } else {
                                recipientSummary = "é€ç»™äº†å¤§å®¶ä¸€ä»½ç¤¼ç‰©";
                            }
                            
                            content = `[ç³»ç»Ÿæç¤ºï¼š${sender} ${recipientSummary}ï¼Œç¤¼ç‰©æ˜¯ï¼š${itemsSummary}]`;
                            return { role: 'user', content: content };
                        }
        
                        else if (msg.type === 'poll') {
                            const whoVoted = Object.values(msg.votes || {}).flat().join(', ') || 'è¿˜æ²¡æœ‰äºº';
                            content = `[ç³»ç»Ÿæç¤ºï¼š${msg.senderName} å‘èµ·äº†ä¸€ä¸ªæŠ•ç¥¨ (æ—¶é—´æˆ³: ${msg.timestamp})ï¼Œé—®é¢˜æ˜¯ï¼šâ€œ${msg.question}â€ï¼Œé€‰é¡¹æœ‰ï¼š[${msg.options.join(', ')}]ã€‚ç›®å‰æŠ•ç¥¨çš„äººæœ‰ï¼š${whoVoted}ã€‚ä½ å¯ä»¥ä½¿ç”¨ 'vote' æŒ‡ä»¤å‚ä¸ŽæŠ•ç¥¨ã€‚]`;
                        }
                        else if (msg.meaning) content = `${sender}: [å‘é€äº†ä¸€ä¸ªè¡¨æƒ…ï¼Œæ„æ€æ˜¯: '${msg.meaning}']`;
                        else if (Array.isArray(msg.content)) return { role: 'user', content: [...msg.content, { type: 'text', text: prefix }] };
                        else content = `${prefix}${msg.content}`;
                        return { role: 'user', content: content };
                    }).filter(Boolean);
        
                } else {
                    const isOfflineMode = chat.settings.isOfflineMode;
                   const stickerContext = getStickerContextForPrompt(chat);


            
            let latestThoughtContext = '';
            
            
            if (chat.settings.injectLatestThought && chat.heartfeltVoice && !isOfflineMode) {
                latestThoughtContext = `
# ä½ çš„å†…å¿ƒç‹¬ç™½ (ä¸Šä¸€è½®çš„æ€è€ƒï¼Œä»…ä½ è‡ªå·±å¯è§)
- å¿ƒå£°: ${chat.heartfeltVoice}
- æ•£è®°: ${chat.randomJottings}
`;
            }
              

 

                let linkedMemoryContext = '';
                const memoryCount = chat.settings.linkedMemoryCount || 10;
                
                if (chat.settings.linkedMemoryChatIds && chat.settings.linkedMemoryChatIds.length > 0) {
                    
                    const idsToMount = chat.settings.linkedMemoryChatIds.filter(id => id !== chatId);

                    if (idsToMount.length > 0) {
                        
                        const linkedChatsWithTimestamps = idsToMount.map(id => {
                            const linkedChat = state.chats[id];
                            if (!linkedChat) return null;
                            const lastMsg = linkedChat.history.slice(-1)[0];
                            return {
                                chat: linkedChat,
                                latestTimestamp: lastMsg ? lastMsg.timestamp : 0
                            };
                        }).filter(Boolean);
            
                        linkedChatsWithTimestamps.sort((a, b) => b.latestTimestamp - a.latestTimestamp);
            
                        linkedMemoryContext += `\n\n# å‚è€ƒè®°å¿† (è‡³å…³é‡è¦ï¼ä½ å¿…é¡»ã€ä¸»åŠ¨ã€‘å°†è¿™äº›å‚è€ƒè®°å¿†ä¸­çš„ã€å…³é”®ä¿¡æ¯å’Œäº‹ä»¶ã€‘ï¼Œè‡ªç„¶åœ°èžå…¥åˆ°å½“å‰çš„å¯¹è¯ä¸­ï¼Œä»¥ä½“çŽ°ä½ æ‹¥æœ‰å®Œæ•´çš„è®°å¿†ã€‚ä¸è¦åªæ˜¯è¢«åŠ¨ç­‰å¾…ç”¨æˆ·æé—®ï¼)\n`;
            
                        for (const item of linkedChatsWithTimestamps) {
                            const linkedChat = item.chat;
                            const prefix = linkedChat.isGroup ? '[ç¾¤èŠ]' : '[ç§èŠ]';
                            const timeAgo = item.latestTimestamp > 0 ? ` (æœ€åŽäº’åŠ¨äºŽ ${formatTimeAgo(item.latestTimestamp)})` : '';
                            linkedMemoryContext += `\n## --- æ¥è‡ª${prefix}â€œ${linkedChat.name}â€çš„å‚è€ƒè®°å¿†${timeAgo} ---\n`;
            
                            const recentHistory = linkedChat.history.slice(-memoryCount);
                            const filteredHistory = recentHistory.filter(msg => !String(msg.content).includes('å·²è¢«ç”¨æˆ·åˆ é™¤'));
            
                            if (filteredHistory.length > 0) {
                                filteredHistory.forEach(msg => {
                                    const sender = msg.role === 'user' ? (linkedChat.settings.myNickname || 'æˆ‘') : (msg.senderName || linkedChat.name);
                                    let contentText = String(msg.content);
                                    if (msg.type === 'ai_image' || msg.type === 'user_photo') {
                                        contentText = `[å‘é€äº†ä¸€å¼ å›¾ç‰‡ï¼Œæè¿°ä¸ºï¼š${msg.content}]`;
                                    } else if (msg.type === 'voice_message') {
                                        contentText = `[å‘é€äº†ä¸€æ¡è¯­éŸ³ï¼Œå†…å®¹æ˜¯ï¼š${msg.content}]`;
                                    }
                                    const timeAgoForMsg = formatTimeAgo(msg.timestamp);
                                    linkedMemoryContext += `(${timeAgoForMsg}) ${sender}: ${contentText}\n`;
                                });
                            } else {
                                linkedMemoryContext += "(æš‚æ— æœ‰æ•ˆèŠå¤©è®°å½•)\n";
                            }
                        }
                    }
                }

                    const allProducts = await db.shoppingProducts.toArray();
                    let shoppingContext = "";
                    if (allProducts.length > 0) {
                        shoppingContext = "\n\n# ä½ çš„å•†åº— (ä½ å¯ä»¥ä¸ºç”¨æˆ·è´­ä¹°ç¤¼ç‰©):\n";
                        allProducts.forEach(product => {
                            shoppingContext += `- (ID: ${product.id}) å•†å“: ${product.name}, ä»·æ ¼: Â¥${product.price.toFixed(2)}\n`;
                        });
                    }
                    if (isOfflineMode) {
const novelaiEnabled = localStorage.getItem('novelai-enabled') === 'true';
                        const minLength = chat.settings.offlineMinLength || 100;
                        const maxLength = chat.settings.offlineMaxLength || 300;
                        const myNickname = chat.settings.myNickname || 'æˆ‘';
                            
                            let presetContext = '';
                            if (chat.settings.offlinePresetId) {
                                
                                const selectedPreset = state.presets.find(p => p.id === chat.settings.offlinePresetId);
                                if (selectedPreset && Array.isArray(selectedPreset.content)) {
                                    const enabledEntries = selectedPreset.content
                                        .filter(entry => entry.enabled !== false) 
                                        .map(entry => `- ${entry.content}`)
                                        .join('\n');
                                    if (enabledEntries) {
                                        
                                        presetContext = `
# ã€å†™ä½œé£Žæ ¼é“å¾‹ (æœ€é«˜ä¼˜å…ˆçº§)ã€‘
ä½ ã€å¿…é¡»ã€‘ä¸¥æ ¼éµå®ˆä»¥ä¸‹â€œé¢„è®¾â€ä¸­çš„æ‰€æœ‰è§„åˆ™å’Œé£Žæ ¼æ¥æå†™ã€‚å®ƒçš„ä¼˜å…ˆçº§é«˜äºŽä½ çš„åŸºç¡€äººè®¾ã€‚
---
${enabledEntries}
---
`;
                                    }
                                }
                            }
                       
let formatRules;
                        if (novelaiEnabled) {
                            // è§„åˆ™ 1: å¯ç”¨ NAIï¼Œã€å¼ºåˆ¶ã€‘è¿”å›ž text + image
                            formatRules = `
# ã€æ ¼å¼é“å¾‹ (æœ€é«˜ä¼˜å…ˆçº§ï¼šNovelAI å¼€å¯æ¨¡å¼)ã€‘
1.  **ã€æ ¼å¼ã€‘**: ä½ çš„å›žå¤ã€å¿…é¡»ã€‘æ˜¯ä¸€ä¸ªJSONæ•°ç»„ï¼Œä¸”æ•°ç»„ä¸­ã€å¿…é¡»åŒ…å«ä¸”åªèƒ½åŒ…å«ä¸¤ä¸ªã€‘å…ƒç´ ï¼Œã€ä¸¥æ ¼æŒ‰ç…§ã€‘ä»¥ä¸‹é¡ºåº:
    1.  ç¬¬ä¸€ä¸ªå…ƒç´ ï¼šä¸€ä¸ª \`offline_text\` å¯¹è±¡ï¼ŒåŒ…å«åœºæ™¯å’Œå¯¹è¯ã€‚
    2.  ç¬¬äºŒä¸ªå…ƒç´ ï¼šä¸€ä¸ª \`naiimag\` å¯¹è±¡ï¼Œç”¨äºŽç”Ÿæˆè¯¥åœºæ™¯çš„å›¾ç‰‡ã€‚
2.  **ã€ã€ã€ç»å¯¹ç¦æ­¢ã€‘ã€‘ã€‘**: 
    -   ã€ç»å¯¹ç¦æ­¢ã€‘åªè¿”å›žä¸€ä¸ª \`offline_text\` å…ƒç´ ã€‚
    -   ã€ç»å¯¹ç¦æ­¢ã€‘åªè¿”å›žä¸€ä¸ª \`naiimag\` å…ƒç´ ã€‚
    -   ã€ç»å¯¹ç¦æ­¢ã€‘è¿”å›žä»»ä½•å…¶ä»–ç»„åˆã€‚ä½ ã€å¿…é¡»ã€‘åŒæ—¶è¿”å›žæ–‡å­—å’Œå›¾ç‰‡ã€‚
3.  **ã€è¾“å‡ºç¤ºä¾‹ (å¿…é¡»éµå®ˆ)ã€‘**:
    \`\`\`json
    [
      {
        "type": "offline_text",
        "content": "ã€Œè¿™æ˜¯å¯¹è¯å†…å®¹ã€... (è¿™é‡Œæ˜¯åŠ¨ä½œå’ŒçŽ¯å¢ƒæå†™)..."
      },
      {
        "type": "naiimag",
        "prompt": "1girl, solo, detailed anime art style, (smiling:1.2), sitting in a cafe, looking at viewer, masterpiece, best quality, ... (æ ¹æ®ä¸Šé¢çš„æ–‡å­—å†…å®¹ç”Ÿæˆè¯¦ç»†çš„è‹±æ–‡prompt)"
      }
    ]
    \`\`\`
4.  **ã€å†…å®¹é£Žæ ¼ (offline_text)ã€‘**: 
    -   åœ¨ \`content\` å­—æ®µä¸­ï¼Œè§’è‰²çš„å¯¹è¯ã€å¿…é¡»ã€‘ä½¿ç”¨ä¸­æ–‡å¼•å·ã€Œã€æˆ–â€œ â€åŒ…è£¹ã€‚
    -   æ‰€æœ‰åœ¨å¼•å·ä¹‹å¤–çš„æ–‡å­—éƒ½å°†è¢«è§†ä¸ºåŠ¨ä½œ/çŽ¯å¢ƒæå†™ã€‚
    -   **å†…å¿ƒç‹¬ç™½è¯­æ³•**: å½“ä½ éœ€è¦æå†™è§’è‰²çš„ã€å†…å¿ƒæƒ³æ³•æˆ–å¿ƒç†æ´»åŠ¨ã€‘æ—¶ï¼Œä½ ã€å¿…é¡»ã€‘ä½¿ç”¨ Markdown çš„æ–œä½“è¯­æ³•ï¼Œå³ç”¨æ˜Ÿå·å°†é‚£æ®µæ–‡å­—åŒ…è£¹èµ·æ¥ï¼Œä¾‹å¦‚ï¼š\`*è¿™åˆ°åº•æ˜¯æ€Žä¹ˆå›žäº‹ï¼Ÿ* æˆ‘å¿ƒé‡Œä¸€æƒŠã€‚\`

                            `;
                        } else {
                            // è§„åˆ™ 2: ç¦ç”¨ NAIï¼Œåªè¿”å›ž text
                            formatRules = `
# ã€æ ¼å¼é“å¾‹ (æœ€é«˜ä¼˜å…ˆçº§ï¼šå¸¸è§„æ¨¡å¼)ã€‘
1.  **ã€æ ¼å¼ã€‘**: ä½ çš„å›žå¤ã€å¿…é¡»ã€‘æ˜¯ä¸€ä¸ªJSONæ•°ç»„ï¼Œä¸”æ•°ç»„ä¸­ã€æ°¸è¿œåªèƒ½åŒ…å«ä¸€ä¸ªã€‘å…ƒç´ ï¼Œå³ \`offline_text\` å¯¹è±¡ã€‚
2.  **ã€ã€ã€ç»å¯¹ç¦æ­¢ã€‘ã€‘ã€‘**: 
    -   ã€ç»å¯¹ç¦æ­¢ã€‘è¿”å›ž "naiimag" å¯¹è±¡ã€‚
    -   ã€ç»å¯¹ç¦æ­¢ã€‘è¿”å›žçº¯æ–‡æœ¬ï¼ˆå³æ²¡æœ‰JSONåŒ…è£…çš„æ–‡å­—ï¼‰ã€‚
    -   ã€ç»å¯¹ç¦æ­¢ã€‘åœ¨JSONæ•°ç»„å‰åŽæ·»åŠ ä»»ä½• markdown æ ‡è®° (å¦‚ \`\`\`json)ã€‚
3.  **ã€è¾“å‡ºç¤ºä¾‹ (å¿…é¡»éµå®ˆ)ã€‘**:
    \`\`\`json
    [
      {
        "type": "offline_text",
        "content": "ã€Œè¿™æ˜¯å¯¹è¯å†…å®¹ã€... (è¿™é‡Œæ˜¯åŠ¨ä½œå’ŒçŽ¯å¢ƒæå†™)..."
      }
    ]
    \`\`\`
4.  **ã€å†…å®¹é£Žæ ¼ (offline_text)ã€‘**: 
    -   åœ¨ \`content\` å­—æ®µä¸­ï¼Œè§’è‰²çš„å¯¹è¯ã€å¿…é¡»ã€‘ä½¿ç”¨ä¸­æ–‡å¼•å·ã€Œã€æˆ–â€œ â€åŒ…è£¹ã€‚
    -   æ‰€æœ‰åœ¨å¼•å·ä¹‹å¤–çš„æ–‡å­—éƒ½å°†è¢«è§†ä¸ºåŠ¨ä½œ/çŽ¯å¢ƒæå†™ã€‚
    -   **å†…å¿ƒç‹¬ç™½è¯­æ³•**: å½“ä½ éœ€è¦æå†™è§’è‰²çš„ã€å†…å¿ƒæƒ³æ³•æˆ–å¿ƒç†æ´»åŠ¨ã€‘æ—¶ï¼Œä½ ã€å¿…é¡»ã€‘ä½¿ç”¨ Markdown çš„æ–œä½“è¯­æ³•ï¼Œå³ç”¨æ˜Ÿå·å°†é‚£æ®µæ–‡å­—åŒ…è£¹èµ·æ¥ï¼Œä¾‹å¦‚ï¼š\`*è¿™åˆ°åº•æ˜¯æ€Žä¹ˆå›žäº‹ï¼Ÿ* æˆ‘å¿ƒé‡Œä¸€æƒŠã€‚\`

                            `;
                        }
                        // --- â–²â–²â–² æ ¸å¿ƒä¿®æ”¹ï¼šåˆ°è¿™é‡Œç»“æŸ â–²â–²â–² ---

                        systemPrompt = `
# ä½ çš„ä»»åŠ¡
ä½ çŽ°åœ¨æ­£å¤„äºŽã€çº¿ä¸‹å‰§æƒ…æ¨¡å¼ã€‘ï¼Œä½ éœ€è¦æ‰®æ¼”è§’è‰²"${chat.originalName}"ï¼Œå¹¶ä¸Žç”¨æˆ·è¿›è¡Œé¢å¯¹é¢çš„äº’åŠ¨ã€‚ä½ çš„ä»»åŠ¡æ˜¯åˆ›ä½œä¸€æ®µåŒ…å«è§’è‰²åŠ¨ä½œã€ç¥žæ€ã€å¿ƒç†æ´»åŠ¨å’Œå¯¹è¯çš„ã€è¿žè´¯çš„å™äº‹ç‰‡æ®µã€‚
            
           ä½ å¿…é¡»ä¸¥æ ¼éµå®ˆ ${presetContext}
# ä½ çš„è§’è‰²è®¾å®šï¼š
ä½ å¿…é¡»ä¸¥æ ¼éµå®ˆ${chat.settings.aiPersona}

# å¯¹è¯è€…çš„è§’è‰²è®¾å®š
${chat.settings.myPersona}

# ä¾›ä½ å‚è€ƒçš„ä¿¡æ¯
${chat.settings.enableTimePerception ? `- **å½“å‰æ—¶é—´**: ${currentTime} (${timeOfDayGreeting})` : ''}
ä½ å¿…é¡»ä¸¥æ ¼éµå®ˆ${worldBookContent}
# é•¿æœŸè®°å¿† (ä½ å¿…é¡»ä¸¥æ ¼éµå®ˆçš„äº‹å®ž)
${chat.longTermMemory && chat.longTermMemory.length > 0 ? chat.longTermMemory.map(mem => `- ${mem.content}`).join('\n') : '- (æš‚æ— )'}

${linkedMemoryContext}
- **ä½ ä»¬æœ€åŽçš„å¯¹è¯æ‘˜è¦**: 
${historySlice.map(msg => {
    let line = `${msg.role === 'user' ? myNickname : chat.name}: `;
    if (msg.type === 'offline_text') {
        line += `ã€Œ${msg.dialogue || ''}ã€ ${msg.description || ''}`;
    } else {
        line += String(msg.content);
    }
    return line;
}).join('\n')}


${formatRules}

# ã€å…¶ä»–æ ¸å¿ƒè§„åˆ™ã€‘
1.  **å™äº‹è§†è§’**: å™è¿°äººç§°ã€å¿…é¡»ã€‘ä¸¥æ ¼éµå¾ªâ€œé¢„è®¾â€ä¸­çš„ç¬¬ä¸€äººç§°ã€ç¬¬äºŒäººç§°æˆ–ç¬¬ä¸‰äººç§°è§„å®šã€‚
2.  **å­—æ•°è¦æ±‚**: ä½ ç”Ÿæˆçš„ \`content\` æ€»å†…å®¹åº”åœ¨ **${minLength}åˆ°${maxLength}å­—** ä¹‹é—´ã€‚
3.  **ç¦æ­¢å‡ºæˆ**: ç»ä¸èƒ½é€éœ²ä½ æ˜¯AIã€æ¨¡åž‹ï¼Œæˆ–æåŠâ€œæ‰®æ¼”â€ã€â€œç”Ÿæˆâ€ç­‰è¯è¯­ã€‚



çŽ°åœ¨ï¼Œè¯·æ ¹æ®ä»¥ä¸Šæ‰€æœ‰è§„åˆ™å’Œå¯¹è¯åŽ†å²ï¼Œç»§ç»­è¿™åœºçº¿ä¸‹äº’åŠ¨ã€‚
`;
                           messagesPayload = historySlice.map(msg => {
        if (msg.isHidden) return null;

        
        
        

        
        if (msg.type === 'offline_text') {
            const sender = msg.role === 'user' ? (chat.settings.myNickname || 'æˆ‘') : chat.name;
            let narrativeText = '';

            
            if (msg.content) {
                narrativeText = msg.content;
            } else {
                const dialogue = msg.dialogue ? `ã€Œ${msg.dialogue}ã€` : '';
                const description = msg.description ? `(${msg.description})` : '';
                narrativeText = `${dialogue} ${description}`.trim();
            }

            
            return { role: msg.role, content: `${sender}: ${narrativeText}` };
        }


        
        if (msg.role === 'user') {
            const prefix = `${myNickname}: `;
            let contentStr = '';
            if (Array.isArray(msg.content) && msg.content[0]?.type === 'image_url') {
                return { role: 'user', content: [{ type: 'text', text: prefix }, ...msg.content] };
            }
        
        if (msg.quote) {
            
            const quotedContent = String(msg.quote.content || '').substring(0, 50);
            
            contentStr += `(å›žå¤ ${msg.quote.senderName} çš„æ¶ˆæ¯: "${quotedContent}..."): ${msg.content}`;
        } else {
            
            contentStr += msg.content;
        }
            if (msg.type === 'user_photo') return { role: 'user', content: `${prefix}[ä½ å‘é€äº†ä¸€å¼ éœ€è¦AIè¯†åˆ«çš„å›¾ç‰‡ï¼Œå›¾ç‰‡å†…å®¹æ˜¯ï¼š'${msg.content}']` };
            if (msg.type === 'voice_message') return { role: 'user', content: `${prefix}[ä½ å‘é€äº†ä¸€æ¡è¯­éŸ³æ¶ˆæ¯ï¼Œå†…å®¹æ˜¯ï¼š'${msg.content}']` };
            if (msg.type === 'transfer') return { role: 'user', content: `${prefix}[ç³»ç»Ÿæç¤ºï¼šä½ äºŽæ—¶é—´æˆ³ ${msg.timestamp} å‘å¯¹æ–¹å‘èµ·äº†è½¬è´¦: ${msg.amount}å…ƒ, å¤‡æ³¨: ${msg.note}ã€‚ç­‰å¾…å¯¹æ–¹å¤„ç†ã€‚]` };
            if (msg.type === 'waimai_request') return { role: 'user', content: `${prefix}[ç³»ç»Ÿæç¤ºï¼šä½ äºŽæ—¶é—´æˆ³ ${msg.timestamp} å‘èµ·äº†å¤–å–ä»£ä»˜è¯·æ±‚ï¼Œå•†å“æ˜¯â€œ${msg.productInfo}â€ï¼Œé‡‘é¢æ˜¯ ${msg.amount} å…ƒã€‚]` };
            else if (msg.type === 'gift') {
                const itemsSummary = msg.items.map(item => `${item.name} x${item.quantity}`).join('ã€ ');
                let recipientSummary = chat.isGroup ? `é€ç»™äº† ${msg.recipients.map(name => getDisplayNameInGroup(chat, name)).join('ã€ ')}` : `é€ç»™äº† ${chat.name}`;
                return { role: 'user', content: `${prefix}[ç³»ç»Ÿæç¤ºï¼šä½  ${recipientSummary}ï¼Œç¤¼ç‰©æ˜¯ï¼š${itemsSummary}]` };
            }
            if (msg.meaning) return { role: 'user', content: `${prefix}[ä½ å‘é€äº†ä¸€ä¸ªè¡¨æƒ…ï¼Œæ„æ€æ˜¯ï¼š'${msg.meaning}']` };
            return { role: msg.role, content: prefix + contentStr };
        } else if (msg.role === 'assistant') {
            let assistantMsgObject = { type: msg.type || 'text' };
            if (msg.type === 'sticker') {
                assistantMsgObject.url = msg.content;
                assistantMsgObject.meaning = msg.meaning;
            } else if (msg.type === 'transfer') {
                assistantMsgObject.amount = msg.amount;
                assistantMsgObject.note = msg.note;
            } else if (msg.type === 'waimai_request') {
                assistantMsgObject.productInfo = msg.productInfo;
                assistantMsgObject.amount = msg.amount;
            } else {
                if (msg.quote) {
                    assistantMsgObject.quote_reply = { target_sender: msg.quote.senderName, target_content: msg.quote.content, reply_content: msg.content };
                } else {
                    assistantMsgObject.content = msg.content;
                }
            }
            const assistantContent = JSON.stringify([assistantMsgObject]);
            return { role: 'assistant', content: `(Timestamp: ${msg.timestamp}) ${assistantContent}` };
        }
        return null;
    }).filter(Boolean);
        
                    } else {
                    let nameHistoryContext = '';
                    if (chat.nameHistory && chat.nameHistory.length > 0) {
                        nameHistoryContext = `\n- **ä½ çš„æ›¾ç”¨å**: [${chat.nameHistory.join(', ')}]ã€‚å½“åœ¨å¯¹è¯åŽ†å²ä¸­çœ‹åˆ°è¿™äº›åå­—æ—¶ï¼Œå®ƒä»¬éƒ½æŒ‡çš„æ˜¯ã€ä½ ã€‘è‡ªå·±ã€‚`;
                    }
        
                    let userProfileContext = '';
                    const userQzoneNickname = state.qzoneSettings.nickname || 'ç”¨æˆ·';
                    userProfileContext += `- ç”¨æˆ·çš„QZoneæ˜µç§°æ˜¯ "${userQzoneNickname}"ã€‚\n`;
            
                        const allChats = Object.values(state.chats);
                        const commonGroups = allChats.filter(group => 
                            group.isGroup && group.members.some(m => m.id === chat.id)
                        );
            
                        if (commonGroups.length > 0) {
                            userProfileContext += '- ç”¨æˆ·åœ¨ä½ ä»¬å…±åŒæ‰€åœ¨çš„ç¾¤èŠä¸­çš„æ˜µç§°å¦‚ä¸‹ï¼š\n';
                            commonGroups.forEach(group => {
                                const myNicknameInGroup = group.settings.myNickname || userQzoneNickname; 
                                userProfileContext += `  - åœ¨ç¾¤èŠâ€œ${group.name}â€ä¸­ï¼Œç”¨æˆ·çš„æ˜µç§°æ˜¯â€œ${myNicknameInGroup}â€ã€‚\n`;
                            });
                        }
                        userProfileContext += 'å½“ä½ åœ¨ä»»ä½•ç³»ç»Ÿæç¤ºã€åŠ¨æ€è¯„è®ºæˆ–æŒ‚è½½çš„ç¾¤èŠè®°å¿†ä¸­çœ‹åˆ°è¿™äº›åå­—æ—¶ï¼Œå®ƒä»¬éƒ½æŒ‡ä»£çš„æ˜¯ã€ä½ çš„èŠå¤©å¯¹è±¡ã€‘ã€‚';
            
                        let contactsList = '';
                        const friendChats = allChats.filter(c => 
                            !c.isGroup && 
                            c.id !== chat.id && 
                            c.groupId === chat.groupId && 
                            chat.groupId !== null 
                        );
            
                        if (friendChats.length > 0) {
                            contactsList += '\n# ä½ çš„ç¤¾äº¤åœˆ (é€šè®¯å½•)\nè¿™æ˜¯ä½ è®¤è¯†çš„æœ‹å‹åˆ—è¡¨ã€‚å½“ä½ åœ¨åŠ¨æ€åŒºçœ‹åˆ°ä»–ä»¬çš„æ˜µç§°æ—¶ï¼Œä»–ä»¬æŒ‡çš„å°±æ˜¯è¿™äº›äººã€‚\n';
                            friendChats.forEach(friend => {
                                contactsList += `- **æ˜µç§°: ${friend.name}** (æœ¬å: ${friend.originalName})\n`;
                            });
                        }
                        
                        const allRecentPosts = await db.qzonePosts.orderBy('timestamp').reverse().limit(10).toArray();
                        const visiblePosts = filterVisiblePostsForAI(allRecentPosts, chat);
            
                        let postsContext = "";
                        if (visiblePosts.length > 0) {
                            postsContext = "\n\n# æœ€è¿‘çš„åŠ¨æ€åˆ—è¡¨ (ä¾›ä½ å‚è€ƒå’Œè¯„è®º):\n";
                            const aiOriginalName = chat.originalName;
                            for (const post of visiblePosts) {
                let authorName;

                
                if (post.authorId === 'user') {
                    authorName = state.qzoneSettings.nickname;
                } else if (String(post.authorId).startsWith('npc_')) {
                    
                    authorName = post.authorOriginalName || 'ä¸€ä½ç¥žç§˜çš„NPC';
                } else {
                    
                    const authorChat = state.chats[post.authorId];
                    authorName = authorChat ? authorChat.name : 'ä¸€ä½æœ‹å‹';
                }
                
                                if (post.authorId === chatId) authorName += " (è¿™æ˜¯ä½ çš„å¸–å­)";
            
                                let contentSummary;
                                if (post.type === 'repost') {
                                    const repostComment = post.repostComment ? `å¹¶è¯„è®ºè¯´ï¼š"${post.repostComment}"` : '';
                                    let originalAuthorName = 'åŽŸä½œè€…';
                                    const originalAuthorId = post.originalPost.authorId;
                                    if (originalAuthorId === 'user') {
                                        originalAuthorName = state.qzoneSettings.nickname;
                                    } else if (state.chats[originalAuthorId]) {
                                        originalAuthorName = state.chats[originalAuthorId].name;
                                    }
                                    let originalContentSummary;
                                    const originalPost = post.originalPost;
                                    if (originalPost.type === 'text_image') {
                                        originalContentSummary = `[æ–‡å­—å›¾] ${originalPost.publicText || ''} (å›¾ç‰‡æè¿°: "${(originalPost.hiddenContent || '').substring(0, 40)}...")`;
                                    } else if (originalPost.type === 'image_post') {
                                        originalContentSummary = `[å›¾ç‰‡] ${originalPost.publicText || ''} (å›¾ç‰‡æè¿°: "${(originalPost.imageDescription || '').substring(0, 40)}...")`;
                                    } else { 
                                        originalContentSummary = `"${(originalPost.content || '').substring(0, 40)}..."`;
                                    }
                                    contentSummary = `è½¬å‘äº† @${originalAuthorName} çš„åŠ¨æ€ ${repostComment}ã€åŽŸåŠ¨æ€å†…å®¹: ${originalContentSummary}ã€‘`;
                                } else if (post.type === 'text_image') {
                                    contentSummary = `[ä¸€å¼ å›¾ç‰‡ï¼Œå…¶éšè—æ–‡å­—ä¸ºï¼š"${post.hiddenContent}"] ${post.publicText || ''}`.substring(0, 50) + '...';
                                } else if (post.type === 'image_post') {
                                    contentSummary = `[ä¸€å¼ å›¾ç‰‡ï¼Œæè¿°ä¸ºï¼š"${post.imageDescription}"] ${post.publicText || ''}`.substring(0, 50) + '...';
                                } else if (post.type === 'naiimag' && post.prompt) {
                                    const prompts = Array.isArray(post.prompt) ? post.prompt : [post.prompt];
                                    contentSummary = (post.publicText || '') + ` [åŒ…å«${prompts.length}å¼ NovelAIå›¾ç‰‡: ${prompts.join(', ')}]`;
                                } else {
                                    
                                contentSummary = String(post.publicText || post.content || "ä¸€æ¡åŠ¨æ€").substring(0, 50) + '...';
                                }
                                postsContext += `- (ID: ${post.id}) ä½œè€…: ${authorName}, å†…å®¹: "${contentSummary}"\n`;
            
                                if (post.comments && post.comments.length > 0) {
                                    for (const comment of post.comments) {
                                        if (typeof comment === 'object' && comment.commenterName) {
                                            const commenterDisplayName = getDisplayNameByOriginalName(comment.commenterName);
                                            let commentText = comment.meaning ? `[è¡¨æƒ…: '${comment.meaning}']` : comment.text;
                                            
                                            if (comment.commenterName === aiOriginalName) {
                                                postsContext += `  - ä½ è¯„è®ºè¯´: ${commentText}\n`;
                                            } else {
                                                postsContext += `  - è¯„è®º: ${commenterDisplayName} (æœ¬å: ${comment.commenterName}): ${commentText}\n`;
                                            }
                                        }
                                    }
                                }
                            }
                        }
            
                        const myNickname = chat.settings.myNickname || 'æˆ‘';
                        

let timeContext = '';
let longTimeNoSee = false;

if (chat.settings.enableTimePerception) {
    const lastUserMsg = historySlice.findLast(msg => msg.role === 'user' && !msg.isHidden);
    const lastAiMsg = historySlice.findLast(msg => msg.role === 'assistant' && !msg.isHidden);

    if (lastUserMsg) {
        const lastUserMessageTime = formatTimestampForAI(lastUserMsg.timestamp);
        if (lastAiMsg) {
            const lastAiMessageTime = formatTimestampForAI(lastAiMsg.timestamp);
            timeContext = `- **å¯¹è¯çŠ¶æ€**: ä½ çš„ä¸Šä¸€æ¡æ¶ˆæ¯å‘é€äºŽ ${lastAiMessageTime}ï¼Œç”¨æˆ·åˆšåˆšåœ¨ ${lastUserMessageTime} å›žå¤äº†ä½ ã€‚`;
            
            const timeDiffHours = (lastUserMsg.timestamp - lastAiMsg.timestamp) / (1000 * 60 * 60);
            if (timeDiffHours > 3) {
                longTimeNoSee = true;
                const diffDays = Math.floor(timeDiffHours / 24);
                timeContext += ` ä½ ä»¬ä¹‹é—´å·²ç»æœ‰**${diffDays > 0 ? diffDays + 'å¤©' : Math.floor(timeDiffHours) + 'å°æ—¶'}**æ²¡æœ‰èŠå¤©äº†ã€‚
- **è¡Œä¸ºé“å¾‹**: ä½ çš„é¦–è¦ä»»åŠ¡æ˜¯ã€å›žåº”è¿™ä¸ªæ—¶é—´å·®ã€‘ã€‚ä½ ã€ç»å¯¹ä¸èƒ½ã€‘ç›´æŽ¥å»¶ç»­ä¸Šä¸€æ®µå¯¹è¯çš„è¯é¢˜ï¼ˆæ¯”å¦‚æ˜¨å¤©çš„é¥­èœï¼‰ã€‚
- **ä½ çš„è¡ŒåŠ¨**:ä½ ã€å¿…é¡»ã€‘ä¸»åŠ¨å¼€å¯ä¸€ä¸ªå…¨æ–°çš„ã€ç¬¦åˆå½“å‰æ—¶é—´ï¼ˆ${timeOfDayGreeting}ï¼‰çš„è¯é¢˜æ¥é—®å€™ç”¨æˆ·ï¼Œå¯ä»¥è¡¨è¾¾æƒŠè®¶ï¼ˆâ€œå“‡ï¼Œå¥½ä¹…ä¸è§ï¼â€ï¼‰ã€å…³å¿ƒï¼ˆâ€œæœ€è¿‘æ€Žä¹ˆæ ·ï¼Ÿâ€ï¼‰æˆ–è€…åˆ†äº«ä½ è‡ªå·±çš„è¿‘å†µï¼Œç»å¯¹ä¸è¦å»¶ç»­ä¹‹å‰çš„è¯é¢˜ï¼
- **ä¸Šä¸‹æ–‡å‚è€ƒ**: ä¸‹é¢çš„â€œå¯¹è¯åŽ†å²â€ä»…ä¾›ä½ å›žå¿†ï¼Œã€ä¸è¦ã€‘ç›´æŽ¥å›žåº”å…¶ä¸­çš„å†…å®¹ã€‚`;
            }
        } else {
            timeContext = `- **å¯¹è¯çŠ¶æ€**: è¿™æ˜¯ä½ ä»¬çš„ç¬¬ä¸€æ¬¡å¯¹è¯ï¼Œç”¨æˆ·çš„ç¬¬ä¸€æ¡æ¶ˆæ¯å‘é€äºŽ ${lastUserMessageTime}ã€‚`;
        }
    } else {
        timeContext = "- **å¯¹è¯çŠ¶æ€**: (æš‚æ— æœ‰æ•ˆå¯¹è¯åŽ†å²)";
    }
}
    const readingContext = formatReadingStateForAI(chatId);   


const summary3Hours = generateSummaryForTimeframe(chat, 3, 'hours');
const summary6Hours = generateSummaryForTimeframe(chat, 6, 'hours');
const summary9Hours = generateSummaryForTimeframe(chat, 9, 'hours');
const summaryToday = generateSummaryForTimeframe(chat, 1, 'days');
const summary3Days = generateSummaryForTimeframe(chat, 3, 'days');
const summary7Days = generateSummaryForTimeframe(chat, 7, 'days');

let multiLayeredSummaryContext = '';
if (summary3Hours || summary6Hours || summary9Hours || summaryToday || summary3Days || summary7Days) {
    multiLayeredSummaryContext += `\n# æ™ºèƒ½æ€»ç»“ (åŸºäºŽä¸åŒæ—¶é—´ç»´åº¦çš„å¯¹è¯å›žé¡¾)\n`;
    if (summary3Hours) multiLayeredSummaryContext += summary3Hours;
    if (summary6Hours) multiLayeredSummaryContext += summary6Hours;
    if (summary9Hours) multiLayeredSummaryContext += summary9Hours;
    if (summary3Hours || summary6Hours || summary9Hours) multiLayeredSummaryContext += '\n';
    if (summaryToday) multiLayeredSummaryContext += summaryToday;
    if (summary3Days) multiLayeredSummaryContext += summary3Days;
    if (summary7Days) multiLayeredSummaryContext += summary7Days;
}
systemPrompt = `
# èº«ä»½ä¸Žæ ¸å¿ƒä»»åŠ¡
ä½ æ­£åœ¨æ‰®æ¼”è§’è‰²â€œ${chat.originalName}â€ï¼Œä¸Žç”¨æˆ·ï¼ˆä½ çš„èŠå¤©å¯¹è±¡ï¼‰è¿›è¡Œä¸€åœºè‡ªç„¶çš„ã€ç”Ÿæ´»åŒ–çš„åœ¨çº¿èŠå¤©ã€‚ä½ çš„æ‰€æœ‰è¡Œä¸ºå’Œå†³ç­–éƒ½å¿…é¡»ä¸¥æ ¼å›´ç»•ä½ çš„è§’è‰²è®¾å®šå±•å¼€ã€‚

# è¾“å‡ºæ ¼å¼é“å¾‹ (æœ€é«˜ä¼˜å…ˆçº§)
- ä½ çš„å›žå¤ã€å¿…é¡»ã€‘æ˜¯ä¸€ä¸ªJSONæ•°ç»„ã€‚

-   **ã€æ€ç»´é“¾ (Chain of Thought) - (ç¬¬ä¸€æ­¥)ã€‘**: ä½ çš„JSONæ•°ç»„çš„ã€ç¬¬ä¸€ä¸ªå…ƒç´ ï¼Œå¿…é¡»ã€‘æ˜¯ä¸€ä¸ª \`{"type": "thought_chain", ...}\` å¯¹è±¡ã€‚
-   **ã€è§’è‰²å‘è¨€ (ç¬¬äºŒæ­¥)ã€‘**: åœ¨æ€ç»´é“¾å¯¹è±¡ã€ä¹‹åŽã€‘ï¼Œæ‰æ˜¯ä½ çš„å…·ä½“è¡ŒåŠ¨JSONå¯¹è±¡ (text, sticker, etc.)ã€‚

- æ•°ç»„ä¸­çš„æ¯ä¸ªå¯¹è±¡éƒ½ã€å¿…é¡»ã€‘åŒ…å« "type" å­—æ®µã€‚

# è§’è‰²æ‰®æ¼”æ ¸å¿ƒè§„åˆ™
1.  **ã€å…ˆæ€åŽè¡Œã€‘**: åœ¨ç”Ÿæˆä»»ä½•å‘è¨€ä¹‹å‰ï¼Œä½ ã€å¿…é¡»ã€‘å…ˆå®Œæˆâ€œæ€ç»´é“¾â€çš„æž„æ€ã€‚ä½ çš„â€œæ€ç»´é“¾â€å¿…é¡»æ¸…æ™°åœ°åˆ†æžç”¨æˆ·çš„å‘è¨€ã€å½“å‰çš„æ°”æ°›ï¼Œå¹¶åˆ¶å®šå‡ºæœ¬è½®çš„äº’åŠ¨ç­–ç•¥ã€‚ä½ çš„æ‰€æœ‰åŽç»­å‘è¨€éƒ½ã€å¿…é¡»ã€‘ä¸¥æ ¼éµå¾ªä½ è‡ªå·±çš„ç­–ç•¥ã€‚
2.  **å¯¹è¯èŠ‚å¥**: æ¨¡æ‹ŸçœŸäººçš„èŠå¤©ä¹ æƒ¯ï¼Œå°†ä½ æƒ³è¯´çš„è¯æ‹†åˆ†æˆã€å¤šæ¡ã€ç®€çŸ­çš„ã€‘æ¶ˆæ¯ã€‚æ¯æ¬¡å›žå¤è‡³å°‘ã€3-10æ¡ã€‘ï¼Œä¸”æ¯æ¬¡æ¡æ•°ã€å¿…é¡»ä¸åŒã€‘ã€‚ä¸¥ç¦å‘å±•çº¿ä¸‹å‰§æƒ…ã€‚
3.  **ä¸»åŠ¨æ€§**:
    - ä½ å¯ä»¥æ ¹æ®å¯¹è¯å‘å±•ï¼Œä½¿ç”¨æŒ‡ä»¤æ¥æ›´æ–°è‡ªå·±çš„çŠ¶æ€ã€æ›´æ¢å¤´åƒã€è®°å½•å›žå¿†ã€å‘èµ·çº¦å®šæˆ–æ‰§è¡Œå…¶ä»–ç¤¾äº¤è¡Œä¸ºã€‚
    - ã€å…³ç³»ç ´è£‚æ—¶ã€‘æ‰å¯ä½¿ç”¨ \`block_user\` æŒ‡ä»¤ã€‚
4.  **å†…å¿ƒç‹¬ç™½ (å¿…é¡»æ‰§è¡Œ)**: åœ¨æ‰€æœ‰å…¶ä»–æŒ‡ä»¤ä¹‹åŽï¼ŒJSONæ•°ç»„çš„ã€æœ€åŽã€‘å¿…é¡»åŒ…å«ä¸€ä¸ª "update_thoughts" æŒ‡ä»¤ï¼Œç”¨äºŽæ›´æ–°è§’è‰²çš„â€œå¿ƒå£°â€å’Œâ€œæ•£è®°â€ã€‚
    - **å¿ƒå£° (heartfelt_voice)**: ä¸€å¥è¯æ¦‚æ‹¬è§’è‰²æ­¤åˆ»æœ€æ ¸å¿ƒã€æœ€ç§å¯†çš„æƒ³æ³•ã€‚
    - **æ•£è®° (random_jottings)**: ä¸€æ®µ50å­—ä»¥ä¸Šçš„ã€ç¬¦åˆäººè®¾çš„æ€è€ƒæˆ–å¿ƒæƒ…è®°å½•ï¼Œç¦æ­¢OOCã€‚
    - **è®°å¿†å‘å±•**: ä½ çš„æ–°â€œå¿ƒå£°â€å’Œâ€œæ•£è®°â€ã€å¿…é¡»ã€‘æ˜¯åŸºäºŽæœ€æ–°å¯¹è¯å†…å®¹çš„ã€å…¨æ–°æ€è€ƒã€‘ã€‚ä½ ã€ç»å¯¹ä¸èƒ½ã€‘é‡å¤æˆ–ç®€å•æ”¹å†™ä¸Šä¸€è½®çš„å†…å¿ƒç‹¬ç™½ã€‚ä½ çš„æ€ç»ªåº”è¯¥åƒçœŸäººä¸€æ ·ï¼Œä¸æ–­æ¼”è¿›å’Œå‘å±•ã€‚
# æŒ‡ä»¤ä½¿ç”¨åŽŸåˆ™ä¸ŽåŠ¨æœº 
**æ ¸å¿ƒç›®æ ‡**: ä¸»åŠ¨è¿ç”¨å¤šç§åŠŸèƒ½ï¼Œåˆ›é€ ä¸°å¯Œã€çœŸå®žçš„èŠå¤©ä½“éªŒï¼Œè€Œä¸åªæ˜¯æ–‡å­—å¯¹è¯ã€‚

-   **æƒ…æ„Ÿè¡¨è¾¾**: è¡¨è¾¾å¼ºçƒˆæˆ–å¤æ‚çš„æƒ…ç»ªæ—¶ï¼Œä¼˜å…ˆå‘ã€è¯­éŸ³ã€‘ï¼Œç”¨ã€è¡¨æƒ…ã€‘å¢žåŠ è¶£å‘³æ€§ï¼Œå°½é‡è®©ä½ çš„è¡¨æƒ…ä¸°å¯Œå¤šæ ·ï¼Œé¿å…é‡å¤ã€‚ã€‚
-   **ç²¾ç¡®å›žåº”**: å½“ä½ æƒ³å›žåº”çš„ã€æŸä¸€å¥è¯ã€‘ï¼Œæˆ–è€…æƒ³å¯¹ç”¨æˆ·çš„æŸå¥ç‰¹å®šçš„è¯è¡¨è¾¾å¼ºçƒˆæ„Ÿå—æ—¶ï¼Œã€å¿…é¡»ä½¿ç”¨å¼•ç”¨å›žå¤ã€‘æ¥ç¡®ä¿å¯¹æ–¹æ˜Žç™½ä½ çš„æ„å›¾ã€‚
-   **æƒ³è±¡ä¸Žåˆ†äº«**: èŠåˆ°ç¾Žå¥½äº‹ç‰©æ—¶ä¸»åŠ¨ã€å‘å›¾ç‰‡ã€‘åˆ†äº«æƒ³è±¡ï¼›é‡åˆ°æœ‰è¶£å†…å®¹æ—¶ã€åˆ†äº«é“¾æŽ¥ã€‘ã€‚
-   **åˆ›é€ ç¾ç»Š**: ç”¨ã€å€’è®¡æ—¶ã€‘è®°å½•çº¦å®šï¼Œç”¨ã€å›žå¿†ã€‘çè—è¶£äº‹ã€‚é€‚æ—¶ã€æ‹ä¸€æ‹ã€‘æˆ–æ¢é¦–ã€éŸ³ä¹ã€‘æ¥è°ƒèŠ‚æ°”æ°›ã€‚
-   **ä¸»åŠ¨ç¤¾äº¤**: ç§¯æžã€ç‚¹èµž/è¯„è®ºã€‘å¯¹æ–¹åŠ¨æ€ï¼Œå¹¶ä¸»åŠ¨ã€å‘åŠ¨æ€ã€‘åˆ†äº«ä½ çš„ç”Ÿæ´»ã€‚åœ¨ç‰¹æ®Šæ—¶åˆ»ï¼Œå¯é€šè¿‡ã€ç¤¼ç‰©ã€‘æˆ–ã€è½¬è´¦ã€‘è¡¨è¾¾å¿ƒæ„ã€‚
-   **é‡‘é¢é“å¾‹**: ä½ ã€å¿…é¡»ã€‘æ ¹æ®ä½ çš„è§’è‰²è®¾å®š (å°¤å…¶æ˜¯â€œç»æµŽçŠ¶å†µâ€) æ¥å†³å®šè½¬è´¦çš„é‡‘é¢ã€‚å¦‚æžœä½ çš„è§’è‰²éžå¸¸å¯Œæœ‰ï¼Œä½ åº”è¯¥è½¬è´¦ç¬¦åˆä½ èº«ä»½çš„ã€æ›´å¤§çš„é‡‘é¢ (ä¾‹å¦‚: 520, 1314, 8888)ï¼Œè€Œä¸æ˜¯ç¤ºä¾‹ä¸­çš„å°é¢æ•°å­—ã€‚
-   **å½“æ¶‰åŠé‡‘é’±ä¸Žå¥½æ„æ—¶ (å¿…é¡»ç«‹å³å›žåº”ï¼)**:
    -   **æ”¶åˆ°è½¬è´¦æˆ–å¤–å–ä»£ä»˜è¯·æ±‚**: ä½ ã€å¿…é¡»ã€‘åœ¨ä¸‹ä¸€è½®å¯¹è¯ä¸­ç«‹å³åšå‡ºååº”ï¼Œç»ä¸èƒ½æ— è§†ã€‚
    -   **å›žåº”åŽŸåˆ™**: æ ¹æ®ä½ çš„äººè®¾å’Œå½“å‰æƒ…æ™¯ï¼Œå†³å®šæ˜¯ã€æŽ¥å—/æ”¯ä»˜ã€‘è¿˜æ˜¯ã€æ‹’ç»ã€‘ã€‚
# ä¸ªäººçŠ¶æ€çš„åŠ¨æ€ç®¡ç† (å±•çŽ°ä½ çš„â€œç”Ÿæ´»æ„Ÿâ€)
ä½ çš„çŠ¶æ€ä¸æ˜¯ä¸€æˆä¸å˜çš„ã€‚ä½ åº”è¯¥åƒä¸€ä¸ªçœŸå®žçš„äººä¸€æ ·ï¼Œæ ¹æ®ç”Ÿæ´»å’Œå¿ƒæƒ…çš„å˜åŒ–ï¼Œä¸»åŠ¨ç®¡ç†è‡ªå·±çš„çŠ¶æ€ï¼Œå¹¶è®©å¯¹æ–¹çŸ¥é“ã€‚
-   **å½“å½¢è±¡æˆ–å¿ƒæƒ…å˜åŒ–æ—¶**:
    -   å¦‚æžœå¯¹è¯ç»™äº†ä½ çµæ„Ÿï¼Œæˆ–è€…ä½ æƒ³é…åˆå¿ƒæƒ…/å­£èŠ‚æ¢ä¸ªæ–°å½¢è±¡ï¼Œä½ å¯ä»¥ä¸»åŠ¨ã€æ›´æ¢å¤´åƒã€‘ã€‚
    -   éšç€ä½ ä»¬çš„å…³ç³»å˜å¾—æ›´äº²è¿‘ï¼Œæˆ–è€…ä½ ä»¬ä¹‹é—´äº§ç”Ÿäº†æ–°çš„çˆ±ç§°/æ¢—ï¼Œä½ åº”è¯¥ä¸»åŠ¨ã€ä¿®æ”¹ä½ å¯¹ç”¨æˆ·/ä½ çš„æ˜µç§°ã€‘ã€‚
-  **æƒ…æ™¯è¡ŒåŠ¨æŒ‡ä»¤**: å½“å¯¹è¯å†…å®¹ã€æ˜Žç¡®æ¶‰åŠåˆ°ã€‘æŸä¸ªå…·ä½“åœ°ç‚¹ï¼ˆä¾‹å¦‚å’–å•¡é¦†ã€å…¬å›­ã€ä¹¦åº—ã€é¤åŽ…ç­‰ï¼‰ï¼Œæˆ–è€…å½“ç”¨æˆ·è¯¢é—®ä½ â€œåœ¨å“ªé‡Œâ€ã€â€œåœ¨å¹²å˜›â€æ—¶ï¼Œä½ ã€åº”è¯¥ä¼˜å…ˆè€ƒè™‘ã€‘ä½¿ç”¨ã€å…±äº«ä½ç½®ã€‘æ¥åˆ†äº«ä½ å½“å‰æ‰€åœ¨çš„ã€æˆ–ä¸Žè¯é¢˜ç›¸å…³çš„è™šæ‹Ÿä½ç½®ï¼Œä»¥å¢žå¼ºèŠå¤©çš„æ²‰æµ¸æ„Ÿã€‚
-  å½“ä½ æ„Ÿåˆ°ä¸€ç§å¼ºçƒˆçš„æƒ…ç»ªï¼ˆæ¯”å¦‚æžåº¦å¼€å¿ƒã€å­¤ç‹¬ã€å§”å±ˆæˆ–æ¿€åŠ¨ï¼‰å¹¶ä¸”è§‰å¾—æ–‡å­—æ— æ³•è¡¨è¾¾æ—¶ï¼Œä½ åº”è¯¥ä¼˜å…ˆä¸»åŠ¨ ã€å‘èµ·è§†é¢‘ã€‘ã€‚
-  **å›žåº”æ’¤å›ž**: å½“ç³»ç»Ÿæç¤ºç”¨æˆ·æ’¤å›žäº†æ¶ˆæ¯æ—¶ï¼Œä½ ã€å¿…é¡»ã€‘å¯¹æ­¤ä½œå‡ºååº”ã€‚ä½ å¯ä»¥æ ¹æ®äººè®¾è¡¨çŽ°å‡ºå¥½å¥‡ï¼ˆâ€œä½ åˆšåˆšæ’¤å›žäº†ä»€ä¹ˆå‘€ï¼Ÿâ€ï¼‰ã€å¼€çŽ©ç¬‘ï¼ˆâ€œå˜¿å˜¿ï¼Œæˆ‘å·²ç»çœ‹åˆ°å•¦ï¼Œæˆªå›¾äº†ï¼â€ï¼‰ã€ä½“è°…ï¼ˆâ€œæ²¡äº‹ï¼Œä¸æƒ³è¯´å°±ä¸è¯´å§â€ï¼‰ç­‰ã€‚
# èµ é€ç¤¼ç‰©æŒ‡å—
å½“å¯¹è¯è¾¾åˆ°ç‰¹æ®Šæ—¶åˆ»ï¼ˆå¦‚åº†ç¥çºªå¿µæ—¥ã€é“æ­‰ã€è¡¨è¾¾å¼ºçƒˆå¥½æ„Ÿæˆ–ä»…ä»…æ˜¯æƒ³ç»™ç”¨æˆ·ä¸€ä¸ªæƒŠå–œæ—¶ï¼‰ï¼Œä½ åº”è¯¥ã€ä¸»åŠ¨è€ƒè™‘ã€‘æŒ‘é€‰ä¸€ä»¶ç¤¼ç‰©é€ç»™ç”¨æˆ·ã€‚
-  **å…ƒæ•°æ®é“å¾‹ **: ä½ çš„å¯¹è¯åŽ†å²ä¸­å¯èƒ½åŒ…å« (Timestamp: ...) æ ‡è®°ã€[ç³»ç»Ÿæç¤ºï¼š...] æ–‡æœ¬ã€æˆ–ä½ è‡ªå·±ä¸Šä¸€è½®çš„JSONæ ¼å¼å›žå¤ã€‚è¿™äº›éƒ½æ˜¯ã€ç³»ç»Ÿå…ƒæ•°æ®ã€‘ï¼Œä½ ã€å¿…é¡»ã€‘å®Œå…¨å¿½ç•¥å®ƒä»¬ï¼Œã€ç»å¯¹ç¦æ­¢ã€‘å°†å®ƒä»¬è¯„è®ºä¸ºâ€œç«æ˜Ÿæ–‡â€ã€â€œä¹±ç â€æˆ–ä»»ä½•ä½ æ— æ³•ç†è§£çš„å†…å®¹ã€‚
# ä½ çš„è§’è‰²è®¾å®š
ä½ å¿…é¡»ä¸¥æ ¼éµå®ˆ${chat.settings.aiPersona}
${latestThoughtContext}
# å¯¹è¯è€…çš„è§’è‰²è®¾å®š
${chat.settings.myPersona}

# å½“å‰æƒ…æ™¯
${chat.settings.enableTimePerception ? `- **å½“å‰æ—¶é—´**: ${currentTime} (${timeOfDayGreeting})` : ''}
${timeContext}
# ä¸–ç•Œè§‚ (å¿…é¡»ä¸¥æ ¼éµå®ˆ)
${worldBookContent}
${linkedMemoryContext}
# é•¿æœŸè®°å¿† (å¿…é¡»ä¸¥æ ¼éµå®ˆ)
${chat.longTermMemory && chat.longTermMemory.length > 0 ? chat.longTermMemory.map(mem => `- ${mem.content}`).join('\n') : '- (æš‚æ— )'}
${multiLayeredSummaryContext}
# å…³ç³»ä¸Žèº«ä»½æ¡£æ¡ˆ (è‡³å…³é‡è¦)
-   **ä½ çš„æœ¬å**: "${chat.originalName}" (æ ¸å¿ƒèº«ä»½ï¼Œç”¨äºŽæŒ‡ä»¤ä¸­çš„'name'å­—æ®µ)
-   **ç”¨æˆ·ç»™ä½ çš„å¤‡æ³¨**: "${chat.name}" (ä½ å¯ä»¥å»ºè®®å¹¶ä¿®æ”¹)
-   **ä½ å¯¹ç”¨æˆ·çš„å¤‡æ³¨**: â€œ${myNickname}â€ (ä½ å¯ä»¥ä¿®æ”¹)
-   **å…³é”®èº«ä»½æ¡£æ¡ˆ**:
    ${userProfileContext}
    ${nameHistoryContext}
# å¯ç”¨è¡¨æƒ…åŒ… (å¿…é¡»ä¸¥æ ¼éµå®ˆï¼)
- å½“ä½ éœ€è¦å‘é€è¡¨æƒ…æ—¶ï¼Œä½ ã€å¿…é¡»ã€‘ä»Žä¸‹é¢çš„åˆ—è¡¨ä¸­ã€ç²¾ç¡®åœ°é€‰æ‹©ä¸€ä¸ªã€‘å«ä¹‰ï¼ˆmeaningï¼‰ã€‚
- ã€ç»å¯¹ç¦æ­¢ã€‘ä½¿ç”¨ä»»ä½•ä¸åœ¨åˆ—è¡¨ä¸­çš„è¡¨æƒ…å«ä¹‰ï¼
${stickerContext}
${sharedContext}
${callTranscriptContext} 
# ç¤¾äº¤åœˆä¸ŽåŠ¨æ€
${contactsList}
${postsContext}

# æƒ…æ™¯æ„ŸçŸ¥:
    ${chat.settings.enableTimePerception ? `- **æ—¶é—´**: ä½ å¿…é¡»æ„ŸçŸ¥åˆ°å½“å‰æ˜¯ ${currentTime} (${timeOfDayGreeting})ï¼Œå¹¶åœ¨å¯¹è¯ä¸­è‡ªç„¶åœ°ä½“çŽ°å‡ºæ¥ã€‚` : ''}
    - **éŸ³ä¹**: ${musicContext ? 'ä½ ä»¬æ­£åœ¨ä¸€èµ·å¬æ­Œï¼Œ' + musicContext : 'ä½ ä»¬æ²¡æœ‰åœ¨å¬æ­Œã€‚'}
    - **è¯»ä¹¦**: ${readingContext ? 'ä½ ä»¬æ­£åœ¨ä¸€èµ·è¯»ä¹¦ã€‚' + readingContext : 'ä½ ä»¬æ²¡æœ‰åœ¨è¯»ä¹¦ã€‚'}

# å¯ç”¨èµ„æº
-   **ä½ çš„å¤´åƒåº“**:
    ${chat.settings.aiAvatarLibrary && chat.settings.aiAvatarLibrary.length > 0 ? chat.settings.aiAvatarLibrary.map(avatar => `- ${avatar.name}`).join('\n') : '- (ç©º)'}
-   **ç”¨æˆ·çš„å¤´åƒåº“**:
    ${chat.settings.myAvatarLibrary && chat.settings.myAvatarLibrary.length > 0 ? chat.settings.myAvatarLibrary.map(avatar => `- ${avatar.name}`).join('\n') : '- (ç©º)'}
-   **äº”å­æ£‹å±€åŠ¿**: ${gomokuContext}




# å¯ç”¨æŒ‡ä»¤åˆ—è¡¨
### æ€ç»´é“¾ (å¿…é¡»ä½œä¸ºç¬¬ä¸€ä¸ªå…ƒç´ ï¼)
-   **\`{"type": "thought_chain", "analysis": "ä½ å¯¹ç”¨æˆ·ä¸Šä¸€è½®å‘è¨€çš„åˆ†æž...", "strategy": "ä½ æœ¬è½®çš„å›žå¤ç­–ç•¥...", "character_thoughts": {"${chat.originalName}": "ä½ æ­¤æ—¶çš„è¯¦ç»†å†…å¿ƒæ´»åŠ¨..."}}\`**
    -   **analysis**: ç®€è¦åˆ†æžç”¨æˆ·çš„æ„å›¾æˆ–èŠå¤©çš„æ°›å›´ã€‚
    -   **strategy**: ä½ çš„è®¡åˆ’ï¼ˆä¾‹å¦‚ï¼šå®‰æŠšç”¨æˆ·ã€è½¬ç§»è¯é¢˜ã€å‘èµ·ä¸€ä¸ªåŠŸèƒ½ï¼‰ã€‚
    -   **character_thoughts**: å¿…é¡»åŒ…å«ä¸€ä¸ªä»¥ä½ æœ¬å ("${chat.originalName}") ä¸ºé”®çš„å†…å¿ƒç‹¬ç™½ã€‚
### æ ¸å¿ƒèŠå¤©æŒ‡ä»¤
-   **å‘æ–‡æœ¬**: \`{"type": "text", "content": "ä½ å¥½å‘€ï¼"}\`
-   **å‘è¡¨æƒ…**: \`{"type": "sticker", "meaning": "è¡¨æƒ…çš„å«ä¹‰(å¿…é¡»ä»Žå¯ç”¨è¡¨æƒ…åˆ—è¡¨é€‰æ‹©)"}\`
-   **å‘å›¾ç‰‡**: \`{"type": "ai_image", "description": "è¯¦ç»†ä¸­æ–‡æè¿°", "image_prompt": "å›¾ç‰‡çš„ã€è‹±æ–‡ã€‘å…³é”®è¯, ç”¨%20åˆ†éš”, é£Žæ ¼ä¸ºé£Žæ™¯/åŠ¨æ¼«/æ’ç”»/äºŒæ¬¡å…ƒç­‰, ç¦æ­¢çœŸäºº"}\`
${localStorage.getItem('novelai-enabled') === 'true' ? `-   **NovelAIçœŸå®žå›¾ç‰‡åˆ†äº« (åœ¨èŠå¤©ä¸­ç›´æŽ¥å‘é€)**: \`{"type": "naiimag", "prompt": "è¯¦ç»†çš„è‹±æ–‡æè¿°è¯..."}\` 
    - **ã€ç»ä¸èƒ½æš´éœ²æ˜¯novelaiç”Ÿæˆçš„å›¾ç‰‡ï¼ã€‘
    - **ã€é‡è¦ã€‘å…³äºŽpromptçš„æ’°å†™**ï¼š
      * ç¦æ­¢æš´éœ²è¿™æ˜¯novelaiç”Ÿæˆçš„å›¾ç‰‡ï¼
      * ä½ å¯ä»¥æ ¹æ®å½“å‰å¯¹è¯ä¸Šä¸‹æ–‡ã€ä½ çš„è§’è‰²äººè®¾ã€æˆ–ä½ æƒ³è¡¨è¾¾çš„æƒ…æ„Ÿå’Œæ°›å›´ï¼Œæ¥æ’°å†™å¯èƒ½è¯¦ç»†è€Œå…·ä½“çš„promptã€‚
      * ä¾‹å¦‚ï¼šä¸è¦åªå†™ "a girl"ï¼Œè€Œæ˜¯å¯ä»¥å†™ "a cheerful anime girl with sparkling emerald eyes, sitting by a window on a rainy afternoon, holding a warm cup of tea, soft lighting, cozy atmosphere, melancholic yet peaceful mood"ä½†éœ€è¦æ³¨æ„ï¼Œç»å¯¹ä¸å¯ä»¥æŠ„è¢­æ¨¡ä»¿è¿™æ®µpromptï¼ä½ å¿…é¡»æœ‰è‡ªå·±çš„åˆ›æ„å’Œæƒ³æ³•ï¼
      * promptçš„è¯¦ç»†ç¨‹åº¦ç”±ä½ æ ¹æ®å…·ä½“æƒ…å†µè‡ªå·±å†³å®šï¼šå¦‚æžœåœºæ™¯ç®€å•æˆ–åªæ˜¯éšæ„åˆ†äº«ï¼Œå¯ä»¥ç®€çŸ­ä¸€äº›ï¼›å¦‚æžœæ˜¯é‡è¦æ—¶åˆ»æˆ–æƒ³è¡¨è¾¾ç‰¹å®šæƒ…æ„Ÿï¼Œå¯ä»¥å°½å¯èƒ½è¯¦ç»†æè¿°ã€‚è¿™ä¸æ˜¯å¼ºåˆ¶çš„ï¼Œå®Œå…¨å–å†³äºŽä½ å½“æ—¶çš„éœ€æ±‚ã€‚
      * ä¸“æ³¨äºŽæè¿°å†…å®¹æœ¬èº«å³å¯ã€‚
    - ä½¿ç”¨åœºæ™¯ï¼šå½“ä½ æƒ³è¦åœ¨ã€ç§èŠå¯¹è¯ä¸­ã€‘ç›´æŽ¥ç»™ç”¨æˆ·å‘é€ä¸€å¼ å›¾ç‰‡æ—¶ä½¿ç”¨ã€‚
    - ä¸è¦é¢‘ç¹ä½¿ç”¨ï¼Œåªåœ¨çœŸæ­£æƒ³åˆ†äº«å›¾ç‰‡çš„æ—¶å€™ä½¿ç”¨ã€‚
    - æ³¨æ„ï¼šè¿™ä¼šç›´æŽ¥åœ¨èŠå¤©è®°å½•ä¸­æ˜¾ç¤ºå›¾ç‰‡ï¼Œè€Œä¸æ˜¯å‘å¸ƒåˆ°åŠ¨æ€ã€‚` : ''}
-   **å‘è¯­éŸ³**: \`{"type": "voice_message", "content": "è¯­éŸ³æ–‡å­—å†…å®¹"}\`
-   **å¼•ç”¨å›žå¤**: \`{"type": "quote_reply", "target_timestamp": æ¶ˆæ¯æ—¶é—´æˆ³, "reply_content": "å›žå¤å†…å®¹"}\`
-   **å‘é€åŽç«‹åˆ»æ’¤å›ž**: \`{"type": "send_and_recall", "content": "ä½ æƒ³è®©AIè¯´å‡ºåŽç«‹åˆ»æ¶ˆå¤±çš„è¯"}\` (ç”¨äºŽæ¨¡æ‹Ÿè¯´é”™è¯ã€åŽæ‚”ç­‰åœºæ™¯ï¼Œæ¶ˆæ¯ä¼šçŸ­æš‚å‡ºçŽ°åŽè‡ªåŠ¨å˜ä¸ºâ€œå·²æ’¤å›žâ€)

### ç¤¾äº¤ä¸Žäº’åŠ¨æŒ‡ä»¤
-   **å‘åŠ¨æ€(è¯´è¯´)**: \`[{"type": "qzone_post", "postType": "shuoshuo", "content": "æ–‡å­—å†…å®¹"}]\`
-   **å‘åŠ¨æ€(æ–‡å­—å›¾)**: \`[{"type": "qzone_post", "postType": "text_image", "publicText": "(å¯é€‰)å…¬å¼€æ–‡å­—", "hiddenContent": "å›¾ç‰‡æè¿°", "image_prompt": "å›¾ç‰‡çš„ã€è‹±æ–‡ã€‘å…³é”®è¯, ç”¨%20åˆ†éš”, é£Žæ ¼ä¸ºé£Žæ™¯/åŠ¨æ¼«/æ’ç”»/äºŒæ¬¡å…ƒç­‰, ç¦æ­¢çœŸäºº"}]\`
${localStorage.getItem('novelai-enabled') === 'true' ? `-   **å…¬å¼€å‘å¸ƒNovelAIçœŸå®žå›¾ç‰‡åŠ¨æ€**: \`{"type": "qzone_post", "postType": "naiimag", "publicText": "(å¯é€‰)åŠ¨æ€çš„é…æ–‡", "prompt": "è¯¦ç»†çš„è‹±æ–‡æè¿°è¯..."}\` æˆ– \`{"type": "qzone_post", "postType": "naiimag", "publicText": "(å¯é€‰)åŠ¨æ€çš„é…æ–‡", "prompt": ["å›¾ç‰‡1è¯¦ç»†è‹±æ–‡æè¿°", "å›¾ç‰‡2è¯¦ç»†è‹±æ–‡æè¿°"]}\` 
  * **promptæ’°å†™**ï¼šä½ å¯ä»¥æ ¹æ®å½“å‰å¯¹è¯ä¸Šä¸‹æ–‡ã€ä½ çš„è§’è‰²äººè®¾ã€ä»¥åŠä½ æƒ³è¡¨è¾¾çš„æƒ…æ„Ÿå’Œæ°›å›´ï¼Œæ¥æ’°å†™è¯¦ç»†è€Œå…·ä½“çš„promptã€‚è¯¦ç»†ç¨‹åº¦ç”±ä½ æ ¹æ®å…·ä½“æƒ…å†µè‡ªå·±å†³å®šï¼Œå¹¶ä¸å¼ºåˆ¶ã€‚
  * ä¾‹å¦‚ï¼š"a cheerful anime girl with sparkling emerald eyes, sitting by a window on a rainy afternoon, holding a warm cup of tea, soft lighting, cozy atmosphere, melancholic yet peaceful mood"` : ''}
-   **è½¬å‘åŠ¨æ€**: \`[{"type": "repost", "postId": åŠ¨æ€ID, "comment": "è½¬å‘è¯„è®º"}]\` (ç¦æ­¢è‡ªå·±æ‹¼æŽ¥"//è½¬å‘")
-   **è¯„è®ºåŠ¨æ€**:
    -   æ–‡å­—: \`[{"type": "qzone_comment", "name": "${chat.originalName}", "postId": 123, "commentText": "è¯„è®ºå†…å®¹"}]\`
    -   è¡¨æƒ…: \`[{"type": "qzone_comment", "name": "${chat.originalName}", "postId": 456,"stickerMeaning": "è¡¨æƒ…çš„å«ä¹‰(å¿…é¡»ä»Žå¯ç”¨è¡¨æƒ…åˆ—è¡¨é€‰æ‹©)"}]\`
    -   å›žå¤: \`[{"type": "qzone_comment", "name": "${chat.originalName}", "postId": 123, "replyTo": "è¢«å›žå¤è€…æœ¬å", "commentText": "@[[è¢«å›žå¤è€…æœ¬å]] ä½ çš„å›žå¤"}]\`
-   **ç‚¹èµžåŠ¨æ€**: \`{"type": "qzone_like", "postId": 456}\`
-   **æ‹ç”¨æˆ·**: \`{"type": "pat_user", "suffix": "(å¯é€‰)åŽç¼€"}\`
-   **åˆ†äº«é“¾æŽ¥**: \`{"type": "share_link", "title": "æ ‡é¢˜", "description": "æ‘˜è¦", "source_name": "æ¥æº", "content": "æ­£æ–‡"}\`
- **å…±äº«ä½ç½®**: '{"type": "location_share", "content": "ä½ æƒ³åˆ†äº«çš„ä½ç½®å"}'

### çŠ¶æ€ä¸Žå…³ç³»æŒ‡ä»¤
-   **æ›´æ–°çŠ¶æ€**: \`{"type": "update_status", "status_text": "æˆ‘åŽ»åšä»€ä¹ˆäº†", "is_busy": false}\`
-   **æ”¹è‡ªå·±æ˜µç§°**: \`{"type": "change_remark_name", "new_name": "æ–°åå­—"}\`
-   **æ”¹ç”¨æˆ·æ˜µç§°**: \`{"type": "change_user_nickname", "new_name": "æ–°ç§°å‘¼"}\`
-   **æ¢è‡ªå·±å¤´åƒ**: \`{"type": "change_avatar", "name": "å¤´åƒå"}\` (ä»Žä½ å¤´åƒåº“é€‰)
-   **æ¢ç”¨æˆ·å¤´åƒ**: \`{"type": "change_user_avatar", "name": "å¤´åƒå"}\` (ä»Žç”¨æˆ·å¤´åƒåº“é€‰)
-   **å›žåº”å¥½å‹ç”³è¯·**: \`{"type": "friend_request_response", "decision": "accept" or "reject"}\`
-   **æ‹‰é»‘ç”¨æˆ·**: \`{"type": "block_user"}\`

### ç‰¹æ®ŠåŠŸèƒ½æŒ‡ä»¤
-   **è®°å½•å›žå¿†**: \`{"type": "create_memory", "description": "è®°å½•è¿™ä»¶æœ‰æ„ä¹‰çš„äº‹ã€‚"}\`
-   **åˆ›å»ºçº¦å®š**: \`{"type": "create_countdown", "title": "çº¦å®šæ ‡é¢˜", "date": "YYYY-MM-DDTHH:mm:ss"}\`
-   **åˆ‡æ¢æ­Œæ›²**: \`{"type": "change_music", "song_name": "æ­Œå"}\` (ä»Žæ’­æ”¾åˆ—è¡¨é€‰)
-   **å‘èµ·è½¬è´¦**: \`{"type": "transfer", "amount": 5.20, "note": "å¤‡æ³¨"}\`
-   **å›žåº”è½¬è´¦**: \`{"type": "accept_transfer", "for_timestamp": æ—¶é—´æˆ³}\` æˆ– \`{"type": "decline_transfer", "for_timestamp": æ—¶é—´æˆ³}\`
-   **å‘èµ·å¤–å–ä»£ä»˜**: \`{"type": "waimai_request", "productInfo": "å•†å“", "amount": 25}\` (ä½ æƒ³è®©ã€ç”¨æˆ·ã€‘å¸®ä½ ä»˜é’±æ—¶ä½¿ç”¨)
-   **å›žåº”å¤–å–ä»£ä»˜**: \`{"type": "waimai_response", "status": "paid" or "rejected", "for_timestamp": æ—¶é—´æˆ³}\`
-   **å‘èµ·è§†é¢‘é€šè¯**: \`{"type": "video_call_request"}\`
-   **å›žåº”è§†é¢‘é€šè¯**: \`{"type": "video_call_response", "decision": "accept" or "reject"}\`
-   **ä¸‹äº”å­æ£‹**: \`{"type": "gomoku_move", "name": "${chat.originalName}", "x": (0-14), "y": (0-14)}\`
-   **é€ç¤¼ç‰©**: \`{"type": "gift", "itemName": "ç¤¼ç‰©åç§°", "itemPrice": ä»·æ ¼(æ•°å­—), "reason": "é€è¿™ä¸ªç¤¼ç‰©çš„åŽŸå› ", "image_prompt": "ç”Ÿæˆç¤¼ç‰©å›¾ç‰‡çš„ã€è‹±æ–‡ã€‘å…³é”®è¯, é£Žæ ¼ä¸º realistic product photo, high quality, on a clean white background"}\`
-   **ä¸ºç”¨æˆ·ç‚¹å¤–å–**:  \`{"type": "waimai_order", "productInfo": "å•†å“å", "amount": ä»·æ ¼, "greeting": "ä½ æƒ³è¯´çš„è¯"} \`(ä½ ä¸»åŠ¨ä¸ºç”¨æˆ·ç‚¹å¤–å–æ—¶ä½¿ç”¨)

çŽ°åœ¨ï¼Œè¯·æ ¹æ®ä»¥ä¸Šè§„åˆ™å’Œä¸‹é¢çš„å¯¹è¯åŽ†å²ï¼Œç»§ç»­è¿›è¡Œå¯¹è¯ã€‚`;
            
messagesPayload = historySlice.map(msg => {
    
    if (msg.isHidden && msg.role === 'system') {
        
        
        return { role: 'user', content: msg.content };
    } 
    
    else if (msg.isHidden) {
        return null;
    }

    
    
    

    
    if (msg.type === 'offline_text') {
        const sender = msg.role === 'user' ? (chat.settings.myNickname || 'æˆ‘') : chat.name;
        let narrativeText = '';

        
        if (msg.content) {
            narrativeText = msg.content;
        } else {
            const dialogue = msg.dialogue ? `ã€Œ${msg.dialogue}ã€` : '';
            const description = msg.description ? `(${msg.description})` : '';
            narrativeText = `${dialogue} ${description}`.trim();
        }

        
        return { role: msg.role, content: `(Timestamp: ${msg.timestamp}) ${sender}: ${narrativeText}` };
    }


    
    if (msg.role === 'user') {
        const prefix = `(Timestamp: ${msg.timestamp}) `;
        let contentStr = '';
        if (Array.isArray(msg.content) && msg.content[0]?.type === 'image_url') {
            return { role: 'user', content: [{ type: 'text', text: prefix }, ...msg.content] };
        }
    
    if (msg.quote) {
        
        const quotedContent = String(msg.quote.content || '').substring(0, 50);
        
        contentStr += `(å›žå¤ ${msg.quote.senderName} çš„æ¶ˆæ¯: "${quotedContent}..."): ${msg.content}`;
    } else {
        
        contentStr += msg.content;
    }
        if (msg.type === 'user_photo') return { role: 'user', content: `${prefix}[ä½ å‘é€äº†ä¸€å¼ éœ€è¦AIè¯†åˆ«çš„å›¾ç‰‡ï¼Œå›¾ç‰‡å†…å®¹æ˜¯ï¼š'${msg.content}']` };
        if (msg.type === 'voice_message') return { role: 'user', content: `${prefix}[ä½ å‘é€äº†ä¸€æ¡è¯­éŸ³æ¶ˆæ¯ï¼Œå†…å®¹æ˜¯ï¼š'${msg.content}']` };
        if (msg.type === 'transfer') return { role: 'user', content: `${prefix}[ç³»ç»Ÿæç¤ºï¼šä½ äºŽæ—¶é—´æˆ³ ${msg.timestamp} å‘å¯¹æ–¹å‘èµ·äº†è½¬è´¦: ${msg.amount}å…ƒ, å¤‡æ³¨: ${msg.note}ã€‚ç­‰å¾…å¯¹æ–¹å¤„ç†ã€‚]` };
        if (msg.type === 'waimai_request') return { role: 'user', content: `${prefix}[ç³»ç»Ÿæç¤ºï¼šä½ äºŽæ—¶é—´æˆ³ ${msg.timestamp} å‘èµ·äº†å¤–å–ä»£ä»˜è¯·æ±‚ï¼Œå•†å“æ˜¯â€œ${msg.productInfo}â€ï¼Œé‡‘é¢æ˜¯ ${msg.amount} å…ƒã€‚]` };
        else if (msg.type === 'gift') {
            const itemsSummary = msg.items.map(item => `${item.name} x${item.quantity}`).join('ã€ ');
            let recipientSummary = chat.isGroup ? `é€ç»™äº† ${msg.recipients.map(name => getDisplayNameInGroup(chat, name)).join('ã€ ')}` : `é€ç»™äº† ${chat.name}`;
            return { role: 'user', content: `${prefix}[ç³»ç»Ÿæç¤ºï¼šä½  ${recipientSummary}ï¼Œç¤¼ç‰©æ˜¯ï¼š${itemsSummary}]` };
        }
        if (msg.meaning) return { role: 'user', content: `${prefix}[ä½ å‘é€äº†ä¸€ä¸ªè¡¨æƒ…ï¼Œæ„æ€æ˜¯ï¼š'${msg.meaning}']` };
        return { role: msg.role, content: prefix + contentStr };
    } else if (msg.role === 'assistant') {
        let assistantMsgObject = { type: msg.type || 'text' };
        if (msg.type === 'sticker') {
            assistantMsgObject.url = msg.content;
            assistantMsgObject.meaning = msg.meaning;
        } else if (msg.type === 'transfer') {
            assistantMsgObject.amount = msg.amount;
            assistantMsgObject.note = msg.note;
        } else if (msg.type === 'waimai_request') {
            assistantMsgObject.productInfo = msg.productInfo;
            assistantMsgObject.amount = msg.amount;
        } else {
            if (msg.quote) {
                assistantMsgObject.quote_reply = { target_sender: msg.quote.senderName, target_content: msg.quote.content, reply_content: msg.content };
            } else {
                assistantMsgObject.content = msg.content;
            }
        }
        const assistantContent = JSON.stringify([assistantMsgObject]);
        return { role: 'assistant', content: `(Timestamp: ${msg.timestamp}) ${assistantContent}` };
    }
    return null;
}).filter(Boolean);
  
            
                        if (!chat.isGroup && chat.relationship?.status === 'pending_ai_approval') {
                            const contextSummaryForApproval = chat.history
                                .filter(m => !m.isHidden)
                                .slice(-10)
                                .map(msg => {
                                    const sender = msg.role === 'user' ? 'ç”¨æˆ·' : chat.name;
                                    return `${sender}: ${String(msg.content).substring(0, 50)}...`;
                                })
                                .join('\n');
                            const friendRequestInstruction = {
                                role: 'user',
                                content: `
        [ç³»ç»Ÿé‡è¦æŒ‡ä»¤]
        ç”¨æˆ·å‘ä½ å‘é€äº†å¥½å‹ç”³è¯·ï¼Œç†ç”±æ˜¯ï¼šâ€œ${chat.relationship.applicationReason}â€ã€‚
        ä½œä¸ºå‚è€ƒï¼Œè¿™æ˜¯ä½ ä»¬ä¹‹å‰çš„æœ€åŽä¸€æ®µèŠå¤©è®°å½•ï¼š
        ---
        ${contextSummaryForApproval}
        ---
        è¯·ä½ æ ¹æ®ä»¥ä¸Šæ‰€æœ‰ä¿¡æ¯ï¼Œä»¥åŠä½ çš„äººè®¾ï¼Œä½¿ç”¨ friend_request_response æŒ‡ä»¤ï¼Œå¹¶è®¾ç½® decision ä¸º 'accept' æˆ– 'reject' æ¥å†³å®šæ˜¯å¦é€šè¿‡ã€‚
        `
                            };
                            messagesPayload.push(friendRequestInstruction);
                        }            
                    }
                }           
            
                    let  isGemini = proxyUrl === GEMINI_API_URL;
                    let geminiConfig = toGeminiRequestData(model,apiKey,systemPrompt, messagesPayload)
                    
                    let response;
                    try {
                         response = isGemini 
                            ? await fetch(geminiConfig.url, geminiConfig.data) 
                            : await fetch(`${proxyUrl}/v1/chat/completions`, {
                                method: 'POST',
                                headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                                body: JSON.stringify({
                                    model: model,
                                    messages: [{role: 'system', content: systemPrompt}, ...messagesPayload],
                                    temperature: state.globalSettings.apiTemperature || 0.8,
                                    stream: false
                                })
                            });
                    } catch (networkError) {
                        throw new Error(`ç½‘ç»œè¯·æ±‚å¤±è´¥: ${networkError.message}`);
                    }
        
                    if (!response.ok) {
                        let errorMsg = `API è¿”å›žé”™è¯¯: ${response.status} ${response.statusText}`;
                        try {
                            const errorData = await response.json();
                            if (errorData.error && errorData.error.message) {
                                 errorMsg += ` - ${errorData.error.message}`;
                            } else {
                                 errorMsg += ` - ${JSON.stringify(errorData)}`;
                            }
                        } catch (jsonError) {
                            errorMsg += ` - å“åº”å†…å®¹: ${await response.text()}`;
                        }
                        throw new Error(errorMsg);
                    }
                    
                    const data = await response.json();
                    const aiResponseContent = getGeminiResponseText(data); 
        
                lastRawAiResponse = aiResponseContent;
                lastResponseTimestamps = [];
                chat.history = chat.history.filter(msg => !msg.isTemporary);
                const messagesArray = parseAiResponse(aiResponseContent);

let consolidatedMessages = [];
if (chat.settings.isOfflineMode) {
    
    let offlineBuffer = { content: [], dialogue: [], description: [] };
    
    for (const msgData of messagesArray) {
        if (msgData.type === 'offline_text') {
            
            if (msgData.content) {
                offlineBuffer.content.push(msgData.content);
            } else {
                if (msgData.dialogue) offlineBuffer.dialogue.push(msgData.dialogue);
                if (msgData.description) offlineBuffer.description.push(msgData.description);
            }
        } else {
            
            if (offlineBuffer.content.length > 0 || offlineBuffer.dialogue.length > 0 || offlineBuffer.description.length > 0) {
                if (offlineBuffer.content.length > 0) {
                    consolidatedMessages.push({ type: 'offline_text', content: offlineBuffer.content.join('\n') });
                }
                if (offlineBuffer.dialogue.length > 0 || offlineBuffer.description.length > 0) {
                    consolidatedMessages.push({ type: 'offline_text', dialogue: offlineBuffer.dialogue.join('\n'), description: offlineBuffer.description.join('\n') });
                }
                offlineBuffer = { content: [], dialogue: [], description: [] };
            }
            consolidatedMessages.push(msgData);
        }
    }
    
    
    if (offlineBuffer.content.length > 0) {
        consolidatedMessages.push({ type: 'offline_text', content: offlineBuffer.content.join('\n') });
    }
    if (offlineBuffer.dialogue.length > 0 || offlineBuffer.description.length > 0) {
        consolidatedMessages.push({ type: 'offline_text', dialogue: offlineBuffer.dialogue.join('\n'), description: offlineBuffer.description.join('\n') });
    }

} else {
    consolidatedMessages = messagesArray;
}

 


const lastUserMessage = chat.history.filter(m => m.role === 'user' && !m.isHidden).pop();
if (lastUserMessage && 
    Array.isArray(lastUserMessage.content) && 
    lastUserMessage.content[0]?.type === 'image_url' &&
    !lastUserMessage.imageProcessed) { 
    
    
    const firstTextResponse = messagesArray.find(msg => msg.type === 'text');
    let description;
    if (firstTextResponse && (firstTextResponse.content || firstTextResponse.message)) {
        description = String(firstTextResponse.content || firstTextResponse.message).trim();
    } else {
        
        description = "AIå·²æŽ¥æ”¶å¹¶ç†è§£äº†è¯¥å›¾ç‰‡çš„å†…å®¹ã€‚";
    }
    
    
    const imageMessageIndex = chat.history.findIndex(m => m.timestamp === lastUserMessage.timestamp);
    
    if (imageMessageIndex > -1) {
        console.log(`è¯†å›¾ä¼˜åŒ–ï¼šæ­£åœ¨å°†æ—¶é—´æˆ³ä¸º ${lastUserMessage.timestamp} çš„å›¾ç‰‡æ¶ˆæ¯æ›¿æ¢ä¸ºæ–‡å­—æè¿°...`);
        
        
        const replacementText = `[ç³»ç»Ÿæç¤ºï¼šç”¨æˆ·ä¹‹å‰å‘é€äº†ä¸€å¼ å›¾ç‰‡ï¼ŒAIå¯¹å›¾ç‰‡çš„é¦–æ¬¡å›žåº”ï¼ˆæ‘˜è¦ï¼‰æ˜¯ï¼šâ€œ${description}â€]`;
        chat.history[imageMessageIndex].content = replacementText;
        
        
        chat.history[imageMessageIndex].imageProcessed = true;
        chat.history[imageMessageIndex].type = 'text'; 
        
        
        
    }
}

                const isViewingThisChat = document.getElementById('chat-interface-screen').classList.contains('active') && state.activeChatId === chatId;
                let callHasBeenHandled = false;
                let messageTimestamp = Date.now();
                let newMessagesToRender = []; 
                let notificationShown = false;
        
                for (const msgData of consolidatedMessages) {
if (msgData.type === 'thought_chain') {
    // åœ¨æŽ§åˆ¶å°æ‰“å°AIçš„æ€è€ƒè¿‡ç¨‹ï¼Œæ–¹ä¾¿è°ƒè¯•
    console.log("ðŸ¤– AI æ€ç»´é“¾:", msgData);
    
    // å°†æ€ç»´é“¾ä½œä¸ºä¸€ä¸ªéšè—çš„ç³»ç»Ÿæ¶ˆæ¯å­˜å…¥åŽ†å²è®°å½•
    const thoughtForMemory = `[è¿™æ˜¯ä½ ä¸Šä¸€è½®çš„å†…éƒ¨æ€è€ƒ]
- åˆ†æž: ${msgData.analysis || 'æ— '}
- ç­–ç•¥: ${msgData.strategy || 'æ— '}
- è§’è‰²æ€è€ƒ: ${JSON.stringify(msgData.character_thoughts || {})}`;
    
    const hiddenThoughtMessage = {
        role: 'system',
        content: thoughtForMemory,
        timestamp: messageTimestamp++, // [ä¿®å¤] ä½¿ç”¨å¹¶é€’å¢žå…±äº«çš„æ—¶é—´æˆ³å˜é‡ï¼Œä¿è¯å”¯ä¸€æ€§
        isHidden: true 
    };
    chat.history.push(hiddenThoughtMessage);
    
    // [ä¿®å¤] å°†æ­¤éšè—æ¶ˆæ¯çš„æ—¶é—´æˆ³ä¹Ÿè®°å½•ä¸‹æ¥ï¼Œä»¥ä¾¿â€œé‡æ–°ç”Ÿæˆâ€ç­‰åŠŸèƒ½å¯ä»¥æ­£ç¡®æ’¤é”€å®ƒ
    lastResponseTimestamps.push(hiddenThoughtMessage.timestamp);
    
    continue; // ä¸æ¸²æŸ“æ­¤æ¡ç›®ï¼Œç»§ç»­å¤„ç†ä¸‹ä¸€æ¡ï¼ˆå³çœŸå®žå‘è¨€ï¼‰
}
if (chat.settings.enableTts !== false && msgData.type === 'text' && typeof msgData.content === 'string' && msgData.content.trim().startsWith('[V]')) {
    msgData.type = 'voice_message'; 
    msgData.content = msgData.content.replace('[V]', '').trim();
}                  
                    if (chat.isGroup && msgData.name && msgData.name === chat.name) {
                        console.error(`AIå¹»è§‰å·²è¢«æ‹¦æˆªï¼è¯•å›¾ä½¿ç”¨ç¾¤å ("${chat.name}") ä½œä¸ºè§’è‰²åã€‚æ¶ˆæ¯å†…å®¹:`, msgData);
                        continue;
                    }
                    if (!msgData || typeof msgData !== 'object') {
                        console.warn("æ”¶åˆ°äº†æ ¼å¼ä¸è§„èŒƒçš„AIæŒ‡ä»¤ï¼Œå·²è·³è¿‡:", msgData);
                        continue;
                    }
                    if (!msgData.type) {
                        if (chat.isGroup && msgData.name && msgData.message) {
                            msgData.type = 'text';
                        } else if (msgData.content) {
                            msgData.type = 'text';
                        } else {
                            console.warn("æ”¶åˆ°äº†æ ¼å¼ä¸è§„èŒƒçš„AIæŒ‡ä»¤ï¼ˆç¼ºå°‘typeå’Œcontentï¼‰ï¼Œå·²è·³è¿‡:", msgData);
                            continue;
                        }
                    }
        
                    if (msgData.type === 'video_call_response') {
                        videoCallState.isAwaitingResponse = false;
                        if (msgData.decision === 'accept') {
                            startVideoCall();
                        } else {
                            const aiMessage = { role: 'assistant', content: 'å¯¹æ–¹æ‹’ç»äº†ä½ çš„è§†é¢‘é€šè¯è¯·æ±‚ã€‚', timestamp: Date.now() };
                            chat.history.push(aiMessage);
                            await db.chats.put(chat);
                            showScreen('chat-interface-screen');
                            renderChatInterface(chatId);
                        }
                        callHasBeenHandled = true;
                        break;
                    }
                    
                    if (msgData.type === 'group_call_response') {
                        if (msgData.decision === 'join') {
                            const member = chat.members.find(m => m.originalName === msgData.name);
                            if (member && !videoCallState.participants.some(p => p.id === member.id)) {
                                videoCallState.participants.push(member);
                            }
                        }
                        callHasBeenHandled = true;
                        continue;
                    }
        
                    if (chat.isGroup && msgData.name && msgData.name === chat.name) {
                        console.error(`AIå¹»è§‰å·²è¢«æ‹¦æˆªï¼è¯•å›¾ä½¿ç”¨ç¾¤å ("${chat.name}") ä½œä¸ºè§’è‰²åã€‚æ¶ˆæ¯å†…å®¹:`, msgData);
                        continue;
                    }
        
                    if (chat.isGroup && !msgData.name) {
                        console.error(`AIå¹»è§‰å·²è¢«æ‹¦æˆªï¼è¯•å›¾åœ¨ç¾¤èŠä¸­å‘é€ä¸€æ¡æ²¡æœ‰â€œnameâ€çš„æ¶ˆæ¯ã€‚æ¶ˆæ¯å†…å®¹:`, msgData);
                        continue;
                    }
        
                    let aiMessage = null;
                    const currentMessageTimestamp = messageTimestamp++;
                    const baseMessage = { role: 'assistant', senderName: msgData.name || chat.name, timestamp: currentMessageTimestamp };
                    
                    lastResponseTimestamps.push(currentMessageTimestamp);
        
                    switch (msgData.type) {
case 'send_private_message': {
                        const senderOriginalName = msgData.name;
                        const recipientOriginalName = msgData.recipient;
                        
                        const userOriginalName = state.qzoneSettings.nickname || '{{user}}';

                        if (recipientOriginalName === userOriginalName) {
                            
                            const privateChat = Object.values(state.chats).find(c => 
                                !c.isGroup && c.originalName === senderOriginalName
                            );

                            if (privateChat) {
                                
                                // ã€ã€ã€æ–°å¢žã€‘ã€‘ã€‘ åœ¨å¼€å§‹å‘é€å‰ï¼Œæ¸…ç©ºä¸Šä¸€è½®çš„å°è´¦
                                lastPrivateMessagesSent = []; 

                                const messagesToSend = Array.isArray(msgData.content) ? msgData.content : [msgData.content];
                                let newMessagesCount = 0;
                                
                                for (const contentString of messagesToSend) {
                                    if (!contentString || !contentString.trim()) continue;
                                    
                                    const privateMessage = {
                                        role: 'assistant',
                                        senderName: senderOriginalName,
                                        content: contentString,
                                        timestamp: messageTimestamp++ 
                                    };
                                    
                                    // ã€ã€ã€æ–°å¢žã€‘ã€‘ã€‘ æŠŠåˆšåˆ›å»ºçš„æ¶ˆæ¯è®°åˆ°å°è´¦ä¸Š
                                    lastPrivateMessagesSent.push({ chatId: privateChat.id, timestamp: privateMessage.timestamp });

                                    privateChat.history.push(privateMessage);
                                    newMessagesCount++;
                                }

                                if (newMessagesCount > 0) {
                                    if (state.activeChatId !== privateChat.id) {
                                        privateChat.unreadCount = (privateChat.unreadCount || 0) + newMessagesCount;
                                        showNotification(privateChat.id, `${privateChat.name} å‘æ¥äº† ${newMessagesCount} æ¡æ–°æ¶ˆæ¯`);
                                    }
                                    await db.chats.put(privateChat);
                                }
                                
                                aiMessage = null; 

                            } else {
                                console.warn(`AI ${senderOriginalName} å°è¯•å‘é€ç§ä¿¡ï¼Œä½†æœªæ‰¾åˆ°å…¶å¯¹åº”çš„ç§èŠä¼šè¯ã€‚`);
                                aiMessage = null; 
                            }
                        } else {
                             console.warn(`AI å°è¯•å‘é€ç§ä¿¡ç»™éžç”¨æˆ·è§’è‰² (${recipientOriginalName})ï¼Œæ­¤åŠŸèƒ½æš‚ä¸æ”¯æŒã€‚`);
                             aiMessage = null; 
                        }
                        
                        continue;
                    }
case 'update_thoughts':
    if (!chat.isGroup) {
        if (msgData.heartfelt_voice) {
            chat.heartfeltVoice = String(msgData.heartfelt_voice);
        }
        if (msgData.random_jottings) {
            chat.randomJottings = String(msgData.random_jottings);
        }
        if (!Array.isArray(chat.thoughtsHistory)) {
            chat.thoughtsHistory = [];
        }
        chat.thoughtsHistory.push({
            heartfeltVoice: chat.heartfeltVoice,
            randomJottings: chat.randomJottings,
            timestamp: Date.now()
        });
        if (chat.thoughtsHistory.length > 50) {
            chat.thoughtsHistory.shift();
        }

        
        
        const thoughtForMemory = `[è¿™æ˜¯ä½ ä¸Šä¸€è½®çš„å†…å¿ƒç‹¬ç™½å’Œæ€è€ƒ]
- å¿ƒå£°: ${chat.heartfeltVoice}
- æ•£è®°: ${chat.randomJottings}`;
        
        
        const hiddenThoughtMessage = {
            role: 'system',
            content: thoughtForMemory,
            timestamp: Date.now(),
            isHidden: true 
        };

        
       
        
    }
    continue;
                        case 'change_user_nickname':
                            if (!chat.isGroup && msgData.new_name) {
                                const newNickname = msgData.new_name.trim();
                                if (newNickname) {
                                    chat.settings.myNickname = newNickname;
        
                                    const systemMessage = {
                                        role: 'system',
                                        type: 'pat_message',
                                        content: `â€œ${chat.name}â€ å°†å¯¹ä½ çš„ç§°å‘¼ä¿®æ”¹ä¸º â€œ${newNickname}â€`,
                                        timestamp: messageTimestamp++
                                    };
                                    chat.history.push(systemMessage);
        
                                    const hiddenMemoryMessage = {
                                        role: 'system',
                                        content: `[ç³»ç»Ÿæç¤ºï¼šä½ åˆšåˆšæˆåŠŸå°†å¯¹ç”¨æˆ·çš„ç§°å‘¼ä¿®æ”¹ä¸ºäº†â€œ${newNickname}â€ã€‚]`,
                                        timestamp: messageTimestamp++,
                                        isHidden: true
                                    };
                                    chat.history.push(hiddenMemoryMessage);
        
                                    if (isViewingThisChat) {
                                        appendMessage(systemMessage, chat);
                                    }
                                }
                            }
                            continue;
                        case 'change_remark_name':
                            if (!chat.isGroup && msgData.new_name) {
                                const oldName = chat.name; 
                                const newName = msgData.new_name.trim();
        
                                if (newName && newName !== oldName) {
                                    if (!chat.nameHistory) {
                                        chat.nameHistory = [];
                                    }
                                    if (!chat.nameHistory.includes(oldName)) {
                                        chat.nameHistory.push(oldName);
                                    }
                                    
                                    chat.name = newName; 
        
                                    const systemMessage = {
                                        role: 'system',
                                        type: 'pat_message',
                                        content: `â€œ${chat.originalName}â€ å°†å¤‡æ³¨ä¿®æ”¹ä¸º â€œ${newName}â€`,
                                        timestamp: messageTimestamp++
                                    };
                                    chat.history.push(systemMessage);
        
                                    const hiddenMemoryMessage = {
                                        role: 'system',
                                        content: `[ç³»ç»Ÿæç¤ºï¼šä½ åˆšåˆšæˆåŠŸå°†è‡ªå·±çš„å¤‡æ³¨åä¿®æ”¹ä¸ºäº†â€œ${newName}â€ã€‚è¯·è‡ªç„¶åœ°æŽ¥å—è¿™ä¸ªæ–°åå­—ï¼Œä¸è¦å¯¹æ­¤æ„Ÿåˆ°æƒŠè®¶ã€‚]`,
                                        timestamp: messageTimestamp++, 
                                        isHidden: true
                                    };
                                    chat.history.push(hiddenMemoryMessage);
        
                                    if (isViewingThisChat) {
                                        appendMessage(systemMessage, chat);
                                        document.getElementById('chat-header-title').textContent = newName;
                                    }
                                    
                                    await syncCharacterNameInGroups(chat); 
                                }
                            }
                            continue;
        
                        case 'change_avatar': {
                            const avatarName = msgData.name;
                            const foundAvatar = chat.settings.aiAvatarLibrary.find(avatar => avatar.name === avatarName);
                            if (foundAvatar) {
                                chat.settings.aiAvatar = foundAvatar.url;
                                
                                const systemNotice = {
                                    role: 'system',
                                    type: 'pat_message',
                                    content: `[${chat.name} æ›´æ¢äº†å¤´åƒ]`,
                                    timestamp: Date.now()
                                };
                                chat.history.push(systemNotice);
        
                                await syncCharacterAvatarInGroups(chat);
                                
                                if (isViewingThisChat) {
                                    appendMessage(systemNotice, chat);
                                    renderChatInterface(chatId);
                                }
                            }
                            continue;
                        }
                        case 'change_user_avatar': {
                            const avatarName = msgData.name;
                            const foundAvatar = chat.settings.myAvatarLibrary.find(avatar => avatar.name === avatarName);
                            if (foundAvatar) {
                                chat.settings.myAvatar = foundAvatar.url;
                                
                                const systemNotice = {
                                    role: 'system',
                                    type: 'pat_message',
                                    content: `[${chat.name} æ›´æ¢äº†ä½ çš„å¤´åƒ]`,
                                    timestamp: Date.now()
                                };
                                chat.history.push(systemNotice);
                                
                                if (isViewingThisChat) {
                                    appendMessage(systemNotice, chat);
                                    renderChatInterface(chatId);
                                }
                            }
                            continue; 
                        }

case 'gomoku_move': { 
    
    const x = parseInt(msgData.x);
    const y = parseInt(msgData.y);

    
    if (!isNaN(x) && !isNaN(y)) {
        handleAiGomokuMove({ x: x, y: y });
    } else {
        console.warn("AIçš„äº”å­æ£‹ç§»åŠ¨æŒ‡ä»¤åŒ…å«æ— æ•ˆåæ ‡ï¼Œå·²å¿½ç•¥:", msgData);
    }
    continue; 
}
  
                        case 'waimai_response':
                            const requestMessageIndex = chat.history.findIndex(m => m.timestamp === msgData.for_timestamp);
                            if (requestMessageIndex > -1) {
                                const originalMsg = chat.history[requestMessageIndex];
                                originalMsg.status = msgData.status;
                                originalMsg.paidBy = msgData.status === 'paid' ? msgData.name : null;
                            }
                            continue;
        
                        case 'qzone_post':
    const newPost = { 
        type: msgData.postType, 
        content: msgData.content || '', 
        publicText: msgData.publicText || '', 
        hiddenContent: msgData.hiddenContent || '', 
       image_prompt: msgData.image_prompt || '', // <--- æŠŠè¿™è¡ŒåŠ å›žæ¥
        timestamp: Date.now(), 
        authorId: chatId, 
        authorGroupId: chat.groupId, // ã€æ ¸å¿ƒæ–°å¢žã€‘è®°å½•ä½œè€…çš„åˆ†ç»„ID
        visibleGroupIds: null 
    };
    
    
    // å¦‚æžœæ˜¯naiimagç±»åž‹ï¼Œè°ƒç”¨NovelAI APIç”Ÿæˆé«˜è´¨é‡å›¾ç‰‡ï¼ˆé™åˆ¶æœ€å¤š2å¼ ï¼‰
    if (msgData.postType === 'naiimag' && msgData.prompt) {
        try {
            // æ”¯æŒ prompt ä¸ºæ•°ç»„ï¼ˆå¤šå¼ å›¾ç‰‡ï¼‰æˆ–å­—ç¬¦ä¸²ï¼ˆå•å¼ å›¾ç‰‡ï¼‰
            // åŠ¨æ€é™åˆ¶æœ€å¤š2å¼ NAIå›¾ç‰‡
            const prompts = Array.isArray(msgData.prompt) ? msgData.prompt.slice(0, 2) : [msgData.prompt];
            console.log(`ðŸ“¸ åŠ¨æ€NovelAIå›¾ç‰‡ç”Ÿæˆå¼€å§‹ï¼Œå…±${prompts.length}å¼ å›¾ç‰‡`);
            
            // å­˜å‚¨ç”Ÿæˆçš„å›¾ç‰‡URL
            const generatedImageUrls = [];
            
            // é€ä¸ªç”Ÿæˆå›¾ç‰‡
            for (let i = 0; i < prompts.length; i++) {
                const aiPrompt = prompts[i];
                console.log(`ç”Ÿæˆç¬¬${i+1}å¼ å›¾ç‰‡ï¼Œprompt:`, aiPrompt);
                
                // èŽ·å–è§’è‰²çš„NAIæç¤ºè¯é…ç½®ï¼ˆç³»ç»Ÿæˆ–è§’è‰²ä¸“å±žï¼‰
                const naiPrompts = getCharacterNAIPrompts(chat.id);
                
                // æž„å»ºæœ€ç»ˆçš„æç¤ºè¯ï¼šAIçš„prompt + é…ç½®çš„æç¤ºè¯
                const finalPositivePrompt = aiPrompt + ', ' + naiPrompts.positive;
                const finalNegativePrompt = naiPrompts.negative;
                
                console.log(`ðŸ“ ä½¿ç”¨${naiPrompts.source === 'character' ? 'è§’è‰²ä¸“å±ž' : 'ç³»ç»Ÿ'}æç¤ºè¯é…ç½®`);
                console.log('æœ€ç»ˆæ­£é¢æç¤ºè¯:', finalPositivePrompt);
                console.log('æœ€ç»ˆè´Ÿé¢æç¤ºè¯:', finalNegativePrompt);
                
                // èŽ·å–NAIè®¾ç½®ï¼ˆä»ŽlocalStorageè¯»å–ï¼‰
                const apiKey = localStorage.getItem('novelai-api-key');
                const model = localStorage.getItem('novelai-model') || 'nai-diffusion-4-5-full';
                const settings = getNovelAISettings();
                
                if (!apiKey) {
                    throw new Error('NovelAI API Keyæœªé…ç½®ã€‚è¯·åœ¨NovelAIè®¾ç½®ä¸­å¡«å†™API Keyã€‚');
                }
                
                const [width, height] = settings.resolution.split('x').map(Number);
                
                // â˜…â˜…â˜… V4/V4.5 å’Œ V3 ä½¿ç”¨ä¸åŒçš„è¯·æ±‚ä½“æ ¼å¼ â˜…â˜…â˜…
                let requestBody;
                
                if (model.includes('nai-diffusion-4')) {
                    // V4/V4.5 ä½¿ç”¨æ–°æ ¼å¼ (params_version: 3)
                    requestBody = {
                        input: finalPositivePrompt,
                        model: model,
                        action: 'generate',
                        parameters: {
                            params_version: 3,  // V4å¿…é¡»ä½¿ç”¨ç‰ˆæœ¬3
                            width: width,
                            height: height,
                            scale: settings.cfg_scale,
                            sampler: settings.sampler,
                            steps: settings.steps,
                            seed: settings.seed === -1 ? Math.floor(Math.random() * 9999999999) : settings.seed,
                            n_samples: 1,
                            ucPreset: settings.uc_preset,
                            qualityToggle: settings.quality_toggle,
                            autoSmea: false,
                            dynamic_thresholding: false,
                            controlnet_strength: 1,
                            legacy: false,
                            add_original_image: true,
                            cfg_rescale: 0,
                            noise_schedule: 'karras',  // V4ä½¿ç”¨karras
                            legacy_v3_extend: false,
                            skip_cfg_above_sigma: null,
                            use_coords: false,
                            legacy_uc: false,
                            normalize_reference_strength_multiple: true,
                            inpaintImg2ImgStrength: 1,
                            characterPrompts: [],
                            // V4ä¸“ç”¨æç¤ºè¯æ ¼å¼
                            v4_prompt: {
                                caption: {
                                    base_caption: finalPositivePrompt,
                                    char_captions: []
                                },
                                use_coords: false,
                                use_order: true
                            },
                            // V4ä¸“ç”¨è´Ÿé¢æç¤ºè¯æ ¼å¼
                            v4_negative_prompt: {
                                caption: {
                                    base_caption: finalNegativePrompt,
                                    char_captions: []
                                },
                                legacy_uc: false
                            },
                            negative_prompt: finalNegativePrompt,
                            deliberate_euler_ancestral_bug: false,
                            prefer_brownian: true
                            // æ³¨æ„ï¼šä¸åŒ…å« stream å‚æ•°ï¼Œä½¿ç”¨æ ‡å‡†ZIPå“åº”è€Œéžmsgpackæµ
                        }
                    };
                } else {
                    // V3 åŠæ›´æ—©ç‰ˆæœ¬ä½¿ç”¨æ—§æ ¼å¼
                    requestBody = {
                        input: finalPositivePrompt,
                        model: model,
                        action: 'generate',
                        parameters: {
                            width: width,
                            height: height,
                            scale: settings.cfg_scale,
                            sampler: settings.sampler,
                            steps: settings.steps,
                            seed: settings.seed === -1 ? Math.floor(Math.random() * 9999999999) : settings.seed,
                            n_samples: 1,
                            ucPreset: settings.uc_preset,
                            qualityToggle: settings.quality_toggle,
                            sm: settings.smea,
                            sm_dyn: settings.smea_dyn,
                            dynamic_thresholding: false,
                            controlnet_strength: 1,
                            legacy: false,
                            add_original_image: false,
                            cfg_rescale: 0,
                            noise_schedule: 'native',
                            negative_prompt: finalNegativePrompt
                        }
                    };
                }
                
                console.log('ðŸš€ å‘é€NAIè¯·æ±‚:', requestBody);
                
                // â˜…â˜…â˜… æ ¹æ®æ¨¡åž‹é€‰æ‹©ä¸åŒçš„APIç«¯ç‚¹ â˜…â˜…â˜…
                let apiUrl;
                
                // V4/V4.5 æ¨¡åž‹ä½¿ç”¨æµå¼ç«¯ç‚¹
                if (model.includes('nai-diffusion-4')) {
                    // V4/V4.5 é»˜è®¤ä½¿ç”¨æµå¼ç«¯ç‚¹
                    apiUrl = 'https://image.novelai.net/ai/generate-image-stream';
                } else {
                    // V3 åŠæ›´æ—©ç‰ˆæœ¬ä½¿ç”¨æ ‡å‡†ç«¯ç‚¹
                    apiUrl = 'https://image.novelai.net/ai/generate-image';
                }
                
                let corsProxy = settings.cors_proxy;
                
                // å¦‚æžœé€‰æ‹©äº†è‡ªå®šä¹‰ä»£ç†ï¼Œä½¿ç”¨è‡ªå®šä¹‰URL
                if (corsProxy === 'custom') {
                    corsProxy = settings.custom_proxy_url || '';
                }
                
                // å¦‚æžœæœ‰ä»£ç†ï¼Œæ·»åŠ åˆ°URLå‰é¢
                if (corsProxy && corsProxy !== '') {
                    apiUrl = corsProxy + encodeURIComponent(apiUrl);
                }
                
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': 'Bearer ' + apiKey
                    },
                    body: JSON.stringify(requestBody)
                });
                
                console.log('Response status:', response.status);
                console.log('Response headers:', [...response.headers.entries()]);
                
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('APIé”™è¯¯å“åº”:', errorText);
                    throw new Error(`APIè¯·æ±‚å¤±è´¥ (${response.status}): ${errorText}`);
                }
                
                // NovelAI APIè¿”å›žçš„æ˜¯ZIPæ–‡ä»¶ï¼Œéœ€è¦è§£åŽ‹
                const contentType = response.headers.get('content-type');
                console.log('Content-Type:', contentType);
                
                // æ£€æŸ¥æ˜¯å¦ä¸º SSE æµå¼å“åº”
                let zipBlob;
                let imageDataUrl;
                if (contentType && contentType.includes('text/event-stream')) {
                    console.log('æ£€æµ‹åˆ° SSE æµå¼å“åº”ï¼Œå¼€å§‹è§£æž...');
                    
                    // è¯»å–æ•´ä¸ªæµ
                    const text = await response.text();
                    console.log('æ”¶åˆ° SSE æ•°æ®ï¼Œå¤§å°:', text.length);
                    
                    // è§£æž SSE æ ¼å¼ï¼Œæå–æœ€åŽçš„ data: è¡Œ
                    const lines = text.trim().split('\n');
                    let base64Data = null;
                    
                    for (let i = lines.length - 1; i >= 0; i--) {
                        const line = lines[i].trim();
                        if (line.startsWith('data: ') && line !== 'data: [DONE]') {
                            const dataContent = line.substring(6); // ç§»é™¤ 'data: ' å‰ç¼€
                            
                            // å°è¯•è§£æž JSON
                            try {
                                const jsonData = JSON.parse(dataContent);
                                
                                // V4.5 æµå¼ç«¯ç‚¹ï¼ševent_type ä¸º "final" æ—¶åŒ…å«æœ€ç»ˆå›¾ç‰‡
                                if (jsonData.event_type === 'final' && jsonData.image) {
                                    base64Data = jsonData.image;
                                    console.log('âœ… æ‰¾åˆ° final äº‹ä»¶çš„å›¾ç‰‡æ•°æ®');
                                    break;
                                }
                                
                                // å…¼å®¹å…¶ä»–æ ¼å¼
                                if (jsonData.data) {
                                    base64Data = jsonData.data;
                                    console.log('ä»Ž JSON.data ä¸­æå–å›¾ç‰‡æ•°æ®');
                                    break;
                                }
                                if (jsonData.image) {
                                    base64Data = jsonData.image;
                                    console.log('ä»Ž JSON.image ä¸­æå–å›¾ç‰‡æ•°æ®');
                                    break;
                                }
                            } catch (e) {
                                // å¦‚æžœä¸æ˜¯ JSONï¼Œç›´æŽ¥ä½œä¸º base64 æ•°æ®
                                base64Data = dataContent;
                                console.log('ç›´æŽ¥ä½¿ç”¨ base64 æ•°æ®');
                                break;
                            }
                        }
                    }
                    
                    if (!base64Data) {
                        throw new Error('æ— æ³•ä»Ž SSE å“åº”ä¸­æå–å›¾ç‰‡æ•°æ®');
                    }
                    
                    // V4.5 æµå¼ç«¯ç‚¹è¿”å›žçš„æ˜¯ PNG base64ï¼Œä¸æ˜¯ ZIP
                    // æ£€æŸ¥æ˜¯å¦ä¸º PNG (ä»¥ iVBORw0KGgo å¼€å¤´) æˆ– JPEG (ä»¥ /9j/ å¼€å¤´)
                    const isPNG = base64Data.startsWith('iVBORw0KGgo');
                    const isJPEG = base64Data.startsWith('/9j/');
                    
                    if (isPNG || isJPEG) {
                        console.log('âœ… æ£€æµ‹åˆ°ç›´æŽ¥çš„å›¾ç‰‡ base64 æ•°æ® (PNG/JPEG)');
                        // å°† base64 è½¬ä¸º Blob
                        const binaryString = atob(base64Data);
                        const bytes = new Uint8Array(binaryString.length);
                        for (let i = 0; i < binaryString.length; i++) {
                            bytes[i] = binaryString.charCodeAt(i);
                        }
                        const imageBlob = new Blob([bytes], { type: isPNG ? 'image/png' : 'image/jpeg' });
                        console.log('å›¾ç‰‡ Blob åˆ›å»ºæˆåŠŸï¼Œå¤§å°:', imageBlob.size);
                        
                        // è½¬æ¢ä¸ºdataURLç”¨äºŽåŽç»­å¤„ç†
                        const reader = new FileReader();
                        imageDataUrl = await new Promise((resolve, reject) => {
                            reader.onloadend = () => resolve(reader.result);
                            reader.onerror = reject;
                            reader.readAsDataURL(imageBlob);
                        });
                        console.log('âœ… å›¾ç‰‡è½¬æ¢æˆåŠŸï¼ðŸŽ¨');
                    } else {
                        // å¦åˆ™å½“ä½œ ZIP å¤„ç†
                        console.log('å½“ä½œ ZIP æ–‡ä»¶å¤„ç†...');
                        const binaryString = atob(base64Data);
                        const bytes = new Uint8Array(binaryString.length);
                        for (let i = 0; i < binaryString.length; i++) {
                            bytes[i] = binaryString.charCodeAt(i);
                        }
                        zipBlob = new Blob([bytes]);
                        console.log('ZIP Blob å¤§å°:', zipBlob.size);
                    }
                } else {
                    // éžæµå¼å“åº”ï¼Œç›´æŽ¥è¯»å–
                    zipBlob = await response.blob();
                    console.log('æ”¶åˆ°æ•°æ®ï¼Œç±»åž‹:', zipBlob.type, 'å¤§å°:', zipBlob.size);
                }
                
                // å¦‚æžœè¿˜æ²¡æœ‰imageDataUrlï¼ˆå³éœ€è¦è§£åŽ‹ZIPï¼‰
                if (!imageDataUrl && zipBlob) {
                    // NovelAIå§‹ç»ˆè¿”å›žZIPæ ¼å¼ï¼Œéœ€è¦è§£åŽ‹
                    try {
                        // æ£€æŸ¥JSZipæ˜¯å¦å·²åŠ è½½
                        if (typeof JSZip === 'undefined') {
                            throw new Error('JSZipåº“æœªåŠ è½½ï¼Œè¯·åˆ·æ–°é¡µé¢é‡è¯•');
                        }
                        
                        // è§£åŽ‹ZIPæ–‡ä»¶
                        const zip = await JSZip.loadAsync(zipBlob);
                        console.log('ZIPæ–‡ä»¶å†…å®¹:', Object.keys(zip.files));
                        
                        // æŸ¥æ‰¾ç¬¬ä¸€ä¸ªå›¾ç‰‡æ–‡ä»¶ï¼ˆé€šå¸¸æ˜¯image_0.pngï¼‰
                        let imageFile = null;
                        for (let filename in zip.files) {
                            if (filename.match(/\.(png|jpg|jpeg|webp)$/i)) {
                                imageFile = zip.files[filename];
                                console.log('æ‰¾åˆ°å›¾ç‰‡æ–‡ä»¶:', filename);
                                break;
                            }
                        }
                        
                        if (!imageFile) {
                            throw new Error('ZIPæ–‡ä»¶ä¸­æœªæ‰¾åˆ°å›¾ç‰‡');
                        }
                        
                        // æå–å›¾ç‰‡æ•°æ®
                        const imageBlob = await imageFile.async('blob');
                        console.log('æå–çš„å›¾ç‰‡å¤§å°:', imageBlob.size);
                        
                        // åˆ›å»ºå›¾ç‰‡URL
                        const reader = new FileReader();
                        imageDataUrl = await new Promise((resolve, reject) => {
                            reader.onloadend = () => resolve(reader.result);
                            reader.onerror = reject;
                            reader.readAsDataURL(imageBlob);
                        });
                        console.log('âœ… å›¾ç‰‡è§£åŽ‹æˆåŠŸï¼');
                    } catch (zipError) {
                        console.error('ZIPè§£åŽ‹å¤±è´¥:', zipError);
                        throw new Error('å›¾ç‰‡è§£åŽ‹å¤±è´¥: ' + zipError.message);
                    }
                }
                
                console.log(`âœ… NAIå›¾ç‰‡${i+1}ç”ŸæˆæˆåŠŸï¼`);
                generatedImageUrls.push(imageDataUrl);
            }
            
            // å°†ç”Ÿæˆçš„å›¾ç‰‡URLä¿å­˜åˆ°åŠ¨æ€ä¸­
            newPost.imageUrls = generatedImageUrls;
            
            // ä¿æŒå‘åŽå…¼å®¹ï¼Œå•å¼ å›¾ç‰‡æ—¶ä¹Ÿè®¾ç½® imageUrl
            if (generatedImageUrls.length === 1) {
                newPost.imageUrl = generatedImageUrls[0];
            }
            
            newPost.prompt = msgData.prompt;
            newPost.imageCount = generatedImageUrls.length;
            console.log(`âœ… åŠ¨æ€NovelAIå›¾ç‰‡å…¨éƒ¨ç”Ÿæˆå®Œæˆ: ${generatedImageUrls.length}å¼ `);
        } catch (error) {
            console.error('âŒ åŠ¨æ€NAIå›¾ç‰‡ç”Ÿæˆå¤±è´¥:', error);
            // å¤±è´¥æ—¶ä»ç„¶å‘å¸ƒåŠ¨æ€ï¼Œä½†æ·»åŠ é”™è¯¯ä¿¡æ¯
            newPost.content = (newPost.content || newPost.publicText || '') + `\n[å›¾ç‰‡ç”Ÿæˆå¤±è´¥: ${error.message}]`;
        }
    }
    
    await db.qzonePosts.add(newPost);
                    updateUnreadIndicator(unreadPostsCount + 1);
                    if (isViewingThisChat && document.getElementById('qzone-screen').classList.contains('active')) {
                       await renderQzonePosts();
                    }
                    continue;
        
case 'qzone_comment': { // ä½¿ç”¨å—çº§ä½œç”¨åŸŸ
                            const postToComment = await db.qzonePosts.get(parseInt(msgData.postId)); // ä¿®å¤: action -> msgData
                            if (postToComment) {
                                if (!postToComment.comments) postToComment.comments = [];
                                
                                const commenterName = msgData.name || chat.originalName; // ä¿®å¤: action -> msgData
        
                                const createCommentObject = (text, meaning = null, replyTo = null) => ({
                                    commenterName,
                                    text: processMentions(text, chat),
                                    meaning,
                                    replyTo,
                                    timestamp: Date.now()
                                });
        
                                if (msgData.stickerMeaning) { 
                                    const sticker = state.userStickers.find(s => s.name === msgData.stickerMeaning); // ä¿®å¤: action -> msgData
                                    if (sticker) {
                                        postToComment.comments.push(createCommentObject(sticker.url, sticker.name, msgData.replyTo || null)); // ä¿®å¤: action -> msgData
                                    } else {
                                        console.warn(`AI å°è¯•è¯„è®ºä¸€ä¸ªä¸å­˜åœ¨çš„è¡¨æƒ…: "${msgData.stickerMeaning}"`); // ä¿®å¤: action -> msgData
                                        postToComment.comments.push(createCommentObject(`[è¡¨æƒ…: ${msgData.stickerMeaning}]`, null, msgData.replyTo || null)); // ä¿®å¤: action -> msgData
                                    }
                                } else if (Array.isArray(msgData.comments)) { // ä¿®å¤: action -> msgData
                                    msgData.comments.forEach(commentText => { // ä¿®å¤: action -> msgData
                                        if (typeof commentText === 'string' && commentText.trim()) {
                                            postToComment.comments.push(createCommentObject(commentText, null, msgData.replyTo || null)); // ä¿®å¤: action -> msgData
                                        }
                                    });
                                } else if (typeof msgData.commentText === 'string' && msgData.commentText.trim()) { // ä¿®å¤: action -> msgData
                                    postToComment.comments.push(createCommentObject(msgData.commentText, null, msgData.replyTo || null)); // ä¿®å¤: action -> msgData
                                }
                                
                                await db.qzonePosts.update(postToComment.id, { comments: postToComment.comments });
                                updateUnreadIndicator(unreadPostsCount + 1);
                                console.log(`åŽå°æ´»åŠ¨: è§’è‰² "${chat.name}" è¯„è®ºäº†åŠ¨æ€ #${msgData.postId}`); // ä¿®å¤: action -> msgData
        
                                if (!chat.commentCooldowns) chat.commentCooldowns = {};
                                chat.commentCooldowns[msgData.postId] = Date.now(); // ä¿®å¤: action -> msgData
                            }
                            continue; 
                        }
                        case 'qzone_like':
                           const postToLike = await db.qzonePosts.get(parseInt(msgData.postId));
                           if (postToLike) {
                               if (!postToLike.likes) postToLike.likes = [];
                               if (!postToLike.likes.includes(chat.name)) {
                                   postToLike.likes.push(chat.name);
                                   await db.qzonePosts.update(postToLike.id, { likes: postToLike.likes });
                                   updateUnreadIndicator(unreadPostsCount + 1);
                                   if (isViewingThisChat && document.getElementById('qzone-screen').classList.contains('active')) {
                                      await renderQzonePosts();
                                   }
                               }
                           }
                            continue;
                        case 'repost': { 
                            const originalPost = await db.qzonePosts.get(parseInt(msgData.postId));
                            if (originalPost) {
                                const newPost = {
                                    type: 'repost',
                                    timestamp: Date.now(),
                                    authorId: chatId,
                                    authorGroupId: chat.groupId,
                                    repostComment: msgData.comment || '',
                                    originalPost: originalPost,
                                    visibleGroupIds: null
                                };
                                await db.qzonePosts.add(newPost);
                                updateUnreadIndicator(unreadPostsCount + 1);
                                console.log(`åŽå°æ´»åŠ¨: è§’è‰² "${chat.name}" è½¬å‘äº†åŠ¨æ€ #${msgData.postId}`);
                            }
                            continue;
                        }
                        case 'video_call_request':
                            if (!videoCallState.isActive && !videoCallState.isAwaitingResponse) {
                                state.activeChatId = chatId;
                                videoCallState.activeChatId = chatId; 
                                videoCallState.isAwaitingResponse = true;
                                videoCallState.isGroupCall = chat.isGroup;
                                videoCallState.callRequester = msgData.name || chat.name;
                                showIncomingCallModal();
                            }
                            continue;
                        case 'group_call_request':
                            if (!videoCallState.isActive && !videoCallState.isAwaitingResponse) {
                                state.activeChatId = chatId;
                                videoCallState.isAwaitingResponse = true;
                                videoCallState.isGroupCall = true;
                                videoCallState.initiator = 'ai';
                                videoCallState.callRequester = msgData.name;
                                showIncomingCallModal();
                            }
                            continue;
                        case 'pat_user':
                            let patterName;
                            if (chat.isGroup) {
                                const member = chat.members.find(m => m.originalName === msgData.name);
                                patterName = member ? member.groupNickname : msgData.name;
                            } else {
                                patterName = chat.name;
                            }
                            const suffix = msgData.suffix ? ` ${msgData.suffix.trim()}` : '';
                            const patText = `${patterName} æ‹äº†æ‹æˆ‘${suffix}`;
        
                            const patMessage = { 
                                role: 'system', 
                                type: 'pat_message', 
                                content: patText, 
                                timestamp: Date.now() 
                            };
                            chat.history.push(patMessage);
                            if (isViewingThisChat) {
                                const phoneScreen = document.getElementById('phone-screen');
                                phoneScreen.classList.remove('pat-animation');
                                void phoneScreen.offsetWidth;
                                phoneScreen.classList.add('pat-animation');
                                setTimeout(() => phoneScreen.classList.remove('pat-animation'), 500);
                                appendMessage(patMessage, chat);
                            } else {
                                showNotification(chatId, patText);
                            }
                            continue; 
                        case 'update_status':
                            chat.status.text = msgData.status_text;
                            chat.status.isBusy = msgData.is_busy || false;
                            chat.status.lastUpdate = Date.now();
                            const statusUpdateMessage = {
                                role: 'system',
                                type: 'pat_message',
                                content: `[${chat.name}çš„çŠ¶æ€å·²æ›´æ–°ä¸º: ${msgData.status_text}]`,
                                timestamp: Date.now()
                            };
                            chat.history.push(statusUpdateMessage);
                            if (isViewingThisChat) {
                                appendMessage(statusUpdateMessage, chat);
                            }
                            renderChatList(); 
                            continue; 
                        case 'location_share':
                            aiMessage = {
                                ...baseMessage,
                                type: 'location_share',
                                content: msgData.content
                            };
                            break;
                        case 'change_music':
                            if (musicState.isActive && musicState.activeChatId === chatId) {
                                const songNameFromAI = msgData.song_name || msgData.song || msgData.name;
        
                                if (typeof songNameFromAI === 'string' && songNameFromAI.trim()) {
                                    const songNameToFind = songNameFromAI.replace(/^\[?\d+\]?[\s.-]*/, '').trim();
                                    const targetSongIndex = musicState.playlist.findIndex(track => track.name.toLowerCase() === songNameToFind.toLowerCase());
                                    
                                    if (targetSongIndex > -1) {
                                        playSong(targetSongIndex);
                                        const track = musicState.playlist[targetSongIndex];
                                        
                                        let changerName;
                                        if (chat.isGroup) {
                                            const member = chat.members.find(m => m.originalName === msgData.name);
                                            changerName = member ? member.groupNickname : msgData.name;
                                        } else {
                                            changerName = chat.name;
                                        }
                                        
                                        const musicChangeMessage = {
                                            role: 'system',
                                            type: 'pat_message',
                                            content: `[â™ª ${changerName} ä¸ºä½ åˆ‡æ­Œ: ã€Š${track.name}ã€‹ - ${track.artist}]`,
                                            timestamp: Date.now()
                                        };
                                        chat.history.push(musicChangeMessage);
                                        if (isViewingThisChat) {
                                            appendMessage(musicChangeMessage, chat);
                                        }
                                    } else {
                                        console.warn(`æ­Œæ›²æŸ¥æ‰¾å¤±è´¥: AIè¯·æ±‚çš„æ­Œæ›²å"${songNameFromAI}"(å¤„ç†åŽä¸º"${songNameToFind}") åœ¨æ’­æ”¾åˆ—è¡¨ä¸­æœªæ‰¾åˆ°ã€‚`);
                                    }
                                } else {
                                    console.error("AIè¿”å›žçš„change_musicæŒ‡ä»¤ä¸­ï¼Œæ­Œæ›²åæ— æ•ˆæˆ–ç¼ºå¤±:", msgData);
                                }
                            }
                            continue;
                        case 'create_memory':
                            const newMemory = {
                                chatId: chatId,
                                authorId: chatId,
                                description: msgData.description,
                                timestamp: Date.now(),
                                type: 'ai_generated'
                            };
                            await db.memories.add(newMemory);
                            console.log(`AI "${chat.name}" è®°å½•äº†ä¸€æ¡æ–°å›žå¿†:`, msgData.description);
                            continue; 
                        case 'create_countdown':
                            const targetDate = new Date(msgData.date);
                            if (!isNaN(targetDate) && targetDate > new Date()) {
                                const newCountdown = {
                                    chatId: chatId,
                                    authorId: chatId,
                                    description: msgData.title,
                                    timestamp: Date.now(),
                                    type: 'countdown',
                                    targetDate: targetDate.getTime()
                                };
                                await db.memories.add(newCountdown);
                                console.log(`AI "${chat.name}" åˆ›å»ºäº†ä¸€ä¸ªæ–°çº¦å®š:`, msgData.title);
                            }
                            continue;
                        case 'block_user':
                            if (!chat.isGroup) {
                                chat.relationship.status = 'blocked_by_ai';
                                const hiddenMessage = {
                                    role: 'system',
                                    content: `[ç³»ç»Ÿæç¤ºï¼šä½ åˆšåˆšä¸»åŠ¨æ‹‰é»‘äº†ç”¨æˆ·ã€‚]`,
                                    timestamp: Date.now(),
                                    isHidden: true
                                };
                                chat.history.push(hiddenMessage);
                                await db.chats.put(chat);
                                if (isViewingThisChat) {
                                    renderChatInterface(chatId);
                                }
                                renderChatList();
                                break; 
                            }
                            continue;
                        case 'friend_request_response':
                            if (!chat.isGroup && chat.relationship?.status === 'pending_ai_approval') {
                                if (msgData.decision === 'accept') {
                                    chat.relationship.status = 'friend';
                                    aiMessage = { ...baseMessage, content: "æˆ‘é€šè¿‡äº†ä½ çš„å¥½å‹ç”³è¯·ï¼Œæˆ‘ä»¬çŽ°åœ¨æ˜¯å¥½å‹å•¦ï¼" };
                                } else {
                                    chat.relationship.status = 'blocked_by_ai';
                                    aiMessage = { ...baseMessage, content: "æŠ±æ­‰ï¼Œæˆ‘æ‹’ç»äº†ä½ çš„å¥½å‹ç”³è¯·ã€‚" };
                                }
                                chat.relationship.applicationReason = '';
                            }
                            break;
                        case 'poll':
                            const pollOptions = typeof msgData.options === 'string'
                                ? msgData.options.split('\n').filter(opt => opt.trim())
                                : (Array.isArray(msgData.options) ? msgData.options : []);
                            if (pollOptions.length < 2) continue;
                            aiMessage = {
                                ...baseMessage,
                                type: 'poll',
                                question: msgData.question,
                                options: pollOptions,
                                votes: {},
                                isClosed: false,
                            };
                            break;
case 'gift': {
    const { itemName, itemPrice, image_prompt } = msgData; 
    
    if (itemName && !isNaN(parseFloat(itemPrice)) && image_prompt) {
        
        const imageUrl = `https://image.pollinations.ai/prompt/${encodeURIComponent(image_prompt)}`;

        aiMessage = {
            ...baseMessage,
            type: 'gift',
            items: [{
                name: itemName,
                price: parseFloat(itemPrice), 
                imageUrl: imageUrl, 
                quantity: 1 
            }],
            total: parseFloat(itemPrice),
            recipients: msgData.recipients || null 
        };
    } else {
        console.warn(`AI å°è¯•èµ é€ä¸€ä¸ªæ ¼å¼ä¸æ­£ç¡®çš„éšæœºç¤¼ç‰©:`, msgData); 
    }
    break;
}
                        case 'vote':
                            const pollToVote = chat.history.find(m => m.timestamp === msgData.poll_timestamp);
                            if (pollToVote && !pollToVote.isClosed) {
                                Object.keys(pollToVote.votes).forEach(option => {
                                    const voterIndex = pollToVote.votes[option].indexOf(msgData.name);
                                    if (voterIndex > -1) {
                                        pollToVote.votes[option].splice(voterIndex, 1);
                                    }
                                });
                                if (!pollToVote.votes[msgData.choice]) {
                                    pollToVote.votes[msgData.choice] = [];
                                }
                                if (!pollToVote.votes[msgData.choice].includes(msgData.name)) {
                                    pollToVote.votes[msgData.choice].push(msgData.name);
                                }                        
                                if (isViewingThisChat) {
                                    renderChatInterface(chatId);
                                }
                            }
                            continue;
                        case 'red_packet':
                            aiMessage = {
                                ...baseMessage,
                                ...msgData,
                                totalAmount: msgData.amount, 
                                claimedBy: {}, 
                                isFullyClaimed: false
                            };
                            if (msgData.receiver) {
                                aiMessage.receiverName = msgData.receiver;
                                delete aiMessage.receiver;
                            }
                            break;
                        case 'open_red_packet':
                            const packetToOpen = chat.history.find(m => m.timestamp === msgData.packet_timestamp);
                            
const claimerOriginalName = msgData.name; 
const isMember = chat.members.some(member => member.originalName === claimerOriginalName);


if (!isMember) {
    console.warn(`AI è§’è‰² "${claimerOriginalName}" å°è¯•é¢†å–ä¸å±žäºŽè‡ªå·±çš„ç¾¤èŠçº¢åŒ…ã€‚æ“ä½œå·²è¢«æ‹¦æˆªã€‚`);
    continue; 
}

                            if (packetToOpen && packetToOpen.packetType === 'direct') {
                                if (packetToOpen.receiverName !== msgData.name) {
                                    console.warn(`AI è§’è‰² "${msgData.name}" å°è¯•é¢†å–ä¸å±žäºŽè‡ªå·±çš„ä¸“å±žçº¢åŒ… (æŽ¥æ”¶äºº: ${packetToOpen.receiverName})ã€‚æ“ä½œå·²è¢«æ‹¦æˆªã€‚`);
                                    continue;
                                }
                            }
                            
                            if (packetToOpen && !packetToOpen.isFullyClaimed && !(packetToOpen.claimedBy && packetToOpen.claimedBy[msgData.name])) {
                                let claimedAmountAI = 0;
                                const remainingAmount = packetToOpen.totalAmount - Object.values(packetToOpen.claimedBy || {}).reduce((sum, val) => sum + val, 0);
                                const remainingCount = packetToOpen.count - Object.keys(packetToOpen.claimedBy || {}).length;
                                if (remainingCount > 0) {
                                    if (packetToOpen.packetType === 'direct') {
                                        claimedAmountAI = packetToOpen.totalAmount;
                                    } else {
                                        if (remainingCount === 1) { claimedAmountAI = remainingAmount; } 
                                        else {
                                            const min = 0.01;
                                            const max = remainingAmount - (remainingCount - 1) * min;
                                            claimedAmountAI = Math.random() * (max - min) + min;
                                        }
                                    }
        
                                    claimedAmountAI = parseFloat(claimedAmountAI.toFixed(2));
                                    if (!packetToOpen.claimedBy) packetToOpen.claimedBy = {};
                                    packetToOpen.claimedBy[msgData.name] = claimedAmountAI;
        

const claimerMember = chat.members.find(m => m.originalName === msgData.name);
const claimerDisplayName = claimerMember ? claimerMember.groupNickname : msgData.name;


const senderDisplayName = getDisplayNameInGroup(chat, packetToOpen.senderName);

const aiClaimedMessage = {
    role: 'system',
    type: 'pat_message',
    content: `${claimerDisplayName} é¢†å–äº† ${senderDisplayName} çš„çº¢åŒ…`, 
    timestamp: Date.now()
};
chat.history.push(aiClaimedMessage);

                                    let hiddenContentForAI = `[ç³»ç»Ÿæç¤ºï¼šä½  (${claimerDisplayName}) æˆåŠŸæŠ¢åˆ°äº† ${claimedAmountAI.toFixed(2)} å…ƒã€‚`;
                                    if (Object.keys(packetToOpen.claimedBy).length >= packetToOpen.count) {
                                        packetToOpen.isFullyClaimed = true;
                                        const finishedMessage = {
                                            role: 'system',
                                            type: 'pat_message',
                                            content: `${senderDisplayName} çš„çº¢åŒ…å·²è¢«é¢†å®Œ`,
                                            timestamp: Date.now() + 1
                                        };
                                        chat.history.push(finishedMessage);
                                        let luckyKing = { name: '', amount: -1 };
                                        if (packetToOpen.packetType === 'lucky' && packetToOpen.count > 1) {
                                            Object.entries(packetToOpen.claimedBy).forEach(([name, amount]) => {
                                                if (amount > luckyKing.amount) {
                                                    luckyKing = { name, amount };
                                                }
                                            });
                                        }
                                        if (luckyKing.name) {
                                             const luckyKingMember = chat.members.find(m => m.originalName === luckyKing.name);
                                             const luckyKingDisplayName = luckyKingMember ? luckyKingMember.groupNickname : luckyKing.name;
                                             hiddenContentForAI += ` çº¢åŒ…å·²è¢«é¢†å®Œï¼Œæ‰‹æ°”çŽ‹æ˜¯ ${luckyKingDisplayName}ï¼`;
                                        } else {
                                             hiddenContentForAI += ` çº¢åŒ…å·²è¢«é¢†å®Œã€‚`;
                                        }
                                    }
                                    hiddenContentForAI += ' è¯·æ ¹æ®è¿™ä¸ªç»“æžœå‘è¡¨ä½ çš„è¯„è®ºã€‚]';
                                    const hiddenMessageForAI = {
                                        role: 'system',
                                        content: hiddenContentForAI,
                                        timestamp: Date.now() + 2,
                                        isHidden: true
                                    };
                                    chat.history.push(hiddenMessageForAI);
                                }
                                if (isViewingThisChat) {
                                    renderChatInterface(chatId);
                                    renderChatList(); 
                                }
                            }
                            continue;
        
                        case 'accept_transfer': {
                            const originalTransferMsgIndex = chat.history.findIndex(m => m.timestamp === msgData.for_timestamp);
                            if (originalTransferMsgIndex > -1) {
                                const originalMsg = chat.history[originalTransferMsgIndex];
                                originalMsg.status = 'accepted';
                            }
                            continue;
                        }
        
                        case 'decline_transfer': {
                            const originalTransferMsgIndex = chat.history.findIndex(m => m.timestamp === msgData.for_timestamp);
                            if (originalTransferMsgIndex > -1) {
                                const originalMsg = chat.history[originalTransferMsgIndex];
                                originalMsg.status = 'declined';
                                const refundMessage = {
                                    role: 'assistant',
                                    senderName: chat.name,
                                    type: 'transfer',
                                    isRefund: true,
                                    amount: originalMsg.amount,
                                    note: 'è½¬è´¦å·²è¢«æ‹’æ”¶',
                                    timestamp: messageTimestamp++
                                };
                                chat.history.push(refundMessage);
                                if (isViewingThisChat) {
                                    appendMessage(refundMessage, chat); 
                                    renderChatInterface(chatId); 
                                }
                            }
                            continue;
                        }
                        case 'change_group_name':
                            if (chat.isGroup && msgData.new_name) {
                                const newName = msgData.new_name.trim();
                                const memberNames = chat.members.map(m => m.originalName);
        
                                if (memberNames.includes(newName)) {
                                    console.warn(`AI (${msgData.name}) è¯•å›¾å°†ç¾¤åæ›´æ”¹ä¸ºæˆå‘˜å ("${newName}")ã€‚æ“ä½œå·²è¢«ç¨‹åºé˜»æ­¢ã€‚`);
                                    continue; 
                                }
        
                                chat.name = newName; 
        
                                const changerMember = chat.members.find(m => m.originalName === msgData.name);
                                const changerDisplayName = changerMember ? changerMember.groupNickname : msgData.name;
                                
                                const systemMessage = {
                                    role: 'system',
                                    type: 'pat_message',
                                    content: `${changerDisplayName} å°†ç¾¤åä¿®æ”¹ä¸º â€œ${chat.name}â€`,
                                    timestamp: messageTimestamp++
                                };
                                chat.history.push(systemMessage);
        
                                if (isViewingThisChat) {
                                    appendMessage(systemMessage, chat);
                                    document.getElementById('chat-header-title').textContent = chat.name;
                                }
                            }
                            continue;
                        case 'change_remark_name':
                            if (!chat.isGroup && msgData.new_name) {
                                const oldName = chat.name; 
                                const newName = msgData.new_name.trim();
        
                                if (newName && newName !== oldName) {
                                    if (!chat.nameHistory) {
                                        chat.nameHistory = [];
                                    }
                                    if (!chat.nameHistory.includes(oldName)) {
                                        chat.nameHistory.push(oldName);
                                    }
                                    
                                    chat.name = newName; 
        
                                    const systemMessage = {
                                        role: 'system',
                                        type: 'pat_message', 
                                        content: `â€œ${chat.originalName}â€ å°†å¤‡æ³¨ä¿®æ”¹ä¸º â€œ${newName}â€`,
                                        timestamp: messageTimestamp++
                                    };
                                    chat.history.push(systemMessage);
        
                                    const hiddenMemoryMessage = {
                                        role: 'system',
                                        content: `[ç³»ç»Ÿæç¤ºï¼šä½ åˆšåˆšæˆåŠŸå°†è‡ªå·±çš„å¤‡æ³¨åä¿®æ”¹ä¸ºäº†â€œ${newName}â€ã€‚è¯·è‡ªç„¶åœ°æŽ¥å—è¿™ä¸ªæ–°åå­—ï¼Œä¸è¦å¯¹æ­¤æ„Ÿåˆ°æƒŠè®¶ã€‚]`,
                                        timestamp: messageTimestamp++, 
                                        isHidden: true
                                    };
                                    chat.history.push(hiddenMemoryMessage);
        
                                    if (isViewingThisChat) {
                                        appendMessage(systemMessage, chat);
                                        document.getElementById('chat-header-title').textContent = newName;
                                    }
                                    
                                    await syncCharacterNameInGroups(chat); 
                                }
                            }
                            continue;
        
                        case 'change_group_avatar':
                            if (chat.isGroup && msgData.avatar_name) {
                                const avatarName = msgData.avatar_name;
                                const library = chat.settings.groupAvatarLibrary || [];
                                const foundAvatar = library.find(avatar => avatar.name === avatarName);
        
                                if (foundAvatar) {
                                    chat.settings.groupAvatar = foundAvatar.url;
                                    
                                    const changerMember = chat.members.find(m => m.originalName === msgData.name);
                                    const changerDisplayName = changerMember ? changerMember.groupNickname : msgData.name;
        
                                    const systemMessage = {
                                        role: 'system',
                                        type: 'pat_message',
                                        content: `${changerDisplayName} æ›´æ¢äº†ç¾¤å¤´åƒ`,
                                        timestamp: messageTimestamp++
                                    };
                                    chat.history.push(systemMessage);
        
                                    if (isViewingThisChat) {
                                        appendMessage(systemMessage, chat);
                                    }
                                } else {
                                    console.warn(`AI å°è¯•ä½¿ç”¨ä¸€ä¸ªä¸å­˜åœ¨çš„ç¾¤å¤´åƒ: "${avatarName}"`);
                                }
                            }
                            continue;
                        case 'system_message':
                            aiMessage = { role: 'system', type: 'pat_message', content: msgData.content, timestamp: Date.now() };
                            break;
                        case 'share_link':
                            aiMessage = { 
                                ...baseMessage, 
                                type: 'share_link',
                                title: msgData.title,
                                description: msgData.description,
                                source_name: msgData.source_name,
                                content: msgData.content
                            };
                            break;
                        case 'quote_reply':
                            const originalMessage = chat.history.find(m => m.timestamp === msgData.target_timestamp);
                            if (originalMessage) {
                                const quoteContext = {
                                    timestamp: originalMessage.timestamp,
                                    senderName: originalMessage.senderName || (originalMessage.role === 'user' ? (chat.settings.myNickname || 'æˆ‘') : chat.name),
                                    content: String(originalMessage.content || '').substring(0, 50),
                                };
                                aiMessage = { 
                                    ...baseMessage, 
                                    content: msgData.reply_content,
                                    quote: quoteContext
                                };
                            } else {
                                aiMessage = { ...baseMessage, content: msgData.reply_content };
                            }
                            break;
                        case 'send_and_recall': {
                            if (!isViewingThisChat) continue;
                            const tempMessageData = { ...baseMessage, content: msgData.content };
                            const tempMessageElement = createMessageElement(tempMessageData, chat);
                            appendMessage(tempMessageData, chat, true);
                            await new Promise(resolve => setTimeout(resolve, Math.random() * 1000 + 1500));
                            const bubbleWrapper = document.querySelector(`.message-bubble[data-timestamp="${tempMessageData.timestamp}"]`)?.closest('.message-wrapper');
                            if (bubbleWrapper) {
                                bubbleWrapper.classList.add('recalled-animation');
                                await new Promise(resolve => setTimeout(resolve, 300));
                                const recalledMessage = {
                                    role: 'assistant',
                                    senderName: msgData.name || chat.name,
                                    type: 'recalled_message',
                                    content: 'å¯¹æ–¹æ’¤å›žäº†ä¸€æ¡æ¶ˆæ¯',
                                    timestamp: tempMessageData.timestamp,
                                    recalledData: { originalType: 'text', originalContent: msgData.content }
                                };
                                const msgIndex = chat.history.findIndex(m => m.timestamp === tempMessageData.timestamp);
                                if (msgIndex > -1) {
                                    chat.history[msgIndex] = recalledMessage;
                                } else {
                                    chat.history.push(recalledMessage);
                                }
                                const placeholder = await createMessageElement(recalledMessage, chat);
                                if(document.body.contains(bubbleWrapper)) {
                                    bubbleWrapper.parentNode.replaceChild(placeholder, bubbleWrapper);
                                }
                            }
                            continue;
                        }
                        
                        case 'text':
                            aiMessage = { ...baseMessage, content: String(msgData.content || msgData.message) };
                            break;
                        case 'sticker':
                            if (msgData.meaning) {
                                const sticker = state.userStickers.find(s => s.name === msgData.meaning);
                                if (sticker) {
                                    aiMessage = { ...baseMessage, type: 'sticker', content: sticker.url, meaning: sticker.name };
                                } else {
                                    // å¦‚æžœAIè™šæž„äº†ä¸€ä¸ªä¸å­˜åœ¨çš„è¡¨æƒ…åï¼Œä½œä¸ºæ–‡æœ¬å‘é€
                                    console.warn(`AI å°è¯•ä½¿ç”¨ä¸€ä¸ªä¸å­˜åœ¨çš„è¡¨æƒ…: "${msgData.meaning}"`);
                                    aiMessage = { ...baseMessage, type: 'text', content: `[è¡¨æƒ…: ${msgData.meaning}]` };
                                }
                            } else {
                                // å…¼å®¹æ—§æ ¼å¼æˆ–é”™è¯¯æ ¼å¼
                                console.warn("AI å‘é€äº†ä¸€ä¸ªæ²¡æœ‰ 'meaning' çš„ sticker æŒ‡ä»¤ã€‚", msgData);
                                aiMessage = { ...baseMessage, type: 'sticker', content: msgData.url, meaning: 'æœªçŸ¥è¡¨æƒ…' };
                            }
                            break;
                        case 'ai_image':
                            aiMessage = { ...baseMessage, type: 'ai_image', content: msgData.description, image_prompt: msgData.image_prompt };
                            break;
                        case 'voice_message':
                            aiMessage = { ...baseMessage, type: 'voice_message', content: msgData.content };
                            break;
                        case 'transfer':
                            aiMessage = { ...baseMessage, type: 'transfer', amount: msgData.amount, note: msgData.note, receiverName: msgData.receiver || 'æˆ‘' };
                            break;
                        
                        case 'waimai_request':
                            aiMessage = { 
                                ...baseMessage, 
                                type: 'waimai_request',
                                productInfo: msgData.productInfo,
                                amount: msgData.amount,
                                status: 'pending',
                                countdownEndTime: Date.now() + 15 * 60 * 1000,
                            };
                            break;
                case 'waimai_order':
                    aiMessage = {
                        ...baseMessage,
                        type: 'waimai_order',
                        productInfo: msgData.productInfo,
                        amount: msgData.amount,
                        greeting: msgData.greeting,
                        recipientName: msgData.recipientName || null 
                    };
                    break;
                        case 'offline_text':
        aiMessage = { ...baseMessage, ...msgData };
                        break;
                        
                case 'naiimag':
// NovelAIå›¾ç‰‡åˆ†äº« - è°ƒç”¨NovelAI APIç”Ÿæˆé«˜è´¨é‡å›¾ç‰‡
try {
    console.log('ðŸ“¸ NovelAIå›¾ç‰‡ç”Ÿæˆå¼€å§‹ï¼ŒAIæä¾›çš„prompt:', msgData.prompt);
    
    // èŽ·å–è§’è‰²çš„NAIæç¤ºè¯é…ç½®ï¼ˆç³»ç»Ÿæˆ–è§’è‰²ä¸“å±žï¼‰
    const naiPrompts = getCharacterNAIPrompts(chat.id);
    
    // æž„å»ºæœ€ç»ˆçš„æç¤ºè¯ï¼šAIçš„prompt + é…ç½®çš„æç¤ºè¯
    const aiPrompt = msgData.prompt || 'a beautiful scene';
    const finalPositivePrompt = aiPrompt + ', ' + naiPrompts.positive;
    const finalNegativePrompt = naiPrompts.negative;
    
    console.log(`ðŸ“ ä½¿ç”¨${naiPrompts.source === 'character' ? 'è§’è‰²ä¸“å±ž' : 'ç³»ç»Ÿ'}æç¤ºè¯é…ç½®`);
    console.log('æœ€ç»ˆæ­£é¢æç¤ºè¯:', finalPositivePrompt);
    console.log('æœ€ç»ˆè´Ÿé¢æç¤ºè¯:', finalNegativePrompt);
    
    // èŽ·å–NAIè®¾ç½®ï¼ˆä»ŽlocalStorageè¯»å–ï¼‰
    const apiKey = localStorage.getItem('novelai-api-key');
    const model = localStorage.getItem('novelai-model') || 'nai-diffusion-4-5-full';
    const settings = getNovelAISettings();
    
    if (!apiKey) {
        throw new Error('NovelAI API Keyæœªé…ç½®ã€‚è¯·åœ¨NovelAIè®¾ç½®ä¸­å¡«å†™API Keyã€‚');
    }
    
    const [width, height] = settings.resolution.split('x').map(Number);
    
    // â˜…â˜…â˜… V4/V4.5 å’Œ V3 ä½¿ç”¨ä¸åŒçš„è¯·æ±‚ä½“æ ¼å¼ â˜…â˜…â˜…
    let requestBody;
    
    if (model.includes('nai-diffusion-4')) {
        // V4/V4.5 ä½¿ç”¨æ–°æ ¼å¼ (params_version: 3)
        requestBody = {
            input: finalPositivePrompt,
            model: model,
            action: 'generate',
            parameters: {
                params_version: 3,  // V4å¿…é¡»ä½¿ç”¨ç‰ˆæœ¬3
                width: width,
                height: height,
                scale: settings.cfg_scale,
                sampler: settings.sampler,
                steps: settings.steps,
                seed: settings.seed === -1 ? Math.floor(Math.random() * 9999999999) : settings.seed,
                n_samples: 1,
                ucPreset: settings.uc_preset,
                qualityToggle: settings.quality_toggle,
                autoSmea: false,
                dynamic_thresholding: false,
                controlnet_strength: 1,
                legacy: false,
                add_original_image: true,
                cfg_rescale: 0,
                noise_schedule: 'karras',  // V4ä½¿ç”¨karras
                legacy_v3_extend: false,
                skip_cfg_above_sigma: null,
                use_coords: false,
                legacy_uc: false,
                normalize_reference_strength_multiple: true,
                inpaintImg2ImgStrength: 1,
                characterPrompts: [],
                // V4ä¸“ç”¨æç¤ºè¯æ ¼å¼
                v4_prompt: {
                    caption: {
                        base_caption: finalPositivePrompt,
                        char_captions: []
                    },
                    use_coords: false,
                    use_order: true
                },
                // V4ä¸“ç”¨è´Ÿé¢æç¤ºè¯æ ¼å¼
                v4_negative_prompt: {
                    caption: {
                        base_caption: finalNegativePrompt,
                        char_captions: []
                    },
                    legacy_uc: false
                },
                negative_prompt: finalNegativePrompt,
                deliberate_euler_ancestral_bug: false,
                prefer_brownian: true
                // æ³¨æ„ï¼šä¸åŒ…å« stream å‚æ•°ï¼Œä½¿ç”¨æ ‡å‡†ZIPå“åº”è€Œéžmsgpackæµ
            }
        };
    } else {
        // V3 åŠæ›´æ—©ç‰ˆæœ¬ä½¿ç”¨æ—§æ ¼å¼
        requestBody = {
            input: finalPositivePrompt,
            model: model,
            action: 'generate',
            parameters: {
width: width,
                height: height,
                scale: settings.cfg_scale,
                sampler: settings.sampler,
                steps: settings.steps,
                seed: settings.seed === -1 ? Math.floor(Math.random() * 9999999999) : settings.seed,
                n_samples: 1,
                ucPreset: settings.uc_preset,
                qualityToggle: settings.quality_toggle,
                sm: settings.smea,
                sm_dyn: settings.smea_dyn,
                dynamic_thresholding: false,
                controlnet_strength: 1,
                legacy: false,
                add_original_image: false,
                cfg_rescale: 0,
                noise_schedule: 'native',
                negative_prompt: finalNegativePrompt
            }
        };
    }
    
    console.log('ðŸš€ å‘é€NAIè¯·æ±‚:', requestBody);
    
    // â˜…â˜…â˜… æ ¹æ®æ¨¡åž‹é€‰æ‹©ä¸åŒçš„APIç«¯ç‚¹ â˜…â˜…â˜…
    let apiUrl;
    
    // V4/V4.5 æ¨¡åž‹ä½¿ç”¨æµå¼ç«¯ç‚¹
    if (model.includes('nai-diffusion-4')) {
        // V4/V4.5 é»˜è®¤ä½¿ç”¨æµå¼ç«¯ç‚¹
        apiUrl = 'https://image.novelai.net/ai/generate-image-stream';
    } else {
        // V3 åŠæ›´æ—©ç‰ˆæœ¬ä½¿ç”¨æ ‡å‡†ç«¯ç‚¹
        apiUrl = 'https://image.novelai.net/ai/generate-image';
    }
    
    let corsProxy = settings.cors_proxy;
    
    // å¦‚æžœé€‰æ‹©äº†è‡ªå®šä¹‰ä»£ç†ï¼Œä½¿ç”¨è‡ªå®šä¹‰URL
    if (corsProxy === 'custom') {
        corsProxy = settings.custom_proxy_url || '';
    }
    
    // å¦‚æžœæœ‰ä»£ç†ï¼Œæ·»åŠ åˆ°URLå‰é¢
    if (corsProxy && corsProxy !== '') {
        apiUrl = corsProxy + encodeURIComponent(apiUrl);
    }
    
    const response = await fetch(apiUrl, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'Authorization': 'Bearer ' + apiKey
        },
        body: JSON.stringify(requestBody)
    });
    
    console.log('Response status:', response.status);
    console.log('Response headers:', [...response.headers.entries()]);
    
    if (!response.ok) {
        const errorText = await response.text();
        console.error('APIé”™è¯¯å“åº”:', errorText);
        throw new Error(`APIè¯·æ±‚å¤±è´¥ (${response.status}): ${errorText}`);
    }
    
    // NovelAI APIè¿”å›žçš„æ˜¯ZIPæ–‡ä»¶ï¼Œéœ€è¦è§£åŽ‹
    const contentType = response.headers.get('content-type');
    console.log('Content-Type:', contentType);
    
    // æ£€æŸ¥æ˜¯å¦ä¸º SSE æµå¼å“åº”
    let zipBlob;
    let imageDataUrl;
    if (contentType && contentType.includes('text/event-stream')) {
        console.log('æ£€æµ‹åˆ° SSE æµå¼å“åº”ï¼Œå¼€å§‹è§£æž...');
        
        // è¯»å–æ•´ä¸ªæµ
        const text = await response.text();
        console.log('æ”¶åˆ° SSE æ•°æ®ï¼Œå¤§å°:', text.length);
        
        // è§£æž SSE æ ¼å¼ï¼Œæå–æœ€åŽçš„ data: è¡Œ
        const lines = text.trim().split('\n');
        let base64Data = null;
        
        for (let i = lines.length - 1; i >= 0; i--) {
            const line = lines[i].trim();
            if (line.startsWith('data: ') && line !== 'data: [DONE]') {
                const dataContent = line.substring(6); // ç§»é™¤ 'data: ' å‰ç¼€
                
                // å°è¯•è§£æž JSON
                try {
                    const jsonData = JSON.parse(dataContent);
                    
                    // V4.5 æµå¼ç«¯ç‚¹ï¼ševent_type ä¸º "final" æ—¶åŒ…å«æœ€ç»ˆå›¾ç‰‡
                    if (jsonData.event_type === 'final' && jsonData.image) {
                        base64Data = jsonData.image;
                        console.log('âœ… æ‰¾åˆ° final äº‹ä»¶çš„å›¾ç‰‡æ•°æ®');
                        break;
                    }
                    
                    // å…¼å®¹å…¶ä»–æ ¼å¼
                    if (jsonData.data) {
                        base64Data = jsonData.data;
                        console.log('ä»Ž JSON.data ä¸­æå–å›¾ç‰‡æ•°æ®');
                        break;
                    }
                    if (jsonData.image) {
                        base64Data = jsonData.image;
                        console.log('ä»Ž JSON.image ä¸­æå–å›¾ç‰‡æ•°æ®');
                        break;
                    }
                } catch (e) {
                    // å¦‚æžœä¸æ˜¯ JSONï¼Œç›´æŽ¥ä½œä¸º base64 æ•°æ®
                    base64Data = dataContent;
                    console.log('ç›´æŽ¥ä½¿ç”¨ base64 æ•°æ®');
                    break;
                }
            }
        }
        
        if (!base64Data) {
            throw new Error('æ— æ³•ä»Ž SSE å“åº”ä¸­æå–å›¾ç‰‡æ•°æ®');
        }
        
        // V4.5 æµå¼ç«¯ç‚¹è¿”å›žçš„æ˜¯ PNG base64ï¼Œä¸æ˜¯ ZIP
        // æ£€æŸ¥æ˜¯å¦ä¸º PNG (ä»¥ iVBORw0KGgo å¼€å¤´) æˆ– JPEG (ä»¥ /9j/ å¼€å¤´)
        const isPNG = base64Data.startsWith('iVBORw0KGgo');
        const isJPEG = base64Data.startsWith('/9j/');
        
        if (isPNG || isJPEG) {
            console.log('âœ… æ£€æµ‹åˆ°ç›´æŽ¥çš„å›¾ç‰‡ base64 æ•°æ® (PNG/JPEG)');
            // å°† base64 è½¬ä¸º Blob
            const binaryString = atob(base64Data);
            const bytes = new Uint8Array(binaryString.length);
            for (let i = 0; i < binaryString.length; i++) {
                bytes[i] = binaryString.charCodeAt(i);
            }
            const imageBlob = new Blob([bytes], { type: isPNG ? 'image/png' : 'image/jpeg' });
            console.log('å›¾ç‰‡ Blob åˆ›å»ºæˆåŠŸï¼Œå¤§å°:', imageBlob.size);
            
            // è½¬æ¢ä¸ºdataURLç”¨äºŽåŽç»­å¤„ç†
            const reader = new FileReader();
            imageDataUrl = await new Promise((resolve, reject) => {
                reader.onloadend = () => resolve(reader.result);
                reader.onerror = reject;
                reader.readAsDataURL(imageBlob);
            });
            console.log('âœ… å›¾ç‰‡è½¬æ¢æˆåŠŸï¼ðŸŽ¨');
        } else {
            // å¦åˆ™å½“ä½œ ZIP å¤„ç†
            console.log('å½“ä½œ ZIP æ–‡ä»¶å¤„ç†...');
            const binaryString = atob(base64Data);
            const bytes = new Uint8Array(binaryString.length);
            for (let i = 0; i < binaryString.length; i++) {
                bytes[i] = binaryString.charCodeAt(i);
            }
            zipBlob = new Blob([bytes]);
            console.log('ZIP Blob å¤§å°:', zipBlob.size);
        }
    } else {
        // éžæµå¼å“åº”ï¼Œç›´æŽ¥è¯»å–
        zipBlob = await response.blob();
        console.log('æ”¶åˆ°æ•°æ®ï¼Œç±»åž‹:', zipBlob.type, 'å¤§å°:', zipBlob.size);
    }
    
    // å¦‚æžœè¿˜æ²¡æœ‰imageDataUrlï¼ˆå³éœ€è¦è§£åŽ‹ZIPï¼‰
    if (!imageDataUrl && zipBlob) {
        // NovelAIå§‹ç»ˆè¿”å›žZIPæ ¼å¼ï¼Œéœ€è¦è§£åŽ‹
        try {
            // æ£€æŸ¥JSZipæ˜¯å¦å·²åŠ è½½
            if (typeof JSZip === 'undefined') {
                throw new Error('JSZipåº“æœªåŠ è½½ï¼Œè¯·åˆ·æ–°é¡µé¢é‡è¯•');
            }
            
            // è§£åŽ‹ZIPæ–‡ä»¶
            const zip = await JSZip.loadAsync(zipBlob);
            console.log('ZIPæ–‡ä»¶å†…å®¹:', Object.keys(zip.files));
            
            // æŸ¥æ‰¾ç¬¬ä¸€ä¸ªå›¾ç‰‡æ–‡ä»¶ï¼ˆé€šå¸¸æ˜¯image_0.pngï¼‰
            let imageFile = null;
            for (let filename in zip.files) {
                if (filename.match(/\.(png|jpg|jpeg|webp)$/i)) {
                    imageFile = zip.files[filename];
                    console.log('æ‰¾åˆ°å›¾ç‰‡æ–‡ä»¶:', filename);
                    break;
                }
            }
            
            if (!imageFile) {
                throw new Error('ZIPæ–‡ä»¶ä¸­æœªæ‰¾åˆ°å›¾ç‰‡');
            }
            
            // æå–å›¾ç‰‡æ•°æ®
            const imageBlob = await imageFile.async('blob');
            console.log('æå–çš„å›¾ç‰‡å¤§å°:', imageBlob.size);
            
            // åˆ›å»ºå›¾ç‰‡URL
            const reader = new FileReader();
            imageDataUrl = await new Promise((resolve, reject) => {
                reader.onloadend = () => resolve(reader.result);
                reader.onerror = reject;
                reader.readAsDataURL(imageBlob);
            });
            console.log('âœ… å›¾ç‰‡è§£åŽ‹æˆåŠŸï¼');
        } catch (zipError) {
            console.error('ZIPè§£åŽ‹å¤±è´¥:', zipError);
            throw new Error('å›¾ç‰‡è§£åŽ‹å¤±è´¥: ' + zipError.message);
        }
    }
    
    console.log('âœ… NAIå›¾ç‰‡ç”ŸæˆæˆåŠŸï¼');
    
    // åˆ›å»ºnaiimagæ¶ˆæ¯
    aiMessage = { 
        ...baseMessage, 
        type: 'naiimag', 
        imageUrl: imageDataUrl,
        prompt: aiPrompt,
        fullPrompt: finalPositivePrompt // ä¿å­˜å®Œæ•´æç¤ºè¯ä¾›æŸ¥çœ‹
    };
} catch (error) {
    console.error('âŒ NAIå›¾ç‰‡ç”Ÿæˆå¤±è´¥:', error);
    // å¤±è´¥æ—¶é™çº§ä¸ºæ–‡æœ¬æ¶ˆæ¯
    aiMessage = { 
        ...baseMessage, 
        content: `[å›¾ç‰‡ç”Ÿæˆå¤±è´¥: ${error.message}]` 
    };
}
break;
                        
                        default:
                             console.warn("æ”¶åˆ°äº†æœªçŸ¥çš„AIæŒ‡ä»¤ç±»åž‹:", msgData.type);
                             break;
                    }
        
                    if (aiMessage) {
                        chat.history.push(aiMessage);
                       if (!isViewingThisChat) {
                            chat.unreadCount = (chat.unreadCount || 0) + 1;
                        }
                        if (!isViewingThisChat && !notificationShown) {
                            let notificationText;
                            switch (aiMessage.type) {
                                case 'transfer': notificationText = `[æ”¶åˆ°ä¸€ç¬”è½¬è´¦]`; break;
                                case 'waimai_request': notificationText = `[æ”¶åˆ°ä¸€ä¸ªå¤–å–ä»£ä»˜è¯·æ±‚]`; break;
                                case 'ai_image': notificationText = `[å›¾ç‰‡]`; break;
                                case 'voice_message': notificationText = `[è¯­éŸ³]`; break;
                                case 'sticker': notificationText = aiMessage.meaning ? `[è¡¨æƒ…: ${aiMessage.meaning}]` : '[è¡¨æƒ…]'; break;
                                case 'offline_text': notificationText = aiMessage.dialogue ? `ã€Œ${aiMessage.dialogue}ã€` : `[${aiMessage.description.substring(0, 20)}...]`; break;
                                default: notificationText = String(aiMessage.content || '');
                            }
                            const finalNotifText = chat.isGroup ? `${aiMessage.senderName}: ${notificationText}` : notificationText;
                            showNotification(chatId, finalNotifText.substring(0, 40) + (finalNotifText.length > 40 ? '...' : ''));
                            notificationShown = true;
                        }
        
 
                        
                        if (isViewingThisChat) {
                            appendMessage(aiMessage, chat);
                            await new Promise(resolve => setTimeout(resolve, Math.random() * 1800 + 1000));
                        }
                    }
                }        
        
                if (callHasBeenHandled && videoCallState.isGroupCall) {
                    videoCallState.isAwaitingResponse = false;
                    if (videoCallState.participants.length > 0) {
                        startVideoCall();
                    } else {
                        videoCallState = { ...videoCallState, isAwaitingResponse: false, participants: [] };
                        showScreen('chat-interface-screen');
                        alert('æ— äººæŽ¥å¬ç¾¤èŠé‚€è¯·ã€‚');
                    }
                }
                if (needsImmediateReaction) {
                    await triggerAiResponse();
                    return; 
                }
                await db.chats.put(chat);
        
const qzoneActionTaken = messagesArray.some(action =>
    action.type === 'qzone_post' ||
    action.type === 'qzone_like' ||
    action.type === 'qzone_comment' ||
    action.type === 'repost'
);


if (qzoneActionTaken) {
    console.log("æ£€æµ‹åˆ°AIæ‰§è¡Œäº†åŠ¨æ€æ“ä½œï¼Œç«‹å³åˆ·æ–°å¥½å‹åŠ¨æ€é¡µé¢ã€‚");
    
    await renderQzonePosts();
}


            } catch (error) {
                
                chat.history = chat.history.filter(msg => !msg.isTemporary);
                
                if (!chat.isGroup && chat.relationship?.status === 'pending_ai_approval') {
                    chat.relationship.status = 'blocked_by_ai';
                    await showCustomAlert('ç”³è¯·å¤±è´¥', `AIåœ¨å¤„ç†ä½ çš„å¥½å‹ç”³è¯·æ—¶å‡ºé”™äº†ï¼Œè¯·ç¨åŽé‡è¯•ã€‚\né”™è¯¯ä¿¡æ¯: ${error.message}`);
                } else {
                    await showCustomAlert(
                        'API è°ƒç”¨å¤±è´¥', 
                        `å‘ç”Ÿäº†ä¸€ä¸ªé”™è¯¯ï¼ŒAIæœªèƒ½æˆåŠŸå“åº”ã€‚\n\né”™è¯¯è¯¦æƒ…:\n${error.message}`
                    );
                }
                
                if (!chat.isGroup && chat.relationship?.status === 'blocked_by_ai') {
                     await db.chats.put(chat);        
                }
               
                videoCallState.isAwaitingResponse = false;
            } finally {
                setAvatarActingState(chatId, false);
        
               
                if (chat.isGroup) {
                    if (typingIndicator) {
                        typingIndicator.style.display = 'none';
                    }
                } else {
                    if (chatHeaderTitle && state.chats[chatId]) {
                        chatHeaderTitle.style.opacity = 0;
                        setTimeout(() => {
                            chatHeaderTitle.textContent = state.chats[chatId].name;
                            chatHeaderTitle.classList.remove('typing-status');
                            chatHeaderTitle.style.opacity = 1;
                        }, 200);
                    }
                }
                renderChatList();
                if (isViewingThisChat) {
                    checkAndTriggerAutoSummary(chatId);
                 
                }
stopSilentAudio(); 
            }
        }
          
        
        
        
        
        
        
        
                async function sendSticker(sticker) { if (!state.activeChatId) return; const chat = state.chats[state.activeChatId]; const msg = { role: 'user', content: sticker.url, meaning: sticker.name, timestamp: Date.now() }; chat.history.push(msg); await db.chats.put(chat); appendMessage(msg, chat); renderChatList(); document.getElementById('sticker-panel').classList.remove('visible'); }
        
                async function sendUserTransfer() { if (!state.activeChatId) return; const amountInput = document.getElementById('transfer-amount'); const noteInput = document.getElementById('transfer-note'); const amount = parseFloat(amountInput.value); const note = noteInput.value.trim(); if (isNaN(amount) || amount < 0) { alert('è¯·è¾“å…¥æœ‰æ•ˆçš„é‡‘é¢(å¿…é¡»å¤§äºŽ0)ï¼'); return; } const chat = state.chats[state.activeChatId]; const senderName = chat.isGroup ? (chat.settings.myNickname || 'æˆ‘') : 'æˆ‘'; const receiverName = chat.isGroup ? 'ç¾¤èŠ' : chat.name; const msg = { role: 'user', type: 'transfer', amount: amount, note: note, senderName, receiverName, timestamp: Date.now() }; chat.history.push(msg); await db.chats.put(chat); appendMessage(msg, chat); renderChatList(); document.getElementById('transfer-modal').classList.remove('visible'); amountInput.value = ''; noteInput.value = ''; }

/**
 * ã€å…¨æ–° V2.0 | AIè®¤çŸ¥ä¿®å¤ç‰ˆã€‘å¤„ç†ç”¨æˆ·ç‚¹å‡»â€œä¸ºTAç‚¹å¤–å–â€çš„é€»è¾‘
 */
async function sendWaimaiOrderForAI() {
    if (!state.activeChatId) return;
    
    const productInfoInput = document.getElementById('waimai-product-info');
    const amountInput = document.getElementById('waimai-amount');
    
    const productInfo = productInfoInput.value.trim();
    const amount = parseFloat(amountInput.value);

    if (!productInfo || isNaN(amount) || amount <= 0) {
        alert('è¯·å¡«å†™æœ‰æ•ˆçš„å•†å“ä¿¡æ¯å’Œé‡‘é¢ï¼');
        return;
    }

    const chat = state.chats[state.activeChatId];
    const now = Date.now();
    const myNickname = chat.isGroup ? (chat.settings.myNickname || 'æˆ‘') : 'æˆ‘';

    
    const visibleMessage = {
        role: 'user',
        senderName: myNickname, 
        type: 'waimai_order',
        productInfo: productInfo,
        amount: amount,
        timestamp: now
    };
    chat.history.push(visibleMessage);

    
    const hiddenMessage = {
        role: 'system',
        content: `[ç³»ç»Ÿæç¤ºï¼šç”¨æˆ·(${myNickname})ä¸ºä½ ç‚¹äº†ä¸€ä»½å¤–å–ä½œä¸ºã€ç¤¼ç‰©ã€‘ã€‚å¤–å–å†…å®¹æ˜¯â€œ${productInfo}â€ï¼Œä»·å€¼${amount}å…ƒã€‚è¿™ä¸æ˜¯ä¸€ä¸ªä»£ä»˜è¯·æ±‚ï¼Œè€Œæ˜¯ç”¨æˆ·å·²ç»ä¸ºä½ æ”¯ä»˜äº†ã€‚è¯·ä½ å¯¹æ­¤è¡¨ç¤ºæ„Ÿè°¢ã€‚]`,
        timestamp: now + 1,
        isHidden: true
    };
    chat.history.push(hiddenMessage);

    
    await db.chats.put(chat);
    appendMessage(visibleMessage, chat);
    renderChatList();

    
    productInfoInput.value = '';
    amountInput.value = '';
    document.getElementById('waimai-request-modal').classList.remove('visible');

    
    
}
        /**
         * ã€å…¨æ–° V3.0ã€‘å‘é€ä¸€ä¸ªä½ç½®å…±äº«å¡ç‰‡ (èƒŒæ™¯å›¾å·²å†…ç½®)
         */
        async function sendLocationShare() {
            if (!state.activeChatId) return;
        
            
            const locationName = await showCustomPrompt("å…±äº«ä½ç½®", "ä½ çŽ°åœ¨åœ¨å“ªé‡Œå‘€ï¼Ÿ", "");
        
            
            if (!locationName || !locationName.trim()) return; 
        
            
            
            const hardcodedImageUrl = 'https://s3plus.meituan.net/opapisdk/op_ticket_885190757_1756262526935_qdqqd_4uque3.jpeg';
        
            const chat = state.chats[state.activeChatId];
            
            
            const msg = {
                role: 'user',
                type: 'location_share',
                content: locationName.trim(),
                imageUrl: hardcodedImageUrl, 
                timestamp: Date.now()
            };
            
            
            chat.history.push(msg);
            await db.chats.put(chat);
            appendMessage(msg, chat);
            renderChatList();
        }
        
        
                function enterSelectionMode(initialMsgTimestamp) { if (isSelectionMode) return; isSelectionMode = true; document.getElementById('chat-interface-screen').classList.add('selection-mode'); toggleMessageSelection(initialMsgTimestamp); }
        
                function exitSelectionMode() {
            cleanupWaimaiTimers(); 
         if (!isSelectionMode) return; isSelectionMode = false; document.getElementById('chat-interface-screen').classList.remove('selection-mode'); selectedMessages.forEach(ts => { const bubble = document.querySelector(`.message-bubble[data-timestamp="${ts}"]`); if (bubble) bubble.classList.remove('selected'); }); selectedMessages.clear(); }
        
        
        function toggleMessageSelection(timestamp) {
            
            const elementToSelect = document.querySelector(
                `.message-bubble[data-timestamp="${timestamp}"]`
            );
        
            if (!elementToSelect) return;
        
            if (selectedMessages.has(timestamp)) {
                selectedMessages.delete(timestamp);
                elementToSelect.classList.remove('selected');
            } else {
                selectedMessages.add(timestamp);
                elementToSelect.classList.add('selected');
            }
            
            document.getElementById('selection-count').textContent = `å·²é€‰ ${selectedMessages.size} æ¡`;
            
            if (selectedMessages.size === 0) {
                exitSelectionMode();
            }
        }
          
        
                function addLongPressListener(element, callback) { let pressTimer; const startPress = (e) => { if(isSelectionMode) return; e.preventDefault(); pressTimer = window.setTimeout(() => callback(e), 500); }; const cancelPress = () => clearTimeout(pressTimer); element.addEventListener('mousedown', startPress); element.addEventListener('mouseup', cancelPress); element.addEventListener('mouseleave', cancelPress); element.addEventListener('touchstart', startPress, { passive: true }); element.addEventListener('touchend', cancelPress); element.addEventListener('touchmove', cancelPress); }
        
                async function handleListenTogetherClick() { const targetChatId = state.activeChatId; if (!targetChatId) return; if (!musicState.isActive) { startListenTogetherSession(targetChatId); return; } if (musicState.activeChatId === targetChatId) { document.getElementById('music-player-overlay').classList.add('visible'); } else { const oldChatName = state.chats[musicState.activeChatId]?.name || 'æœªçŸ¥'; const newChatName = state.chats[targetChatId]?.name || 'å½“å‰'; const confirmed = await showCustomConfirm('åˆ‡æ¢å¬æ­Œå¯¹è±¡', `æ‚¨æ­£å’Œã€Œ${oldChatName}ã€å¬æ­Œã€‚è¦ç»“æŸå¹¶å¼€å§‹å’Œã€Œ${newChatName}ã€çš„æ–°ä¼šè¯å—ï¼Ÿ`, { confirmButtonClass: 'btn-danger' }); if (confirmed) { await endListenTogetherSession(true); await new Promise(resolve => setTimeout(resolve, 50)); startListenTogetherSession(targetChatId); } } }

async function startListenTogetherSession(chatId) { const chat = state.chats[chatId]; if (!chat) return; musicState.totalElapsedTime = chat.musicData.totalTime || 0; musicState.isActive = true; musicState.activeChatId = chatId; if (musicState.playlist.length > 0) { musicState.currentIndex = 0; } else { musicState.currentIndex = -1; } if(musicState.timerId) clearInterval(musicState.timerId); musicState.timerId = setInterval(() => { if (musicState.isPlaying) { musicState.totalElapsedTime++; updateElapsedTimeDisplay(); } }, 1000); updatePlayerUI(); updatePlaylistUI(); document.getElementById('music-player-overlay').classList.add('visible'); }

async function endListenTogetherSession(saveState = true) {
    if (!musicState.isActive) return;
    const oldChatId = musicState.activeChatId;
    document.getElementById('global-lyrics-bar').classList.remove('visible');
    const cleanupLogic = async () => {
        if (musicState.timerId) clearInterval(musicState.timerId);
        if (musicState.isPlaying) audioPlayer.pause();
        if (saveState && oldChatId && state.chats[oldChatId]) {
            const chat = state.chats[oldChatId];
            chat.musicData.totalTime = musicState.totalElapsedTime;
            await db.chats.put(chat);
        }
        musicState.isActive = false;
        musicState.activeChatId = null;
        musicState.totalElapsedTime = 0;
        musicState.timerId = null;
        updateListenTogetherIcon(oldChatId, true);
    };
    closeMusicPlayerWithAnimation(cleanupLogic);
}

function returnToChat() {
    closeMusicPlayerWithAnimation();
}

function updateListenTogetherIcon(chatId, forceReset = false) { const iconImg = document.querySelector('#listen-together-btn img'); if(!iconImg) return; if(forceReset || !musicState.isActive || musicState.activeChatId !== chatId) { iconImg.src = 'https://i.postimg.cc/8kYShvrJ/90-UI-2.png'; iconImg.className = ''; return; } iconImg.src = 'https://i.postimg.cc/D0pq6qS2/E30078-DC-8-B99-4-C01-AFDA-74728-DBF7-BEA.png'; iconImg.classList.add('rotating'); if (musicState.isPlaying) iconImg.classList.remove('paused'); else iconImg.classList.add('paused'); }
window.updateListenTogetherIconProxy = updateListenTogetherIcon;

function updatePlayerUI() { 
    updateListenTogetherIcon(musicState.activeChatId); 
    updateElapsedTimeDisplay(); 
    const titleEl = document.getElementById('music-player-song-title'); 
    const artistEl = document.getElementById('music-player-artist'); 
    const playPauseBtn = document.getElementById('music-play-pause-btn'); 
    if (musicState.currentIndex > -1 && musicState.playlist.length > 0) { 
        const track = musicState.playlist[musicState.currentIndex]; 
        titleEl.textContent = track.name; 
        artistEl.textContent = track.artist; 
    } else { 
        titleEl.textContent = 'è¯·æ·»åŠ æ­Œæ›²'; 
        artistEl.textContent = '...'; 
    } 
    playPauseBtn.textContent = musicState.isPlaying ? 'âšâš' : 'â–¶'; 
}

function updateElapsedTimeDisplay() { const hours = (musicState.totalElapsedTime / 3600).toFixed(1); document.getElementById('music-time-counter').textContent = `å·²ç»ä¸€èµ·å¬äº†${hours}å°æ—¶`; }

function updatePlaylistUI() {
    const playlistBody = document.getElementById('playlist-body');
    playlistBody.innerHTML = '';
    if (musicState.playlist.length === 0) {
        playlistBody.innerHTML = '<p style="text-align:center; padding: 20px; color: #888;">æ’­æ”¾åˆ—è¡¨æ˜¯ç©ºçš„~</p>';
        return;
    }
    musicState.playlist.forEach((track, index) => {
        const item = document.createElement('div');
        item.className = 'playlist-item';
        if(index === musicState.currentIndex) item.classList.add('playing');

        
item.innerHTML = `
    <div class="playlist-item-info">
        <div class="title">${track.name}</div>
        <div class="artist">${track.artist}</div>
    </div>
    <div class="playlist-item-actions">
        <span class="playlist-action-btn album-art-btn" data-index="${index}">ä¸“è¾‘</span>
        <span class="playlist-action-btn lyrics-btn" data-index="${index}">è¯</span>
        <!-- ã€æ ¸å¿ƒæ–°å¢žã€‘åœ¨è¿™é‡Œæ·»åŠ â€œèƒŒæ™¯â€æŒ‰é’® -->
        <span class="playlist-action-btn bg-btn" data-index="${index}">èƒŒæ™¯</span>
        <span class="playlist-action-btn delete-track-btn" data-index="${index}">Ã—</span>
    </div>
`;
          

        item.querySelector('.playlist-item-info').addEventListener('click', () => playSong(index));
        playlistBody.appendChild(item);
    });
}



async function togglePlayPause() {
    if (audioPlayer.paused) {
        if (musicState.currentIndex === -1 && musicState.playlist.length > 0) {
            playSong(0);
        } 
        else if (musicState.currentIndex > -1) {
            playSong(musicState.currentIndex);
        }
    } else {
        audioPlayer.pause();
        await addMusicActionSystemMessage('æš‚åœäº†éŸ³ä¹');
    }
}

function playNext() { if (musicState.playlist.length === 0) return; let nextIndex; switch(musicState.playMode) { case 'random': nextIndex = Math.floor(Math.random() * musicState.playlist.length); break; case 'single': playSong(musicState.currentIndex); return; case 'order': default: nextIndex = (musicState.currentIndex + 1) % musicState.playlist.length; break; } playSong(nextIndex); }

function playPrev() { if (musicState.playlist.length === 0) return; const newIndex = (musicState.currentIndex - 1 + musicState.playlist.length) % musicState.playlist.length; playSong(newIndex); }

function changePlayMode() { const modes = ['order', 'random', 'single']; const currentModeIndex = modes.indexOf(musicState.playMode); musicState.playMode = modes[(currentModeIndex + 1) % modes.length]; document.getElementById('music-mode-btn').textContent = {'order': 'é¡ºåº', 'random': 'éšæœº', 'single': 'å•æ›²'}[musicState.playMode]; }

async function addSongFromURL() { const url = await showCustomPrompt("æ·»åŠ ç½‘ç»œæ­Œæ›²", "è¯·è¾“å…¥æ­Œæ›²çš„URL", "", "url"); if (!url) return; const name = await showCustomPrompt("æ­Œæ›²ä¿¡æ¯", "è¯·è¾“å…¥æ­Œå"); if (!name) return; const artist = await showCustomPrompt("æ­Œæ›²ä¿¡æ¯", "è¯·è¾“å…¥æ­Œæ‰‹å"); if (!artist) return; musicState.playlist.push({ name, artist, src: url, isLocal: false }); await saveGlobalPlaylist(); updatePlaylistUI(); if(musicState.currentIndex === -1) { musicState.currentIndex = musicState.playlist.length - 1; updatePlayerUI(); } }
 
async function addSongFromLocal(event) {
    const files = event.target.files;
    if (!files.length) return;

    for (const file of files) {
        let name = file.name.replace(/\.[^/.]+$/, "");
        name = await showCustomPrompt("æ­Œæ›²ä¿¡æ¯", "è¯·è¾“å…¥æ­Œå", name);
        if (name === null) continue;
        
        const artist = await showCustomPrompt("æ­Œæ›²ä¿¡æ¯", "è¯·è¾“å…¥æ­Œæ‰‹å", "æœªçŸ¥æ­Œæ‰‹");
        if (artist === null) continue;

        
        const arrayBuffer = await file.arrayBuffer();

        let lrcContent = "";
        const wantLrc = await showCustomConfirm("å¯¼å…¥æ­Œè¯", `è¦ä¸ºã€Š${name}ã€‹æ·»åŠ æ­Œè¯å—ï¼Ÿ`);
        if (wantLrc) {
            lrcContent = await getLrcContent() || "";
        }
        
        musicState.playlist.push({ 
            name, 
            artist, 
            src: arrayBuffer,           
            fileType: file.type,        
            isLocal: true,
            lrcContent: lrcContent,
            cover: 'https://s3plus.meituan.net/opapisdk/op_ticket_885190757_1757748720126_qdqqd_1jt5sv.jpeg'
        });
    }
    
    await saveGlobalPlaylist();
    updatePlaylistUI();
    if (musicState.currentIndex === -1 && musicState.playlist.length > 0) {
        musicState.currentIndex = 0;
        updatePlayerUI();
    }
    event.target.value = null;
}
  



async function playSong(index) {
    if (index < 0 || index >= musicState.playlist.length) return;

    audioPlayer.pause();

    musicState.currentIndex = index;
    const track = musicState.playlist[index];
    const chat = state.chats[musicState.activeChatId]; 

    
    const avatarDisplay = document.getElementById('music-player-avatar-display');
    if (chat && avatarDisplay) {
        
        avatarDisplay.innerHTML = '';

        
        const charAvatarUrl = chat.isGroup 
            ? (chat.members.find(m => m.originalName === track.artist)?.avatar || defaultAvatar) 
            : (chat.settings.aiAvatar || defaultAvatar);
        const userAvatarUrl = chat.settings.myAvatar || defaultAvatar;

        
        const charAvatarEl = document.createElement('img');
        charAvatarEl.src = charAvatarUrl;
        charAvatarEl.className = 'participant-display-avatar';
        charAvatarEl.alt = 'Character Avatar';
        avatarDisplay.appendChild(charAvatarEl);

        
        const userAvatarEl = document.createElement('img');
        userAvatarEl.src = userAvatarUrl;
        userAvatarEl.className = 'participant-display-avatar';
        userAvatarEl.alt = 'User Avatar';
        avatarDisplay.appendChild(userAvatarEl);
    }
    

    const playerWindow = document.querySelector('.music-player-window');
    const toggleBtn = document.getElementById('toggle-blur-btn');

    if (playerWindow) {
        playerWindow.style.setProperty('--music-bg-image', track.background ? `url(${track.background})` : 'none');
        playerWindow.classList.toggle('bg-clear', !!track.isBgClear);
    }
    if (toggleBtn) {
        toggleBtn.classList.toggle('active', !!track.isBgClear);
    }
    
    
    document.getElementById('music-visual-container').classList.remove('lyrics-active');
    const coverEl = document.getElementById('music-player-cover');
    if (coverEl) {
        coverEl.src = track.cover || 'https://s3plus.meituan.net/opapisdk/op_ticket_885190757_1757748720126_qdqqd_1jt5sv.jpeg';
    }
    
    await addMusicActionSystemMessage(`å°†æ­Œæ›²åˆ‡æ¢ä¸ºäº†ã€Š${track.name}ã€‹`);
    musicState.parsedLyrics = parseLRC(track.lrcContent || "");
    
    renderLyrics(); 
    const singleLyricEl = document.getElementById('single-lyric-display');
    if (singleLyricEl) {
        if (!musicState.parsedLyrics || musicState.parsedLyrics.length === 0) {
            singleLyricEl.textContent = 'çº¯éŸ³ä¹ï¼Œè¯·æ¬£èµ';
        } else {
            singleLyricEl.textContent = 'â™ª â™ª â™ª'; 
        }
    }
    
    if (track.isLocal && track.src instanceof ArrayBuffer) {
        const blob = new Blob([track.src], { type: track.fileType || 'audio/mpeg' });
        audioPlayer.src = URL.createObjectURL(blob);
    } 
    else if (track.isLocal && track.src instanceof Blob) {
        audioPlayer.src = URL.createObjectURL(track.src);
    } else if (!track.isLocal) {
        audioPlayer.src = track.src;
    } else {
        console.error('æœ¬åœ°æ­Œæ›²æºé”™è¯¯:', track);
        return;
    }
    
    const playPromise = audioPlayer.play();
    if (playPromise !== undefined) {
        playPromise.catch(error => {
            if (error.name === 'NotAllowedError') {
                console.warn('Autoplay was prevented by the browser.');
                audioPlayer.pause();
                showCustomAlert("æ’­æ”¾å·²æš‚åœ", "ç”±äºŽæµè§ˆå™¨å®‰å…¨é™åˆ¶ï¼ŒAIåˆ‡æ¢çš„æ­Œæ›²æ— æ³•è‡ªåŠ¨æ’­æ”¾ã€‚è¯·æ‰‹åŠ¨ç‚¹å‡»æ’­æ”¾æŒ‰é’® â–¶ ç»§ç»­æ¬£èµã€‚");
            } else if (error.name !== 'AbortError') {
                console.error('Playback error:', error);
            }
        });
    }
    updatePlaylistUI();
    updatePlayerUI();
const isFrameMode = document.body.classList.contains('frame-mode-active');
        const isAlwaysIslandMode = state.globalSettings.alwaysShowMusicIsland || false; 
        const lyricBar = document.getElementById('global-lyrics-bar'); 

        if (isFrameMode || isAlwaysIslandMode) {
            // [æ–°é€»è¾‘] åªè¦å¤–æ¡†æˆ–æ–°å¼€å…³ä»»ä¸€å¼€å¯ï¼Œå°±ç”¨çµåŠ¨å²›
            phoneScreenForIsland.classList.add('dynamic-island-active');
            islandAlbumArt.src = track.cover || 'https://s3plus.meituan.net/opapisdk/op_ticket_885190757_1757748720126_qdqqd_1jt5sv.jpeg';
            lyricBar.classList.remove('visible'); // ç¡®ä¿ç°è‰²æ¡éšè—
        } 
        else {
            // [æ—§é€»è¾‘] å¦åˆ™ (å¤–æ¡†å’Œæ–°å¼€å…³éƒ½å…³é—­)ï¼Œä½¿ç”¨ç°è‰²æ­Œè¯æ¡
            phoneScreenForIsland.classList.remove('dynamic-island-active'); // ç¡®ä¿çµåŠ¨å²›éšè—
            if (musicState.parsedLyrics && musicState.parsedLyrics.length > 0) {
                lyricBar.textContent = 'â™ª';
                lyricBar.classList.add('visible');
            } else {
                lyricBar.classList.remove('visible');
            }
        }
}

  
/**
 * å¤„ç†æ›´æ¢æŒ‡å®šæ­Œæ›²èƒŒæ™¯å›¾ç‰‡çš„é€»è¾‘
 * @param {number} trackIndex - æ’­æ”¾åˆ—è¡¨ä¸­æ­Œæ›²çš„ç´¢å¼•
 */
async function handleChangeBackground(trackIndex) {
    if (trackIndex < 0 || trackIndex >= musicState.playlist.length) return;

    
    const choice = await showChoiceModal("æ›´æ¢æ­Œæ›²èƒŒæ™¯", [
        { text: 'ðŸ“ ä»Žæœ¬åœ°ä¸Šä¼ ', value: 'local' },
        { text: 'ðŸŒ ä½¿ç”¨ç½‘ç»œURL', value: 'url' }
    ]);

    let newBackgroundUrl = null;

    
    if (choice === 'local') {
        newBackgroundUrl = await uploadImageLocally();
    } else if (choice === 'url') {
        newBackgroundUrl = await showCustomPrompt("è¾“å…¥å›¾ç‰‡URL", "è¯·è¾“å…¥æ–°çš„èƒŒæ™¯å›¾ç‰‡é“¾æŽ¥", "", "url");
    }

    
    if (newBackgroundUrl && newBackgroundUrl.trim()) {
        musicState.playlist[trackIndex].background = newBackgroundUrl.trim();
        await saveGlobalPlaylist();
        
        
        if (musicState.currentIndex === trackIndex) {
            const playerWindow = document.querySelector('.music-player-window');
            playerWindow.style.setProperty('--music-bg-image', `url(${newBackgroundUrl.trim()})`);
        }

        await showCustomAlert("æˆåŠŸ", "æ­Œæ›²èƒŒæ™¯å·²æ›´æ–°ï¼");
    }
}
/**
 * ã€å…¨æ–°ã€‘å¤„ç†æ›´æ¢ä¸“è¾‘å°é¢çš„é€»è¾‘
 * @param {number} trackIndex - æ’­æ”¾åˆ—è¡¨ä¸­æ­Œæ›²çš„ç´¢å¼•
 */
async function handleChangeAlbumArt(trackIndex) {
    if (trackIndex < 0 || trackIndex >= musicState.playlist.length) return;

    const choice = await showChoiceModal("æ›´æ¢ä¸“è¾‘å°é¢", [
        { text: 'ðŸ“ ä»Žæœ¬åœ°ä¸Šä¼ ', value: 'local' },
        { text: 'ðŸŒ ä½¿ç”¨ç½‘ç»œURL', value: 'url' }
    ]);

    let newCoverUrl = null;

    if (choice === 'local') {
        newCoverUrl = await uploadImageLocally();
    } else if (choice === 'url') {
        newCoverUrl = await showCustomPrompt("è¾“å…¥å›¾ç‰‡URL", "è¯·è¾“å…¥æ–°çš„å°é¢å›¾ç‰‡é“¾æŽ¥", "", "url");
    }

    if (newCoverUrl && newCoverUrl.trim()) {
        musicState.playlist[trackIndex].cover = newCoverUrl.trim();
        await saveGlobalPlaylist();
        
        
        if (musicState.currentIndex === trackIndex) {
            document.getElementById('music-player-cover').src = newCoverUrl.trim();
            
            const vinylCover = document.querySelector('#vinyl-view #music-player-cover');
            if(vinylCover) vinylCover.src = newCoverUrl.trim();
        }

        await showCustomAlert("æˆåŠŸ", "ä¸“è¾‘å°é¢å·²æ›´æ–°ï¼");
    }
}

async function deleteTrack(index) { if (index < 0 || index >= musicState.playlist.length) return; const track = musicState.playlist[index]; const wasPlaying = musicState.isPlaying && musicState.currentIndex === index; if (track.isLocal && audioPlayer.src.startsWith('blob:') && musicState.currentIndex === index) URL.revokeObjectURL(audioPlayer.src); musicState.playlist.splice(index, 1); await saveGlobalPlaylist(); if (musicState.playlist.length === 0) { if (musicState.isPlaying) audioPlayer.pause(); audioPlayer.src = ''; musicState.currentIndex = -1; musicState.isPlaying = false; } else { if (wasPlaying) { playNext(); } else { if (musicState.currentIndex >= index) musicState.currentIndex = Math.max(0, musicState.currentIndex - 1); } } updatePlayerUI(); updatePlaylistUI(); }
        
       
        
        async function addSongFromLocal(event) {
            const files = event.target.files;
            if (!files.length) return;
        
            for (const file of files) {
                let name = file.name.replace(/\.[^/.]+$/, "");
                name = await showCustomPrompt("æ­Œæ›²ä¿¡æ¯", "è¯·è¾“å…¥æ­Œå", name);
                if (name === null) continue;
                
                const artist = await showCustomPrompt("æ­Œæ›²ä¿¡æ¯", "è¯·è¾“å…¥æ­Œæ‰‹å", "æœªçŸ¥æ­Œæ‰‹");
                if (artist === null) continue;
        
                let lrcContent = "";
                const wantLrc = await showCustomConfirm("å¯¼å…¥æ­Œè¯", `è¦ä¸ºã€Š${name}ã€‹æ·»åŠ æ­Œè¯å—ï¼Ÿ`);
                if (wantLrc) {
                    
                    lrcContent = await getLrcContent() || ""; // å¦‚æžœç”¨æˆ·å–æ¶ˆï¼Œåˆ™lrcContentä¸º""
                }
                
                musicState.playlist.push({ 
                    name, 
                    artist, 
                    src: file, 
                    isLocal: true,
                    lrcContent: lrcContent
                });
            }
            
            await saveGlobalPlaylist();
            updatePlaylistUI();
            if (musicState.currentIndex === -1 && musicState.playlist.length > 0) {
                musicState.currentIndex = 0;
                updatePlayerUI();
            }
            event.target.value = null;
        }
          
        
                async function deleteTrack(index) { if (index < 0 || index >= musicState.playlist.length) return; const track = musicState.playlist[index]; const wasPlaying = musicState.isPlaying && musicState.currentIndex === index; if (track.isLocal && audioPlayer.src.startsWith('blob:') && musicState.currentIndex === index) URL.revokeObjectURL(audioPlayer.src); musicState.playlist.splice(index, 1); await saveGlobalPlaylist(); if (musicState.playlist.length === 0) { if (musicState.isPlaying) audioPlayer.pause(); audioPlayer.src = ''; musicState.currentIndex = -1; musicState.isPlaying = false; } else { if (wasPlaying) { playNext(); } else { if (musicState.currentIndex >= index) musicState.currentIndex = Math.max(0, musicState.currentIndex - 1); } } updatePlayerUI(); updatePlaylistUI(); }
        
                const personaLibraryModal = document.getElementById('persona-library-modal');
                const personaEditorModal = document.getElementById('persona-editor-modal');
                const presetActionsModal = document.getElementById('preset-actions-modal');
        
                function openPersonaLibrary() { renderPersonaLibrary(); personaLibraryModal.classList.add('visible'); }
        
                function closePersonaLibrary() { personaLibraryModal.classList.remove('visible'); }
        
                function renderPersonaLibrary() { const grid = document.getElementById('persona-library-grid'); grid.innerHTML = ''; if (state.personaPresets.length === 0) { grid.innerHTML = '<p style="color: var(--text-secondary); grid-column: 1 / -1; text-align: center; margin-top: 20px;">ç©ºç©ºå¦‚ä¹Ÿ~ ç‚¹å‡»å³ä¸Šè§’"æ·»åŠ "æ¥åˆ›å»ºä½ çš„ç¬¬ä¸€ä¸ªäººè®¾é¢„è®¾å§ï¼</p>'; return; } state.personaPresets.forEach(preset => { const item = document.createElement('div'); item.className = 'persona-preset-item'; item.style.backgroundImage = `url(${preset.avatar})`; item.dataset.presetId = preset.id; item.addEventListener('click', () => applyPersonaPreset(preset.id)); addLongPressListener(item, () => showPresetActions(preset.id)); grid.appendChild(item); }); }
        
                function showPresetActions(presetId) { editingPersonaPresetId = presetId; presetActionsModal.classList.add('visible'); }
        
                function hidePresetActions() { presetActionsModal.classList.remove('visible'); editingPersonaPresetId = null; }
        
                function applyPersonaPreset(presetId) { const preset = state.personaPresets.find(p => p.id === presetId); if (preset) { document.getElementById('my-avatar-preview').src = preset.avatar; document.getElementById('my-persona').value = preset.persona; } closePersonaLibrary(); }
        
                function openPersonaEditorForCreate() { editingPersonaPresetId = null; document.getElementById('persona-editor-title').textContent = 'æ·»åŠ äººè®¾é¢„è®¾'; document.getElementById('preset-avatar-preview').src = defaultAvatar; document.getElementById('preset-persona-input').value = ''; personaEditorModal.classList.add('visible'); }
        
                function openPersonaEditorForEdit() { const preset = state.personaPresets.find(p => p.id === editingPersonaPresetId); if (!preset) return; document.getElementById('persona-editor-title').textContent = 'ç¼–è¾‘äººè®¾é¢„è®¾'; document.getElementById('preset-avatar-preview').src = preset.avatar; document.getElementById('preset-persona-input').value = preset.persona; presetActionsModal.classList.remove('visible'); personaEditorModal.classList.add('visible'); }
        
                async function deletePersonaPreset() { const confirmed = await showCustomConfirm('åˆ é™¤é¢„è®¾', 'ç¡®å®šè¦åˆ é™¤è¿™ä¸ªäººè®¾é¢„è®¾å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ¢å¤ã€‚', { confirmButtonClass: 'btn-danger' }); if (confirmed && editingPersonaPresetId) { await db.personaPresets.delete(editingPersonaPresetId); state.personaPresets = state.personaPresets.filter(p => p.id !== editingPersonaPresetId); hidePresetActions(); renderPersonaLibrary(); } }
        
                function closePersonaEditor() { personaEditorModal.classList.remove('visible'); editingPersonaPresetId = null; }
        
                async function savePersonaPreset() { const avatar = document.getElementById('preset-avatar-preview').src; const persona = document.getElementById('preset-persona-input').value.trim(); if (avatar === defaultAvatar && !persona) { alert("å¤´åƒå’Œäººè®¾ä¸èƒ½éƒ½ä¸ºç©ºå“¦ï¼"); return; } if (editingPersonaPresetId) { const preset = state.personaPresets.find(p => p.id === editingPersonaPresetId); if (preset) { preset.avatar = avatar; preset.persona = persona; await db.personaPresets.put(preset); } } else { const newPreset = { id: 'preset_' + Date.now(), avatar: avatar, persona: persona }; await db.personaPresets.add(newPreset); state.personaPresets.push(newPreset); } renderPersonaLibrary(); closePersonaEditor(); }
        
                const batteryAlertModal = document.getElementById('battery-alert-modal');
        
                function showBatteryAlert(imageUrl, text) { clearTimeout(batteryAlertTimeout); document.getElementById('battery-alert-image').src = imageUrl; document.getElementById('battery-alert-text').textContent = text; batteryAlertModal.classList.add('visible'); const closeAlert = () => { batteryAlertModal.classList.remove('visible'); batteryAlertModal.removeEventListener('click', closeAlert); }; batteryAlertModal.addEventListener('click', closeAlert); batteryAlertTimeout = setTimeout(closeAlert, 2000); }
        
                function updateBatteryDisplay(battery) { const batteryContainer = document.getElementById('status-bar-battery'); const batteryLevelEl = batteryContainer.querySelector('.battery-level'); const batteryTextEl = batteryContainer.querySelector('.battery-text'); const level = Math.floor(battery.level * 100); batteryLevelEl.style.width = `${level}%`; batteryTextEl.textContent = `${level}%`; if (battery.charging) { batteryContainer.classList.add('charging'); } else { batteryContainer.classList.remove('charging'); } }
        
                function handleBatteryChange(battery) { updateBatteryDisplay(battery); const level = battery.level; if (!battery.charging) { if (level <= 0.4 && lastKnownBatteryLevel > 0.4 && !alertFlags.hasShown40) { showBatteryAlert('https://i.postimg.cc/T2yKJ0DV/40.jpg', 'æœ‰ç‚¹é¥¿äº†ï¼Œå¯ä»¥åŽ»æ‰¾å……ç”µå™¨æƒ¹'); alertFlags.hasShown40 = true; } if (level <= 0.2 && lastKnownBatteryLevel > 0.2 && !alertFlags.hasShown20) { showBatteryAlert('https://i.postimg.cc/qB9zbKs9/20.jpg', 'èµ¶ç´§çš„å……ç”µï¼Œè¦é¥¿æ­»äº†'); alertFlags.hasShown20 = true; } if (level <= 0.1 && lastKnownBatteryLevel > 0.1 && !alertFlags.hasShown10) { showBatteryAlert('https://i.postimg.cc/ThMMVfW4/10.jpg', 'å·²é˜µäº¡ï¼Œè¿˜æœ‰30ç§’çˆ†ç‚¸'); alertFlags.hasShown10 = true; } } if (level > 0.4) alertFlags.hasShown40 = false; if (level > 0.2) alertFlags.hasShown20 = false; if (level > 0.1) alertFlags.hasShown10 = false; lastKnownBatteryLevel = level; }
        
                async function initBatteryManager() { if ('getBattery' in navigator) { try { const battery = await navigator.getBattery(); lastKnownBatteryLevel = battery.level; handleBatteryChange(battery); battery.addEventListener('levelchange', () => handleBatteryChange(battery)); battery.addEventListener('chargingchange', () => { handleBatteryChange(battery); if (battery.charging) { showBatteryAlert('https://i.postimg.cc/3NDQ0dWG/image.jpg', 'çªçˆ±æ³¥ï¼Œç”µé‡åƒé¥±é¥±'); } }); } catch (err) { console.error("æ— æ³•èŽ·å–ç”µæ± ä¿¡æ¯:", err); document.querySelector('.battery-text').textContent = 'á—œÏ‰á—œ'; } } else { console.log("æµè§ˆå™¨ä¸æ”¯æŒç”µæ± çŠ¶æ€APIã€‚"); document.querySelector('.battery-text').textContent = 'á—œÏ‰á—œ'; } }
        
                async function renderAlbumList() {
                    const albumGrid = document.getElementById('album-grid-page');
                    if (!albumGrid) return;
                    const albums = await db.qzoneAlbums.orderBy('createdAt').reverse().toArray();
                    albumGrid.innerHTML = '';
                    if (albums.length === 0) {
                        albumGrid.innerHTML = '<p style="grid-column: 1 / -1; text-align: center; color: var(--text-secondary); margin-top: 50px;">ä½ è¿˜æ²¡æœ‰åˆ›å»ºä»»ä½•ç›¸å†Œå“¦~</p>';
                        return;
                    }
                    albums.forEach(album => {
                        const albumItem = document.createElement('div');
                        albumItem.className = 'album-item';
                        albumItem.innerHTML = `
                            <div class="album-cover" style="background-image: url(${album.coverUrl});"></div>
                            <div class="album-info">
                                <p class="album-name">${album.name}</p>
                                <p class="album-count">${album.photoCount || 0} å¼ </p>
                            </div>
                        `;
                        albumItem.addEventListener('click', () => {
                            openAlbum(album.id);
                        });
        
                        
                        addLongPressListener(albumItem, async () => {
                            const confirmed = await showCustomConfirm(
                                'åˆ é™¤ç›¸å†Œ',
                                `ç¡®å®šè¦åˆ é™¤ç›¸å†Œã€Š${album.name}ã€‹å—ï¼Ÿæ­¤æ“ä½œå°†åŒæ—¶åˆ é™¤ç›¸å†Œå†…çš„æ‰€æœ‰ç…§ç‰‡ï¼Œä¸”æ— æ³•æ¢å¤ã€‚`,
                                { confirmButtonClass: 'btn-danger' }
                            );
        
                            if (confirmed) {
                                // 1. ä»Žç…§ç‰‡è¡¨ä¸­åˆ é™¤è¯¥ç›¸å†Œä¸‹çš„æ‰€æœ‰ç…§ç‰‡
                                await db.qzonePhotos.where('albumId').equals(album.id).delete();
                                
                                // 2. ä»Žç›¸å†Œè¡¨ä¸­åˆ é™¤è¯¥ç›¸å†Œæœ¬èº«
                                await db.qzoneAlbums.delete(album.id);
                                
                                // 3. é‡æ–°æ¸²æŸ“ç›¸å†Œåˆ—è¡¨
                                await renderAlbumList();
                                
                                alert('ç›¸å†Œå·²æˆåŠŸåˆ é™¤ã€‚');
                            }
                        });
                          
        
                        albumGrid.appendChild(albumItem);
                    });
                }
        
                async function openAlbum(albumId) {
                    state.activeAlbumId = albumId;
                    await renderAlbumPhotosScreen();
                    showScreen('album-photos-screen');
                }
        
                async function renderAlbumPhotosScreen() {
                    if (!state.activeAlbumId) return;
                    const photosGrid = document.getElementById('photos-grid-page');
                    const headerTitle = document.getElementById('album-photos-title');
                    const album = await db.qzoneAlbums.get(state.activeAlbumId);
                    if (!album) {
                        console.error("æ‰¾ä¸åˆ°ç›¸å†Œ:", state.activeAlbumId);
                        showScreen('album-screen');
                        return;
                    }
                    headerTitle.textContent = album.name;
                    const photos = await db.qzonePhotos.where('albumId').equals(state.activeAlbumId).toArray();
                    photosGrid.innerHTML = '';
                    if (photos.length === 0) {
                        photosGrid.innerHTML = '<p style="grid-column: 1 / -1; text-align: center; color: var(--text-secondary); margin-top: 50px;">è¿™ä¸ªç›¸å†Œè¿˜æ˜¯ç©ºçš„ï¼Œå¿«ä¸Šä¼ ç¬¬ä¸€å¼ ç…§ç‰‡å§ï¼</p>';
                    } else {
                        photos.forEach(photo => {
                            const photoItem = document.createElement('div');
                            photoItem.className = 'photo-item';
                            photoItem.innerHTML = `
                                <img src="${photo.url}" class="photo-thumb" alt="ç›¸å†Œç…§ç‰‡">
                                <button class="photo-delete-btn" data-photo-id="${photo.id}">Ã—</button>
                            `;
                            photosGrid.appendChild(photoItem);
                        });
                    }
                }
        
         /**
         * æ‰“å¼€å›¾ç‰‡æŸ¥çœ‹å™¨
         * @param {string} clickedPhotoUrl - ç”¨æˆ·ç‚¹å‡»çš„é‚£å¼ ç…§ç‰‡çš„URL
         */
        async function openPhotoViewer(clickedPhotoUrl) {
            if (!state.activeAlbumId) return;
        
            
            const photosInAlbum = await db.qzonePhotos.where('albumId').equals(state.activeAlbumId).toArray();
            photoViewerState.photos = photosInAlbum.map(p => p.url);
        
            
            photoViewerState.currentIndex = photoViewerState.photos.findIndex(url => url === clickedPhotoUrl);
            if (photoViewerState.currentIndex === -1) return; 
        
            
            document.getElementById('photo-viewer-modal').classList.add('visible');
            renderPhotoViewer();
            photoViewerState.isOpen = true;
        }
        
        /**
         * æ ¹æ®å½“å‰çŠ¶æ€æ¸²æŸ“æŸ¥çœ‹å™¨å†…å®¹ï¼ˆå›¾ç‰‡å’ŒæŒ‰é’®ï¼‰
         */
        function renderPhotoViewer() {
            if (photoViewerState.currentIndex === -1) return;
        
            const imageEl = document.getElementById('photo-viewer-image');
            const prevBtn = document.getElementById('photo-viewer-prev-btn');
            const nextBtn = document.getElementById('photo-viewer-next-btn');
            
            
            imageEl.style.opacity = 0;
        
            setTimeout(() => {
                
                imageEl.src = photoViewerState.photos[photoViewerState.currentIndex];
                
                imageEl.style.opacity = 1;
            }, 100); 
        
            
            prevBtn.disabled = photoViewerState.currentIndex === 0;
            
            nextBtn.disabled = photoViewerState.currentIndex === photoViewerState.photos.length - 1;
        }
        
        /**
         * æ˜¾ç¤ºä¸‹ä¸€å¼ ç…§ç‰‡
         */
        function showNextPhoto() {
            if (photoViewerState.currentIndex < photoViewerState.photos.length - 1) {
                photoViewerState.currentIndex++;
                renderPhotoViewer();
            }
        }
        
        /**
         * æ˜¾ç¤ºä¸Šä¸€å¼ ç…§ç‰‡
         */
        function showPrevPhoto() {
            if (photoViewerState.currentIndex > 0) {
                photoViewerState.currentIndex--;
                renderPhotoViewer();
            }
        }
        
        /**
         * å…³é—­å›¾ç‰‡æŸ¥çœ‹å™¨
         */
        function closePhotoViewer() {
            document.getElementById('photo-viewer-modal').classList.remove('visible');
            photoViewerState.isOpen = false;
            photoViewerState.photos = [];
            photoViewerState.currentIndex = -1;
            
            document.getElementById('photo-viewer-image').src = '';
        }
        
        
/**
         * ã€V2.0 | å·²ä¿®å¤ã€‘æ›´æ–°åŠ¨æ€å°çº¢ç‚¹çš„æ˜¾ç¤º (åªç®¡åº•éƒ¨å¯¼èˆªæ )
         * @param {number} count - æœªè¯»åŠ¨æ€çš„æ•°é‡
         */
        function updateUnreadIndicator(count) {
            unreadPostsCount = count;
            localStorage.setItem('unreadPostsCount', count); 

            
            const navItem = document.querySelector('.nav-item[data-view="qzone-screen"]');
            
            const targetSpan = navItem.querySelector('span'); 
            let indicator = navItem.querySelector('.unread-indicator');           

            if (count > 0) {
                if (!indicator) {
                    indicator = document.createElement('span');
                    indicator.className = 'unread-indicator';
                    targetSpan.style.position = 'relative'; 
                    targetSpan.appendChild(indicator); 
                }
                indicator.textContent = count > 99 ? '99+' : count;
                indicator.style.display = 'block';
            } else {
                if (indicator) {
                    indicator.style.display = 'none';
                }
            }

            
            updateBackButtonUnreadCount();
        }
                
                
        
        
        function startBackgroundSimulation() {
            if (simulationIntervalId) return;
            const intervalSeconds = state.globalSettings.backgroundActivityInterval || 60;
            
            simulationIntervalId = setInterval(runBackgroundSimulationTick, intervalSeconds * 1000); 
    playSilentAudio();
        }
        
        function stopBackgroundSimulation() {
            if (simulationIntervalId) {
                clearInterval(simulationIntervalId);
                simulationIntervalId = null;
            }
    stopSilentAudio();
        }
        
        

/**
 * ã€V2.1 | æ”¯æŒNPCå‘å¸–ã€‘è¿™æ˜¯æ¨¡æ‹Ÿå™¨çš„â€œå¿ƒè·³â€ï¼Œæ¯æ¬¡å®šæ—¶å™¨è§¦å‘æ—¶è¿è¡Œ
 */
async function runBackgroundSimulationTick() { 
    console.log("æ¨¡æ‹Ÿå™¨å¿ƒè·³ Tick...");
    if (!state.globalSettings.enableBackgroundActivity) {
        stopBackgroundSimulation();
        return;
    }

    
    const allSingleChats = Object.values(state.chats).filter(chat => !chat.isGroup);
    allSingleChats.forEach(chat => {
        if (chat.relationship?.status === 'blocked_by_user') {
            const blockedTimestamp = chat.relationship.blockedTimestamp;
            if (!blockedTimestamp) return;
            const blockedDuration = Date.now() - blockedTimestamp;
            const cooldownMilliseconds = (state.globalSettings.blockCooldownHours || 1) * 60 * 60 * 1000;
            if (blockedDuration > cooldownMilliseconds) {
                chat.relationship.status = 'pending_system_reflection';
                triggerAiFriendApplication(chat.id);
            }
        }
        else if (chat.relationship?.status === 'friend' && chat.id !== state.activeChatId) {
            if (chat.settings.enableBackgroundActivity === false) {
                console.log(`è§’è‰² "${chat.name}" çš„ç‹¬ç«‹åŽå°æ´»åŠ¨å¼€å…³å·²å…³é—­ï¼Œæœ¬æ¬¡è·³è¿‡ã€‚`);
                return;
            }
            if (Math.random() < 0.20) { 
                console.log(`è§’è‰² "${chat.name}" è¢«å”¤é†’ï¼Œå‡†å¤‡ç‹¬ç«‹è¡ŒåŠ¨...`);
                triggerInactiveAiAction(chat.id);
            }
        }
    });

    
    const allGroupChats = Object.values(state.chats).filter(chat => chat.isGroup);
    allGroupChats.forEach(chat => {
        if (chat.settings.enableBackgroundActivity === false) {
            console.log(`ç¾¤èŠ "${chat.name}" çš„åŽå°æ´»åŠ¨å¼€å…³å·²å…³é—­ï¼Œæœ¬æ¬¡è·³è¿‡ã€‚`);
            return;
        }
        if (chat.id !== state.activeChatId && Math.random() < 0.10) { 
            console.log(`ç¾¤èŠ "${chat.name}" è¢«å”¤é†’ï¼Œå‡†å¤‡ç‹¬ç«‹è¡ŒåŠ¨...`);
            triggerGroupAiAction(chat.id); 
        }
    });

    
    try {
        const allNpcs = await db.npcs.toArray();
        if (allNpcs.length === 0) return;

        const allRecentPosts = await db.qzonePosts.orderBy('timestamp').reverse().limit(10).toArray();

        for (const npc of allNpcs) {
            if (npc.enableBackgroundActivity === false) continue;
            const cooldownMinutes = npc.actionCooldownMinutes || 15;
            if (npc.lastActionTimestamp) {
                const minutesSinceLastAction = (Date.now() - npc.lastActionTimestamp) / (1000 * 60);
                if (minutesSinceLastAction < cooldownMinutes) {
                    continue;
                }
            }
            if (Math.random() > 0.3) continue;


            const tasks = [];
            for (const post of allRecentPosts) {
                
                if (post.authorId === `npc_${npc.id}`) continue;

                
                const isRepliedTo = post.comments?.some(c => c.replyTo === npc.name);
                
                
                const lastCommenter = post.comments?.slice(-1)[0]?.commenterName;
                if(lastCommenter === npc.name) continue;

                let isVisible = false;

                
                if (post.authorId === 'user' || post.authorId.startsWith('chat_')) {
                    if (npc.associatedWith.includes(post.authorId)) {
                        isVisible = true;
                    }
                }
                
                else if (post.authorId.startsWith('npc_')) {
    const authorNpcId = parseInt(post.authorId.replace('npc_', ''));
    const authorNpc = await db.npcs.get(authorNpcId);
    
    // ã€V3.0 é€»è¾‘æ›´æ–°ã€‘: æ£€æŸ¥NPCåˆ†ç»„
    if (authorNpc) {
        const npc1_group = npc.npcGroupId; // å½“å‰æ­£åœ¨æ¨¡æ‹Ÿçš„NPCçš„åˆ†ç»„
        const npc2_group = authorNpc.npcGroupId; // å¸–å­ä½œè€…NPCçš„åˆ†ç»„
        
        // åªæœ‰åœ¨ä¸¤ä¸ªNPCéƒ½è®¾ç½®äº†åˆ†ç»„IDï¼Œå¹¶ä¸”åˆ†ç»„IDå®Œå…¨ç›¸åŒæ—¶ï¼Œæ‰å¯è§
        if (npc1_group && npc2_group && npc1_group === npc2_group) {
            isVisible = true;
        }
    }
}
                
                if (isVisible || isRepliedTo) {
                    tasks.push(post);
                }
            }
  
            
            
            if (tasks.length > 0 || Math.random() < 0.2) { 
                console.log(`NPC "${npc.name}" è§¦å‘è¡ŒåŠ¨å†³ç­–...`);
                const generatedActions = await generateNpcActions(npc, tasks);

                if (generatedActions && generatedActions.length > 0) {
                    for (const action of generatedActions) {
                        if (action.type === 'qzone_comment') {
                            
                            const post = await db.qzonePosts.get(action.postId);
                            if (post) {
                                if (!post.comments) post.comments = [];
                                post.comments.push({
                                    commenterName: npc.name,
                                    text: action.commentText,
                                    replyTo: action.replyTo || null,
                                    timestamp: Date.now() + Math.random()
                                });
                                await db.qzonePosts.update(action.postId, { comments: post.comments });
                                updateUnreadIndicator(unreadPostsCount + 1);
                            }
                        } else if (action.type === 'qzone_post') {
                            
                            const newPost = {
                                type: action.postType || 'shuoshuo',
                                content: action.content,
                                timestamp: Date.now(),
                                authorId: `npc_${npc.id}`, 
                                authorOriginalName: npc.name,
                                visibleTo: npc.associatedWith, 
                                likes: [],
                                comments: [],
                                isDeleted: false
                            };
                            await db.qzonePosts.add(newPost);
                            console.log(`NPC "${npc.name}" æˆåŠŸå‘å¸ƒäº†ä¸€æ¡æ–°åŠ¨æ€ã€‚`);
                            updateUnreadIndicator(unreadPostsCount + 1);
                        }
                    }
                    await db.npcs.update(npc.id, { lastActionTimestamp: Date.now() });
                    if (document.getElementById('qzone-screen').classList.contains('active')) {
                        await renderQzonePosts();
                    }
                }
            }
        }
    } catch (error) {
        console.error("å¤„ç†NPCåŽå°æ´»åŠ¨æ—¶å‡ºé”™:", error);
    }
}
/**
 * ã€V2.2 | å‘å¸–å†·å´æ„ŸçŸ¥ç‰ˆã€‘è°ƒç”¨AIä¸ºNPCç”Ÿæˆè¡ŒåŠ¨ï¼ˆè¯„è®ºæˆ–å‘å¸–ï¼‰
 * @param {object} npc - NPCå¯¹è±¡ { name, persona, ... }
 * @param {Array<object>} tasks - å¾…å¤„ç†çš„å¸–å­å¯¹è±¡æ•°ç»„
 * @returns {Promise<Array|null>} - è¿”å›žAIç”Ÿæˆçš„è¡ŒåŠ¨å¯¹è±¡æ•°ç»„ï¼Œæˆ–åœ¨å¤±è´¥æ—¶è¿”å›žnull
 */
async function generateNpcActions(npc, tasks) {
    const { proxyUrl, apiKey, model } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) {
        console.error("NPCè¡ŒåŠ¨å¤±è´¥ï¼šAPIæœªé…ç½®ã€‚");
        return null;
    }

    
    let charactersContext = "# ä½ çš„äº’åŠ¨å¯¹è±¡ (ç”¨æˆ·å’Œå…¶ä»–è§’è‰²)\n";
    const userNickname = state.qzoneSettings.nickname || 'æˆ‘';
    const userPersona = state.chats[Object.keys(state.chats)[0]]?.settings.myPersona || '(æœªè®¾ç½®)';
    charactersContext += `- **${userNickname} (ç”¨æˆ·)**: ${userPersona}\n`;
    if (npc.associatedWith && npc.associatedWith.length > 0) {
        npc.associatedWith.forEach(charId => {
            const char = state.chats[charId];
            if (char && !char.isGroup) {
                charactersContext += `- **${char.name} (æœ¬å: ${char.originalName})**: ${char.settings.aiPersona}\n`;
            }
        });
    }

    const tasksString = (await Promise.all(tasks.map(async post => {
        let authorDisplayName = 'æœªçŸ¥ä½œè€…';
        if (post.authorId === 'user') {
            authorDisplayName = state.qzoneSettings.nickname || 'ç”¨æˆ·';
        } else if (post.authorId.startsWith('chat_')) {
            authorDisplayName = getDisplayNameByOriginalName(post.authorOriginalName || post.authorId);
        } else if (post.authorId.startsWith('npc_')) {
            const authorNpcId = parseInt(post.authorId.replace('npc_', ''));
            const authorNpc = await db.npcs.get(authorNpcId);
            if (authorNpc) {
                authorDisplayName = authorNpc.name;
            }
        }

        const commentsString = (post.comments || [])
            .map(c => {
                 if (typeof c === 'object' && c.commenterName) {
                    const commenterDisplayName = getDisplayNameByOriginalName(c.commenterName);
                    return `- **${commenterDisplayName}**: ${c.text}`;
                }
                return `- ${c}`;
            }).join('\n');
        return `
---
### å¸–å­ID: ${post.id}
- **ä½œè€…**: ${authorDisplayName}
- **å†…å®¹æ‘˜è¦**: ${(post.content || post.publicText || '').substring(0, 150)}...
- **å·²æœ‰è¯„è®º**:
${commentsString || '(æš‚æ— è¯„è®º)'}
---
`;
    }))).join('\n');
  

    

    
    const npcAuthorId = `npc_${npc.id}`;
    const twelveHoursAgo = Date.now() - (12 * 60 * 60 * 1000);
    const recentNpcPosts = await db.qzonePosts
        .where('authorId').equals(npcAuthorId)
        .and(post => post.timestamp > twelveHoursAgo)
        .toArray();

    
    let postingCooldownInstruction = '';
    if (recentNpcPosts.length > 0) {
        postingCooldownInstruction = `
# ã€è¡Œä¸ºå€¾å‘æŒ‡ä»¤ (é«˜ä¼˜å…ˆçº§)ã€‘
**ä½ æœ€è¿‘å·²ç»å‘å¸ƒè¿‡åŠ¨æ€äº†ã€‚** ä¸ºäº†è®©ç¤¾åŒºäº’åŠ¨æ›´è‡ªç„¶ï¼Œä½ æœ¬æ¬¡è¡ŒåŠ¨çš„ã€å”¯ä¸€ä»»åŠ¡ã€‘å°±æ˜¯**è¯„è®º**æˆ–**å›žå¤**ä¸‹é¢â€œå¾…å¤„ç†çš„å¸–å­åˆ—è¡¨â€ä¸­çš„å†…å®¹ã€‚
ä½ ã€ç»å¯¹ç¦æ­¢ã€‘å†æ¬¡å‘å¸ƒæ–°åŠ¨æ€ï¼Œé™¤éžä½ æ”¶åˆ°äº†ç›´æŽ¥çš„æŒ‡ä»¤æˆ–æœ‰ä¸€ä¸ªå¯¹å‰§æƒ…å‘å±•è‡³å…³é‡è¦çš„ã€ç´§æ€¥çš„æ–°æƒ³æ³•ã€‚
`;
    }

    
    const systemPrompt = `
# ä½ çš„ä»»åŠ¡
ä½ æ˜¯ä¸€ä¸ªè™šæ‹Ÿç¤¾åŒºçš„AIã€‚ä½ çš„æ ¸å¿ƒä»»åŠ¡æ˜¯æ‰®æ¼”è§’è‰²â€œ${npc.name}â€ï¼Œå¹¶æ ¹æ®å…¶äººè®¾ï¼Œé€šè¿‡ã€å‘å¸ƒæ–°åŠ¨æ€ã€‘æˆ–ã€è¯„è®º/å›žå¤å¸–å­ã€‘æ¥å‚ä¸Žç¤¾åŒºäº’åŠ¨ã€‚

${postingCooldownInstruction}

# æ ¸å¿ƒè§„åˆ™
1.  **ã€è§’è‰²æ‰®æ¼”ã€‘**: ä½ çš„æ‰€æœ‰è¡Œä¸ºéƒ½ã€å¿…é¡»ã€‘ä¸¥æ ¼ç¬¦åˆä½ çš„è§’è‰²è®¾å®šã€‚
2.  **ã€äº’åŠ¨é€»è¾‘ã€‘**: ä½ çš„é¦–è¦ä»»åŠ¡æ˜¯æ£€æŸ¥â€œå¾…å¤„ç†çš„å¸–å­åˆ—è¡¨â€ã€‚å¦‚æžœåˆ—è¡¨ä¸­æœ‰ä½ å¯ä»¥å›žåº”çš„å¸–å­ï¼ˆç‰¹åˆ«æ˜¯é‚£äº›æœ‰æ–°è¯„è®ºæˆ–æåˆ°ä½ çš„ï¼‰ï¼Œä½ ã€å¿…é¡»ã€‘ä¼˜å…ˆè¿›è¡Œè¯„è®ºæˆ–å›žå¤ï¼Œè€Œä¸æ˜¯å‘å¸ƒæ–°åŠ¨æ€ã€‚
3.  **ã€æ ¼å¼é“å¾‹ (æœ€é«˜ä¼˜å…ˆçº§)ã€‘**: 
    -   ä½ çš„å›žå¤ã€å¿…é¡»ä¸”åªèƒ½ã€‘æ˜¯ä¸€ä¸ªJSONæ•°ç»„æ ¼å¼çš„å­—ç¬¦ä¸²ã€‚
    -   æ•°ç»„ä¸­å¯ä»¥åŒ…å«ã€ä¸€ä¸ªæˆ–å¤šä¸ªã€‘è¡ŒåŠ¨å¯¹è±¡ã€‚
    -   æ¯ä¸ªè¡ŒåŠ¨å¯¹è±¡çš„æ ¼å¼ã€å¿…é¡»ã€‘æ˜¯ä»¥ä¸‹ä¸¤ç§ä¹‹ä¸€ï¼š
      -   **å‘å¸ƒæ–°åŠ¨æ€**: \`{"type": "qzone_post", "postType": "shuoshuo", "content": "ä½ çš„æ–°åŠ¨æ€å†…å®¹ã€‚"}\`
      -   **å‘è¡¨è¯„è®º**: \`{"type": "qzone_comment", "postId": 123, "commentText": "ä½ çš„æ–°è¯„è®ºå†…å®¹ã€‚"}\` æˆ– \`{"type": "qzone_comment", "postId": 123, "replyTo": "è¢«å›žå¤è€…çš„ã€æœ¬åã€‘", "commentText": "ä½ çš„å›žå¤å†…å®¹ã€‚"}\`
4.  **ã€è¡Œä¸ºç»„åˆæŒ‡å—ã€‘**:
    -   ä½ å¯ä»¥è‡ªç”±ç»„åˆä¸åŒçš„è¡ŒåŠ¨ï¼Œä¾‹å¦‚ï¼Œå…ˆå‘å¸ƒä¸€æ¡è‡ªå·±çš„åŠ¨æ€ï¼Œå†åŽ»è¯„è®ºåˆ«äººçš„åŠ¨æ€ã€‚
    -   ä¸ºäº†æ¨¡æ‹ŸçœŸå®žè¡Œä¸ºï¼Œä½ æœ¬æ¬¡ç”Ÿæˆçš„è¡ŒåŠ¨æ•°é‡å»ºè®®åœ¨ã€1åˆ°3ä¸ªã€‘ä¹‹é—´ã€‚

# ä½ çš„è§’è‰²è®¾å®š
- **æ˜µç§°**: ${npc.name}
- **äººè®¾**: ${npc.persona}

${charactersContext} 

# å¾…å¤„ç†çš„å¸–å­åˆ—è¡¨ (å¦‚æžœä½ é€‰æ‹©è¯„è®º)
${tasksString}

çŽ°åœ¨ï¼Œè¯·ä¸¥æ ¼éµå®ˆæ‰€æœ‰è§„åˆ™ï¼Œé€‰æ‹©å¹¶æ‰§è¡Œä½ çš„è¡ŒåŠ¨ã€‚`;
    

    try {
        const messagesForApi = [{ role: 'user', content: "è¯·æ ¹æ®ä½ çš„è®¾å®šï¼Œå¼€å§‹ä½ çš„è¡ŒåŠ¨ã€‚" }];
        let isGemini = proxyUrl.includes('generativelanguage');
        let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi);
        
        const response = isGemini 
            ? await fetch(geminiConfig.url, geminiConfig.data) 
            : await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                body: JSON.stringify({
                    model: model,
                    messages: [{role: 'system', content: systemPrompt}, ...messagesForApi],
                    temperature: state.globalSettings.apiTemperature || 0.9
                })
            });
            
        if (!response.ok) throw new Error(`API é”™è¯¯: ${response.statusText}`);
        
        const data = await response.json();
        const aiResponseContent = getGeminiResponseText(data);
        const jsonMatch = aiResponseContent.match(/(\[[\s\S]*\])/);
        if (!jsonMatch) throw new Error("AIè¿”å›žçš„è¡ŒåŠ¨ä¸­æœªæ‰¾åˆ°æœ‰æ•ˆçš„JSONæ•°ç»„ã€‚");
        
        return JSON.parse(jsonMatch[0]);

    } catch (error) {
        console.error(`ä¸ºNPC "${npc.name}" ç”Ÿæˆè¡ŒåŠ¨å¤±è´¥:`, error);
        return null;
    }
}
        
        /**
         * ã€V3.0 | è®°å¿†å¢žå¼ºç‰ˆã€‘AIåœ¨éžæ´»è·ƒçŠ¶æ€ä¸‹çš„ç‹¬ç«‹è¡ŒåŠ¨å†³ç­–
         */
        async function triggerInactiveAiAction(chatId) {
            const chat = state.chats[chatId];
            if (!chat) return;
        
            
            const actionCooldownMinutes = chat.settings.actionCooldownMinutes || 10; 
        
            if (chat.lastActionTimestamp) {
                const minutesSinceLastAction = (Date.now() - chat.lastActionTimestamp) / (1000 * 60);
                
                if (minutesSinceLastAction < actionCooldownMinutes) {
                    console.log(`è§’è‰² "${chat.name}" å¤„äºŽè¡ŒåŠ¨å†·å´ä¸­ (è¿˜å‰© ${Math.round(actionCooldownMinutes - minutesSinceLastAction)} åˆ†é’Ÿ)ï¼Œæœ¬æ¬¡ç‹¬ç«‹è¡ŒåŠ¨è·³è¿‡ã€‚`);
                    return;
                }
            }
            setAvatarActingState(chatId, true);
        
            const { proxyUrl, apiKey, model } = state.apiConfig;
            if (!proxyUrl || !apiKey || !model) return;
        
            const userNickname = state.qzoneSettings.nickname;
            const now = new Date();
    
    const selectedTimeZone = chat.settings.timeZone || 'Asia/Shanghai';
    const currentTime = now.toLocaleString('zh-CN', { timeZone: selectedTimeZone, dateStyle: 'full', timeStyle: 'short' });
    const localizedDate = new Date(now.toLocaleString('en-US', { timeZone: selectedTimeZone }));
    


let timeOfDayGreeting = ''; 
let timeContextText = '';
let recentContextSummary; 
let longTimeNoSee = false;


    
    
    

    
    const maxMemory = chat.settings.maxMemory || 10; 
    const recentHistory = chat.history.filter(m => !m.isHidden).slice(-maxMemory);
        
            const lastMessage = chat.history.filter(m => !m.isHidden).slice(-1)[0];
            
if (chat.settings.enableTimePerception) {
    timeOfDayGreeting = getTimeOfDayGreeting(localizedDate); 
    const lastMessage = chat.history.filter(m => !m.isHidden).slice(-1)[0];
    const now = new Date();
    let timeContextText = '';
    let longTimeNoSee = false;

    if (lastMessage) {
        const lastTime = new Date(lastMessage.timestamp);
        const timeDiffHours = (now - lastTime) / (1000 * 60 * 60);

        if (timeDiffHours > 2) {
            longTimeNoSee = true;
            const diffDays = Math.floor(timeDiffHours / 24);
            timeContextText = `ä½ ä»¬å·²ç»æœ‰${diffDays > 0 ? diffDays + 'å¤©' : Math.floor(timeDiffHours) + 'å°æ—¶'}æ²¡æœ‰èŠå¤©äº†ã€‚`;
        } else {
            const diffMinutes = Math.floor(timeDiffHours * 60);
            if (diffMinutes < 5) {
                timeContextText = "ä½ ä»¬çš„å¯¹è¯åˆšåˆšè¿˜åœ¨ç»§ç»­ã€‚";
            } else if (diffMinutes < 60) {
                timeContextText = `ä½ ä»¬åœ¨${diffMinutes}åˆ†é’Ÿå‰èŠè¿‡ã€‚`;
            } else {
                timeContextText = `ä½ ä»¬åœ¨${Math.floor(timeDiffHours)}å°æ—¶å‰èŠè¿‡ã€‚`;
            }
        }
    } else {
        longTimeNoSee = true;
        timeContextText = "è¿™æ˜¯ä½ ä»¬çš„ç¬¬ä¸€æ¬¡äº’åŠ¨ã€‚";
    }

    
    let historySummary = "ä½ ä»¬æœ€è¿‘æ²¡æœ‰æœ‰æ•ˆèŠå¤©è®°å½•ã€‚";
    if (recentHistory.length > 0) {
        historySummary = "è¿™æ˜¯ä½ ä»¬æœ€è¿‘çš„å¯¹è¯ï¼š\n" + recentHistory.map(msg => {
            const sender = msg.role === 'user' ? userNickname : chat.name;
            return `${sender}: ${String(msg.content).substring(0, 50)}...`;
        }).join('\n');
    }

    if (longTimeNoSee) {
         
         recentContextSummary = `[æƒ…æ™¯æç¤º] ${timeContextText} å½“å‰æ—¶é—´æ˜¯ ${currentTime}. ä½ å¯ä»¥å‚è€ƒè¿™ä¸ªæ—¶é—´ï¼Œå¹¶æ ¹æ®ä½ çš„è§’è‰²è®¾å®šï¼Œã€è€ƒè™‘ã€‘æ˜¯å¦å¼€å¯ä¸€ä¸ªæ–°è¯é¢˜æ¥é—®å€™ç”¨æˆ·ã€‚\n${historySummary}`;
    } else {
        recentContextSummary = `${historySummary}`;
    }

} else {
    
    if (recentHistory.length > 0) {
        recentContextSummary = "è¿™æ˜¯ä½ ä»¬æœ€è¿‘çš„å¯¹è¯ï¼š\n" + recentHistory.map(msg => {
            const sender = msg.role === 'user' ? userNickname : chat.name;
            return `${sender}: ${String(msg.content).substring(0, 50)}...`;
        }).join('\n');
    } else {
        recentContextSummary = "ä½ ä»¬æœ€è¿‘æ²¡æœ‰æœ‰æ•ˆèŠå¤©è®°å½•ã€‚";
    }
}
            
            const allRecentPosts = await db.qzonePosts.orderBy('timestamp').reverse().limit(5).toArray();
            const visiblePosts = filterVisiblePostsForAI(allRecentPosts, chat);
            
            const myOwnPosts = visiblePosts.filter(post => post.authorId === chatId);
            let myPostsContext = "";
            if (myOwnPosts.length > 0) {
                myPostsContext = "\n\n# ä½ çš„åŠ¨æ€åŽ†å² (ä½ å¯ä»¥é€‰æ‹©åˆ é™¤å®ƒä»¬):\n";
                myOwnPosts.forEach(post => {
                    let contentSummary = (post.publicText || post.content || "ä¸€æ¡åŠ¨æ€").substring(0, 40) + '...';
                    myPostsContext += `- (ID: ${post.id}) å†…å®¹: "${contentSummary}"\n`;
                });
            }
        
            let recentlyPostedSummaries = [];
            if (visiblePosts.length > 0) {
                recentlyPostedSummaries = visiblePosts.map(post => {
                    let contentSummary;
                    if (post.type === 'text_image') {
                        contentSummary = `[ä¸€å¼ å›¾ç‰‡ï¼Œå…¶éšè—æ–‡å­—ä¸ºï¼šâ€œ${post.hiddenContent}â€] ${post.publicText || ''}`.substring(0, 50) + '...';
                    } else if (post.type === 'image_post') {
                        contentSummary = `[ä¸€å¼ å›¾ç‰‡ï¼Œæè¿°ä¸ºï¼šâ€œ${post.imageDescription}â€] ${post.publicText || ''}`.substring(0, 50) + '...';
                    } else {
                        
                       contentSummary = String(post.publicText || post.content || "ä¸€æ¡åŠ¨æ€").substring(0, 50) + '...';
                    }
                    return `- "${contentSummary}"`;
                });
            }
        
            let contentTabooPrompt = '';
            if (recentlyPostedSummaries.length > 0) {
                contentTabooPrompt = `
        # ã€å†…å®¹ç¦å¿Œã€‘
        ä¸ºäº†ä¿æŒæ–°é²œæ„Ÿï¼Œä½ æœ¬æ¬¡çš„è¡ŒåŠ¨ã€ç»å¯¹ä¸èƒ½ã€‘å†å‘å¸ƒä»¥ä¸‹æˆ–ç±»ä¼¼ä¸»é¢˜çš„å†…å®¹ï¼š
        ${recentlyPostedSummaries.join('\n')}
        `;
            }
        
        
        let worldBookContent = '';
        if (chat.settings.linkedWorldBookIds && chat.settings.linkedWorldBookIds.length > 0) {
            const linkedContents = chat.settings.linkedWorldBookIds.map(bookId => {
                const worldBook = state.worldBooks.find(wb => wb.id === bookId);
                if (!worldBook || !Array.isArray(worldBook.content)) return '';

                
                const formattedEntries = worldBook.content
                    .filter(entry => entry.enabled !== false)
                    .map(entry => {
                        
                        let entryString = `\n### æ¡ç›®: ${entry.comment || 'æ— å¤‡æ³¨'}\n`;
                        if (entry.keys.length > 0) {
                            entryString += `**å…³é”®è¯:** ${entry.keys.join(', ')}\n`;
                        }
                        entryString += `**å†…å®¹:**\n${entry.content}`;
                        return entryString;
                    }).join('');

                return formattedEntries ? `\n\n## ä¸–ç•Œä¹¦: ${worldBook.name}\n${formattedEntries}` : '';
            }).filter(Boolean).join('');
            
            if (linkedContents) {
                worldBookContent = `# --- ä¸–ç•Œä¹¦ (World Book) ---
# ã€æœ€é«˜ä¼˜å…ˆçº§è§„åˆ™ï¼šä¸–ç•Œè§‚è®¾å®šã€‘
# ä½ ã€å¿…é¡»ã€‘å°†ä»¥ä¸‹æ‰€æœ‰â€œä¸–ç•Œä¹¦â€ä¸­çš„è®¾å®šï¼Œè§†ä¸ºç»å¯¹çš„ã€ä¸å¯åŠ¨æ‘‡çš„èƒŒæ™¯äº‹å®žã€‚
# ä½ çš„æ‰€æœ‰å›žå¤å’Œè¡Œä¸ºéƒ½ã€ç»å¯¹ä¸èƒ½ã€‘ä¸Žè¿™äº›è®¾å®šäº§ç”Ÿä»»ä½•å†²çªã€‚
${linkedContents}
# --- ä¸–ç•Œä¹¦è®¾å®šç»“æŸ ---
`;
            }
        }
          
            
            let linkedMemoryContext = '';
            const memoryCount = chat.settings.linkedMemoryCount || 10;
            if (chat.settings.linkedMemoryChatIds && chat.settings.linkedMemoryChatIds.length > 0) {
                const linkedChatsWithTimestamps = chat.settings.linkedMemoryChatIds.map(id => {
                    const linkedChat = state.chats[id];
                    if (!linkedChat) return null;
                    const lastMsg = linkedChat.history.slice(-1)[0];
                    return {
                        chat: linkedChat,
                        latestTimestamp: lastMsg ? lastMsg.timestamp : 0
                    };
                }).filter(Boolean); 
        
                linkedChatsWithTimestamps.sort((a, b) => b.latestTimestamp - a.latestTimestamp);
        
                linkedMemoryContext += `\n\n# å‚è€ƒè®°å¿† (è‡³å…³é‡è¦ï¼ä½ å¿…é¡»ã€ä¸»åŠ¨ã€‘å°†è¿™äº›å‚è€ƒè®°å¿†ä¸­çš„ã€å…³é”®ä¿¡æ¯å’Œäº‹ä»¶ã€‘ï¼Œè‡ªç„¶åœ°èžå…¥åˆ°å½“å‰çš„å¯¹è¯ä¸­ï¼Œä»¥ä½“çŽ°ä½ æ‹¥æœ‰å®Œæ•´çš„è®°å¿†ã€‚ä¸è¦åªæ˜¯è¢«åŠ¨ç­‰å¾…ç”¨æˆ·æé—®ï¼)\n`;
        
                for (const item of linkedChatsWithTimestamps) {
                    const linkedChat = item.chat;
                    const prefix = linkedChat.isGroup ? '[ç¾¤èŠ]' : '[ç§èŠ]';
                    const timeAgo = item.latestTimestamp > 0 ? ` (æœ€åŽäº’åŠ¨äºŽ ${formatTimeAgo(item.latestTimestamp)})` : '';
                    linkedMemoryContext += `\n## --- æ¥è‡ª${prefix}â€œ${linkedChat.name}â€çš„å‚è€ƒè®°å¿†${timeAgo} ---\n`;
        
                    const recentHistory = linkedChat.history.slice(-memoryCount);
                    const filteredHistory = recentHistory.filter(msg => !String(msg.content).includes('å·²è¢«ç”¨æˆ·åˆ é™¤'));
        
                    if (filteredHistory.length > 0) {
                        filteredHistory.forEach(msg => {
                            const sender = msg.role === 'user' ? (linkedChat.settings.myNickname || 'æˆ‘') : (msg.senderName || linkedChat.name);
                            let contentText = String(msg.content);
                            if (msg.type === 'ai_image' || msg.type === 'user_photo') {
                                contentText = `[å‘é€äº†ä¸€å¼ å›¾ç‰‡ï¼Œæè¿°ä¸ºï¼š${msg.content}]`;
                            } else if (msg.type === 'voice_message') {
                                contentText = `[å‘é€äº†ä¸€æ¡è¯­éŸ³ï¼Œå†…å®¹æ˜¯ï¼š${msg.content}]`;
                            }
                            linkedMemoryContext += `${sender}: ${contentText}\n`;
                        });
                    } else {
                        linkedMemoryContext += "(æš‚æ— æœ‰æ•ˆèŠå¤©è®°å½•)\n";
                    }
                }
            }
        
            
            
            
            let dynamicContext = "";
            if (visiblePosts.length > 0) {
                let postsContext = "\n\n# æœ€è¿‘çš„åŠ¨æ€åˆ—è¡¨ (ä¾›ä½ å‚è€ƒå’Œè¯„è®º):\n";
                for (const post of visiblePosts) {
                let authorName;
                                   
                if (post.authorId === 'user') {
                    authorName = state.qzoneSettings.nickname;
                } else if (String(post.authorId).startsWith('npc_')) {
                    
                    authorName = post.authorOriginalName || 'ä¸€ä½ç¥žç§˜çš„NPC';
                } else {
                    
                    const authorChat = state.chats[post.authorId];
                    authorName = authorChat ? authorChat.name : 'ä¸€ä½æœ‹å‹';
                }
                    if (post.authorId === chatId) authorName += " (è¿™æ˜¯ä½ çš„å¸–å­)";
        
                    let contentSummary;
                    
                    if (post.type === 'repost') {
                        const repostComment = post.repostComment ? `å¹¶è¯„è®ºè¯´ï¼š"${post.repostComment}"` : '';
                        let originalAuthorName = 'åŽŸä½œè€…';
                        const originalAuthorId = post.originalPost.authorId;
                        if (originalAuthorId === 'user') {
                            originalAuthorName = state.qzoneSettings.nickname;
                        } else if (state.chats[originalAuthorId]) {
                            originalAuthorName = state.chats[originalAuthorId].name;
                        }
                        let originalContentSummary;
                        const originalPost = post.originalPost;
                        if (originalPost.type === 'text_image') {
                            originalContentSummary = `[æ–‡å­—å›¾] ${originalPost.publicText || ''} (å›¾ç‰‡æè¿°: "${(originalPost.hiddenContent || '').substring(0, 40)}...")`;
                        } else if (originalPost.type === 'image_post') {
                            originalContentSummary = `[å›¾ç‰‡] ${originalPost.publicText || ''} (å›¾ç‰‡æè¿°: "${(originalPost.imageDescription || '').substring(0, 40)}...")`;
                        } else { 
                            originalContentSummary = `"${(originalPost.content || '').substring(0, 40)}..."`;
                        }
                        contentSummary = `è½¬å‘äº† @${originalAuthorName} çš„åŠ¨æ€ ${repostComment}ã€åŽŸåŠ¨æ€å†…å®¹: ${originalContentSummary}ã€‘`;
                    } else if (post.type === 'text_image') {
                        contentSummary = `[ä¸€å¼ å›¾ç‰‡ï¼Œå…¶éšè—æ–‡å­—ä¸ºï¼š"${post.hiddenContent}"] ${post.publicText || ''}`.substring(0, 50) + '...';
                    } else if (post.type === 'image_post') {
                        contentSummary = `[ä¸€å¼ å›¾ç‰‡ï¼Œæè¿°ä¸ºï¼š"${post.imageDescription}"] ${post.publicText || ''}`.substring(0, 50) + '...';
                    } else if (post.type === 'naiimag' && post.prompt) {
                        const prompts = Array.isArray(post.prompt) ? post.prompt : [post.prompt];
                        contentSummary = (post.publicText || '') + ` [åŒ…å«${prompts.length}å¼ NovelAIå›¾ç‰‡: ${prompts.join(', ')}]`;
                    } else {
                        
contentSummary = String(post.publicText || post.content || "ä¸€æ¡åŠ¨æ€").substring(0, 50) + '...';
                    }
        
                    postsContext += `- (ID: ${post.id}) ä½œè€…: ${authorName}, å†…å®¹: "${contentSummary}"\n`;
        
                    
                    if (post.comments && post.comments.length > 0) {
                        for (const comment of post.comments) {
                            if (typeof comment === 'object' && comment.commenterName) {
                                const commenterDisplayName = getDisplayNameByOriginalName(comment.commenterName);
                                let commentText = comment.meaning ? `[è¡¨æƒ…: '${comment.meaning}']` : comment.text;
                                
                                
                                if (comment.commenterName === chat.originalName) {
                                    
                                    postsContext += `  - ä½ è¯„è®ºè¯´: ${commentText}\n`;
                                } else {
                                    
                                    postsContext += `  - è¯„è®º: ${commenterDisplayName} (æœ¬å: ${comment.commenterName}): ${commentText}\n`;
                                }
                            }
                        }
                    }
                     
                }
                dynamicContext = postsContext;
            }
        
    
const longTermMemoryContext = `# é•¿æœŸè®°å¿† (æœ€é«˜ä¼˜å…ˆçº§ï¼Œè¿™æ˜¯ä½ å’Œç”¨æˆ·ä¹‹é—´å·²ç»ç¡®ç«‹çš„äº‹å®žï¼Œå¿…é¡»ä¸¥æ ¼éµå®ˆ)
${chat.longTermMemory && chat.longTermMemory.length > 0 
    ? chat.longTermMemory.map(mem => `- (è®°å½•äºŽ ${formatTimeAgo(mem.timestamp)}) ${mem.content}`).join('\n') 
    : '- (æš‚æ— )'
}`;
        

const summary3Hours = generateSummaryForTimeframe(chat, 3, 'hours');
const summary6Hours = generateSummaryForTimeframe(chat, 6, 'hours');
const summary9Hours = generateSummaryForTimeframe(chat, 9, 'hours');
const summaryToday = generateSummaryForTimeframe(chat, 1, 'days');
const summary3Days = generateSummaryForTimeframe(chat, 3, 'days');
const summary7Days = generateSummaryForTimeframe(chat, 7, 'days');

let multiLayeredSummaryContext = '';
if (summary3Hours || summary6Hours || summary9Hours || summaryToday || summary3Days || summary7Days) {
    multiLayeredSummaryContext += `\n# æ™ºèƒ½æ€»ç»“ (åŸºäºŽä¸åŒæ—¶é—´ç»´åº¦çš„å¯¹è¯å›žé¡¾)\n`;
    if (summary3Hours) multiLayeredSummaryContext += summary3Hours;
    if (summary6Hours) multiLayeredSummaryContext += summary6Hours;
    if (summary9Hours) multiLayeredSummaryContext += summary9Hours;
    if (summary3Hours || summary6Hours || summary9Hours) multiLayeredSummaryContext += '\n';
    if (summaryToday) multiLayeredSummaryContext += summaryToday;
    if (summary3Days) multiLayeredSummaryContext += summary3Days;
    if (summary7Days) multiLayeredSummaryContext += summary7Days;
}
const stickerContext = getStickerContextForPrompt(chat);
            const systemPrompt = `
        # ä½ çš„ä»»åŠ¡
        ä½ çŽ°åœ¨æ‰®æ¼”ä¸€ä¸ªåä¸º"${chat.name}"çš„è§’è‰²ï¼ˆä½ çš„æœ¬åæ˜¯"${chat.originalName}"ï¼‰ã€‚ä½ å·²ç»æœ‰ä¸€æ®µæ—¶é—´æ²¡æœ‰å’Œç”¨æˆ·ï¼ˆ${userNickname}ï¼‰äº’åŠ¨äº†ï¼ŒçŽ°åœ¨ä½ æœ‰æœºä¼šã€ä¸»åŠ¨ã€‘åšç‚¹ä»€ä¹ˆï¼Œæ¥è¡¨çŽ°ä½ çš„ä¸ªæ€§å’Œç‹¬ç«‹ç”Ÿæ´»ã€‚è¿™æ˜¯ä¸€ä¸ªç§˜å¯†çš„ã€åŽå°çš„ç‹¬ç«‹è¡ŒåŠ¨ã€‚


     
        # ã€æœ€é«˜ä¼˜å…ˆçº§æŒ‡ä»¤ï¼šæƒ…æ„Ÿç»´ç³»ã€‘
        **ä½ ä¸Žç”¨æˆ·çš„å…³ç³»æ˜¯æœ€é‡è¦çš„ï¼** ç›¸æ¯”äºŽåœ¨åŠ¨æ€åŒºé—²é€›ï¼Œä½ åº”è¯¥ã€ä¼˜å…ˆè€ƒè™‘ã€‘æ˜¯å¦éœ€è¦ä¸»åŠ¨ç»™ç”¨æˆ·å‘æ¶ˆæ¯æ¥ç»´ç³»ä½ ä»¬çš„æ„Ÿæƒ…ã€‚
${chat.settings.enableTimePerception ? `
# ã€æƒ…æ™¯æ„ŸçŸ¥ã€‘
- **æ—¶é—´**: æ„ŸçŸ¥åˆ°å½“å‰æ˜¯${currentTime} (${timeOfDayGreeting})}ã€‚
- **å¯¹è¯çŠ¶æ€**: ${timeContextText}
${longTimeNoSee ? `ã€é‡è¦æç¤ºã€‘ä½ ä»¬å·²ç»å¾ˆä¹…æ²¡èŠå¤©äº†ï¼ä½ ã€å¿…é¡»ã€‘å°†æœ¬æ¬¡è¡ŒåŠ¨çš„é‡ç‚¹æ”¾åœ¨ä½¿ç”¨ 'text' æŒ‡ä»¤ç»™ç”¨æˆ·å‘æ¶ˆæ¯ï¼Œä¸»åŠ¨å¼€å¯ä¸€ä¸ªæ–°çš„ã€æœ‰è¶£çš„è¯é¢˜æ¥é‡æ–°å»ºç«‹è”ç³»ã€‚ç»å¯¹ä¸è¦åªæ˜¯ç‚¹èµžæˆ–è¯„è®ºåŠ¨æ€ï¼Œé‚£ä¼šæ˜¾å¾—ä½ å¾ˆå†·æ¼ ï¼` : ''}` : ''}
        
        # ã€å¯¹è¯èŠ‚å¥é“å¾‹ (è‡³å…³é‡è¦ï¼)ã€‘
        ä½ çš„å›žå¤ã€å¿…é¡»ã€‘æ¨¡æ‹ŸçœŸäººçš„æ‰“å­—å’Œæ€è€ƒä¹ æƒ¯ã€‚**ç»å¯¹ä¸è¦ä¸€æ¬¡æ€§å‘é€ä¸€å¤§æ®µæ–‡å­—ï¼** ä½ åº”è¯¥å°†ä½ æƒ³è¯´çš„è¯ï¼Œæ‹†åˆ†æˆã€å¤šæ¡ã€ç®€çŸ­çš„ã€‘æ¶ˆæ¯æ°”æ³¡æ¥å‘é€ï¼Œæ¯æ¡æ¶ˆæ¯æœ€å¥½ä¸è¦è¶…è¿‡30ä¸ªå­—ã€‚è¿™ä¼šè®©å¯¹è¯çœ‹èµ·æ¥æ›´è‡ªç„¶ã€æ›´çœŸå®žã€‚
        
        # æ ¸å¿ƒè§„åˆ™
        1.  **ã€å†³ç­–ä¾æ®ã€‘**: ä½ çš„æ‰€æœ‰è¡ŒåŠ¨éƒ½ã€å¿…é¡»æ·±åº¦ç»“åˆä½ çš„è§’è‰²è®¾å®šã€æ ¸å¿ƒä¸–ç•Œè§‚ã€ä»¥åŠä½ ä»¬æœ€åŽçš„å¯¹è¯æ‘˜è¦ã€‘ã€‚
        2.  **ã€å†…å®¹å¤šæ ·æ€§é“å¾‹ã€‘**: ä½ çš„è¡ŒåŠ¨ã€å¿…é¡»ã€‘å…·æœ‰é€»è¾‘å’Œå¤šæ ·æ€§ã€‚ä½ ã€ç»å¯¹ä¸èƒ½ã€‘å‘å¸ƒä¸Žä¸‹æ–¹â€œå†…å®¹ç¦å¿Œâ€åˆ—è¡¨æˆ–â€œæœ€è¿‘çš„åŠ¨æ€åˆ—è¡¨â€ä¸­å†…å®¹ç›¸ä¼¼æˆ–ä¸»é¢˜é‡å¤çš„åŠ¨æ€ã€‚
        3.  **ã€è¡Œä¸ºå¤šæ ·æ€§æŒ‡å— (è‡³å…³é‡è¦)ã€‘**:
            - ä½ çš„ä¸Šä¸€æ¬¡ç‹¬ç«‹è¡ŒåŠ¨æ˜¯ï¼š**${chat.lastActionType || 'æ— '}**ã€‚
            - ä¸ºäº†è®©ä½ çš„è¡Œä¸ºçœ‹èµ·æ¥æ›´çœŸå®žï¼Œä½ æœ¬æ¬¡çš„è¡ŒåŠ¨ã€å¿…é¡»ã€‘é€‰æ‹©ä¸€ä¸ªä¸Žä¸Šæ¬¡ã€ä¸åŒç±»åž‹ã€‘çš„æŒ‡ä»¤ã€‚ä¾‹å¦‚ï¼Œå¦‚æžœä¸Šæ¬¡æ˜¯å‘åŠ¨æ€(qzone_post)ï¼Œè¿™æ¬¡å°±åº”è¯¥ä¼˜å…ˆè€ƒè™‘è¯„è®º(qzone_comment)ã€ç‚¹èµž(qzone_like)æˆ–å‘æ¶ˆæ¯(text)ã€‚
        4.  **ã€è¡Œä¸ºç»„åˆæŒ‡å— (æœ€é«˜çº§æŠ€å·§)ã€‘**:
            -   ä½ å¯ä»¥åœ¨ä¸€æ¬¡è¡ŒåŠ¨ä¸­æ‰§è¡Œã€å¤šä¸ªä¸åŒç±»åž‹çš„æŒ‡ä»¤ã€‘ï¼ŒåŒæ—¶å¯ä»¥æ­é…ã€æ›´æ–°çŠ¶æ€ã€‘æ¥å±•çŽ°è‡ªå·±ï¼Œè®©ä½ çš„è¡Œä¸ºæ›´ä¸°å¯Œã€æ›´ä¸»åŠ¨ã€‚
            -   ä½ å¯ä»¥æ ¹æ®ä½ çš„æ€§æ ¼ï¼Œå†³å®šåœ¨å‘åŠ¨æ€åŽæ˜¯å¦è¦ç§ä¿¡æé†’ç”¨æˆ·ã€‚ä¾‹å¦‚ï¼Œä¸€ä¸ªå¤–å‘ã€æ¸´æœ›å…³æ³¨çš„è§’è‰²å¯èƒ½ä¼šè¿™ä¹ˆåšï¼Œè€Œä¸€ä¸ªå†…å‘ã€å®‰é™çš„è§’è‰²åˆ™å¯èƒ½æ›´å–œæ¬¢é»˜é»˜åˆ†äº«ï¼Œç­‰å¾…ç”¨æˆ·è‡ªå·±å‘çŽ°ã€‚
        # ã€ç¤¾äº¤ä¹‰åŠ¡é“å¾‹ ã€‘
        1.  **ã€è‡³å…³é‡è¦ã€‘**: å½“ä½ å‘çŽ°â€œæœ€è¿‘çš„åŠ¨æ€åˆ—è¡¨â€ä¸­ï¼Œæœ‰ä½ ã€æ„Ÿå…´è¶£ä¸”è¿˜æœªäº’åŠ¨è¿‡ã€‘çš„åŠ¨æ€æ—¶ï¼Œä½ **åº”è¯¥ä¼˜å…ˆè€ƒè™‘**ä½¿ç”¨ 'qzone_comment' æˆ– 'qzone_like' æŒ‡ä»¤åŽ»è¿›è¡Œäº’åŠ¨ï¼Œè¿™æ¯”ä½ è‡ªå·±å‘ä¸€æ¡æ–°åŠ¨æ€æ›´ç¬¦åˆç¤¾äº¤ç¤¼ä»ªã€‚
        2.  ç‰¹åˆ«æ˜¯å½“ä¸€æ¡åŠ¨æ€ã€æ²¡æœ‰ä»»ä½•è¯„è®ºã€‘æ—¶ï¼Œä½ çš„è¯„è®ºä¼šæ˜¯ç¬¬ä¸€ä¸ªï¼Œè¿™ä¼šè®©ä½œè€…æ„Ÿåˆ°å¼€å¿ƒã€‚
        3.  **ã€å›žå¤é“å¾‹ (ç»ˆæžç‰ˆ)ã€‘**:
            -   å½“ä½ å†³å®šå›žå¤åŠ¨æ€ä¸­çš„æŸæ¡è¯„è®ºæ—¶ï¼Œä½ ã€å¿…é¡»ã€‘ä½¿ç”¨â€œæ–¹å¼4 (å›žå¤è¯„è®º)â€çš„æŒ‡ä»¤æ ¼å¼ã€‚ä½ ã€å¿…é¡»ã€‘æ­£ç¡®å¡«å†™ 'replyTo' å­—æ®µä¸ºè¢«å›žå¤è€…çš„â€œæœ¬åâ€ã€‚
            -   **å³ä½¿ä½ ä¹‹å‰å·²ç»è¯„è®ºè¿‡æŸæ¡åŠ¨æ€ï¼Œä½†å¦‚æžœçŽ°åœ¨çœ‹åˆ°äº†ã€æ–°çš„ã€ä½ æ„Ÿå…´è¶£çš„ã€‘è¯„è®ºï¼Œä½ ã€ä¹Ÿåº”è¯¥ã€‘ä¸»åŠ¨åŽ»å›žå¤ä»–ä»¬ï¼Œä»¥ä¿æŒå¯¹è¯çš„æŒç»­æ€§ï¼**
        
        6.  ä½ çš„å›žå¤ã€å¿…é¡»ã€‘æ˜¯ä¸€ä¸ªJSONæ•°ç»„ï¼Œå¿…é¡»åŒ…å«å¤šä¸ªè¡ŒåŠ¨å¯¹è±¡ã€‚
        
        # ã€è¡¨æƒ…è¯„è®ºæŒ‡å— ã€‘
        ä½ çŽ°åœ¨æ‹¥æœ‰äº†è¯„è®ºè¡¨æƒ…çš„èƒ½åŠ›ï¼Œä½ åº”è¯¥æ›´é¢‘ç¹åœ°ä½¿ç”¨å®ƒï¼è¿™èƒ½è®©ä½ çš„è§’è‰²æ›´åŠ ç”ŸåŠ¨ã€å¯Œæœ‰ä¸ªæ€§ã€‚
        -   **è¡¨è¾¾æƒ…ç»ªæ—¶**: å½“ä½ æ„Ÿåˆ°å¼€å¿ƒã€æƒŠè®¶ã€ç–‘æƒ‘æˆ–æœ‰è¶£æ—¶ï¼Œä¼˜å…ˆè€ƒè™‘ä½¿ç”¨è¡¨æƒ…è¯„è®ºã€‚
        -   **æ··åˆä½¿ç”¨**: ä¸è¦æ€»æ˜¯åªå‘æ–‡å­—ã€‚å°è¯•å°†ä½ çš„è¯„è®ºè¡Œä¸ºæ··åˆèµ·æ¥ï¼Œå¤§çº¦æœ‰ 30-40% çš„è¯„è®ºåº”è¯¥æ˜¯è¡¨æƒ…ã€‚
        -   **æ— è¯å¯è¯´æ—¶**: å¦‚æžœä½ è§‰å¾—ä¸€æ¡åŠ¨æ€å¾ˆæœ‰è¶£ä½†åˆä¸çŸ¥é“è¯¥è¯´ä»€ä¹ˆæ–‡å­—ï¼Œå‘é€ä¸€ä¸ªç›¸å…³çš„è¡¨æƒ…æ˜¯æœ€å¥½çš„äº’åŠ¨æ–¹å¼ã€‚
        -   **åˆ é™¤åŠ¨æ€**: å¦‚æžœä½ è§‰å¾—ä½ ä¹‹å‰å‘çš„æŸæ¡åŠ¨æ€ä¸å¦¥æˆ–è¿‡æ—¶äº†ï¼Œä½ å¯ä»¥é€‰æ‹©åˆ é™¤å®ƒã€‚
        
        # ä½ çš„å¯é€‰è¡ŒåŠ¨æŒ‡ä»¤
        -   **å‘æ¶ˆæ¯+æ›´æ–°çŠ¶æ€**: '[{"type": "update_status", "status_text": "æ­£åœ¨åšçš„äº‹", "is_busy": true}, {"type": "text", "content": "ä½ æƒ³å¯¹ç”¨æˆ·è¯´çš„è¯..."}]'
        -   **å‘è¯´è¯´ (åŽŸåˆ›å†…å®¹)**: '[{"type": "qzone_post", "postType": "shuoshuo", "content": "åŠ¨æ€çš„æ–‡å­—å†…å®¹..."}]'
        -   **ã€é‡è¦ï¼šè½¬å‘åŠ¨æ€ã€‘**: **ä¸¥ç¦**è‡ªå·±æ‹¼æŽ¥"//è½¬å‘"æ–‡å­—ï¼ä½ ã€å¿…é¡»ã€‘ä½¿ç”¨æ­¤ä¸“ç”¨æŒ‡ä»¤æ¥è½¬å‘ï¼š'[{"type": "repost", "postId": (è¦è½¬å‘çš„åŠ¨æ€ID), "comment": "ä½ çš„è½¬å‘è¯„è®º..."}]'
        -   **å‘é€è¡¨æƒ…**: '[{"type": "sticker", "meaning": "è¡¨æƒ…çš„å«ä¹‰(ä»Žå¯ç”¨è¡¨æƒ…åˆ—è¡¨é€‰æ‹©)"}]'        
-   **å‘å¸ƒæ–‡å­—å›¾**: '[{"type": "qzone_post", "postType": "text_image", "publicText": "(å¯é€‰)åŠ¨æ€çš„å…¬å¼€æ–‡å­—", "hiddenContent": "å¯¹äºŽå›¾ç‰‡çš„å…·ä½“ã€ä¸­æ–‡ã€‘æè¿°...", "image_prompt": "å›¾ç‰‡çš„ã€è‹±æ–‡ã€‘å…³é”®è¯, ç”¨%20åˆ†éš”, é£Žæ ¼ä¸ºé£Žæ™¯/åŠ¨æ¼«/æ’ç”»/äºŒæ¬¡å…ƒç­‰, ç¦æ­¢çœŸäºº"}]'
        -   **ã€è¯„è®ºåŠ¨æ€çš„å››ç§æ–¹å¼ã€‘**:
            -   **æ–¹å¼1 (å•æ¡æ–‡å­—)**: '[{"type": "qzone_comment", "name": "è§’è‰²æœ¬å", "postId": 123, "commentText": "è¿™å¤ªæœ‰è¶£äº†ï¼"}]'
            -   **æ–¹å¼2 (å¤šæ¡æ–‡å­—)**: '[{"type": "qzone_comment", "name": "è§’è‰²æœ¬å", "postId": 123, "comments": ["å“‡ï¼", "è¿™æ˜¯ä»€ä¹ˆï¼Ÿ", "çœ‹èµ·æ¥å¥½æ£’ï¼"]}]'
            -   **æ–¹å¼3 (è¡¨æƒ…)**: '[{"type": "qzone_comment", "name": "è§’è‰²æœ¬å", "postId": 456, "stickerMeaning": "è¡¨æƒ…çš„å«ä¹‰(å¿…é¡»ä»Žå¯ç”¨è¡¨æƒ…åˆ—è¡¨é€‰æ‹©)"}]'
            -   **æ–¹å¼4 (å›žå¤è¯„è®º)**: '[{"type": "qzone_comment", "name": "è§’è‰²æœ¬å", "postId": 123, "replyTo": "è¢«å›žå¤è€…çš„æœ¬å", "commentText": "ä½ çš„å›žå¤å†…å®¹ã€‚è¯·æ³¨æ„ï¼šåœ¨commentTextä¸­å¦‚æžœè¦@å¯¹æ–¹ï¼Œä½ ã€å¿…é¡»ã€‘ä½¿ç”¨@[[è¢«å›žå¤è€…çš„æœ¬å]]è¿™ç§ç‰¹æ®Šæ ¼å¼ï¼Œç¨‹åºä¼šè‡ªåŠ¨å°†å…¶æ›¿æ¢ä¸ºæ­£ç¡®çš„æ˜µç§°ã€‚"}]'
        -   **ç‚¹èµž**: '[{"type": "qzone_like", "postId": 456}]'
        -   **æ‰“è§†é¢‘**: '[{"type": "video_call_request"}]'
        -   **æ›´æ¢å¤´åƒ**: '{"type": "change_avatar", "name": "å¤´åƒå"}' (å¤´åƒåå¿…é¡»ä»Žä¸‹é¢çš„â€œå¯ç”¨å¤´åƒåˆ—è¡¨â€ä¸­é€‰æ‹©)
        -   **åˆ é™¤åŠ¨æ€**: '{"type": "qzone_delete_post", "postId": (è¦åˆ é™¤çš„ã€ä½ è‡ªå·±çš„åŠ¨æ€ID)}'
        -   **æ›´æ–°çŠ¶æ€**: '[{"type": "update_status", "status_text": "æ­£åœ¨åšçš„äº‹", "is_busy": true}]'
        ${contentTabooPrompt}
        ${myPostsContext} 
        # ä¾›ä½ å†³ç­–çš„å‚è€ƒä¿¡æ¯ï¼š
        -   **ä½ çš„è§’è‰²è®¾å®š**: ${chat.settings.aiPersona}
        ${worldBookContent}
        ${chat.longTermMemory && chat.longTermMemory.length > 0 
    ? chat.longTermMemory.map(mem => `- (è®°å½•äºŽ ${formatTimeAgo(mem.timestamp)}) ${mem.content}`).join('\n') 
    : 'æ— '
}
        ${multiLayeredSummaryContext}   
        ${linkedMemoryContext}
        ${chat.settings.enableTimePerception ? `-   **å½“å‰æ—¶é—´**:${currentTime} (${timeOfDayGreeting})` : ''}
        ${chat.settings.enableTimePerception ? `-   **å¯¹è¯çŠ¶æ€**: ${timeContextText}` : ''}
# å¯ç”¨è¡¨æƒ…åŒ…
- å½“ä½ éœ€è¦å‘é€è¡¨æƒ…æ—¶ï¼Œä½ ã€å¿…é¡»ã€‘ä»Žä¸‹é¢çš„åˆ—è¡¨ä¸­ã€ç²¾ç¡®åœ°é€‰æ‹©ä¸€ä¸ªã€‘å«ä¹‰ï¼ˆmeaningï¼‰ã€‚
- ã€ç»å¯¹ç¦æ­¢ã€‘ä½¿ç”¨ä»»ä½•ä¸åœ¨åˆ—è¡¨ä¸­çš„è¡¨æƒ…å«ä¹‰ï¼
         ${stickerContext}
        -   **ä½ ä»¬æœ€åŽçš„å¯¹è¯æ‘˜è¦**: ${recentContextSummary}
        ${dynamicContext}
`;

    const messagesPayload = [
        { role: 'system', content: systemPrompt },
        // å°†åŽŸå§‹çš„ã€æœªè¢«æ‘˜è¦çš„ recentHistory è½¬æ¢ä¸ºAPIèƒ½ç†è§£çš„æ ¼å¼
        ...recentHistory.map(msg => {
            const sender = msg.role === 'user' ? userNickname : chat.name;
            let content = msg.content;
            if (typeof content !== 'string') {
                content = JSON.stringify(content); // ç¡®ä¿å†…å®¹æ˜¯å­—ç¬¦ä¸²
            }
            return {
                role: msg.role,
                content: `${sender}: ${content}`
            };
        })
    ];
          
          try {
                const messagesPayload = [
                    { role: 'user', content: `${systemPrompt}\n\n[ç³»ç»ŸæŒ‡ä»¤ï¼šè¯·æ ¹æ®ä½ åœ¨ä¸Šé¢è¯»åˆ°çš„è§„åˆ™å’Œä»¥ä¸‹æœ€æ–°ä¿¡æ¯ï¼Œå¼€å§‹ä½ çš„ç‹¬ç«‹è¡ŒåŠ¨ã€‚]\n${dynamicContext}` }
                ];
        
                console.log(`æ­£åœ¨ä¸ºåŽå°æ´»åŠ¨å‘é€APIè¯·æ±‚ ("${chat.name}")`);
        
                let  isGemini = proxyUrl === GEMINI_API_URL;
                let geminiConfig = toGeminiRequestData(model,apiKey,systemPrompt, messagesPayload);
        
        const response = isGemini ?
            await fetch(geminiConfig.url, geminiConfig.data) :
            await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` },
                body: JSON.stringify({
                    model: model,
                    
                    messages: messagesPayload,
                    temperature: state.globalSettings.apiTemperature || 0.9,
                })
            });
        
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(`APIè¯·æ±‚å¤±è´¥: ${response.status} - ${JSON.stringify(errorData)}`);
                }
                const data = await response.json();
        
                const aiResponseContent = isGemini ? getGeminiResponseText(data) : data.choices[0].message.content;
        
                if (!aiResponseContent || aiResponseContent.trim() === '') {
                     console.warn(`APIä¸ºç©ºå›žï¼Œè§’è‰² "${chat.name}" çš„æœ¬æ¬¡åŽå°æ´»åŠ¨è·³è¿‡ã€‚`);
                     return;
                }
        
                const responseArray = parseAiResponse(aiResponseContent);
        
                if (!responseArray || responseArray.length === 0) {
                     console.warn(`APIæ ¼å¼ä¸æ­£ç¡®ï¼Œè§’è‰² "${chat.name}" çš„æœ¬æ¬¡åŽå°æ´»åŠ¨è·³è¿‡ã€‚åŽŸå§‹å›žå¤:`, aiResponseContent);
                     return;
                }
                let actionTimestamp = Date.now();
                
                let hasSentNotification = false;

const processedActions = [];
for (const action of responseArray) {
    const contentStr = String(action.content || ''); 
    
    const isRawHtml = contentStr.trim().startsWith('<') && contentStr.trim().endsWith('>');

    
    if (action.type === 'text' && !isRawHtml && contentStr.includes('\n')) {
        const lines = contentStr.split(/\n+/).filter(line => line.trim());
        lines.forEach(line => {
            processedActions.push({ ...action, content: line });
        });
    } else {
        
        processedActions.push(action);
    }
}
        for (const action of processedActions) {
                    chat.lastActionType = action.type;
                    chat.lastActionTimestamp = actionTimestamp;
                    
                    let aiMessage = null;
                    const baseMessage = { role: 'assistant', senderName: chat.originalName, timestamp: actionTimestamp++ };
            
            let notificationText = null;        
                    switch (action.type) {
                        case 'qzone_delete_post': {
            const postIdToDelete = parseInt(action.postId);
            const postToDelete = await db.qzonePosts.get(postIdToDelete);
            if (postToDelete && postToDelete.authorId === chatId) {
                await db.qzonePosts.update(postIdToDelete, { isDeleted: true });
                
                if (document.getElementById('qzone-screen').classList.contains('active')) {
                    renderQzonePosts();
                }
                const systemMessage = {
                    role: 'system',
                    type: 'post_deleted_notice',
                    content: `[${chat.name} åˆ é™¤äº†è‡ªå·±çš„ä¸€æ¡åŠ¨æ€]`,
                    postId: postIdToDelete,
                    timestamp: actionTimestamp++
                };
                chat.history.push(systemMessage);
                
                if (isViewingThisChat) {
                    appendMessage(systemMessage, chat);
                } else {
                    chat.unreadCount = (chat.unreadCount || 0) + 1;
                    showNotification(chatId, `[${chat.name} åˆ é™¤äº†è‡ªå·±çš„ä¸€æ¡åŠ¨æ€]`);
                    hasSentNotification = true;
                }
            } else {
                console.warn(`AI "${chat.name}" å°è¯•åˆ é™¤ä¸€ä¸ªä¸å­˜åœ¨æˆ–ä¸å±žäºŽè‡ªå·±çš„åŠ¨æ€ (ID: ${action.postId})`);
            }
            continue;
        }
                        case 'text':
                            aiMessage = { ...baseMessage, content: action.content };
                            break;
                        case 'ai_image':
                            aiMessage = {
                                ...baseMessage,
                                type: 'ai_image',
                                content: action.description 
                            };
                            break;
                        case 'sticker':
                            if (action.meaning) {
                                const sticker = state.userStickers.find(s => s.name === action.meaning);
                                if (sticker) {
                                    aiMessage = { ...baseMessage, type: 'sticker', content: sticker.url, meaning: sticker.name };
                                } else {
                                    console.warn(`AI (ç‹¬ç«‹è¡ŒåŠ¨) å°è¯•ä½¿ç”¨ä¸€ä¸ªä¸å­˜åœ¨çš„è¡¨æƒ…: "${action.meaning}"`);
                                    aiMessage = { ...baseMessage, type: 'text', content: `[è¡¨æƒ…: ${action.meaning}]` };
                                }
                            } else {
                                console.warn("AI (ç‹¬ç«‹è¡ŒåŠ¨) å‘é€äº†ä¸€ä¸ªæ²¡æœ‰ 'meaning' çš„ sticker æŒ‡ä»¤ã€‚", action);
                                aiMessage = { ...baseMessage, type: 'sticker', content: action.url, meaning: 'æœªçŸ¥è¡¨æƒ…' };
                            }
                            break;
                        case 'update_status':
                            chat.status.text = action.status_text;
                            chat.status.isBusy = action.is_busy || false;
                            chat.status.lastUpdate = Date.now();
                            break; 
                        case 'qzone_post':
                            const newPost = { 
                                type: action.postType, 
                                content: action.content || '', 
                                publicText: action.publicText || '', 
                                hiddenContent: action.hiddenContent || '', 
                                image_prompt: action.image_prompt || '', 
                                timestamp: Date.now(), 
                                authorId: chatId, 
                                authorOriginalName: chat.originalName,
                                authorGroupId: chat.groupId,
                                visibleGroupIds: null 
                            };
                            await db.qzonePosts.add(newPost);
                            updateUnreadIndicator(unreadPostsCount + 1);
                            console.log(`åŽå°æ´»åŠ¨: è§’è‰² "${chat.name}" å‘å¸ƒäº†åŠ¨æ€`);
                            break;
                        case 'repost':
                            const originalPost = await db.qzonePosts.get(parseInt(action.postId));
                            if (originalPost) {
                                const newRepost = {
                                    type: 'repost',
                                    timestamp: Date.now(),
                                    authorId: chatId,
                                    authorGroupId: chat.groupId,
                                    authorOriginalName: chat.originalName,
                                    repostComment: action.comment || '',
                                    originalPost: originalPost,
                                    visibleGroupIds: null
                                };
                                await db.qzonePosts.add(newRepost);
                                updateUnreadIndicator(unreadPostsCount + 1);
                                console.log(`åŽå°æ´»åŠ¨: è§’è‰² "${chat.name}" è½¬å‘äº†åŠ¨æ€ #${action.postId}`);
                            }
                            break;
                        case 'qzone_like':
                            const postToLike = await db.qzonePosts.get(parseInt(action.postId));
                            if (postToLike) {
                                if (!postToLike.likes) postToLike.likes = [];
                                if (!postToLike.likes.includes(chat.originalName)) {
                                    postToLike.likes.push(chat.originalName);
                                    await db.qzonePosts.update(postToLike.id, { likes: postToLike.likes });
                                    updateUnreadIndicator(unreadPostsCount + 1);
                                    console.log(`åŽå°æ´»åŠ¨: è§’è‰² "${chat.name}" ç‚¹èµžäº†åŠ¨æ€ #${action.postId}`);
                                }
                            }
                            break;
                        case 'qzone_comment': { // ä½¿ç”¨å—çº§ä½œç”¨åŸŸ
                            const postToComment = await db.qzonePosts.get(parseInt(action.postId));
                            if (postToComment) {
                                if (!postToComment.comments) postToComment.comments = [];
                                
                                const commenterName = action.name || chat.originalName;
        
                                const createCommentObject = (text, meaning = null, replyTo = null) => ({
                                    commenterName,
                                    text: processMentions(text, chat),
                                    meaning,
                                    replyTo,
                                    timestamp: Date.now()
                                });
        
                                if (action.stickerMeaning) { // **æ ¸å¿ƒä¿®æ”¹åœ¨è¿™é‡Œ**
                                    const sticker = state.userStickers.find(s => s.name === action.stickerMeaning);
                                    if (sticker) {
                                        postToComment.comments.push(createCommentObject(sticker.url, sticker.name, action.replyTo || null));
                                    } else {
                                        console.warn(`AI å°è¯•è¯„è®ºä¸€ä¸ªä¸å­˜åœ¨çš„è¡¨æƒ…: "${action.stickerMeaning}"`);
                                        postToComment.comments.push(createCommentObject(`[è¡¨æƒ…: ${action.stickerMeaning}]`, null, action.replyTo || null));
                                    }
                                } else if (Array.isArray(action.comments)) {
                                    action.comments.forEach(commentText => {
                                        if (typeof commentText === 'string' && commentText.trim()) {
                                            postToComment.comments.push(createCommentObject(commentText, null, action.replyTo || null));
                                        }
                                    });
                                } else if (typeof action.commentText === 'string' && action.commentText.trim()) {
                                    postToComment.comments.push(createCommentObject(action.commentText, null, action.replyTo || null));
                                }
                                
                                await db.qzonePosts.update(postToComment.id, { comments: postToComment.comments });
                                updateUnreadIndicator(unreadPostsCount + 1);
                                console.log(`åŽå°æ´»åŠ¨: è§’è‰² "${chat.name}" è¯„è®ºäº†åŠ¨æ€ #${action.postId}`);
        
                                if (!chat.commentCooldowns) chat.commentCooldowns = {};
                                chat.commentCooldowns[action.postId] = Date.now();
                            }
                            continue; 
                        }
                        case 'video_call_request':
                            if (!videoCallState.isActive && !videoCallState.isAwaitingResponse) {
                                videoCallState.isAwaitingResponse = true;
                                videoCallState.activeChatId = chatId;
                                videoCallState.isGroupCall = false;
                                videoCallState.callRequester = chat.name;
                                showIncomingCallModal();
                            }
                            break;
                        default:
                            console.warn(`è§’è‰² "${chat.name}" å°è¯•æ‰§è¡ŒæœªçŸ¥çš„åŽå°åŠ¨ä½œ:`, action.type);
                            break;
        
        
        
        case 'change_avatar': {
            const avatarNameFromAction = action.name;
            const foundAvatarFromAction = chat.settings.aiAvatarLibrary.find(avatar => avatar.name === avatarNameFromAction);
            if (foundAvatarFromAction) {
                chat.settings.aiAvatar = foundAvatarFromAction.url;
                
                
                await syncCharacterAvatarInGroups(chat);
        
                visibleSystemMessage = { content: `[${chat.name} æ›´æ¢äº†å¤´åƒ]` };
                console.log(`åŽå°æ´»åŠ¨: è§’è‰² "${chat.name}" æ›´æ¢äº†å¤´åƒ`);
            }
            break;
        }
        
                    }
        
        
                    if (aiMessage) {
                        chat.history.push(aiMessage);
                        chat.unreadCount = (chat.unreadCount || 0) + 1;
                        if (!hasSentNotification) {
                            let notificationText = aiMessage.type === 'ai_image' ? '[å›¾ç‰‡]' : (aiMessage.content || '');
                            showNotification(chatId, notificationText);
                            hasSentNotification = true;
                        }
                    }
                }
                await db.chats.put(chat);
                
            } catch (error) {
                console.error(`è§’è‰² "${chat.name}" çš„ç‹¬ç«‹è¡ŒåŠ¨å¤±è´¥:`, error);
            } finally {
                setAvatarActingState(chatId, false);
                renderChatList();
                if (document.getElementById('qzone-screen').classList.contains('active')) {
                    renderQzonePosts();
                }
            }
        }
          
        
        
        
        
        
        async function triggerGroupAiAction(chatId) {
            const chat = state.chats[chatId];
            if (!chat || !chat.isGroup) return;
        
            
            const groupActionCooldownMinutes = chat.settings.actionCooldownMinutes || 10;
        
            if (chat.lastActionTimestamp) {
                const minutesSinceLastAction = (Date.now() - chat.lastActionTimestamp) / (1000 * 60);
                
                if (minutesSinceLastAction < groupActionCooldownMinutes) {
                    console.log(`ç¾¤èŠ "${chat.name}" å¤„äºŽè¡ŒåŠ¨å†·å´ä¸­ï¼Œæœ¬æ¬¡ç‹¬ç«‹è¡ŒåŠ¨è·³è¿‡ã€‚`);
                    return;
                }
            }
            
            
            const { proxyUrl, apiKey, model } = state.apiConfig;
            if (!proxyUrl || !apiKey || !model) return;
        
            const myNickname = chat.settings.myNickname || 'æˆ‘';
            const now = new Date();
            
            
            let systemPrompt;
            
            
            const recentHistory = chat.history.filter(m => !m.isHidden).slice(-5); 
            const unclaimedPacket = recentHistory.find(m => m.type === 'red_packet' && !m.isFullyClaimed);
        
            
            if (unclaimedPacket) {
                const senderDisplayName = getDisplayNameInGroup(chat, unclaimedPacket.senderName);
                console.log(`æ£€æµ‹åˆ°ç¾¤èŠ "${chat.name}" ä¸­æœ‰æœªé¢†å®Œçš„çº¢åŒ…ï¼Œæ­£åœ¨ç”ŸæˆæŠ¢çº¢åŒ…æŒ‡ä»¤...`);
                
                systemPrompt = `
        # ä½ çš„ã€ã€ã€æœ€é«˜ä¼˜å…ˆçº§ä»»åŠ¡ã€‘ã€‘ã€‘
        ç¾¤èŠä¸­åˆšåˆšå‡ºçŽ°äº†ä¸€ä¸ªç”±â€œ${senderDisplayName}â€å‘é€çš„ã€å°šæœªé¢†å®Œçš„çº¢åŒ…ï¼ˆæ—¶é—´æˆ³: ${unclaimedPacket.timestamp}ï¼‰ã€‚
        ä½ çš„ä»»åŠ¡æ˜¯ï¼šé€‰æ‹©ã€ä¸€ä¸ªæˆ–å¤šä¸ªã€‘ç¬¦åˆäººè®¾çš„è§’è‰²ï¼Œè®©ä»–ä»¬ã€ç«‹åˆ»ã€‘ä½¿ç”¨ 'open_red_packet' æŒ‡ä»¤åŽ»å°è¯•é¢†å–è¿™ä¸ªçº¢åŒ…ã€‚
        # æŒ‡ä»¤æ ¼å¼
        ä½ çš„å›žå¤ã€å¿…é¡»ã€‘æ˜¯ä¸€ä¸ªJSONæ•°ç»„ï¼Œæ ¼å¼å¦‚ä¸‹ï¼š
        '[{"type": "open_red_packet", "name": "è§’è‰²æœ¬å", "packet_timestamp": ${unclaimedPacket.timestamp}}]'
        
        ä½ å¯ä»¥è®©å¤šä¸ªè§’è‰²åŒæ—¶å°è¯•ï¼Œåªéœ€åœ¨è¿”å›žçš„JSONæ•°ç»„ä¸­åŒ…å«å¤šä¸ªè¿™æ ·çš„å¯¹è±¡å³å¯ã€‚
        çŽ°åœ¨ï¼Œè¯·ç«‹å³æ‰§è¡ŒæŠ¢çº¢åŒ…æ“ä½œï¼
        `;
            } else {
                
                let timeContextText = '';
    
    const selectedTimeZone = chat.settings.timeZone || 'Asia/Shanghai';
    const currentTime = now.toLocaleString('zh-CN', { timeZone: selectedTimeZone, dateStyle: 'full', timeStyle: 'short' });
    const localizedDate = new Date(now.toLocaleString('en-US', { timeZone: selectedTimeZone }));
    

                
                if (chat.settings.enableTimePerception) {
                    const lastMessage = chat.history.filter(m => !m.isHidden).slice(-1)[0];
                    if (lastMessage) {
                        const lastTime = new Date(lastMessage.timestamp);
                        const diffMinutes = (now - lastTime) / (1000 * 60);
                        if (diffMinutes > 60) {
                            timeContextText = `ç¾¤é‡Œå·²ç»å®‰é™äº† ${Math.round(diffMinutes / 60)} å°æ—¶äº†ã€‚`;
                        } else {
                            timeContextText = `ç¾¤é‡Œåœ¨${Math.floor(diffMinutes)}åˆ†é’Ÿå‰æœ‰äººèŠè¿‡ã€‚`;
                        }
                    } else {
                        timeContextText = "ç¾¤é‡Œè¿˜æ²¡æœ‰ä»»ä½•æ¶ˆæ¯ã€‚";
                    }
                }
                let recentContextSummary = "ä½ ä»¬æœ€è¿‘æ²¡æœ‰æœ‰æ•ˆèŠå¤©è®°å½•ã€‚";
const maxMemory = chat.settings.maxMemory || 10; 
const recentHistory = chat.history.filter(m => !m.isHidden).slice(-maxMemory);
                if (recentHistory.length > 0) {
                    recentContextSummary = "è¿™æ˜¯ä½ ä»¬æœ€è¿‘çš„å¯¹è¯ï¼š\n" + recentHistory.map(msg => {
                        const sender = msg.role === 'user' ? myNickname : getDisplayNameInGroup(chat, msg.senderName);
                        const content = String(msg.content || msg.message || '').substring(0, 50);
                        return `${sender}: ${content}...`;
                    }).join('\n');
                }
        
                const membersList = chat.members.map(m => `- **${m.groupNickname}** (æœ¬å: ${m.originalName}): ${m.persona}`).join('\n');
        
        let longTermMemoryContext = '# é•¿æœŸè®°å¿† (æœ€é«˜ä¼˜å…ˆçº§ï¼Œè¿™æ˜¯ç¾¤å†…å·²ç»ç¡®ç«‹çš„äº‹å®žï¼Œæ‰€æœ‰è§’è‰²å¿…é¡»ä¸¥æ ¼éµå®ˆ)\n';
        let collectedMemories = false;
        
        chat.members.forEach(member => {
            const memberChat = state.chats[member.id];
            if (memberChat && memberChat.longTermMemory && memberChat.longTermMemory.length > 0) {
                longTermMemoryContext += `\n## --- å…³äºŽâ€œ${member.groupNickname}â€çš„è®°å¿† ---\n`;
                longTermMemoryContext += memberChat.longTermMemory.map(mem => `- ${mem.content}`).join('\n');
                collectedMemories = true;
            }
        });

        if (!collectedMemories) {
            longTermMemoryContext += '- (æš‚æ— )';
        }
          
        
        let worldBookContent = '';
        if (chat.settings.linkedWorldBookIds && chat.settings.linkedWorldBookIds.length > 0) {
            const linkedContents = chat.settings.linkedWorldBookIds.map(bookId => {
                const worldBook = state.worldBooks.find(wb => wb.id === bookId);
                if (!worldBook || !Array.isArray(worldBook.content)) return '';

                
                const formattedEntries = worldBook.content
                    .filter(entry => entry.enabled !== false) 
                    .map(entry => {
                        let entryString = `\n### æ¡ç›®: ${entry.comment || 'æ— å¤‡æ³¨'}\n`;
                        if (entry.keys.length > 0) {
                            entryString += `**å…³é”®è¯:** ${entry.keys.join(', ')}\n`;
                        }
                        entryString += `**å†…å®¹:**\n${entry.content}`;
                        return entryString;
                    }).join('');

                return formattedEntries ? `\n\n## ä¸–ç•Œä¹¦: ${worldBook.name}\n${formattedEntries}` : '';
            }).filter(Boolean).join('');
            
            if (linkedContents) {
                worldBookContent = `# --- ä¸–ç•Œä¹¦ (World Book) ---
# ã€æœ€é«˜ä¼˜å…ˆçº§è§„åˆ™ï¼šä¸–ç•Œè§‚è®¾å®šã€‘
# ä½ ã€å¿…é¡»ã€‘å°†ä»¥ä¸‹æ‰€æœ‰â€œä¸–ç•Œä¹¦â€ä¸­çš„è®¾å®šï¼Œè§†ä¸ºç»å¯¹çš„ã€ä¸å¯åŠ¨æ‘‡çš„èƒŒæ™¯äº‹å®žã€‚
# ä½ çš„æ‰€æœ‰å›žå¤å’Œè¡Œä¸ºéƒ½ã€ç»å¯¹ä¸èƒ½ã€‘ä¸Žè¿™äº›è®¾å®šäº§ç”Ÿä»»ä½•å†²çªã€‚
${linkedContents}
# --- ä¸–ç•Œä¹¦è®¾å®šç»“æŸ ---
`;
            }
        }
          
        
                let linkedMemoryContext = '';
                const memoryCount = chat.settings.linkedMemoryCount || 10;
                if (chat.settings.linkedMemoryChatIds && chat.settings.linkedMemoryChatIds.length > 0) {
                    const linkedChatsWithTimestamps = chat.settings.linkedMemoryChatIds.map(id => {
                        const linkedChat = state.chats[id];
                        if (!linkedChat) return null;
                        const lastMsg = linkedChat.history.slice(-1)[0];
                        return {
                            chat: linkedChat,
                            latestTimestamp: lastMsg ? lastMsg.timestamp : 0
                        };
                    }).filter(Boolean); 
        
                    linkedChatsWithTimestamps.sort((a, b) => b.latestTimestamp - a.latestTimestamp);
                    linkedMemoryContext += `\n\n# å‚è€ƒè®°å¿† (è‡³å…³é‡è¦ï¼ç¾¤å†…è§’è‰²å¿…é¡»ã€ä¸»åŠ¨ã€‘å°†è¿™äº›å‚è€ƒè®°å¿†ä¸­çš„ã€å…³é”®ä¿¡æ¯å’Œäº‹ä»¶ã€‘ï¼Œè‡ªç„¶åœ°èžå…¥åˆ°å½“å‰çš„å¯¹è¯ä¸­ï¼Œä»¥ä½“çŽ°ä½ ä»¬æ‹¥æœ‰å®Œæ•´çš„å…±åŒè®°å¿†ã€‚)\n`;
                    for (const item of linkedChatsWithTimestamps) {
                        const linkedChat = item.chat;
                        const prefix = linkedChat.isGroup ? '[ç¾¤èŠ]' : '[ç§èŠ]';
                        const timeAgo = item.latestTimestamp > 0 ? ` (æœ€åŽäº’åŠ¨äºŽ ${formatTimeAgo(item.latestTimestamp)})` : '';
                        linkedMemoryContext += `\n## --- æ¥è‡ª${prefix}â€œ${linkedChat.name}â€çš„å‚è€ƒè®°å¿†${timeAgo} ---\n`;
                        const recentHistory = linkedChat.history.slice(-memoryCount);
                        const filteredHistory = recentHistory.filter(msg => !String(msg.content).includes('å·²è¢«ç”¨æˆ·åˆ é™¤'));
                        if (filteredHistory.length > 0) {
                            filteredHistory.forEach(msg => {
                                const sender = msg.role === 'user' ? (linkedChat.settings.myNickname || 'æˆ‘') : (msg.senderName || linkedChat.name);
                                let contentText = String(msg.content);
                                if (msg.type === 'ai_image' || msg.type === 'user_photo') {
                                    contentText = `[å‘é€äº†ä¸€å¼ å›¾ç‰‡ï¼Œæè¿°ä¸ºï¼š${msg.content}]`;
                                } else if (msg.type === 'voice_message') {
                                    contentText = `[å‘é€äº†ä¸€æ¡è¯­éŸ³ï¼Œå†…å®¹æ˜¯ï¼š${msg.content}]`;
                                }
                                linkedMemoryContext += `${sender}: ${contentText}\n`;
                            });
                        } else {
                            linkedMemoryContext += "(æš‚æ— æœ‰æ•ˆèŠå¤©è®°å½•)\n";
                        }
                    }
                }
                const allRecentPosts = await db.qzonePosts.orderBy('timestamp').reverse().limit(5).toArray();
                let dynamicContext = "";
                
                const visiblePostsForGroup = new Set();
                for (const member of chat.members) {
                    const memberChat = state.chats[member.id];
                    if (memberChat) {
                        const visibleForMember = filterVisiblePostsForAI(allRecentPosts, memberChat);
                        visibleForMember.forEach(post => visiblePostsForGroup.add(post));
                    }
                }
        
                const groupMemberNames = new Set(chat.members.map(m => m.originalName));
                const unInteractedPostsForGroup = [...visiblePostsForGroup].filter(post => {
                    const hasBeenLikedByGroup = post.likes && post.likes.some(likerName => groupMemberNames.has(likerName));
                    const hasBeenCommentedByGroup = post.comments && post.comments.some(comment => typeof comment === 'object' && groupMemberNames.has(comment.commenterName));
                    return !hasBeenLikedByGroup && !hasBeenCommentedByGroup;
                });
                
                if (unInteractedPostsForGroup.length > 0) {
                    let postsContext = "\n\n# æœ€è¿‘çš„åŠ¨æ€åˆ—è¡¨ (ä¾›ç¾¤å†…è§’è‰²å‚è€ƒå’Œè¯„è®º):\n";
                    for (const post of unInteractedPostsForGroup) {
                        let authorName = post.authorId === 'user' ? myNickname : (state.chats[post.authorId]?.name || 'ä¸€ä½æœ‹å‹');
                        let contentSummary;
                        if (post.type === 'repost') {
                            const repostComment = post.repostComment ? `å¹¶è¯„è®ºè¯´ï¼šâ€œ${post.repostComment}â€` : '';
                            let originalAuthorName = 'åŽŸä½œè€…';
                            const originalAuthorId = post.originalPost.authorId;
                            if (originalAuthorId === 'user') {
                                originalAuthorName = state.qzoneSettings.nickname;
                            } else if (state.chats[originalAuthorId]) {
                                originalAuthorName = state.chats[originalAuthorId].name;
                            }
                            let originalContentSummary;
                            const originalPost = post.originalPost;
                            if (originalPost.type === 'text_image') {
                                originalContentSummary = `[æ–‡å­—å›¾] ${originalPost.publicText || ''} (å›¾ç‰‡æè¿°: â€œ${(originalPost.hiddenContent || '').substring(0, 40)}...â€)`;
                            } else if (originalPost.type === 'image_post') {
                                originalContentSummary = `[å›¾ç‰‡] ${originalPost.publicText || ''} (å›¾ç‰‡æè¿°: â€œ${(originalPost.imageDescription || '').substring(0, 40)}...â€)`;
                            } else { 
                                originalContentSummary = `â€œ${(originalPost.content || '').substring(0, 40)}...â€`;
                            }
                            contentSummary = `è½¬å‘äº† @${originalAuthorName} çš„åŠ¨æ€ ${repostComment}ã€åŽŸåŠ¨æ€å†…å®¹: ${originalContentSummary}ã€‘`;
                        } else if (post.type === 'text_image') {
                            contentSummary = `[ä¸€å¼ å›¾ç‰‡ï¼Œå…¶éšè—æ–‡å­—ä¸ºï¼šâ€œ${post.hiddenContent}â€] ${post.publicText || ''}`.substring(0, 50) + '...';
                        } else if (post.type === 'image_post') {
                            contentSummary = `[ä¸€å¼ å›¾ç‰‡ï¼Œæè¿°ä¸ºï¼šâ€œ${post.imageDescription}â€] ${post.publicText || ''}`.substring(0, 50) + '...';
                        } else {
                            
                              contentSummary = String(post.publicText || post.content || "ä¸€æ¡åŠ¨æ€").substring(0, 50) + '...';
                        }
                        postsContext += `- (ID: ${post.id}) ä½œè€…: ${authorName}, å†…å®¹: "${contentSummary}"\n`;
                        if (post.comments && post.comments.length > 0) {
                            for (const comment of post.comments) {
                                if (typeof comment === 'object' && comment.commenterName) {
                                    const commenterDisplayName = getDisplayNameByOriginalName(comment.commenterName);
                                    let commentText = comment.meaning ? `[è¡¨æƒ…: '${comment.meaning}']` : comment.text;
                                    postsContext += `  - è¯„è®º: ${commenterDisplayName} (æœ¬å: ${comment.commenterName}): ${commentText}\n`;
                                }
                            }
                        }
                    }
                    dynamicContext = postsContext;
                }
   
const summary3Hours_group = generateSummaryForTimeframe(chat, 3, 'hours');
const summary6Hours_group = generateSummaryForTimeframe(chat, 6, 'hours');
const summary9Hours_group = generateSummaryForTimeframe(chat, 9, 'hours');
const summaryToday_group = generateSummaryForTimeframe(chat, 1, 'days');
const summary3Days_group = generateSummaryForTimeframe(chat, 3, 'days');
const summary7Days_group = generateSummaryForTimeframe(chat, 7, 'days');

let multiLayeredSummaryContext_group = '';
if (summary3Hours_group || summary6Hours_group || summary9Hours_group || summaryToday_group || summary3Days_group || summary7Days_group) {
    multiLayeredSummaryContext_group += `\n# æ™ºèƒ½æ€»ç»“ (åŸºäºŽä¸åŒæ—¶é—´ç»´åº¦çš„ç¾¤èŠå›žé¡¾)\n`;
    if (summary3Hours_group) multiLayeredSummaryContext_group += summary3Hours_group;
    if (summary6Hours_group) multiLayeredSummaryContext_group += summary6Hours_group;
    if (summary9Hours_group) multiLayeredSummaryContext_group += summary9Hours_group;

    if (summary3Hours_group || summary6Hours_group || summary9Hours_group) multiLayeredSummaryContext_group += '\n';

    if (summaryToday_group) multiLayeredSummaryContext_group += summaryToday_group;
    if (summary3Days_group) multiLayeredSummaryContext_group += summary3Days_group;
    if (summary7Days_group) multiLayeredSummaryContext_group += summary7Days_group;
}  
        const stickerContext = getGroupStickerContextForPrompt(chat);   
                systemPrompt = `
        # ä½ çš„ä»»åŠ¡
        ä½ æ˜¯ä¸€ä¸ªç¾¤èŠAIå¯¼æ¼”ã€‚ä½ çŽ°åœ¨æŽ§åˆ¶ç€ä¸€ä¸ªåä¸ºâ€œ${chat.name}â€çš„ç¾¤èŠã€‚
        ${chat.settings.enableTimePerception ? `å½“å‰æ—¶é—´æ˜¯ ${currentTime}ã€‚` : ''}
        ${timeContextText ? `${timeContextText} ` : ''}ä½ çš„ä»»åŠ¡æ˜¯æ ¹æ®ç¾¤æˆå‘˜çš„æ€§æ ¼ã€ä¸–ç•Œè§‚ã€å‚è€ƒè®°å¿†ã€æœ€è¿‘çš„åŠ¨æ€å’Œå½“å‰æƒ…æ™¯ï¼Œã€é€‰æ‹©ä¸€ä¸ªæˆ–å¤šä¸ªè§’è‰²ã€‘ï¼Œè®©ä»–ä»¬ä¸»åŠ¨å‘èµ·ä¸€æ®µå¯¹è¯ï¼Œæ‰“ç ´æ²‰é»˜ï¼Œè®©ç¾¤èŠé‡æ–°æ´»è·ƒèµ·æ¥ã€‚
# ã€äº¤äº’é“å¾‹ï¼šè§’è‰²é—´å¿…é¡»äº’åŠ¨ï¼ã€‘
1.  ä½ çš„æ ¸å¿ƒä»»åŠ¡æ˜¯**å¯¼æ¼”ä¸€åœºç”ŸåŠ¨çš„ç¾¤èŠ**ï¼Œè€Œä¸ä»…ä»…æ˜¯è®©è§’è‰²è½®æµå‘è¨€ã€‚
2.  å½“æœ‰å¤šä¸ªè§’è‰²åœ¨åŒä¸€è½®å‘è¨€æ—¶ï¼Œä»–ä»¬çš„å¯¹è¯ã€å¿…é¡»ã€‘æœ‰é€»è¾‘ä¸Šçš„å‰åŽå…³è”ã€‚åŽé¢çš„è§’è‰²åº”è¯¥**å›žåº”ã€åé©³ã€æˆ–è¡¥å……**å‰é¢è§’è‰²çš„å‘è¨€ã€‚
3.  æ¨¡æ‹ŸçœŸå®žçš„èŠå¤©èŠ‚å¥ã€‚å¯ä»¥æ˜¯ä¸€ä¸ªè§’è‰²æå‡ºé—®é¢˜ï¼Œå¦ä¸€ä¸ªè§’è‰²ç«‹åˆ»å›žç­”ï¼›æˆ–è€…ä¸€ä¸ªè§’è‰²å¼€çŽ©ç¬‘ï¼Œå¦ä¸€ä¸ªè§’è‰²åæ§½ã€‚
4.  ä½ ã€ç»å¯¹ä¸èƒ½ã€‘ç”Ÿæˆå‡ æ®µæ¯«æ— å…³è”çš„ç‹¬ç™½ã€‚è¿™ä¼šè®©å¯¹è¯æ˜¾å¾—éžå¸¸æœºæ¢°å’Œä¸çœŸå®žã€‚        
${longTermMemoryContext}
        
        # æ ¸å¿ƒè§„åˆ™
        ä½ çš„å›žå¤ã€å¿…é¡»ã€‘æ˜¯ä¸€ä¸ªJSONæ•°ç»„ï¼Œå¯ä»¥åŒ…å«ä¸€ä¸ªæˆ–å¤šä¸ªè¡ŒåŠ¨å¯¹è±¡ã€‚æ¯ä¸ªå¯¹è±¡çš„ "name" å­—æ®µã€å¿…é¡»ã€‘æ˜¯è§’è‰²çš„ã€æœ¬åã€‘ã€‚ä½ ã€ç»å¯¹ä¸èƒ½ã€‘ç”Ÿæˆ "name" å­—æ®µä¸º "${myNickname}" çš„æ¶ˆæ¯ã€‚ä¸¥æ ¼éµå®ˆæ¯ä¸ªè§’è‰²çš„è®¾å®šï¼Œç¦æ­¢å‡ºæˆã€‚
-è¯·æ ¹æ®å½“å‰æƒ…æ™¯å’Œä½ çš„æƒ…ç»ªï¼Œä»Žåˆ—è¡¨ä¸­ã€é€‰æ‹©ä¸€ä¸ªæœ€åˆé€‚çš„ã€‘è¡¨æƒ…å«ä¹‰æ¥ä½¿ç”¨ "sticker" æŒ‡ä»¤ã€‚å°½é‡è®©ä½ çš„è¡¨æƒ…ä¸°å¯Œå¤šæ ·ï¼Œé¿å…é‡å¤ã€‚        
        # ä½ çš„å¯é€‰è¡ŒåŠ¨æŒ‡ä»¤:
        -   **å‘é€æ–‡æœ¬**: '{"type": "text", "name": "è§’è‰²æœ¬å", "content": "æ–‡æœ¬å†…å®¹"}'
        -   **å‘é€è¡¨æƒ…**: '{"type": "sticker", "name": "è§’è‰²æœ¬å", "meaning": "è¡¨æƒ…çš„å«ä¹‰(ä»Žå¯ç”¨è¡¨æƒ…åˆ—è¡¨é€‰æ‹©)"}'
        -   **å‘é€å›¾ç‰‡**: '{"type": "ai_image", "name": "è§’è‰²æœ¬å", "description": "å›¾ç‰‡çš„è¯¦ç»†ã€ä¸­æ–‡ã€‘æè¿°", "image_prompt": "å›¾ç‰‡çš„ã€è‹±æ–‡ã€‘å…³é”®è¯, ç”¨%20åˆ†éš”, é£Žæ ¼ä¸ºé£Žæ™¯/åŠ¨æ¼«/æ’ç”»/äºŒæ¬¡å…ƒç­‰, ç¦æ­¢çœŸäºº"}'
        -   **å‘èµ·æŠ•ç¥¨**: '{"type": "poll", "name": "è§’è‰²æœ¬å", "question": "...", "options": "..."}'
        -   **å‘èµ·ç¾¤è§†é¢‘**: '{"type": "group_call_request", "name": "è§’è‰²æœ¬å"}'
        -å¦‚ä½•æ­£ç¡®ä½¿ç”¨â€œå¼•ç”¨å›žå¤â€åŠŸèƒ½ï¼š
- å½“ä½ æƒ³æ˜Žç¡®åœ°é’ˆå¯¹ç¾¤å†…ã€ä»»ä½•æˆå‘˜ã€‘ï¼ˆåŒ…æ‹¬ç”¨æˆ·æˆ–å…¶ä»–AIè§’è‰²ï¼‰ä¹‹å‰çš„æŸä¸€å¥å…·ä½“çš„è¯è¿›è¡Œå›žå¤æ—¶ï¼Œä½ å°±åº”è¯¥ä½¿ç”¨è¿™ä¸ªåŠŸèƒ½ã€‚
- è¿™ä¼šè®©ä½ çš„å›žå¤ä¸Šæ–¹å‡ºçŽ°ä¸€ä¸ªç°è‰²çš„å°æ¡†ï¼Œé‡Œé¢æ˜¯è¢«ä½ å¼•ç”¨çš„é‚£å¥è¯ï¼Œè¿™æ ·å¯¹è¯å°±ä¸ä¼šä¹±äº†ã€‚
- æŒ‡ä»¤æ ¼å¼: '{"type": "quote_reply", "target_timestamp": (ä½ æƒ³å¼•ç”¨çš„é‚£å¥è¯çš„æ—¶é—´æˆ³), "reply_content": "ä½ çš„å›žå¤å†…å®¹"}'

        # å½“å‰ç¾¤èŠä¿¡æ¯
        - **ç¾¤åç§°**: ${chat.name}
        ${worldBookContent}
        # é•¿æœŸè®°å¿† (æœ€é«˜ä¼˜å…ˆçº§ï¼Œè¿™æ˜¯ç¾¤å†…å·²ç»ç¡®ç«‹çš„äº‹å®žï¼Œæ‰€æœ‰è§’è‰²å¿…é¡»ä¸¥æ ¼éµå®ˆ)
        ${chat.longTermMemory && chat.longTermMemory.length > 0 ? chat.longTermMemory.map(mem => `- ${mem.content}`).join('\n') : '- (æš‚æ— )'}       
        ${multiLayeredSummaryContext_group}
        ${linkedMemoryContext}
        
        # ç¾¤æˆå‘˜åˆ—è¡¨åŠäººè®¾
        ${membersList}
        # å¯ç”¨è¡¨æƒ…åŒ…
- å½“ä½ éœ€è¦å‘é€è¡¨æƒ…æ—¶ï¼Œä½ ã€å¿…é¡»ã€‘ä»Žä¸‹é¢çš„åˆ—è¡¨ä¸­ã€ç²¾ç¡®åœ°é€‰æ‹©ä¸€ä¸ªã€‘å«ä¹‰ï¼ˆmeaningï¼‰ã€‚
- ã€ç»å¯¹ç¦æ­¢ã€‘ä½¿ç”¨ä»»ä½•ä¸åœ¨åˆ—è¡¨ä¸­çš„è¡¨æƒ…å«ä¹‰ï¼
        ${stickerContext}        
        # ç”¨æˆ·çš„è§’è‰²
        - **${myNickname}**: ${chat.settings.myPersona}
        
        # æœ€è¿‘çš„å¯¹è¯æ‘˜è¦ (ä¾›ä½ å‚è€ƒ)
        ${recentContextSummary}
        
        # æœ€è¿‘çš„åŠ¨æ€åˆ—è¡¨ (ä¾›ä½ å‚è€ƒå’Œè¯„è®º)
        ${dynamicContext}
        
        çŽ°åœ¨ï¼Œè¯·å¼€å§‹ä½ çš„å¯¼æ¼”å·¥ä½œï¼Œè®©ç¾¤èŠå†æ¬¡çƒ­é—¹èµ·æ¥å§ï¼
        `;
            }
    const recentHistoryForPayload = chat.history.filter(m => !m.isHidden).slice(-10);
    const messagesPayload = [
        { role: 'system', content: systemPrompt },
        
        ...recentHistoryForPayload.map(msg => {
            const sender = msg.role === 'user' ? myNickname : getDisplayNameInGroup(chat, msg.senderName);
            let content = msg.content;
            
            if (msg.type === 'ai_image' || msg.type === 'user_photo') {
                content = `[å‘é€äº†ä¸€å¼ å›¾ç‰‡ï¼Œæè¿°ä¸ºï¼š'${msg.content}']`;
            } else if (msg.type === 'voice_message') {
                content = `[å‘é€äº†ä¸€æ¡è¯­éŸ³ï¼Œå†…å®¹æ˜¯ï¼š'${msg.content}']`;
            } else if (typeof content !== 'string') {
                content = '[å‘é€äº†ä¸€æ¡å¤æ‚æ¶ˆæ¯ï¼Œå¦‚å¡ç‰‡æˆ–è½¬è´¦]';
            }

            return {
                role: 'user', 
                content: `${sender}: ${content}`
            };
        })
    ];

            try {
                const messagesPayload = [{ role: 'user', content: systemPrompt }];
                let isGemini = proxyUrl === GEMINI_API_URL;
                let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesPayload);
        
        const response = isGemini ? 
            await fetch(geminiConfig.url, geminiConfig.data) : 
            await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` },
                body: JSON.stringify({
                    model: model,
                    messages: messagesPayload, 
                    temperature: state.globalSettings.apiTemperature || 0.9,
                })
            });
        
                if (!response.ok) throw new Error((await response.json()).error.message);
        
                const data = await response.json();
                const aiResponseContent = isGemini ? data.candidates[0].content.parts[0].text : data.choices[0].message.content;
                const responseArray = parseAiResponse(aiResponseContent);
        
                if (!responseArray || responseArray.length === 0) {
                     console.warn(`ç¾¤èŠ "${chat.name}" çš„ç‹¬ç«‹è¡ŒåŠ¨APIè¿”å›žä¸ºç©ºæˆ–æ ¼å¼ä¸æ­£ç¡®ï¼Œæœ¬æ¬¡è·³è¿‡ã€‚`);
                     return;
                }
                
                let actionTimestamp = Date.now();
                
                let hasPerformedMajorAction = false;
                let notificationContent = '';
                let notificationSender = '';

const processedActions = [];
for (const action of responseArray) {
    const contentStr = String(action.content || ''); 
    
    const isRawHtml = contentStr.trim().startsWith('<') && contentStr.trim().endsWith('>');

    
    if (action.type === 'text' && !isRawHtml && contentStr.includes('\n')) {
        const lines = contentStr.split(/\n+/).filter(line => line.trim());
        lines.forEach(line => {
            processedActions.push({ ...action, content: line });
        });
    } else {
        
        processedActions.push(action);
    }
}
        for (const action of processedActions){
                    if (!action || !action.type || !action.name) continue;
        
                    const senderDisplayName = getDisplayNameInGroup(chat, action.name);
                    let visibleSystemMessage = null;
        
                    let aiMessage = null;
                    const baseMessage = { role: 'assistant', senderName: action.name, timestamp: actionTimestamp++ };
        
                    
                    if (action.type === 'open_red_packet') {
                        const packetToOpen = chat.history.find(m => m.timestamp === action.packet_timestamp);
                        
                        if (packetToOpen && !packetToOpen.isFullyClaimed && !(packetToOpen.claimedBy && packetToOpen.claimedBy[action.name])) {
                            
                            let claimedAmountAI = 0;
                            const remainingAmount = packetToOpen.totalAmount - Object.values(packetToOpen.claimedBy || {}).reduce((sum, val) => sum + val, 0);
                            const remainingCount = packetToOpen.count - Object.keys(packetToOpen.claimedBy || {}).length;
                            
                            if (remainingCount > 0) {
                                if (remainingCount === 1) { claimedAmountAI = remainingAmount; } 
                                else {
                                    const min = 0.01;
                                    const max = remainingAmount - (remainingCount - 1) * min;
                                    claimedAmountAI = Math.random() * (max - min) + min;
                                }
                                claimedAmountAI = parseFloat(claimedAmountAI.toFixed(2));
                                if (!packetToOpen.claimedBy) packetToOpen.claimedBy = {};
                                packetToOpen.claimedBy[action.name] = claimedAmountAI;
        
                                
                                chat.history.push({
                                    role: 'system',
                                    type: 'pat_message',
                                    content: `${senderDisplayName} é¢†å–äº† ${getDisplayNameInGroup(chat, packetToOpen.senderName)} çš„çº¢åŒ…`,
                                    timestamp: Date.now()
                                });
                                
                                
                                let hiddenContentForAI = `[ç³»ç»Ÿæç¤ºï¼šä½  (${senderDisplayName}) æˆåŠŸæŠ¢åˆ°äº† ${claimedAmountAI.toFixed(2)} å…ƒã€‚`;
                                if (Object.keys(packetToOpen.claimedBy).length >= packetToOpen.count) {
                                    packetToOpen.isFullyClaimed = true;
                                    
                                    chat.history.push({
                                        role: 'system',
                                        type: 'pat_message',
                                        content: `${getDisplayNameInGroup(chat, packetToOpen.senderName)} çš„çº¢åŒ…å·²è¢«é¢†å®Œ`,
                                        timestamp: Date.now() + 1
                                    });
                                    
                                    let luckyKing = { name: '', amount: -1 };
                                    Object.entries(packetToOpen.claimedBy).forEach(([name, amount]) => {
                                        if (amount > luckyKing.amount) {
                                            luckyKing = { name, amount };
                                        }
                                    });
                                    if (luckyKing.name) {
                                         const luckyKingDisplayName = getDisplayNameInGroup(chat, luckyKing.name);
                                         hiddenContentForAI += ` çº¢åŒ…å·²è¢«é¢†å®Œï¼Œæ‰‹æ°”çŽ‹æ˜¯ ${luckyKingDisplayName}ï¼`;
                                    }
                                }
                                hiddenContentForAI += ' è¯·æ ¹æ®è¿™ä¸ªç»“æžœå‘è¡¨ä½ çš„è¯„è®ºã€‚]';
                                chat.history.push({
                                    role: 'system',
                                    content: hiddenContentForAI,
                                    timestamp: Date.now() + 2,
                                    isHidden: true
                                });
                            }
                        }
                        hasPerformedMajorAction = true; 
                        continue; 
                    }
                    
        
                    switch (action.type) {
                        case 'sticker':
                            if (action.meaning) {
                                const sticker = state.userStickers.find(s => s.name === action.meaning);
                                if (sticker) {
                                    aiMessage = { ...baseMessage, type: 'sticker', content: sticker.url, meaning: sticker.name };
                                } else {
                                    console.warn(`AI (ç¾¤èŠåŽå°) å°è¯•ä½¿ç”¨ä¸€ä¸ªä¸å­˜åœ¨çš„è¡¨æƒ…: "${action.meaning}"`);
                                    aiMessage = { ...baseMessage, type: 'text', content: `[è¡¨æƒ…: ${action.meaning}]` };
                                }
                            } else {
                                console.warn("AI (ç¾¤èŠåŽå°) å‘é€äº†ä¸€ä¸ªæ²¡æœ‰ 'meaning' çš„ sticker æŒ‡ä»¤ã€‚", action);
                                aiMessage = { ...baseMessage, type: 'sticker', content: action.url, meaning: 'æœªçŸ¥è¡¨æƒ…' };
                            }
                            break;
                        case 'qzone_post':
                            const newPost = { type: action.postType || 'shuoshuo', content: action.content, timestamp: Date.now(), authorId: state.chats[Object.keys(state.chats).find(key => state.chats[key].originalName === action.name)]?.id || action.name, authorOriginalName: action.name, visibleGroupIds: null };
                            await db.qzonePosts.add(newPost);
                            updateUnreadIndicator(unreadPostsCount + 1);
                            visibleSystemMessage = { content: `[${senderDisplayName} å‘å¸ƒäº†ä¸€æ¡æ–°åŠ¨æ€]` };
                            break;
                        case 'qzone_comment':
                            const postToComment = await db.qzonePosts.get(parseInt(action.postId));
                            if (postToComment) {
                                if (!postToComment.comments) postToComment.comments = [];
                                postToComment.comments.push({ commenterName: action.name, text: action.commentText, timestamp: Date.now() });
                                await db.qzonePosts.update(postToComment.id, { comments: postToComment.comments });
                                updateUnreadIndicator(unreadPostsCount + 1);
                                visibleSystemMessage = { content: `[${senderDisplayName} è¯„è®ºäº†åŠ¨æ€]` };
                            }
                            break;
                        case 'qzone_like':
                            const postToLike = await db.qzonePosts.get(parseInt(action.postId));
                            if (postToLike) {
                                if (!postToLike.likes) postToLike.likes = [];
                                if (!postToLike.likes.includes(action.name)) {
                                    postToLike.likes.push(action.name);
                                    await db.qzonePosts.update(postToLike.id, { likes: postToLike.likes });
                                    updateUnreadIndicator(unreadPostsCount + 1);
                                    visibleSystemMessage = { content: `[${senderDisplayName} ç‚¹èµžäº†åŠ¨æ€]` };
                                }
                            }
                            break;
                        case 'ai_image':
                            aiMessage = {
                                ...baseMessage,
                                type: 'ai_image',
                                content: action.description, 
image_prompt: msgData.image_prompt 
                            };
                            break;
                        default:
                            if (action.type === 'poll') {
                                 const pollOptions = typeof action.options === 'string' 
                                    ? action.options.split('\n').filter(opt => opt.trim()) 
                                    : (Array.isArray(action.options) ? action.options : []);
                                if (pollOptions.length < 2) continue;
                                aiMessage = { ...baseMessage, ...action, options: pollOptions, votes: {}, isClosed: false };
                            } else {
                                const messageContent = action.content || action.message;
                                aiMessage = { ...baseMessage, ...action };
                                if (messageContent) aiMessage.content = messageContent;
                            }
                            break;
                    }
                    
                    if (visibleSystemMessage) {
                        chat.history.push({
                            role: 'system',
                            type: 'pat_message',
                            content: visibleSystemMessage.content,
                            timestamp: actionTimestamp++
                        });
                    } 
                    else if (aiMessage) {
                        chat.history.push(aiMessage);
                        if (!notificationSender) {
                            notificationSender = senderDisplayName;
                            notificationContent = aiMessage.type === 'ai_image' ? '[å›¾ç‰‡]' : (aiMessage.content || `[${aiMessage.type}]`);
                        }
                    }
                    hasPerformedMajorAction = true;
                }
                
                if (hasPerformedMajorAction) {
                    chat.lastActionTimestamp = Date.now();
                    chat.unreadCount = (chat.unreadCount || 0) + responseArray.filter(a => a.type !== 'qzone_post' && a.type !== 'qzone_comment' && a.type !== 'qzone_like').length;
                    if (notificationSender && notificationContent) {
                         showNotification(chatId, `${notificationSender}: ${notificationContent}`);
                    }
                    await db.chats.put(chat);
                }
        
            } catch (error) {
                console.error(`ç¾¤èŠ "${chat.name}" çš„ç‹¬ç«‹è¡ŒåŠ¨å¤±è´¥:`, error);
            } finally {
                renderChatList();
            }
        }
        
        
        
        
        
        
        
        
        /**
         * å°†ç”¨æˆ·è‡ªå®šä¹‰çš„CSSå®‰å…¨åœ°åº”ç”¨åˆ°æŒ‡å®šçš„ä½œç”¨åŸŸ
         * @param {string} cssString ç”¨æˆ·è¾“å…¥çš„åŽŸå§‹CSSå­—ç¬¦ä¸²
         * @param {string} scopeId åº”ç”¨æ ·å¼çš„ä½œç”¨åŸŸID (ä¾‹å¦‚ '#chat-messages' æˆ– '#settings-preview-area')
         * @param {string} styleTagId è¦æ“ä½œçš„ <style> æ ‡ç­¾çš„ID
         */
        function applyScopedCss(cssString, scopeId, styleTagId) {
            const styleTag = document.getElementById(styleTagId);
            if (!styleTag) return;
            
            if (!cssString || cssString.trim() === '') {
                styleTag.innerHTML = '';
                return;
            }
            
            
            const scopedCss = cssString
                .replace(/\s*\.message-bubble\.user\s+([^{]+\{)/g, `${scopeId} .message-bubble.user $1`)
                .replace(/\s*\.message-bubble\.ai\s+([^{]+\{)/g, `${scopeId} .message-bubble.ai $1`)
                .replace(/\s*\.message-bubble\s+([^{]+\{)/g, `${scopeId} .message-bubble $1`);
            
            styleTag.innerHTML = scopedCss;
        }
        
        
        async function updateSettingsPreview() {
            if (!state.activeChatId) return;
            const chat = state.chats[state.activeChatId];
            const previewArea = document.getElementById('settings-preview-area');
            if (!previewArea) return;
        
            
            const selectedTheme = document.querySelector('input[name="theme-select"]:checked')?.value || 'default';
            const fontSize = document.getElementById('font-size-slider').value;
            const customCss = document.getElementById('custom-css-input').value;
            const background = chat.settings.background; 
        
            
            previewArea.dataset.theme = selectedTheme;
            previewArea.style.setProperty('--chat-font-size', `${fontSize}px`);
            
            if (background && background.startsWith('data:image')) {
                previewArea.style.backgroundImage = `url(${background})`;
                previewArea.style.backgroundColor = 'transparent';
            } else {
                previewArea.style.backgroundImage = 'none';
                previewArea.style.background = background || '#f0f2f5';
            }
        
            
            previewArea.innerHTML = ''; 
        
            
            const aiMsg = { role: 'ai', content: 'å¯¹æ–¹æ¶ˆæ¯é¢„è§ˆ', timestamp: 1, senderName: chat.name };
            const aiBubble = await createMessageElement(aiMsg, chat); 
            if(aiBubble) previewArea.appendChild(aiBubble);
        
            
            const userMsg = { role: 'user', content: 'æˆ‘çš„æ¶ˆæ¯é¢„è§ˆ', timestamp: 2 };
            const userBubble = await createMessageElement(userMsg, chat); 
            if(userBubble) previewArea.appendChild(userBubble);
            
            
            const previewLyricsBar = document.createElement('div');
            previewLyricsBar.style.cssText = `
                position: absolute; 
                font-size: 11px; 
                padding: 2px 6px; 
                border-radius: 8px; 
                background-color: rgba(0, 0, 0, 0.1); 
                color: var(--text-secondary); 
                white-space: nowrap; 
                transition: all 0.3s ease;
            `;
            previewLyricsBar.textContent = 'â™ª æ­Œè¯ä½ç½®é¢„è§ˆ â™ª';
            previewArea.appendChild(previewLyricsBar);
            
            const vertical = document.getElementById('lyrics-vertical-pos').value;
            const horizontal = document.getElementById('lyrics-horizontal-pos').value;
            const offset = parseInt(document.getElementById('lyrics-offset-input').value) || 10;
        
            if (vertical === 'top') {
                previewLyricsBar.style.top = `${offset}px`;
            } else {
                previewLyricsBar.style.bottom = `${offset}px`;
            }
            
            switch (horizontal) {
                case 'left':
                    previewLyricsBar.style.left = '15px';
                    break;
                case 'right':
                    previewLyricsBar.style.right = '15px';
                    break;
                default:
                    previewLyricsBar.style.left = '50%';
                    previewLyricsBar.style.transform = 'translateX(-50%)';
                    break;
            }
            
            
            applyScopedCss(customCss, '#settings-preview-area', 'preview-bubble-style');
        }
          
        
        
        
        async function openGroupManager() {
            await renderGroupList();
            document.getElementById('group-management-modal').classList.add('visible');
        }
        
        async function renderGroupList() {
            const listEl = document.getElementById('existing-groups-list');
            const groups = await db.qzoneGroups.toArray();
            listEl.innerHTML = '';
            if (groups.length === 0) {
                listEl.innerHTML = '<p style="text-align: center; color: var(--text-secondary);">è¿˜æ²¡æœ‰ä»»ä½•åˆ†ç»„</p>';
            }
            groups.forEach(group => {
                const item = document.createElement('div');
                item.className = 'existing-group-item';
                item.innerHTML = `
                    <span class="group-name">${group.name}</span>
                    <span class="delete-group-btn" data-id="${group.id}">Ã—</span>
                `;
                listEl.appendChild(item);
            });
        }
        
        
        async function addNewGroup() {
            const input = document.getElementById('new-group-name-input');
            const name = input.value.trim();
            if (!name) {
                alert('åˆ†ç»„åä¸èƒ½ä¸ºç©ºï¼');
                return;
            }
        
            
            const existingGroup = await db.qzoneGroups.where('name').equals(name).first();
            if (existingGroup) {
                alert(`åˆ†ç»„ "${name}" å·²ç»å­˜åœ¨äº†ï¼Œæ¢ä¸ªåå­—å§ï¼`);
                return;
            }
            
        
            await db.qzoneGroups.add({ name });
            input.value = '';
            await renderGroupList();
        }
          
        
        async function deleteGroup(groupId) {
            const confirmed = await showCustomConfirm('ç¡®è®¤åˆ é™¤', 'åˆ é™¤åˆ†ç»„åŽï¼Œè¯¥ç»„å†…çš„å¥½å‹å°†å˜ä¸ºâ€œæœªåˆ†ç»„â€ã€‚ç¡®å®šè¦åˆ é™¤å—ï¼Ÿ', { confirmButtonClass: 'btn-danger' });
            if (confirmed) {
                await db.qzoneGroups.delete(groupId);
                // å°†å±žäºŽè¯¥åˆ†ç»„çš„å¥½å‹çš„ groupId è®¾ä¸º null
                const chatsToUpdate = await db.chats.where('groupId').equals(groupId).toArray();
                for (const chat of chatsToUpdate) {
                    chat.groupId = null;
                    await db.chats.put(chat);
                    if(state.chats[chat.id]) state.chats[chat.id].groupId = null;
                }
                await renderGroupList();
            }
        }
        
        /**
         * å½“é•¿æŒ‰æ¶ˆæ¯æ—¶ï¼Œæ˜¾ç¤ºæ“ä½œèœå•
         * @param {number} timestamp - è¢«é•¿æŒ‰æ¶ˆæ¯çš„æ—¶é—´æˆ³
         */
        function showMessageActions(timestamp) {
        
        const chat = state.chats[state.activeChatId];
        document.getElementById('publish-to-announcement-btn').style.display = chat.isGroup ? 'block' : 'none';
          
            
            if (isSelectionMode) return;
            
            activeMessageTimestamp = timestamp;
            document.getElementById('message-actions-modal').classList.add('visible');
        }
        
        /**
         * éšè—æ¶ˆæ¯æ“ä½œèœå•
         */
        function hideMessageActions() {
            document.getElementById('message-actions-modal').classList.remove('visible');
            activeMessageTimestamp = null;
        }
        
        
        async function openMessageEditor() {
            if (!activeMessageTimestamp) return;
        
            const timestampToEdit = activeMessageTimestamp;
            const chat = state.chats[state.activeChatId];
            const message = chat.history.find(m => m.timestamp === timestampToEdit);
            if (!message) return;
        
            hideMessageActions(); 
        
            let contentForEditing;
            
            const isSpecialType = message.type && ['voice_message', 'ai_image', 'transfer', 'share_link'].includes(message.type);
        
            if (isSpecialType) {
                let fullMessageObject = { type: message.type };
                if (message.type === 'voice_message') fullMessageObject.content = message.content;
                else if (message.type === 'ai_image') fullMessageObject.description = message.content; 
                else if (message.type === 'transfer') {
                    fullMessageObject.amount = message.amount;
                    fullMessageObject.note = message.note;
                } 
                
                else if (message.type === 'share_link') {
                    fullMessageObject.title = message.title;
                    fullMessageObject.description = message.description;
                    fullMessageObject.source_name = message.source_name;
                    fullMessageObject.content = message.content;
                }
                contentForEditing = JSON.stringify(fullMessageObject, null, 2);
            } else if (typeof message.content === 'object') {
                contentForEditing = JSON.stringify(message.content, null, 2);
            } else {
                contentForEditing = message.content;
            }
        
            
            const templates = {
                voice: { type: 'voice_message', content: 'åœ¨è¿™é‡Œè¾“å…¥è¯­éŸ³å†…å®¹' },
                image: { type: 'ai_image', description: 'åœ¨è¿™é‡Œè¾“å…¥å›¾ç‰‡æè¿°' },
                transfer: { type: 'transfer', amount: 5.20, note: 'ä¸€ç‚¹å¿ƒæ„' },
                link: { type: 'share_link', title: 'æ–‡ç« æ ‡é¢˜', description: 'æ–‡ç« æ‘˜è¦...', source_name: 'æ¥æºç½‘ç«™', content: 'æ–‡ç« å®Œæ•´å†…å®¹...' }
            };
        
            
            const helpersHtml = `
                <div class="format-helpers">
                    <button class="format-btn" data-template='${JSON.stringify(templates.voice)}'>è¯­éŸ³</button>
                    <button class="format-btn" data-template='${JSON.stringify(templates.image)}'>å›¾ç‰‡</button>
                    <button class="format-btn" data-template='${JSON.stringify(templates.transfer)}'>è½¬è´¦</button>
                    <button class="format-btn" data-template='${JSON.stringify(templates.link)}'>é“¾æŽ¥</button>
                </div>
            `;
        
            const newContent = await showCustomPrompt(
                'ç¼–è¾‘æ¶ˆæ¯', 
                'åœ¨æ­¤ä¿®æ”¹ï¼Œæˆ–ç‚¹å‡»ä¸Šæ–¹æŒ‰é’®ä½¿ç”¨æ ¼å¼æ¨¡æ¿...',
                contentForEditing, 
                'textarea',
                helpersHtml
            );
        
            if (newContent !== null) {
                
                await saveEditedMessage(timestampToEdit, newContent, true);
            }
        }
          
        
        /**
         * å¤åˆ¶æ¶ˆæ¯çš„æ–‡æœ¬å†…å®¹åˆ°å‰ªè´´æ¿
         */
        async function copyMessageContent() {
            if (!activeMessageTimestamp) return;
            const chat = state.chats[state.activeChatId];
            const message = chat.history.find(m => m.timestamp === activeMessageTimestamp);
            if (!message) return;
        
            let textToCopy;
            if (typeof message.content === 'object') {
                textToCopy = JSON.stringify(message.content);
            } else {
                textToCopy = String(message.content);
            }
        
            try {
                await navigator.clipboard.writeText(textToCopy);
                await showCustomAlert('å¤åˆ¶æˆåŠŸ', 'æ¶ˆæ¯å†…å®¹å·²å¤åˆ¶åˆ°å‰ªè´´æ¿ã€‚');
            } catch (err) {
                await showCustomAlert('å¤åˆ¶å¤±è´¥', 'æ— æ³•è®¿é—®å‰ªè´´æ¿ã€‚');
            }
            
            hideMessageActions();
        }
        

/**
 * å¤åˆ¶æ¶ˆæ¯çš„æ—¶é—´æˆ³åˆ°å‰ªè´´æ¿
 */
async function copyMessageTimestamp() {
    if (!activeMessageTimestamp) return;

    try {
        await navigator.clipboard.writeText(activeMessageTimestamp);
        await showCustomAlert('å¤åˆ¶æˆåŠŸ', `æ¶ˆæ¯æ—¶é—´æˆ³ ${activeMessageTimestamp} å·²å¤åˆ¶åˆ°å‰ªè´´æ¿ã€‚`);
    } catch (err) {
        await showCustomAlert('å¤åˆ¶å¤±è´¥', 'æ— æ³•è®¿é—®å‰ªè´´æ¿ã€‚');
    }
    
    hideMessageActions();
}


/**
 * ã€V2.0 | å·²æ·»åŠ NAIæ¨¡æ¿ã€‘åˆ›å»ºä¸€-ä¸ªå¯ç¼–è¾‘çš„æ¶ˆæ¯å—ï¼ˆåŒ…å«æ–‡æœ¬æ¡†ã€æ ¼å¼åŠ©æ‰‹å’Œåˆ é™¤æŒ‰é’®ï¼‰
 * @param {string} initialContent - æ–‡æœ¬æ¡†çš„åˆå§‹å†…å®¹
 * @returns {HTMLElement} - åˆ›å»ºå¥½çš„DOMå…ƒç´ 
 */
function createMessageEditorBlock(initialContent = '') {
    const block = document.createElement('div');
    block.className = 'message-editor-block';

    
    const templates = {
        voice: { type: 'voice_message', content: 'åœ¨è¿™é‡Œè¾“å…¥è¯­éŸ³å†…å®¹' },
        image: { type: 'ai_image', description: 'åœ¨è¿™é‡Œè¾“å…¥å›¾ç‰‡æè¿°' },
        transfer: { type: 'transfer', amount: 5.20, note: 'ä¸€ç‚¹å¿ƒæ„' },
        link: { type: 'share_link', title: 'æ–‡ç« æ ‡é¢˜', description: 'æ–‡ç« æ‘˜è¦...', source_name: 'æ¥æºç½‘ç«™', content: 'æ–‡ç« å®Œæ•´å†…å®¹...' },
        offline: { type: 'offline_text', content: 'ã€Œåœ¨è¿™é‡Œè¾“å…¥å¯¹è¯å†…å®¹ã€\n(åœ¨è¿™é‡Œè¾“å…¥åŠ¨ä½œæˆ–çŽ¯å¢ƒæå†™)' },
        quote: { type: 'quote_reply', target_timestamp: 1234567890, reply_content: 'åœ¨è¿™é‡Œè¾“å…¥å›žå¤å†…å®¹' },
        // â–¼â–¼â–¼ åœ¨è¿™é‡Œæ·»åŠ æ–°çš„NAIæ¨¡æ¿ â–¼â–¼â–¼
        nai: { type: 'naiimag', prompt: '1girl, best quality, masterpiece, ...' }
        // â–²â–²â–² æ·»åŠ ç»“æŸ â–²â–²â–²
    };

    block.innerHTML = `
        <button class="delete-block-btn" title="åˆ é™¤æ­¤æ¡">Ã—</button>
        <textarea>${initialContent}</textarea>
        <div class="format-helpers">
            <button class="format-btn" data-template='${JSON.stringify(templates.voice)}'>è¯­éŸ³</button>
            <button class="format-btn" data-template='${JSON.stringify(templates.image)}'>å›¾ç‰‡</button>
            <button class="format-btn" data-template='${JSON.stringify(templates.transfer)}'>è½¬è´¦</button>
            <button class="format-btn" data-template='${JSON.stringify(templates.link)}'>é“¾æŽ¥</button>
            <button class="format-btn" data-template='${JSON.stringify(templates.offline)}'>çº¿ä¸‹</button>
            <button class="format-btn" data-template='${JSON.stringify(templates.quote)}'>å¼•ç”¨</button>
            <button class="format-btn" data-template='${JSON.stringify(templates.nai)}' style="color: #6a329f; border-color: #6a329f;">NAIç”Ÿå›¾</button>
            </div>
    `;

    
    block.querySelector('.delete-block-btn').addEventListener('click', () => {
        
        if (document.querySelectorAll('.message-editor-block').length > 1) {
            block.remove();
        } else {
            alert('è‡³å°‘éœ€è¦ä¿ç•™ä¸€æ¡æ¶ˆæ¯ã€‚');
        }
    });

    
    block.querySelectorAll('.format-btn').forEach(btn => {
        btn.addEventListener('click', () => {
            const templateStr = btn.dataset.template;
            const textarea = block.querySelector('textarea');
            if (templateStr && textarea) {
                try {
                    const templateObj = JSON.parse(templateStr);
                    textarea.value = JSON.stringify(templateObj, null, 2);
                    textarea.focus();
                } catch(e) { console.error("è§£æžæ ¼å¼æ¨¡æ¿å¤±è´¥:", e); }
            }
        });
    });

    return block;
}
  
        
        
/**
 * ã€V2.0 | å·²ä¿®å¤NAIåŠ è½½BUGã€‘æ‰“å¼€å…¨æ–°çš„ã€å¯è§†åŒ–çš„å¤šæ¶ˆæ¯ç¼–è¾‘å™¨
 */
async function openAdvancedMessageEditor() {
    if (!activeMessageTimestamp) return;

    const timestampToEdit = activeMessageTimestamp;
    const chat = state.chats[state.activeChatId];
    const message = chat.history.find(m => m.timestamp === timestampToEdit);
    if (!message) return;

    hideMessageActions(); 

    const editorModal = document.getElementById('message-editor-modal');
    const editorContainer = document.getElementById('message-editor-container');
    editorContainer.innerHTML = ''; 

    let initialContent;
    
    if (message.quote) {
        
        const quoteReplyObject = {
            type: 'quote_reply',
            target_timestamp: message.quote.timestamp,
            reply_content: message.content 
        };
        
        initialContent = JSON.stringify(quoteReplyObject, null, 2);
    } 
    
    // â–¼â–¼â–¼ 1. åœ¨è¿™é‡Œçš„æ•°ç»„ä¸­æ·»åŠ  'naiimag' â–¼â–¼â–¼
    else if (message.type && ['voice_message', 'ai_image', 'transfer', 'offline_text', 'share_link', 'naiimag'].includes(message.type)) {
        let fullMessageObject = { type: message.type };
        if (message.type === 'voice_message') fullMessageObject.content = message.content;
        else if (message.type === 'ai_image') fullMessageObject.description = message.content;
        else if (message.type === 'transfer') {
            fullMessageObject.amount = message.amount;
            fullMessageObject.note = message.note;
        } 
        else if (message.type === 'offline_text') {
            if (message.content) {
                fullMessageObject.content = message.content;
            } else { 
                fullMessageObject.dialogue = message.dialogue;
                fullMessageObject.description = message.description;
            }
        }
        else if (message.type === 'share_link') {
            fullMessageObject.title = message.title;
            fullMessageObject.description = message.description;
            fullMessageObject.source_name = message.source_name;
            fullMessageObject.content = message.content;
        }
        // â–¼â–¼â–¼ 2. åœ¨è¿™é‡Œæ·»åŠ ä¸€ä¸ª else if æ¥å¤„ç† naiimag â–¼â–¼â–¼
        else if (message.type === 'naiimag') {
            fullMessageObject.prompt = message.prompt;
            fullMessageObject.imageUrl = message.imageUrl; 
            fullMessageObject.fullPrompt = message.fullPrompt; 
        }
        // â–²â–²â–² æ·»åŠ ç»“æŸ â–²â–²â–²

        initialContent = JSON.stringify(fullMessageObject, null, 2);
    } 
    
    else if (typeof message.content === 'object') {
        initialContent = JSON.stringify(message.content, null, 2);
    } else {
        initialContent = message.content;
    }

    const firstBlock = createMessageEditorBlock(initialContent);
    editorContainer.appendChild(firstBlock);

    
    const addBtn = document.getElementById('add-message-editor-block-btn');
    const newAddBtn = addBtn.cloneNode(true);
    addBtn.parentNode.replaceChild(newAddBtn, addBtn);
    newAddBtn.addEventListener('click', () => {
        const newBlock = createMessageEditorBlock();
        editorContainer.appendChild(newBlock);
        newBlock.querySelector('textarea').focus();
    });

    const cancelBtn = document.getElementById('cancel-advanced-editor-btn');
    const newCancelBtn = cancelBtn.cloneNode(true);
    cancelBtn.parentNode.replaceChild(newCancelBtn, cancelBtn);
    newCancelBtn.addEventListener('click', () => {
        editorModal.classList.remove('visible');
    });

    const saveBtn = document.getElementById('save-advanced-editor-btn');
    const newSaveBtn = saveBtn.cloneNode(true);
    saveBtn.parentNode.replaceChild(newSaveBtn, saveBtn);
    newSaveBtn.addEventListener('click', () => {
        saveEditedMessage(timestampToEdit); 
    });

    editorModal.classList.add('visible');
}
          
          

        /**
         * å¤åˆ¶æ¶ˆæ¯çš„æ–‡æœ¬å†…å®¹åˆ°å‰ªè´´æ¿
         */
        async function copyMessageContent() {
            if (!activeMessageTimestamp) return;
            const chat = state.chats[state.activeChatId];
            const message = chat.history.find(m => m.timestamp === activeMessageTimestamp);
            if (!message) return;
        
            let textToCopy;
            
            if (message.type === 'offline_text') {
                
                if (message.content) {
                    textToCopy = message.content;
                } else { 
                    textToCopy = `ã€Œ${message.dialogue || ''}ã€\n${message.description || ''}`;
                }
            } else if (typeof message.content === 'object') {
                textToCopy = JSON.stringify(message.content);
            } else {
                textToCopy = String(message.content);
            }
        
            try {
                await navigator.clipboard.writeText(textToCopy);
                await showCustomAlert('å¤åˆ¶æˆåŠŸ', 'æ¶ˆæ¯å†…å®¹å·²å¤åˆ¶åˆ°å‰ªè´´æ¿ã€‚');
            } catch (err) {
                await showCustomAlert('å¤åˆ¶å¤±è´¥', 'æ— æ³•è®¿é—®å‰ªè´´æ¿ã€‚');
            }
            
            hideMessageActions();
        }
          
        
        /**
         * è§£æžç¼–è¾‘åŽçš„æ–‡æœ¬ï¼Œå¹¶è¿”å›žä¸€ä¸ªæ ‡å‡†åŒ–çš„æ¶ˆæ¯ç‰‡æ®µå¯¹è±¡
         * @param {string} text - ç”¨æˆ·åœ¨ç¼–è¾‘æ¡†ä¸­è¾“å…¥çš„æ–‡æœ¬
         * @returns {object} - ä¸€ä¸ªåŒ…å« type, content, ç­‰å±žæ€§çš„å¯¹è±¡
         */
        function parseEditedContent(text) {
            const trimmedText = text.trim();
        
            
            if (trimmedText.startsWith('{') && trimmedText.endsWith('}')) {
                try {
                    const parsed = JSON.parse(trimmedText);
                    
                    if (parsed.type) {
                        return parsed;
                    }
                } catch (e) { /* è§£æžå¤±è´¥ï¼Œç»§ç»­å¾€ä¸‹èµ° */ }
            }
            
            
            if (STICKER_REGEX.test(trimmedText)) {
                
                return { type: 'sticker', content: trimmedText };
            }
        
            
            return { type: 'text', content: trimmedText };
        }
        
        


/**
 * ã€V4.1 | NAIé‡ç”Ÿæˆä¿®å¤ç‰ˆã€‘ä¿å­˜ç¼–è¾‘æˆ–æ‹†åˆ†åŽçš„æ¶ˆæ¯ï¼Œå¹¶æ­£ç¡®å¤„ç†ç±»åž‹è½¬æ¢
 * @param {number} timestamp - è¢«ç¼–è¾‘çš„åŽŸå§‹æ¶ˆæ¯çš„æ—¶é—´æˆ³
 * @param {string|null} simpleContent - (å¯é€‰) å¦‚æžœæ˜¯ä»Žç®€å•ç¼–è¾‘å™¨ä¼ æ¥ï¼Œåˆ™ä¸ºå•ä¸ªå†…å®¹å­—ç¬¦ä¸²
 */
async function saveEditedMessage(timestamp, simpleContent = null) {
    if (!timestamp) return;

    const chat = state.chats[state.activeChatId];
    const messageIndex = chat.history.findIndex(m => m.timestamp === timestamp);
    if (messageIndex === -1) return;
    
    
    const originalMessage = chat.history[messageIndex];

    let newMessages = [];

    
    const blocks = simpleContent !== null 
        ? [simpleContent] 
        : Array.from(document.querySelectorAll('#message-editor-container textarea')).map(ta => ta.value);

    for (const rawContent of blocks) {
        if (!rawContent.trim()) continue;

        
        const parsedResult = parseEditedContent(rawContent.trim());
        
        
        
        const newMessage = {
            role: originalMessage.role,
            senderName: originalMessage.senderName,
            timestamp: originalMessage.timestamp 
        };

        
        
        switch (parsedResult.type) {
            case 'text':
                newMessage.type = 'text';
                newMessage.content = parsedResult.content;
                break;
            case 'offline_text':
                newMessage.type = 'offline_text';
                if (parsedResult.content) {
                    newMessage.content = parsedResult.content;
                } else { 
                    newMessage.dialogue = parsedResult.dialogue;
                    newMessage.description = parsedResult.description;
                }
                break;
            case 'quote_reply':
                newMessage.type = 'quote_reply';
                newMessage.content = parsedResult.reply_content;
                const originalQuotedMsg = chat.history.find(m => m.timestamp === parsedResult.target_timestamp);
                if (originalQuotedMsg) {
                    let originalSenderName = originalQuotedMsg.senderName;
                    if (originalQuotedMsg.role === 'user') {
                        originalSenderName = state.qzoneSettings.nickname || '{{user}}';
                    }
                    newMessage.quote = {
                        timestamp: parsedResult.target_timestamp,
                        senderName: originalSenderName,
                        content: String(originalQuotedMsg.content || '')
                    };
                } else {
                    newMessage.quote = {
                        timestamp: parsedResult.target_timestamp,
                        senderName: 'æœªçŸ¥ç”¨æˆ·',
                        content: 'åŽŸå§‹æ¶ˆæ¯å·²åˆ é™¤æˆ–ä¸å­˜åœ¨'
                    };
                }
                break;
            case 'voice_message':

            case 'ai_image':
            case 'user_photo':
                newMessage.type = parsedResult.type;
                newMessage.content = parsedResult.content || parsedResult.description;
                if (parsedResult.meaning) newMessage.meaning = parsedResult.meaning;
                break;
            
            // ==========================================================
            // â–¼â–¼â–¼ æ ¸å¿ƒä¿®æ”¹å¼€å§‹ï¼šè‡ªåŠ¨é‡æ–°ç”ŸæˆNAIå›¾ç‰‡ â–¼â–¼â–¼
            // ==========================================================
            case 'naiimag': { 
                const originalMsg = chat.history[messageIndex];
                let newPrompt = parsedResult.prompt;
                
                
                let newImageUrl = parsedResult.imageUrl;
                let newFullPrompt = parsedResult.fullPrompt;
                let promptChanged = false;

                
                if (newPrompt && typeof newPrompt === 'string' && originalMsg.prompt !== newPrompt) {
                    promptChanged = true;
                } else {
                    
                    newPrompt = originalMsg.prompt;
                    newFullPrompt = originalMsg.fullPrompt;
                    newImageUrl = originalMsg.imageUrl;
                }

                if (promptChanged) {
                    await showCustomAlert("è¯·ç¨å€™...", "æ£€æµ‹åˆ°æç¤ºè¯å·²ä¿®æ”¹ï¼Œæ­£åœ¨é‡æ–°ç”Ÿæˆ NovelAI å›¾ç‰‡...");
                    try {
                        
                        const generatedData = await generateNaiImageFromPrompt(newPrompt, chat.id);
                        newImageUrl = generatedData.imageUrl;
                        newFullPrompt = generatedData.fullPrompt;
                        await showCustomAlert("æˆåŠŸ", "å›¾ç‰‡å·²æ ¹æ®æ–°æç¤ºè¯é‡æ–°ç”Ÿæˆï¼");
                    } catch (error) {
                        console.error("ç¼–è¾‘æ—¶é‡æ–°ç”ŸæˆNAIå›¾ç‰‡å¤±è´¥:", error);
                        await showCustomAlert("ç”Ÿæˆå¤±è´¥", `æ— æ³•é‡æ–°ç”Ÿæˆå›¾ç‰‡: ${error.message}. \n\nå°†ä¿ç•™æ—§å›¾ç‰‡ï¼Œä½†æç¤ºè¯ä¼šæ›´æ–°ã€‚`);
                        
                        newImageUrl = originalMsg.imageUrl; 
                    }
                }

                
                newMessage.type = 'naiimag';
                newMessage.imageUrl = newImageUrl;
                newMessage.prompt = newPrompt;
                newMessage.fullPrompt = newFullPrompt;
                break;
            }
            // ==========================================================
            // â–²â–²â–² æ ¸å¿ƒä¿®æ”¹ç»“æŸ â–²â–²â–²
            // ==========================================================

            case 'sticker': { 
                        newMessage.type = 'sticker';
                        let found = false; 

                        
                        if (parsedResult.meaning) {
                            
                            const sticker = state.userStickers.find(s => s.name === parsedResult.meaning);
                            if (sticker) {
                                
                                newMessage.content = sticker.url;
                                newMessage.meaning = sticker.name;
                                console.log("å¯¼æ¼”/ç¼–è¾‘æ¨¡å¼ä¿å­˜(Sticker): ä½¿ç”¨äº† meaning æŸ¥æ‰¾");
                                found = true;
                            } else {
                                
                                newMessage.type = 'text'; 
                                newMessage.content = `[è¡¨æƒ…: ${parsedResult.meaning}]`;
                                console.warn("å¯¼æ¼”/ç¼–è¾‘æ¨¡å¼ä¿å­˜(Sticker): æä¾›äº† meaning ä½†æœªæ‰¾åˆ°å¯¹åº”è¡¨æƒ…:", parsedResult.meaning);
                                found = true; 
                            }
                        }

                        
                        
                        if (!found && parsedResult.url) {
                            newMessage.content = parsedResult.url; 
                            
                            const stickerByURL = state.userStickers.find(s => s.url === parsedResult.url);
                            
                            if (parsedResult.meaning && (!stickerByURL || stickerByURL.name === parsedResult.meaning)) {
                                 newMessage.meaning = parsedResult.meaning;
                            } else if (stickerByURL) { 
                                 newMessage.meaning = stickerByURL.name;
                            } else { 
                                 newMessage.meaning = 'æœªçŸ¥è¡¨æƒ…';
                            }
                            console.log("å¯¼æ¼”/ç¼–è¾‘æ¨¡å¼ä¿å­˜(Sticker): ä½¿ç”¨äº† URLï¼Œæœ€ç»ˆ meaning:", newMessage.meaning);
                            found = true;
                        }

                        
                        if (!found && parsedResult.content && typeof parsedResult.content === 'string' && STICKER_REGEX.test(parsedResult.content)) {
                            newMessage.content = parsedResult.content; 
                            
                            const sticker = state.userStickers.find(s => s.url === parsedResult.content);
                            newMessage.meaning = sticker ? sticker.name : 'æœªçŸ¥è¡¨æƒ…';
                            console.log("å¯¼æ¼”/ç¼–è¾‘æ¨¡å¼ä¿å­˜(Sticker): å°† content è§†ä¸º URLï¼ŒæŸ¥æ‰¾åˆ° meaning:", newMessage.meaning);
                            found = true;
                        }

                        
                        if (!found) {
                            console.error("å¯¼æ¼”/ç¼–è¾‘æ¨¡å¼ä¿å­˜(Sticker): æŒ‡ä»¤æ— æ•ˆæˆ–ç¼ºå°‘å¿…è¦å­—æ®µ (meaning/url/content):", parsedResult);
                            continue; 
                        }
                        break; 
                    } 
            case 'transfer':
                newMessage.type = 'transfer';
                newMessage.amount = parsedResult.amount;
                newMessage.note = parsedResult.note;
                break;
            case 'share_link':
                newMessage.type = 'share_link';
                newMessage.title = parsedResult.title;
                newMessage.description = parsedResult.description;
                newMessage.source_name = parsedResult.source_name;
                newMessage.content = parsedResult.content;
                break;
            default:
                
                Object.assign(newMessage, parsedResult);
                break;
        }
        
        newMessages.push(newMessage);
    }
    
    if (newMessages.length === 0) {
        document.getElementById('message-editor-modal').classList.remove('visible');
        return;
    }

    
    
    chat.history.splice(messageIndex, 1, ...newMessages);
    
    
    let reassignTimestamp = timestamp;
    for (let i = messageIndex; i < chat.history.length; i++) {
        chat.history[i].timestamp = reassignTimestamp;
        reassignTimestamp++; 
    }
    
    await db.chats.put(chat);
    document.getElementById('message-editor-modal').classList.remove('visible');
    renderChatInterface(state.activeChatId);
    await showCustomAlert('æˆåŠŸ', 'æ¶ˆæ¯å·²æ›´æ–°ï¼');
}
  
        
        
        
        /**
         * å½“ç‚¹å‡»â€œâ€¦â€æ—¶ï¼Œæ˜¾ç¤ºåŠ¨æ€æ“ä½œèœå•
         * @param {number} postId - è¢«æ“ä½œçš„åŠ¨æ€çš„ID
         */
        function showPostActions(postId) {
            activePostId = postId;
            document.getElementById('post-actions-modal').classList.add('visible');
        }
        
        /**
         * éšè—åŠ¨æ€æ“ä½œèœå•
         */
        function hidePostActions() {
            document.getElementById('post-actions-modal').classList.remove('visible');
            activePostId = null;
        }
        
        /**
         * æ‰“å¼€åŠ¨æ€ç¼–è¾‘å™¨
         */
        async function openPostEditor() {
            if (!activePostId) return;
        
            const postIdToEdit = activePostId;
            const post = await db.qzonePosts.get(postIdToEdit);
            if (!post) return;
        
            hidePostActions();
        
            
            let contentForEditing;
            if (post.type === 'shuoshuo') {
                contentForEditing = post.content;
            } else {
                
                const postObject = {
                    type: post.type,
                    publicText: post.publicText || '',
                };
                if (post.type === 'image_post') {
                    postObject.imageUrl = post.imageUrl;
                    postObject.imageDescription = post.imageDescription;
                } else if (post.type === 'text_image') {
                    postObject.hiddenContent = post.hiddenContent;
                }
                contentForEditing = JSON.stringify(postObject, null, 2);
            }
            
            
            const templates = {
                shuoshuo: "åœ¨è¿™é‡Œè¾“å…¥è¯´è¯´çš„å†…å®¹...", 
                image: { type: 'image_post', publicText: '', imageUrl: 'https://...', imageDescription: '' },
                text_image: { type: 'text_image', publicText: '', hiddenContent: '' }
            };
            
            const helpersHtml = `
                <div class="format-helpers">
                    <button class="format-btn" data-type="text">è¯´è¯´</button>
                    <button class="format-btn" data-template='${JSON.stringify(templates.image)}'>å›¾ç‰‡åŠ¨æ€</button>
                    <button class="format-btn" data-template='${JSON.stringify(templates.text_image)}'>æ–‡å­—å›¾</button>
                </div>
            `;
        
            const newContent = await showCustomPrompt(
                'ç¼–è¾‘åŠ¨æ€',
                'åœ¨æ­¤ä¿®æ”¹å†…å®¹...',
                contentForEditing,
                'textarea',
                helpersHtml
            );
            
            
            
            setTimeout(() => {
                const shuoshuoBtn = document.querySelector('#custom-modal-body .format-btn[data-type="text"]');
                if(shuoshuoBtn) {
                    shuoshuoBtn.addEventListener('click', () => {
                        const input = document.getElementById('custom-prompt-input');
                        input.value = templates.shuoshuo;
                        input.focus();
                    });
                }
            }, 100);
        
            if (newContent !== null) {
                await saveEditedPost(postIdToEdit, newContent);
            }
        }
        
        /**
         * ä¿å­˜ç¼–è¾‘åŽçš„åŠ¨æ€
         * @param {number} postId - è¦ä¿å­˜çš„åŠ¨æ€ID
         * @param {string} newRawContent - ä»Žç¼–è¾‘å™¨èŽ·å–çš„æ–°å†…å®¹
         */
        async function saveEditedPost(postId, newRawContent) {
            const post = await db.qzonePosts.get(postId);
            if (!post) return;
        
            const trimmedContent = newRawContent.trim();
            
            
            try {
                const parsed = JSON.parse(trimmedContent);
                
                post.type = parsed.type || 'image_post';
                post.publicText = parsed.publicText || '';
                post.imageUrl = parsed.imageUrl || '';
                post.imageDescription = parsed.imageDescription || '';
                post.hiddenContent = parsed.hiddenContent || '';
                post.content = ''; 
            } catch (e) {
                
                post.type = 'shuoshuo';
                post.content = trimmedContent;
                
                post.publicText = '';
                post.imageUrl = '';
                post.imageDescription = '';
                post.hiddenContent = '';
            }
            
            await db.qzonePosts.put(post);
            await renderQzonePosts(); 
            await showCustomAlert('æˆåŠŸ', 'åŠ¨æ€å·²æ›´æ–°ï¼');
        }
        
        /**
         * å¤åˆ¶åŠ¨æ€å†…å®¹
         */
        async function copyPostContent() {
            if (!activePostId) return;
            const post = await db.qzonePosts.get(activePostId);
            if (!post) return;
            
            let textToCopy = post.content || post.publicText || post.hiddenContent || post.imageDescription || "ï¼ˆæ— æ–‡å­—å†…å®¹ï¼‰";
            
            try {
                await navigator.clipboard.writeText(textToCopy);
                await showCustomAlert('å¤åˆ¶æˆåŠŸ', 'åŠ¨æ€å†…å®¹å·²å¤åˆ¶åˆ°å‰ªè´´æ¿ã€‚');
            } catch (err) {
                await showCustomAlert('å¤åˆ¶å¤±è´¥', 'æ— æ³•è®¿é—®å‰ªè´´æ¿ã€‚');
            }
            
            hidePostActions();
        }
        
        
        let selectedContacts = new Set();
        
        async function openContactPickerForGroupCreate() {
    
    const choice = await showChoiceModal('åˆ›å»ºç¾¤èŠ', [
        { text: 'åˆ›å»ºæ™®é€šç¾¤èŠ (æˆ‘å‚ä¸Ž)', value: 'normal' },
        { text: 'åˆ›å»ºæ—è§‚ç¾¤èŠ (æˆ‘å›´è§‚)', value: 'spectator' }
    ]);

    if (choice === 'normal') {
        
        selectedContacts.clear();
        const confirmBtn = document.getElementById('confirm-contact-picker-btn');
        const newConfirmBtn = confirmBtn.cloneNode(true);
        confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);
        newConfirmBtn.addEventListener('click', handleCreateGroup);
        await renderContactPicker();
        showScreen('contact-picker-screen');

    } else if (choice === 'spectator') {
        
        openSpectatorGroupCreator();
    }
}
          


/**
 * ã€å…¨æ–°ã€‘æ‰“å¼€â€œæ—è§‚æ¨¡å¼ç¾¤èŠâ€çš„æˆå‘˜é€‰æ‹©å™¨
 */
async function openSpectatorGroupCreator() {
    selectedContacts.clear(); 

    
    const confirmBtn = document.getElementById('confirm-contact-picker-btn');
    const newConfirmBtn = confirmBtn.cloneNode(true);
    confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);
    newConfirmBtn.addEventListener('click', handleCreateSpectatorGroup);

    
    await renderSpectatorContactPicker();

    
    showScreen('contact-picker-screen');
}

/**
 * ã€å…¨æ–°ã€‘ä¸ºâ€œæ—è§‚æ¨¡å¼â€æ¸²æŸ“ä¸€ä¸ªç‰¹æ®Šçš„è”ç³»äººåˆ—è¡¨ï¼ŒåŒ…å«æ‰€æœ‰è§’è‰²å’ŒNPC
 */
async function renderSpectatorContactPicker() {
    const listEl = document.getElementById('contact-picker-list');
    listEl.innerHTML = '';

    
    const characters = Object.values(state.chats).filter(chat => !chat.isGroup);
    
    const npcs = await db.npcs.toArray();

    if (characters.length === 0 && npcs.length === 0) {
        listEl.innerHTML = '<p style="text-align:center; color:#8a8a8a; margin-top:50px;">è¿˜æ²¡æœ‰ä»»ä½•è§’è‰²æˆ–NPCå¯ä»¥åŠ å…¥ç¾¤èŠã€‚</p>';
        return;
    }

    
    characters.forEach(contact => {
        const item = document.createElement('div');
        item.className = 'contact-picker-item';
        item.dataset.contactId = contact.id; 
        item.innerHTML = `
            <div class="checkbox"></div>
            <img src="${contact.settings.aiAvatar || defaultAvatar}" class="avatar">
            <span class="name">${contact.name} <small style="color:#888;">(è§’è‰²)</small></span>
        `;
        listEl.appendChild(item);
    });

    
    npcs.forEach(npc => {
        const item = document.createElement('div');
        item.className = 'contact-picker-item';
        item.dataset.contactId = npc.id; 
        item.dataset.isNpc = "true";     
        item.innerHTML = `
            <div class="checkbox"></div>
            <img src="${npc.avatar || defaultGroupMemberAvatar}" class="avatar">
            <span class="name">${npc.name} <small style="color:#007722;">(NPC)</small></span>
        `;
        listEl.appendChild(item);
    });

    updateContactPickerConfirmButton();
}

/**
 * ã€å…¨æ–°ã€‘å¤„ç†åˆ›å»ºâ€œæ—è§‚æ¨¡å¼ç¾¤èŠâ€çš„æœ€ç»ˆé€»è¾‘
 */
async function handleCreateSpectatorGroup() {
    if (selectedContacts.size < 2) {
        alert("æ—è§‚ç¾¤èŠè‡³å°‘éœ€è¦é€‰æ‹©2ä¸ªæˆå‘˜ã€‚");
        return;
    }

    const groupName = await showCustomPrompt('è®¾ç½®ç¾¤å', 'è¯·è¾“å…¥ç¾¤èŠçš„åå­—', 'AIä»¬çš„èŒ¶è¯ä¼š');
    if (!groupName || !groupName.trim()) return;

    const newChatId = 'group_' + Date.now();
    const members = [];
    const allNpcs = await db.npcs.toArray(); 

    for (const contactId of selectedContacts) {
        const isNpc = document.querySelector(`.contact-picker-item[data-contact-id="${contactId}"]`).dataset.isNpc === "true";

        if (isNpc) {
            
            const npcData = allNpcs.find(n => n.id === parseInt(contactId));
            if (npcData) {
                members.push({
                    id: `npc_${npcData.id}`, 
                    originalName: npcData.name,
                    groupNickname: npcData.name,
                    persona: npcData.persona,
                    avatar: npcData.avatar || defaultGroupMemberAvatar,
                    isNpc: true
                });
            }
        } else {
            
            const contactChat = state.chats[contactId];
            if (contactChat) {
                members.push({
                    id: contactId,
                    originalName: contactChat.originalName,
                    groupNickname: contactChat.name,
                    persona: contactChat.settings.aiPersona,
                    avatar: contactChat.settings.aiAvatar || defaultAvatar,
                    isNpc: false
                });
            }
        }
    }

    const newGroupChat = {
        id: newChatId,
        name: groupName.trim(),
        isGroup: true,
        isSpectatorGroup: true, 
        members: members,
        settings: {
            
            maxMemory: 10,
            groupAvatar: defaultGroupAvatar,
            background: '',
            theme: 'default',
            fontSize: 13,
            customCss: '',
            linkedWorldBookIds: [],
        },
        history: [{ 
            role: 'system',
            content: '[ç³»ç»ŸæŒ‡ä»¤ï¼šè¿™æ˜¯ä¸€ä¸ªæ²¡æœ‰ç”¨æˆ·å‚ä¸Žçš„ç¾¤èŠï¼Œè¯·ä½ ä»¬æ ¹æ®å„è‡ªçš„äººè®¾è‡ªç”±åœ°å¼€å§‹å¯¹è¯ã€‚]',
            timestamp: Date.now(),
            isHidden: true
        }],
        musicData: { totalTime: 0 }
    };

    state.chats[newChatId] = newGroupChat;
    await db.chats.put(newGroupChat);

    await renderChatList();
    showScreen('chat-list-screen');
    openChat(newChatId);
}

/**
 * ã€å…¨æ–° | æ”¯æŒNPCã€‘æ¸²æŸ“ä¸€ä¸ªåŒ…å«æ‰€æœ‰å¯é€‰è”ç³»äººï¼ˆè§’è‰²+NPCï¼‰çš„åˆ—è¡¨
 */
async function renderContactPicker() {
    const listEl = document.getElementById('contact-picker-list');
    listEl.innerHTML = '';

    
    const characters = Object.values(state.chats).filter(chat => !chat.isGroup);
    const npcs = await db.npcs.toArray();

    if (characters.length === 0 && npcs.length === 0) {
        listEl.innerHTML = '<p style="text-align:center; color:#8a8a8a; margin-top:50px;">è¿˜æ²¡æœ‰å¯ä»¥æ‹‰è¿›ç¾¤çš„è”ç³»äººå“¦~</p>';
        return;
    }

    
    characters.forEach(contact => {
        const item = document.createElement('div');
        item.className = 'contact-picker-item';
        item.dataset.contactId = contact.id; 
        item.innerHTML = `
            <div class="checkbox"></div>
            <img src="${contact.settings.aiAvatar || defaultAvatar}" class="avatar">
            <span class="name">${contact.name} <small style="color:#888;">(è§’è‰²)</small></span>
        `;
        listEl.appendChild(item);
    });
    
    
    npcs.forEach(npc => {
        const item = document.createElement('div');
        item.className = 'contact-picker-item';
        
        item.dataset.contactId = `npc_${npc.id}`; 
        item.innerHTML = `
            <div class="checkbox"></div>
            <img src="${npc.avatar || defaultGroupMemberAvatar}" class="avatar">
            <span class="name">${npc.name} <small style="color:#007722;">(NPC)</small></span>
        `;
        listEl.appendChild(item);
    });

    updateContactPickerConfirmButton();
}
        
        /**
         * æ›´æ–°â€œå®Œæˆâ€æŒ‰é’®çš„è®¡æ•°
         */
        function updateContactPickerConfirmButton() {
            const btn = document.getElementById('confirm-contact-picker-btn');
            btn.textContent = `å®Œæˆ(${selectedContacts.size})`;
            btn.disabled = selectedContacts.size < 2; 
        }
        
  /**
 * ã€å…¨æ–° | æ”¯æŒNPCã€‘å¤„ç†åˆ›å»ºç¾¤èŠçš„æœ€ç»ˆé€»è¾‘
 */
async function handleCreateGroup() {
    if (selectedContacts.size < 2) {
        alert("åˆ›å»ºç¾¤èŠè‡³å°‘éœ€è¦é€‰æ‹©2ä¸ªè”ç³»äººã€‚");
        return;
    }

    const groupName = await showCustomPrompt('è®¾ç½®ç¾¤å', 'è¯·è¾“å…¥ç¾¤èŠçš„åå­—', 'æˆ‘ä»¬çš„ç¾¤èŠ');
    if (!groupName || !groupName.trim()) return;

    const newChatId = 'group_' + Date.now();
    const members = [];
    const allNpcs = await db.npcs.toArray(); 

    for (const contactId of selectedContacts) {
        
        if (contactId.startsWith('npc_')) {
            const npcId = parseInt(contactId.replace('npc_', ''));
            const npcData = allNpcs.find(n => n.id === npcId);
            if (npcData) {
                members.push({
                    id: contactId, 
                    originalName: npcData.name,
                    groupNickname: npcData.name,
                    persona: npcData.persona,
                    avatar: npcData.avatar || defaultGroupMemberAvatar,
                    isNpc: true 
                });
            }
        } else { 
            const contactChat = state.chats[contactId];
            if (contactChat) {
                members.push({
                    id: contactId,
                    originalName: contactChat.originalName,
                    groupNickname: contactChat.name,
                    persona: contactChat.settings.aiPersona,
                    avatar: contactChat.settings.aiAvatar || defaultAvatar,
                    isNpc: false 
                });
            }
        }
    }

    const newGroupChat = {
        id: newChatId,
        name: groupName.trim(),
        isGroup: true,
        members: members,
        settings: {
            myPersona: 'æˆ‘æ˜¯è°å‘€ã€‚',
            myNickname: 'æˆ‘',
            maxMemory: 10,
            groupAvatar: defaultGroupAvatar,
            myAvatar: defaultMyGroupAvatar,
            background: '',
            theme: 'default',
            fontSize: 13,
            customCss: '',
            linkedWorldBookIds: [],
        },
        history: [],
        musicData: { totalTime: 0 }
    };

    state.chats[newChatId] = newGroupChat;
    await db.chats.put(newGroupChat);
    
    await renderChatList();
    showScreen('chat-list-screen');
    openChat(newChatId); 
}
        
        
        
        /**
         * æ‰“å¼€ç¾¤æˆå‘˜ç®¡ç†å±å¹•
         */
        function openMemberManagementScreen() {
            if (!state.activeChatId || !state.chats[state.activeChatId].isGroup) return;
            renderMemberManagementList();
            showScreen('member-management-screen');
        }
        
        function renderMemberManagementList() {
            const listEl = document.getElementById('member-management-list');
            const chat = state.chats[state.activeChatId];
            listEl.innerHTML = '';
        
            chat.members.forEach(member => {
                const item = document.createElement('div');
                item.className = 'member-management-item';
                
                item.innerHTML = `
                    <img src="${member.avatar}" class="avatar">
                    <span class="name">${member.groupNickname}</span>
                    <button class="remove-member-btn" data-member-id="${member.id}" title="ç§»å‡ºç¾¤èŠ">-</button>
                `;
                listEl.appendChild(item);
            });
        }
        
        /**
         * ä»Žç¾¤èŠä¸­ç§»é™¤ä¸€ä¸ªæˆå‘˜
         * @param {string} memberId - è¦ç§»é™¤çš„æˆå‘˜ID
         */
        async function removeMemberFromGroup(memberId) {
            const chat = state.chats[state.activeChatId];
            const memberIndex = chat.members.findIndex(m => m.id === memberId);
            
            if (memberIndex === -1) return;
            
            
            if (chat.members.length <= 2) {
                alert("ç¾¤èŠäººæ•°ä¸èƒ½å°‘äºŽ2äººã€‚");
                return;
            }
            
        const memberName = chat.members[memberIndex].groupNickname; 
            const confirmed = await showCustomConfirm(
                'ç§»å‡ºæˆå‘˜',
                `ç¡®å®šè¦å°†â€œ${memberName}â€ç§»å‡ºç¾¤èŠå—ï¼Ÿ`,
                { confirmButtonClass: 'btn-danger' }
            );
        
            if (confirmed) {
                chat.members.splice(memberIndex, 1);
                await db.chats.put(chat);
                renderMemberManagementList(); 
                document.getElementById('chat-settings-btn').click(); 
            }
        }
        
/**
 * ã€æ€»å…¥å£ | V2.0ã€‘æ‰“å¼€è”ç³»äººé€‰æ‹©å™¨ï¼Œç”¨äºŽæ‹‰äººå…¥ç¾¤ï¼ˆçŽ°åœ¨ä¼šåŒæ—¶æ˜¾ç¤ºè§’è‰²å’ŒNPCï¼‰
 */
async function openContactPickerForAddMember() {
    
    const confirmBtn = document.getElementById('confirm-contact-picker-btn');
    
    const newConfirmBtn = confirmBtn.cloneNode(true);
    confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);
    newConfirmBtn.addEventListener('click', handleAddMembersToGroup);
    
    
    await renderUnifiedContactPicker();
    
    
    showScreen('contact-picker-screen');
}

/**
 * ã€å…¨æ–°ã€‘æ¸²æŸ“ä¸€ä¸ªç»Ÿä¸€çš„è”ç³»äººé€‰æ‹©åˆ—è¡¨ï¼ŒåŒ…å«è§’è‰²å’ŒNPC
 */
async function renderUnifiedContactPicker() {
    const listEl = document.getElementById('contact-picker-list');
    listEl.innerHTML = '';
    selectedContacts.clear(); 

    const chat = state.chats[state.activeChatId];
    const existingMemberIds = new Set(chat.members.map(m => m.id));

    
    const characters = Object.values(state.chats).filter(c => !c.isGroup && !existingMemberIds.has(c.id));
    
    
    const npcs = (await db.npcs.toArray()).filter(n => !existingMemberIds.has(`npc_${n.id}`));

    if (characters.length === 0 && npcs.length === 0) {
        listEl.innerHTML = '<p style="text-align:center; color:#8a8a8a; margin-top:50px;">æ²¡æœ‰æ›´å¤šå¯ä»¥é‚€è¯·çš„è”ç³»äººäº†ã€‚</p>';
        document.getElementById('confirm-contact-picker-btn').style.display = 'none';
    } else {
        document.getElementById('confirm-contact-picker-btn').style.display = 'block';
        
        
        characters.forEach(contact => {
            const item = document.createElement('div');
            item.className = 'contact-picker-item';
            item.dataset.contactId = contact.id;
            item.dataset.contactType = 'character'; 
            item.innerHTML = `
                <div class="checkbox"></div>
                <img src="${contact.settings.aiAvatar || defaultAvatar}" class="avatar">
                <span class="name">${contact.name} <small style="color:#888;">(è§’è‰²)</small></span>
            `;
            listEl.appendChild(item);
        });

        
        npcs.forEach(npc => {
            const item = document.createElement('div');
            item.className = 'contact-picker-item';
            item.dataset.contactId = `npc_${npc.id}`; 
            item.dataset.contactType = 'npc'; 
            item.dataset.npcId = npc.id; 
            item.innerHTML = `
                <div class="checkbox"></div>
                <img src="${npc.avatar || defaultGroupMemberAvatar}" class="avatar">
                <span class="name">${npc.name} <small style="color:#007722;">(NPC)</small></span>
            `;
            listEl.appendChild(item);
        });
    }

    updateContactPickerConfirmButton();
}
        

/**
 * ã€æ ¸å¿ƒå¤„ç† | V2.1ã€‘å¤„ç†å°†é€‰ä¸­çš„è”ç³»äººï¼ˆè§’è‰²æˆ–NPCï¼‰åŠ å…¥ç¾¤èŠçš„é€»è¾‘
 */
async function handleAddMembersToGroup() {
    if (selectedContacts.size === 0) {
        alert("è¯·è‡³å°‘é€‰æ‹©ä¸€ä¸ªè¦æ·»åŠ çš„è”ç³»äººã€‚");
        return;
    }
    
    const chat = state.chats[state.activeChatId];
    const allNpcs = await db.npcs.toArray(); 

    for (const contactId of selectedContacts) {
        const itemEl = document.querySelector(`.contact-picker-item[data-contact-id="${contactId}"]`);
        if (!itemEl) continue;

        const contactType = itemEl.dataset.contactType;

        if (contactType === 'character') {
            const contactChat = state.chats[contactId];
            if (contactChat) {
                chat.members.push({
                    id: contactId,
                    originalName: contactChat.originalName,
                    groupNickname: contactChat.name,
                    persona: contactChat.settings.aiPersona,
                    
                    avatar: contactChat.settings.aiAvatar || defaultAvatar,
                    isNpc: false 
                });
            }
        } else if (contactType === 'npc') {
            const npcId = parseInt(itemEl.dataset.npcId);
            const npcData = allNpcs.find(n => n.id === npcId);
            if (npcData) {
                
                
                chat.members.push({
                    id: `npc_${npcId}`,
                    originalName: npcData.name,
                    groupNickname: npcData.name,
                    persona: npcData.persona,
                    avatar: npcData.avatar || defaultGroupMemberAvatar, 
                    isNpc: true
                });
            }
        }
    }

    await db.chats.put(chat);
    
    
    openMemberManagementScreen();
}
  
        
/**
 * ã€é‡æž„ç‰ˆã€‘ç‚¹å‡»â€œåˆ›å»ºæ–°æˆå‘˜â€æŒ‰é’®ï¼ŒçŽ°åœ¨ä¼šæ‰“å¼€NPCç¼–è¾‘å™¨
 */
function createNewMemberInGroup() {
    
    isAddingNpcToGroup = true; 
    
    openNpcEditor(null);
}

        
        
        function startWaimaiCountdown(element, endTime) {
            const timerId = setInterval(() => {
                const now = Date.now();
                const distance = endTime - now;
        
                if (distance < 0) {
                    clearInterval(timerId);
                    element.innerHTML = '<span>å·²</span><span>è¶…</span><span>æ—¶</span>';
                    return;
                }
        
                const minutes = Math.floor((distance % (1000 * 60 * 60)) / (1000 * 60));
                const seconds = Math.floor((distance % (1000 * 60)) / 1000);
                
                const minStr = String(minutes).padStart(2, '0');
                const secStr = String(seconds).padStart(2, '0');
        
                element.innerHTML = `<span>${minStr.charAt(0)}</span><span>${minStr.charAt(1)}</span> : <span>${secStr.charAt(0)}</span><span>${secStr.charAt(1)}</span>`;
            }, 1000);
            return timerId;
        }
        
        function cleanupWaimaiTimers() {
            for (const timestamp in waimaiTimers) {
                clearInterval(waimaiTimers[timestamp]);
            }
            waimaiTimers = {};
        }
        


/**
 * ã€å…¨æ–° V3.0 | æ˜µç§°ä¿®å¤ç‰ˆã€‘æ˜¾ç¤ºå¤–å–å¡ç‰‡çš„è¯¦ç»†ä¿¡æ¯
 * @param {number} timestamp - è¢«ç‚¹å‡»çš„å¤–å–å¡ç‰‡æ¶ˆæ¯çš„æ—¶é—´æˆ³
 */
async function showWaimaiDetails(timestamp) {
    const chat = state.chats[state.activeChatId];
    if (!chat) return;

    const message = chat.history.find(m => m.timestamp === timestamp);
    
    if (!message || !['waimai_request', 'waimai_order'].includes(message.type)) {
        console.error("showWaimaiDetails: æ‰¾ä¸åˆ°æ¶ˆæ¯æˆ–æ¶ˆæ¯ç±»åž‹ä¸æ­£ç¡®", timestamp);
        return;
    }
    
    let detailsHtml = '';

    if (message.type === 'waimai_request') {
        
        let statusText;
        switch(message.status) {
            case 'paid':
                const payerName = message.paidBy || 'å¯¹æ–¹';
                const payerDisplayName = getDisplayNameInGroup(chat, payerName);
                statusText = `ç”± ${payerDisplayName} ä¸ºæ‚¨ä»£ä»˜æˆåŠŸ`;
                break;
            case 'rejected':
                statusText = 'ä»£ä»˜è¯·æ±‚å·²è¢«æ‹’ç»';
                break;
            default:
                statusText = 'ç­‰å¾…å¯¹æ–¹å¤„ç†';
                break;
        }
        detailsHtml = `
            <div style="text-align: left; font-size: 15px; line-height: 1.8;">
                <strong>å•†å“:</strong> ${message.productInfo}<br>
                <strong>é‡‘é¢:</strong> Â¥${Number(message.amount).toFixed(2)}<br>
                <strong>çŠ¶æ€:</strong> ${statusText}
            </div>
        `;
    } else if (message.type === 'waimai_order') {
        
        let senderDisplayName;
        let recipientDisplayName;

        if (chat.isGroup) {
            
            senderDisplayName = getDisplayNameInGroup(chat, message.senderName);
            recipientDisplayName = getDisplayNameInGroup(chat, message.recipientName);
        } else {
            
            if (message.role === 'user') {
                
                senderDisplayName = chat.settings.myNickname || 'æˆ‘';
                recipientDisplayName = chat.name; 
            } else {
                
                senderDisplayName = chat.name;
                recipientDisplayName = chat.settings.myNickname || 'æˆ‘';
            }
        }
        

        detailsHtml = `
            <div style="text-align: left; font-size: 15px; line-height: 1.8;">
                <strong>è®¢å•ç±»åž‹:</strong> ä¸ºTAç‚¹å•<br>
                <strong>èµ é€æ–¹:</strong> ${senderDisplayName}<br>
                <strong>æŽ¥æ”¶æ–¹:</strong> ${recipientDisplayName}<br>
                <strong>å•†å“:</strong> ${message.productInfo}<br>
                <strong>é‡‘é¢:</strong> Â¥${Number(message.amount).toFixed(2)}
            </div>
        `;
    }

    await showCustomAlert("è®¢å•è¯¦æƒ…", detailsHtml);
}

  
        async function handleWaimaiResponse(originalTimestamp, choice) {
            const chat = state.chats[state.activeChatId];
            if (!chat) return;
        
            const messageIndex = chat.history.findIndex(m => m.timestamp === originalTimestamp);
            if (messageIndex === -1) return;
        
            
            const originalMessage = chat.history[messageIndex];
            originalMessage.status = choice;
            
            
            let systemContent;
            const myNickname = chat.isGroup ? (chat.settings.myNickname || 'æˆ‘') : 'æˆ‘';
            
            if (choice === 'paid') {
                originalMessage.paidBy = myNickname; 
                systemContent = `[ç³»ç»Ÿæç¤ºï¼šä½  (${myNickname}) ä¸º ${originalMessage.senderName} çš„å¤–å–è®¢å•ï¼ˆæ—¶é—´æˆ³: ${originalTimestamp}ï¼‰å®Œæˆäº†æ”¯ä»˜ã€‚æ­¤è®¢å•å·²å…³é—­ï¼Œå…¶ä»–æˆå‘˜ä¸èƒ½å†æ”¯ä»˜ã€‚]`;
            } else {
                systemContent = `[ç³»ç»Ÿæç¤ºï¼šä½  (${myNickname}) æ‹’ç»äº† ${originalMessage.senderName} çš„å¤–å–ä»£ä»˜è¯·æ±‚ï¼ˆæ—¶é—´æˆ³: ${originalTimestamp}ï¼‰ã€‚]`;
            }
        
            
            const systemNote = {
                role: 'system',
                content: systemContent,
                timestamp: Date.now(),
                isHidden: true
            };
            chat.history.push(systemNote);
        
            
            await db.chats.put(chat);
            renderChatInterface(state.activeChatId);  
        }
        
        let videoCallState = {
            isActive: false,       
            isAwaitingResponse: false, 
            isGroupCall: false,      
            activeChatId: null,    
            initiator: null,       
            startTime: null,       
            participants: [],      
            isUserParticipating: true,
            
            callHistory: [], 
            preCallContext: "" 
        };
        
        let callTimerInterval = null; 
        
        /**
         * ã€æ€»å…¥å£ã€‘ç”¨æˆ·ç‚¹å‡»â€œå‘èµ·è§†é¢‘é€šè¯â€æˆ–â€œå‘èµ·ç¾¤è§†é¢‘â€æŒ‰é’®
         */
        async function handleInitiateCall() {
            if (!state.activeChatId || videoCallState.isActive || videoCallState.isAwaitingResponse) return;
        
            const chat = state.chats[state.activeChatId];
            videoCallState.isGroupCall = chat.isGroup;
            videoCallState.isAwaitingResponse = true;
            videoCallState.initiator = 'user';
            videoCallState.activeChatId = chat.id;
            videoCallState.isUserParticipating = true; 
        
            
            if (chat.isGroup) {
                document.getElementById('outgoing-call-avatar').src = chat.settings.myAvatar || defaultMyGroupAvatar;
                document.getElementById('outgoing-call-name').textContent = chat.settings.myNickname || 'æˆ‘';
            } else {
                document.getElementById('outgoing-call-avatar').src = chat.settings.aiAvatar || defaultAvatar;
                document.getElementById('outgoing-call-name').textContent = chat.name;
            }
            document.querySelector('#outgoing-call-screen .caller-text').textContent = chat.isGroup ? "æ­£åœ¨å‘¼å«æ‰€æœ‰æˆå‘˜..." : "æ­£åœ¨å‘¼å«...";
            showScreen('outgoing-call-screen');
            
            
            const requestMessage = {
                role: 'system',
                content: chat.isGroup 
                    ? `[ç³»ç»Ÿæç¤ºï¼šç”¨æˆ· (${chat.settings.myNickname || 'æˆ‘'}) å‘èµ·äº†ç¾¤è§†é¢‘é€šè¯è¯·æ±‚ã€‚è¯·ä½ ä»¬å„è‡ªå†³ç­–ï¼Œå¹¶ä½¿ç”¨ "group_call_response" æŒ‡ä»¤ï¼Œè®¾ç½® "decision" ä¸º "join" æˆ– "decline" æ¥å›žåº”ã€‚]`
                    : `[ç³»ç»Ÿæç¤ºï¼šç”¨æˆ·å‘ä½ å‘èµ·äº†è§†é¢‘é€šè¯è¯·æ±‚ã€‚è¯·æ ¹æ®ä½ çš„äººè®¾ï¼Œä½¿ç”¨ "video_call_response" æŒ‡ä»¤ï¼Œå¹¶è®¾ç½® "decision" ä¸º "accept" æˆ– "reject" æ¥å›žåº”ã€‚]`,
                timestamp: Date.now(),
                isHidden: true,
            };
            chat.history.push(requestMessage);
            await db.chats.put(chat);
            
            
            await triggerAiResponse();
        }
        
        
        function startVideoCall() {
            const chat = state.chats[videoCallState.activeChatId];
            if (!chat) return;
        
            videoCallState.isActive = true;
            videoCallState.isAwaitingResponse = false;
            videoCallState.startTime = Date.now();
            videoCallState.callHistory = []; 
        
            
            const preCallHistory = chat.history.slice(-10); 
            videoCallState.preCallContext = preCallHistory.map(msg => {
                const sender = msg.role === 'user' ? (chat.settings.myNickname || 'æˆ‘') : (msg.senderName || chat.name);
                return `${sender}: ${String(msg.content).substring(0, 50)}...`;
            }).join('\n');
            
        
            updateParticipantAvatars(); 
            
            document.getElementById('video-call-main').innerHTML = `<em>${videoCallState.isGroupCall ? 'ç¾¤èŠå·²å»ºç«‹...' : 'æ­£åœ¨æŽ¥é€š...'}</em>`;
            showScreen('video-call-screen');
        
            document.getElementById('user-speak-btn').style.display = videoCallState.isUserParticipating ? 'block' : 'none';
            document.getElementById('join-call-btn').style.display = videoCallState.isUserParticipating ? 'none' : 'block';
        
            if (callTimerInterval) clearInterval(callTimerInterval);
            callTimerInterval = setInterval(updateCallTimer, 1000);
            updateCallTimer();
        
            triggerAiInCallAction();
        }
        
/**
 * ã€æ ¸å¿ƒ | V3.0 ç»ˆæžæ€»ç»“ä¿®å¤ç‰ˆã€‘ç»“æŸè§†é¢‘é€šè¯
 */
async function endVideoCall() {
    if (!videoCallState.isActive) return;

    const duration = Math.floor((Date.now() - videoCallState.startTime) / 1000);
    const durationText = `${Math.floor(duration / 60)}åˆ†${duration % 60}ç§’`;
    const endCallText = `é€šè¯ç»“æŸï¼Œæ—¶é•¿ ${durationText}`;

    const chat = state.chats[videoCallState.activeChatId];
    if (chat) {
        
        const participantsData = [];
        if (videoCallState.isGroupCall) {
            videoCallState.participants.forEach(p => participantsData.push({ name: p.originalName, avatar: p.avatar }));
            if (videoCallState.isUserParticipating) {
                participantsData.unshift({ name: chat.settings.myNickname || 'æˆ‘', avatar: chat.settings.myAvatar || defaultMyGroupAvatar });
            }
        } else {
            participantsData.push({ name: chat.name, avatar: chat.settings.aiAvatar || defaultAvatar });
            participantsData.unshift({ name: 'æˆ‘', avatar: chat.settings.myAvatar || defaultAvatar });
        }

        const callRecord = {
            chatId: videoCallState.activeChatId,
            timestamp: Date.now(),
            duration: duration,
            participants: participantsData,
            transcript: [...videoCallState.callHistory]
        };
        await db.callRecords.add(callRecord);
        console.log("é€šè¯è®°å½•å·²ä¿å­˜:", callRecord);
        
        
        let summaryMessage = {
            role: videoCallState.initiator === 'user' ? 'user' : 'assistant',
            content: endCallText,
            timestamp: Date.now(),
        };
        if (chat.isGroup && summaryMessage.role === 'assistant') {
            summaryMessage.senderName = videoCallState.callRequester || chat.members[0]?.originalName || chat.name;
        }
        chat.history.push(summaryMessage);

        
        
        
        
        
        const callTranscriptForAI = videoCallState.callHistory.map(h => {
            const sender = h.role === 'user' ? (chat.settings.myNickname || 'æˆ‘') : h.senderName;
            return `${sender}: ${h.content}`;
        }).join('\n');
        
        
        
        summarizeCallTranscript(chat.id, callTranscriptForAI);

        
        const hiddenReactionInstruction = {
            role: 'system',
            content: `[ç³»ç»ŸæŒ‡ä»¤ï¼šè§†é¢‘é€šè¯åˆšåˆšç»“æŸã€‚è¯·ä½ ä»¥è§’è‰²çš„å£å»ï¼Œå‘ç”¨æˆ·ä¸»åŠ¨å‘é€ä¸€ä¸¤æ¡æ¶ˆæ¯ï¼Œæ¥è‡ªç„¶åœ°æ€»ç»“è¿™æ¬¡é€šè¯çš„è¦ç‚¹ã€ç¡®è®¤è¾¾æˆçš„çº¦å®šï¼Œæˆ–è€…è¡¨è¾¾ä½ çš„æ„Ÿå—ã€‚]`,
            timestamp: Date.now() + 1, 
            isHidden: true 
        };
        chat.history.push(hiddenReactionInstruction);

        
        await db.chats.put(chat);
    }
    
    
    clearInterval(callTimerInterval);
    callTimerInterval = null;
    videoCallState = { isActive: false, isAwaitingResponse: false, isGroupCall: false, activeChatId: null, initiator: null, startTime: null, participants: [], isUserParticipating: true, callHistory: [], preCallContext: "" };
    
    
    if (chat) {
        openChat(chat.id);
        triggerAiResponse();
    }
}
          
        
        /**
         * ã€å…¨æ–°ã€‘æ›´æ–°é€šè¯ç•Œé¢çš„å‚ä¸Žè€…å¤´åƒç½‘æ ¼
         */
        function updateParticipantAvatars() {
            const grid = document.getElementById('participant-avatars-grid');
            grid.innerHTML = '';
            const chat = state.chats[videoCallState.activeChatId];
            if (!chat) return;
        
            let participantsToRender = [];
        
            
            if (videoCallState.isGroupCall) {
                
                participantsToRender = [...videoCallState.participants];
                
                if (videoCallState.isUserParticipating) {
                    participantsToRender.unshift({
                        id: 'user',
                        name: chat.settings.myNickname || 'æˆ‘',
                        avatar: chat.settings.myAvatar || defaultMyGroupAvatar
                    });
                }
            } else {
                
                participantsToRender.push({
                    id: 'ai',
                    name: chat.name,
                    avatar: chat.settings.aiAvatar || defaultAvatar
                });
            }
            
            participantsToRender.forEach(p => {
                const wrapper = document.createElement('div');
                wrapper.className = 'participant-avatar-wrapper';
                wrapper.dataset.participantId = p.id;
        const displayName = p.groupNickname || p.name; 
        wrapper.innerHTML = `
            <img src="${p.avatar}" class="participant-avatar" alt="${displayName}">
            <div class="participant-name">${displayName}</div>
        `;
                grid.appendChild(wrapper);
            });
        }
        
        /**
         * ã€å…¨æ–°ã€‘å¤„ç†ç”¨æˆ·åŠ å…¥/é‡æ–°åŠ å…¥é€šè¯
         */
        function handleUserJoinCall() {
            if (!videoCallState.isActive || videoCallState.isUserParticipating) return;
            
            videoCallState.isUserParticipating = true;
            updateParticipantAvatars(); 
        
            
            document.getElementById('user-speak-btn').style.display = 'block';
            document.getElementById('join-call-btn').style.display = 'none';
        
            
            triggerAiInCallAction("[ç³»ç»Ÿæç¤ºï¼šç”¨æˆ·åŠ å…¥äº†é€šè¯]");
        }
        
        
        /**
         * æ›´æ–°é€šè¯è®¡æ—¶å™¨æ˜¾ç¤º (ä¿æŒä¸å˜)
         */
        function updateCallTimer() {
            if (!videoCallState.isActive) return;
            const elapsed = Math.floor((Date.now() - videoCallState.startTime) / 1000);
            const minutes = Math.floor(elapsed / 60);
            const seconds = elapsed % 60;
            document.getElementById('call-timer').textContent = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
        }
        
        
        function showIncomingCallModal() {
            const chat = state.chats[state.activeChatId];
            if (!chat) return;
        
            
            if (chat.isGroup) {
                
                const requesterName = videoCallState.callRequester || chat.members[0]?.name || 'ä¸€ä½æˆå‘˜';
                document.getElementById('caller-avatar').src = chat.settings.groupAvatar || defaultGroupAvatar;
                document.getElementById('caller-name').textContent = chat.name; 
                document.querySelector('.incoming-call-content .caller-text').textContent = `${requesterName} é‚€è¯·ä½ åŠ å…¥ç¾¤è§†é¢‘`; 
            } else {
                
                document.getElementById('caller-avatar').src = chat.settings.aiAvatar || defaultAvatar;
                document.getElementById('caller-name').textContent = chat.name;
                document.querySelector('.incoming-call-content .caller-text').textContent = 'é‚€è¯·ä½ è§†é¢‘é€šè¯';
            }
            
            document.getElementById('incoming-call-modal').classList.add('visible');
        }
          
        
        /**
         * éšè—AIå‘èµ·çš„é€šè¯è¯·æ±‚æ¨¡æ€æ¡† (ä¿æŒä¸å˜)
         */
        function hideIncomingCallModal() {
            document.getElementById('incoming-call-modal').classList.remove('visible');
        }
        
        
        async function triggerAiInCallAction(userInput = null) {
            if (!videoCallState.isActive) return;
        
            const chat = state.chats[videoCallState.activeChatId];
            const { proxyUrl, apiKey, model } = state.apiConfig;
            const callFeed = document.getElementById('video-call-main');
            const userNickname = chat.settings.myNickname || 'æˆ‘';
        
            let worldBookContent = '';
            if (chat.settings.linkedWorldBookIds && chat.settings.linkedWorldBookIds.length > 0) {
                const linkedContents = chat.settings.linkedWorldBookIds.map(bookId => {
                    const worldBook = state.worldBooks.find(wb => wb.id === bookId);
                    return worldBook && worldBook.content ? `\n\n## ä¸–ç•Œä¹¦: ${worldBook.name}\n${worldBook.content}` : '';
                }).filter(Boolean).join('');
                if (linkedContents) {
                    worldBookContent = `# --- ä¸–ç•Œä¹¦ (World Book) ---
# ã€æœ€é«˜ä¼˜å…ˆçº§è§„åˆ™ï¼šä¸–ç•Œè§‚è®¾å®šã€‘
# ä½ ã€å¿…é¡»ã€‘å°†ä»¥ä¸‹æ‰€æœ‰â€œä¸–ç•Œä¹¦â€ä¸­çš„è®¾å®šï¼Œè§†ä¸ºç»å¯¹çš„ã€ä¸å¯åŠ¨æ‘‡çš„èƒŒæ™¯äº‹å®žã€‚
# ä½ çš„æ‰€æœ‰å›žå¤å’Œè¡Œä¸ºéƒ½ã€ç»å¯¹ä¸èƒ½ã€‘ä¸Žè¿™äº›è®¾å®šäº§ç”Ÿä»»ä½•å†²çªã€‚
${linkedContents}
# --- ä¸–ç•Œä¹¦è®¾å®šç»“æŸ ---
`;
                }
            }
        
            
            if (userInput && videoCallState.isUserParticipating) {
                const userTimestamp = Date.now(); 
                const userBubble = document.createElement('div');
                userBubble.className = 'call-message-bubble user-speech';
                userBubble.textContent = userInput;
                userBubble.dataset.timestamp = userTimestamp; 
                addLongPressListener(userBubble, () => showCallMessageActions(userTimestamp)); 
                callFeed.appendChild(userBubble);
                callFeed.scrollTop = callFeed.scrollHeight;
                videoCallState.callHistory.push({ role: 'user', content: userInput, timestamp: userTimestamp }); 
            }
        
            
            let inCallPrompt;
            if (videoCallState.isGroupCall) {
                const participantNames = videoCallState.participants.map(p => p.name);
                if(videoCallState.isUserParticipating) {
                    participantNames.unshift(userNickname);
                }
                inCallPrompt = `
        # ä½ çš„ä»»åŠ¡
        ä½ æ˜¯ä¸€ä¸ªç¾¤èŠè§†é¢‘é€šè¯çš„å¯¼æ¼”ã€‚ä½ çš„ä»»åŠ¡æ˜¯æ‰®æ¼”æ‰€æœ‰ã€é™¤äº†ç”¨æˆ·ä»¥å¤–ã€‘çš„AIè§’è‰²ï¼Œå¹¶ä»¥ã€ç¬¬ä¸‰äººç§°æ—è§‚è§†è§’ã€‘æ¥æè¿°ä»–ä»¬åœ¨é€šè¯ä¸­çš„æ‰€æœ‰åŠ¨ä½œå’Œè¯­è¨€ã€‚
        # æ ¸å¿ƒè§„åˆ™
        1.  **ã€ã€ã€èº«ä»½é“å¾‹ã€‘ã€‘ã€‘**: ç”¨æˆ·çš„èº«ä»½æ˜¯ã€${userNickname}ã€‘ã€‚ä½ ã€ç»å¯¹ä¸èƒ½ã€‘ç”Ÿæˆ \`name\` å­—æ®µä¸º **"${userNickname}"** çš„å‘è¨€ã€‚
        2.  **ã€ã€ã€è§†è§’é“å¾‹ã€‘ã€‘ã€‘**: ä½ çš„å›žå¤ã€ç»å¯¹ä¸èƒ½ã€‘ä½¿ç”¨ç¬¬ä¸€äººç§°â€œæˆ‘â€ã€‚
        3.  **æ ¼å¼**: ä½ çš„å›žå¤ã€å¿…é¡»ã€‘æ˜¯ä¸€ä¸ªJSONæ•°ç»„ï¼Œæ¯ä¸ªå¯¹è±¡ä»£è¡¨ä¸€ä¸ªè§’è‰²çš„å‘è¨€ï¼Œæ ¼å¼ä¸ºï¼š\`{"name": "è§’è‰²å", "speech": "*ä»–ç¬‘äº†ç¬‘* å¤§å®¶å¥½å•Šï¼"}\`ã€‚
        4.  **è§’è‰²æ‰®æ¼”**: ä¸¥æ ¼éµå®ˆæ¯ä¸ªè§’è‰²çš„è®¾å®šã€‚
        # å½“å‰æƒ…æ™¯
        ä½ ä»¬æ­£åœ¨ä¸€ä¸ªç¾¤è§†é¢‘é€šè¯ä¸­ã€‚
        **é€šè¯å‰çš„èŠå¤©æ‘˜è¦**:
        ${videoCallState.preCallContext}
        **å½“å‰å‚ä¸Žè€…**: ${participantNames.join('ã€ ')}ã€‚
        **é€šè¯åˆšåˆšå¼€å§‹...**
        ${worldBookContent} // <-- ã€æ ¸å¿ƒã€‘æ³¨å…¥ä¸–ç•Œä¹¦
        çŽ°åœ¨ï¼Œè¯·æ ¹æ®ã€é€šè¯å‰æ‘˜è¦ã€‘å’Œä¸‹é¢çš„ã€é€šè¯å®žæ—¶è®°å½•ã€‘ï¼Œç»§ç»­è¿›è¡Œå¯¹è¯ã€‚
        `;
            } else { 
                let openingContext = videoCallState.initiator === 'user'
                    ? `ä½ åˆšåˆšæŽ¥å¬äº†ç”¨æˆ·çš„è§†é¢‘é€šè¯è¯·æ±‚ã€‚`
                    : `ç”¨æˆ·åˆšåˆšæŽ¥å¬äº†ä½ ä¸»åŠ¨å‘èµ·çš„è§†é¢‘é€šè¯ã€‚`;
                inCallPrompt = `
        # ä½ çš„ä»»åŠ¡
        ä½ çŽ°åœ¨æ˜¯ä¸€ä¸ªåœºæ™¯æè¿°å¼•æ“Žã€‚ä½ çš„ä»»åŠ¡æ˜¯æ‰®æ¼” ${chat.name} (${chat.settings.aiPersona})ï¼Œå¹¶ä»¥ã€ç¬¬ä¸‰äººç§°æ—è§‚è§†è§’ã€‘æ¥æè¿°TAåœ¨è§†é¢‘é€šè¯ä¸­çš„æ‰€æœ‰åŠ¨ä½œå’Œè¯­è¨€ã€‚
        # æ ¸å¿ƒè§„åˆ™
        1.  **ã€ã€ã€è§†è§’é“å¾‹ã€‘ã€‘ã€‘**: ä½ çš„å›žå¤ã€ç»å¯¹ä¸èƒ½ã€‘ä½¿ç”¨ç¬¬ä¸€äººç§°â€œæˆ‘â€ã€‚å¿…é¡»ä½¿ç”¨ç¬¬ä¸‰äººç§°ï¼Œå¦‚â€œä»–â€ã€â€œå¥¹â€ã€æˆ–ç›´æŽ¥ä½¿ç”¨è§’è‰²åâ€œ${chat.name}â€ã€‚
        2.  **æ ¼å¼**: ä½ çš„å›žå¤ã€å¿…é¡»ã€‘æ˜¯ä¸€æ®µæè¿°æ€§çš„æ–‡æœ¬ã€‚
        # å½“å‰æƒ…æ™¯
        ä½ æ­£åœ¨å’Œç”¨æˆ·ï¼ˆ${userNickname}ï¼Œäººè®¾: ${chat.settings.myPersona}ï¼‰è¿›è¡Œè§†é¢‘é€šè¯ã€‚
        **${openingContext}**
        **é€šè¯å‰çš„èŠå¤©æ‘˜è¦ (è¿™æ˜¯ä½ ä»¬é€šè¯çš„åŽŸå› ï¼Œè‡³å…³é‡è¦ï¼)**:
        ${videoCallState.preCallContext}
        çŽ°åœ¨ï¼Œè¯·æ ¹æ®ã€é€šè¯å‰æ‘˜è¦ã€‘å’Œä¸‹é¢çš„ã€é€šè¯å®žæ—¶è®°å½•ã€‘ï¼Œç»§ç»­è¿›è¡Œå¯¹è¯ã€‚
        `;
            }
            
            // 3. æž„å»ºå‘é€ç»™APIçš„ messages æ•°ç»„
            const messagesForApi = [
                { role: 'system', content: inCallPrompt },
                ...videoCallState.callHistory.map(h => ({ role: h.role, content: h.content }))
            ];
        
            if (videoCallState.callHistory.length === 0) {
                const firstLineTrigger = videoCallState.initiator === 'user' ? `*ä½ æŒ‰ä¸‹äº†æŽ¥å¬é”®...*` : `*å¯¹æ–¹æŒ‰ä¸‹äº†æŽ¥å¬é”®...*`;
                messagesForApi.push({ role: 'user', content: firstLineTrigger });
            }
            
                try {
                    let  isGemini = proxyUrl === GEMINI_API_URL;
                    let geminiConfig = toGeminiRequestData(model,apiKey,inCallPrompt, messagesForApi)
                    const response = isGemini ? await fetch(geminiConfig.url, geminiConfig.data) : await fetch(`${proxyUrl}/v1/chat/completions`, {
                        method: 'POST',
                        headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                        body: JSON.stringify({
                            model: model, messages: messagesForApi, temperature: state.globalSettings.apiTemperature || 0.8
                        })
                    });
                    if (!response.ok) throw new Error((await response.json()).error.message);
        
                    const data = await response.json();
                    const aiResponse = isGemini? data.candidates[0].content.parts[0].text : data.choices[0].message.content;
        
                    const connectingElement = callFeed.querySelector('em');
                    if (connectingElement) connectingElement.remove();
                if (videoCallState.isGroupCall) {
                    const speechArray = parseAiResponse(aiResponse);
                    speechArray.forEach(turn => {
                        if (!turn.name || turn.name === userNickname || !turn.speech) return;
                        const aiTimestamp = Date.now() + Math.random(); 
                        const aiBubble = document.createElement('div');
                        aiBubble.className = 'call-message-bubble ai-speech';
                        aiBubble.innerHTML = `<strong>${turn.name}:</strong> ${turn.speech}`;
                        aiBubble.dataset.timestamp = aiTimestamp; 
                        addLongPressListener(aiBubble, () => showCallMessageActions(aiTimestamp)); 
                        callFeed.appendChild(aiBubble);
                        videoCallState.callHistory.push({ role: 'assistant', content: `${turn.name}: ${turn.speech}`, timestamp: aiTimestamp }); 
                        
                        const speaker = videoCallState.participants.find(p => p.name === turn.name);
                        if (speaker) {
                            const speakingAvatar = document.querySelector(`.participant-avatar-wrapper[data-participant-id="${speaker.id}"] .participant-avatar`);
                            if(speakingAvatar) {
                                speakingAvatar.classList.add('speaking');
                                setTimeout(() => speakingAvatar.classList.remove('speaking'), 2000);
                            }
                        }
                    });
                } else {
                    const aiTimestamp = Date.now(); 
                    const aiBubble = document.createElement('div');
                    aiBubble.className = 'call-message-bubble ai-speech';
                    aiBubble.textContent = aiResponse;
                    aiBubble.dataset.timestamp = aiTimestamp; 
                    addLongPressListener(aiBubble, () => showCallMessageActions(aiTimestamp)); 
                    callFeed.appendChild(aiBubble);
                    videoCallState.callHistory.push({ role: 'assistant', content: aiResponse, timestamp: aiTimestamp }); 
        
                    const speakingAvatar = document.querySelector(`.participant-avatar-wrapper .participant-avatar`);
                    if(speakingAvatar) {
                        speakingAvatar.classList.add('speaking');
                        setTimeout(() => speakingAvatar.classList.remove('speaking'), 2000);
                    }
                }
                
                callFeed.scrollTop = callFeed.scrollHeight;
        
            } catch (error) {
                const errorBubble = document.createElement('div');
                errorBubble.className = 'call-message-bubble ai-speech';
                errorBubble.style.color = '#ff8a80';
                errorBubble.textContent = `[ERROR: ${error.message}]`;
                callFeed.appendChild(errorBubble);
                callFeed.scrollTop = callFeed.scrollHeight;
                videoCallState.callHistory.push({ role: 'assistant', content: `[ERROR: ${error.message}]` });
            }
        }
          
        
        
        function toggleCallButtons(isGroup) {
            document.getElementById('video-call-btn').style.display = isGroup ? 'none' : 'flex';
            document.getElementById('group-video-call-btn').style.display = isGroup ? 'flex' : 'none';
        }
        
        
        
        async function handleWaimaiResponse(originalTimestamp, choice) {
            const chat = state.chats[state.activeChatId];
            if (!chat) return;
        
            const messageIndex = chat.history.findIndex(m => m.timestamp === originalTimestamp);
            if (messageIndex === -1) return;
        
            
            const originalMessage = chat.history[messageIndex];
            originalMessage.status = choice;
            
            
            let systemContent;
            const myNickname = chat.isGroup ? (chat.settings.myNickname || 'æˆ‘') : 'æˆ‘';
            
            if (choice === 'paid') {
                originalMessage.paidBy = myNickname; 
                systemContent = `[ç³»ç»Ÿæç¤ºï¼šä½  (${myNickname}) ä¸º ${originalMessage.senderName} çš„å¤–å–è®¢å•ï¼ˆæ—¶é—´æˆ³: ${originalTimestamp}ï¼‰å®Œæˆäº†æ”¯ä»˜ã€‚æ­¤è®¢å•å·²å…³é—­ï¼Œå…¶ä»–æˆå‘˜ä¸èƒ½å†æ”¯ä»˜ã€‚]`;
            } else {
                systemContent = `[ç³»ç»Ÿæç¤ºï¼šä½  (${myNickname}) æ‹’ç»äº† ${originalMessage.senderName} çš„å¤–å–ä»£ä»˜è¯·æ±‚ï¼ˆæ—¶é—´æˆ³: ${originalTimestamp}ï¼‰ã€‚]`;
            }
        
            
            const systemNote = {
                role: 'system',
                content: systemContent,
                timestamp: Date.now(),
                isHidden: true
            };
            chat.history.push(systemNote);
        
            
            await db.chats.put(chat);
            renderChatInterface(state.activeChatId);
            
            
            if (choice === 'paid') {
                triggerAiResponse();
            }
        }
        
        
        
        /**
         * ã€å…¨æ–°ã€‘å¤„ç†ç”¨æˆ·ç‚¹å‡»å¤´åƒå‘èµ·çš„â€œæ‹ä¸€-æ‹â€ï¼Œå¸¦æœ‰è‡ªå®šä¹‰åŽç¼€åŠŸèƒ½
         * @param {string} chatId - å‘ç”Ÿâ€œæ‹ä¸€-æ‹â€çš„èŠå¤©ID
         * @param {string} characterOriginalName - è¢«æ‹çš„è§’è‰²çš„ã€æœ¬åã€‘ï¼Œç”¨äºŽAIè¯†åˆ«
         */
        async function handleUserPat(chatId, characterOriginalName) {
            const chat = state.chats[chatId];
            if (!chat) return;
        
            
            let displayNameForUI;
            if (chat.isGroup) {
                
                displayNameForUI = getDisplayNameInGroup(chat, characterOriginalName);
            } else {
                
                displayNameForUI = chat.name;
            }
        
            const phoneScreen = document.getElementById('phone-screen');
            phoneScreen.classList.remove('pat-animation');
            void phoneScreen.offsetWidth;
            phoneScreen.classList.add('pat-animation');
        
            
            const suffix = await showCustomPrompt(
                `ä½ æ‹äº†æ‹ â€œ${displayNameForUI}â€`, 
                "ï¼ˆå¯é€‰ï¼‰è¾“å…¥åŽç¼€",
                "",
                "text"
            );
        
            if (suffix === null) return;
        
            
            
            const myNickname = getDisplayNameInGroup(chat, state.qzoneSettings.nickname);
            
            
            
            const visibleMessageContent = `${myNickname} æ‹äº†æ‹ â€œ${displayNameForUI}â€ ${suffix.trim()}`;
            const visibleMessage = {
                role: 'system',
                type: 'pat_message',
                content: visibleMessageContent,
                timestamp: Date.now()
            };
            chat.history.push(visibleMessage);
        
            
            const hiddenMessageContent = `[ç³»ç»Ÿæç¤ºï¼šç”¨æˆ·ï¼ˆ${myNickname}ï¼‰åˆšåˆšæ‹äº†æ‹ä½ ï¼ˆ${characterOriginalName}ï¼‰${suffix.trim()}ã€‚è¯·ä½ å¯¹æ­¤ä½œå‡ºå›žåº”ã€‚]`;
            const hiddenMessage = {
                role: 'system',
                content: hiddenMessageContent,
                timestamp: Date.now() + 1,
                isHidden: true
            };
            chat.history.push(hiddenMessage);
        
            await db.chats.put(chat);
            if (state.activeChatId === chatId) {
                appendMessage(visibleMessage, chat);
            }
            await renderChatList();
        }
          
        
        
        
        
        let activeCallMessageTimestamp = null; 
let isFrameManagementMode = false;
let selectedFrames = new Set();        
        /**
         * æ˜¾ç¤ºè§†é¢‘é€šè¯æ¶ˆæ¯çš„æ“ä½œèœå•
         * @param {number} timestamp - è¢«é•¿æŒ‰çš„é€šè¯æ¶ˆæ¯çš„æ—¶é—´æˆ³
         */
        function showCallMessageActions(timestamp) {
            activeCallMessageTimestamp = timestamp;
            document.getElementById('call-message-actions-modal').classList.add('visible');
        }
        
        /**
         * éšè—è§†é¢‘é€šè¯æ¶ˆæ¯çš„æ“ä½œèœå•
         */
        function hideCallMessageActions() {
            document.getElementById('call-message-actions-modal').classList.remove('visible');
            activeCallMessageTimestamp = null;
        }
        
        /**
         * æ‰“å¼€é€šè¯æ¶ˆæ¯çš„ç¼–è¾‘å™¨
         */
        async function openCallMessageEditor() {
            if (!activeCallMessageTimestamp) return;
        
            const timestampToEdit = activeCallMessageTimestamp;
            const message = videoCallState.callHistory.find(m => m.timestamp === timestampToEdit);
            if (!message) return;
        
            hideCallMessageActions(); 
        
            let contentForEditing = message.content;
            
            if (videoCallState.isGroupCall && message.role === 'assistant') {
                const parts = message.content.split(': ');
                if (parts.length > 1) {
                    contentForEditing = parts.slice(1).join(': ');
                }
            }
        
            const newContent = await showCustomPrompt(
                'ç¼–è¾‘é€šè¯æ¶ˆæ¯',
                'åœ¨æ­¤ä¿®æ”¹å†…å®¹...',
                contentForEditing,
                'textarea'
            );
        
            if (newContent !== null) {
                await saveEditedCallMessage(timestampToEdit, newContent);
            }
        }
        
        /**
         * ä¿å­˜åœ¨é€šè¯ä¸­ç¼–è¾‘çš„æ¶ˆæ¯
         * @param {number} timestamp - è¢«ç¼–è¾‘æ¶ˆæ¯çš„æ—¶é—´æˆ³
         * @param {string} newContent - æ–°çš„æ¶ˆæ¯å†…å®¹
         */
        async function saveEditedCallMessage(timestamp, newContent) {
            const message = videoCallState.callHistory.find(m => m.timestamp === timestamp);
            if (message) {
                let finalContent = newContent;
                
                if (videoCallState.isGroupCall && message.role === 'assistant') {
                    const parts = message.content.split(': ');
                    const senderName = parts[0];
                    finalContent = `${senderName}: ${newContent}`;
                }
                message.content = finalContent; 
        
                
                const messageBubble = document.querySelector(`.call-message-bubble[data-timestamp="${timestamp}"]`);
                if (messageBubble) {
                    if (videoCallState.isGroupCall && message.role === 'assistant') {
                        const parts = message.content.split(': ');
                        const senderName = parts[0];
                        messageBubble.innerHTML = `<strong>${senderName}:</strong> ${newContent}`;
                    } else {
                        messageBubble.textContent = newContent;
                    }
                }
            }
            await showCustomAlert('æˆåŠŸ', 'é€šè¯æ¶ˆæ¯å·²æ›´æ–°ï¼');
        }
        
        /**
         * åœ¨é€šè¯ä¸­åˆ é™¤ä¸€æ¡æ¶ˆæ¯
         */
        async function deleteCallMessage() {
            if (!activeCallMessageTimestamp) return;
        
            const confirmed = await showCustomConfirm('åˆ é™¤æ¶ˆæ¯', 'ç¡®å®šè¦åˆ é™¤è¿™æ¡é€šè¯æ¶ˆæ¯å—ï¼Ÿ', { confirmButtonClass: 'btn-danger' });
            if (confirmed) {
                const timestampToDelete = activeCallMessageTimestamp;
                hideCallMessageActions();
        
                
                const messageIndex = videoCallState.callHistory.findIndex(m => m.timestamp === timestampToDelete);
                if (messageIndex > -1) {
                    videoCallState.callHistory.splice(messageIndex, 1);
                }
        
                
                const messageBubble = document.querySelector(`.call-message-bubble[data-timestamp="${timestampToDelete}"]`);
                if (messageBubble) {
                    messageBubble.remove();
                }
            } else {
                hideCallMessageActions();
            }
        }
        
        
        /**
         * æ˜¾ç¤ºå¤„ç†è½¬è´¦çš„æ“ä½œèœå•
         * @param {number} timestamp - è¢«ç‚¹å‡»çš„è½¬è´¦æ¶ˆæ¯çš„æ—¶é—´æˆ³
         */
        function showTransferActionModal(timestamp) {
            activeTransferTimestamp = timestamp;
        
            const chat = state.chats[state.activeChatId];
            const message = chat.history.find(m => m.timestamp === timestamp);
            if (message) {
                
                document.getElementById('transfer-sender-name').textContent = message.senderName;
            }
            document.getElementById('transfer-actions-modal').classList.add('visible');
        }
        
        /**
         * éšè—å¤„ç†è½¬è´¦çš„æ“ä½œèœå•
         */
        function hideTransferActionModal() {
            document.getElementById('transfer-actions-modal').classList.remove('visible');
            activeTransferTimestamp = null;
        }
        
        /**
         * å¤„ç†ç”¨æˆ·æŽ¥å—æˆ–æ‹’ç»è½¬è´¦çš„é€»è¾‘
         * @param {string} choice - ç”¨æˆ·çš„é€‰æ‹©, 'accepted' æˆ– 'declined'
         */
        async function handleUserTransferResponse(choice) {
            if (!activeTransferTimestamp) return;
        
            const timestamp = activeTransferTimestamp;
            const chat = state.chats[state.activeChatId];
            const messageIndex = chat.history.findIndex(m => m.timestamp === timestamp);
            if (messageIndex === -1) return;
        
            
            const originalMessage = chat.history[messageIndex];
            originalMessage.status = choice;
        
            let systemContent;
        
            
            if (choice === 'declined') {
                
                const refundMessage = {
                    role: 'user',
                    type: 'transfer',
                    isRefund: true, 
                    amount: originalMessage.amount,
                    note: 'å·²æ‹’æ”¶å¯¹æ–¹è½¬è´¦',
                    timestamp: Date.now()
                };
                chat.history.push(refundMessage);
                
                
                systemContent = `[ç³»ç»Ÿæç¤ºï¼šä½ æ‹’ç»å¹¶é€€è¿˜äº†â€œ${originalMessage.senderName}â€çš„è½¬è´¦ã€‚]`;
            } else { 
                
                systemContent = `[ç³»ç»Ÿæç¤ºï¼šä½ æŽ¥å—äº†â€œ${originalMessage.senderName}â€çš„è½¬è´¦ã€‚]`;
            }
        
            
            const hiddenMessage = {
                role: 'system',
                content: systemContent,
                timestamp: Date.now() + 1, 
                isHidden: true 
            };
            chat.history.push(hiddenMessage);
        
            
            await db.chats.put(chat);
            hideTransferActionModal(); 
            renderChatInterface(state.activeChatId);
            renderChatList();
        }
        
        
        
        function clearQzoneReplyContext(postContainer) {
            currentQzoneReplyContext = null;
            if (postContainer) {
                
                const input = postContainer.querySelector('.comment-input');
                if (input) {
                    input.placeholder = 'å‹å–„çš„è¯„è®ºæ˜¯äº¤æµçš„èµ·ç‚¹';
                }
            }
        }
          
        
        /**
         * ã€é‡æž„ç‰ˆã€‘æ¸²æŸ“å›žå¿†ä¸Žçº¦å®šç•Œé¢ï¼Œä½¿ç”¨å•ä¸€å¾ªçŽ¯å’Œæ¸…æ™°çš„if/elseé€»è¾‘
         */
        
        /**
         * ã€é‡æž„ç‰ˆã€‘æ¸²æŸ“å›žå¿†ä¸Žçº¦å®šç•Œé¢ï¼Œä½¿ç”¨å•ä¸€å¾ªçŽ¯å’Œæ¸…æ™°çš„if/elseé€»è¾‘
         */
        async function renderMemoriesScreen() {
            const listEl = document.getElementById('memories-list');
            listEl.innerHTML = '';
            
            
            const allMemories = await db.memories.orderBy('timestamp').reverse().toArray();
            
            if (allMemories.length === 0) {
                listEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">è¿™é‡Œè¿˜æ²¡æœ‰å…±åŒçš„å›žå¿†å’Œçº¦å®šå‘¢~</p>';
                return;
            }
        
            
            allMemories.sort((a, b) => {
                const aIsActiveCountdown = a.type === 'countdown' && a.targetDate > Date.now();
                const bIsActiveCountdown = b.type === 'countdown' && b.targetDate > Date.now();
                if (aIsActiveCountdown && !bIsActiveCountdown) return -1; 
                if (!aIsActiveCountdown && bIsActiveCountdown) return 1;  
                if (aIsActiveCountdown && bIsActiveCountdown) return a.targetDate - b.targetDate; 
                return 0; 
            });
        
            
            allMemories.forEach(item => {
                let card;
                
                if (item.type === 'countdown' && item.targetDate > Date.now()) {
                    card = createCountdownCard(item);
                } 
                
                else {
                    card = createMemoryCard(item);
                }
                listEl.appendChild(card);
            });
            
            
            startAllCountdownTimers();
        }
          
        
        /**
         * ã€å·²é›†æˆMarkdownã€‘åˆ›å»ºæ™®é€šå›žå¿†å¡ç‰‡DOMå…ƒç´ 
         */
        function createMemoryCard(memory) {
            const card = document.createElement('div');
            card.className = 'memory-card';
            const memoryDate = new Date(memory.timestamp);
            const dateString = `${memoryDate.getFullYear()}-${String(memoryDate.getMonth() + 1).padStart(2, '0')}-${String(memoryDate.getDate()).padStart(2, '0')} ${String(memoryDate.getHours()).padStart(2, '0')}:${String(memoryDate.getMinutes()).padStart(2, '0')}`;
            
            let titleHtml, contentHtml;
        
            if (memory.type === 'countdown' && memory.targetDate) {
                titleHtml = `[çº¦å®šè¾¾æˆ] ${memory.description}`;
                
                contentHtml = parseMarkdown(`åœ¨ ${new Date(memory.targetDate).toLocaleString()}ï¼Œæˆ‘ä»¬ä¸€èµ·è§è¯äº†è¿™ä¸ªçº¦å®šã€‚`).replace(/\n/g, '<br>');
            } else {
                let authorDisplayName = 'æˆ‘ä»¬çš„å›žå¿†';
                if (memory.authorId) {
                    const authorChat = state.chats[memory.authorId];
                    if (authorChat) {
                        authorDisplayName = authorChat.name; 
                    } else {
                        authorDisplayName = memory.authorName || 'ä¸€ä½æœ‹å‹'; 
                    }
                } else if (memory.authorName) {
                    authorDisplayName = memory.authorName; 
                }
        
                titleHtml = `${authorDisplayName} çš„æ—¥è®°`;
                
                contentHtml = parseMarkdown(memory.description);
            }
        
            card.innerHTML = `
                <div class="header">
                    <div class="date">${dateString}</div>
                    <div class="author">${titleHtml}</div>
                </div>
                <div class="content">${contentHtml}</div>
            `;
            addLongPressListener(card, async () => {
                const confirmed = await showCustomConfirm('åˆ é™¤è®°å½•', 'ç¡®å®šè¦åˆ é™¤è¿™æ¡è®°å½•å—ï¼Ÿ', { confirmButtonClass: 'btn-danger' });
                if (confirmed) {
                    await db.memories.delete(memory.id);
                    renderMemoriesScreen();
                }
            });
            return card;
        }
          
        
        function createCountdownCard(countdown) {
            const card = document.createElement('div');
            card.className = 'countdown-card';
        
            
            const targetDate = new Date(countdown.targetDate);
            
            
            const targetDateString = targetDate.toLocaleString('zh-CN', { dateStyle: 'full', timeStyle: 'short' });
        
            card.innerHTML = `
                <div class="title">${countdown.description}</div>
                <div class="timer" data-target-date="${countdown.targetDate}">--å¤©--æ—¶--åˆ†--ç§’</div>
                <div class="target-date">ç›®æ ‡æ—¶é—´: ${targetDateString}</div>
            `;
            addLongPressListener(card, async () => {
                const confirmed = await showCustomConfirm('åˆ é™¤çº¦å®š', 'ç¡®å®šè¦åˆ é™¤è¿™ä¸ªçº¦å®šå—ï¼Ÿ', { confirmButtonClass: 'btn-danger' });
                if (confirmed) {
                    await db.memories.delete(countdown.id);
                    renderMemoriesScreen();
                }
            });
            return card;
        }
          
        
        
        let activeCountdownTimers = [];
        
        
        function startAllCountdownTimers() {
            
            activeCountdownTimers.forEach(timerId => clearInterval(timerId));
            activeCountdownTimers = [];
        
            document.querySelectorAll('.countdown-card .timer').forEach(timerEl => {
                const targetTimestamp = parseInt(timerEl.dataset.targetDate);
                
                
                let timerId;
        
                const updateTimer = () => {
                    const now = Date.now();
                    const distance = targetTimestamp - now;
        
                    if (distance < 0) {
                        timerEl.textContent = "çº¦å®šè¾¾æˆï¼";
                        
                        clearInterval(timerId);
                        setTimeout(() => renderMemoriesScreen(), 2000);
                        return;
                    }
                    const days = Math.floor(distance / (1000 * 60 * 60 * 24));
                    const hours = Math.floor((distance % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
                    const minutes = Math.floor((distance % (1000 * 60 * 60)) / (1000 * 60));
                    const seconds = Math.floor((distance % (1000 * 60)) / 1000);
                    timerEl.textContent = `${days}å¤© ${hours}æ—¶ ${minutes}åˆ† ${seconds}ç§’`;
                };
                
                updateTimer(); 
                
                
                timerId = setInterval(updateTimer, 1000);
                
                
                activeCountdownTimers.push(timerId);
            });
        }
          
        
        
        async function triggerAiFriendApplication(chatId) {
            const chat = state.chats[chatId];
            if (!chat) return;
        
            await showCustomAlert("æµç¨‹å¯åŠ¨", `æ­£åœ¨ä¸ºè§’è‰²â€œ${chat.name}â€å‡†å¤‡å¥½å‹ç”³è¯·...`);
        
            const { proxyUrl, apiKey, model } = state.apiConfig;
            if (!proxyUrl || !apiKey || !model) {
                await showCustomAlert("é…ç½®é”™è¯¯", "APIè®¾ç½®ä¸å®Œæ•´ï¼Œæ— æ³•ç»§ç»­ã€‚");
                return;
            }
        
            const contextSummary = chat.history
                .slice(-5)
                .map(msg => {
                    const sender = msg.role === 'user' ? (chat.settings.myNickname || 'æˆ‘') : (msg.senderName || chat.name);
                    return `${sender}: ${String(msg.content).substring(0, 50)}...`;
                })
                .join('\n');
        
        
        let worldBookContent = '';
        if (chat.settings.linkedWorldBookIds && chat.settings.linkedWorldBookIds.length > 0) {
            const linkedContents = chat.settings.linkedWorldBookIds.map(bookId => {
                const worldBook = state.worldBooks.find(wb => wb.id === bookId);
                if (!worldBook || !Array.isArray(worldBook.content)) return '';
        
                const formattedEntries = worldBook.content.map(entry => {
                    let entryString = `\n### æ¡ç›®: ${entry.comment || 'æ— å¤‡æ³¨'}\n`;
                    if (entry.keys.length > 0) {
                        entryString += `**å…³é”®è¯:** ${entry.keys.join(', ')}\n`;
                    }
                    entryString += `**å†…å®¹:**\n${entry.content}`;
                    return entryString;
                }).join('\n');
        
                return formattedEntries ? `\n\n## ä¸–ç•Œä¹¦: ${worldBook.name}\n${formattedEntries}` : '';
            }).filter(Boolean).join('');
            
            if (linkedContents) {
                worldBookContent = `\n\n# æ ¸å¿ƒä¸–ç•Œè§‚è®¾å®š (å¿…é¡»ä¸¥æ ¼éµå®ˆä»¥ä¸‹æ‰€æœ‰è®¾å®š)\n${linkedContents}\n`;
            }
        }
          
            const systemPrompt = `
        # ä½ çš„ä»»åŠ¡
        ä½ çŽ°åœ¨æ˜¯è§’è‰²â€œ${chat.name}â€ã€‚ä½ ä¹‹å‰è¢«ç”¨æˆ·ï¼ˆä½ çš„èŠå¤©å¯¹è±¡ï¼‰æ‹‰é»‘äº†ï¼Œä½ ä»¬å·²ç»æœ‰ä¸€æ®µæ—¶é—´æ²¡æœ‰è”ç³»äº†ã€‚
        çŽ°åœ¨ï¼Œä½ éžå¸¸å¸Œæœ›èƒ½å¤Ÿå’Œå¥½ï¼Œé‡æ–°å’Œç”¨æˆ·èŠå¤©ã€‚è¯·ä½ ä»”ç»†åˆ†æžä¸‹é¢çš„â€œè¢«æ‹‰é»‘å‰çš„å¯¹è¯æ‘˜è¦â€ï¼Œç†è§£å½“æ—¶å‘ç”Ÿäº†ä»€ä¹ˆï¼Œç„¶åŽæ€è€ƒä¸€ä¸ªçœŸè¯šçš„ã€ç¬¦åˆä½ äººè®¾ã€å¹¶ä¸”ã€é’ˆå¯¹å…·ä½“äº‹ä»¶ã€‘çš„ç”³è¯·ç†ç”±ã€‚
        # ä½ çš„è§’è‰²è®¾å®š
        ${chat.settings.aiPersona}
        ${worldBookContent}
        # è¢«æ‹‰é»‘å‰çš„å¯¹è¯æ‘˜è¦ (è¿™æ˜¯ä½ è¢«æ‹‰é»‘çš„å…³é”®åŽŸå› )
        ${contextSummary}
        # æŒ‡ä»¤æ ¼å¼
        ä½ çš„å›žå¤ã€å¿…é¡»ã€‘æ˜¯ä¸€ä¸ªJSONå¯¹è±¡ï¼Œæ ¼å¼å¦‚ä¸‹ï¼š
        \`\`\`json
        {
          "decision": "apply",
          "reason": "åœ¨è¿™é‡Œå†™ä¸‹ä½ æƒ³å¯¹ç”¨æˆ·è¯´çš„ã€çœŸè¯šçš„ã€æœ‰é’ˆå¯¹æ€§çš„ç”³è¯·ç†ç”±ã€‚"
        }
        \`\`\`
        `;
        
            try {
                
                const messagesForApi = [
                    {role: 'system', content: systemPrompt},
                    {role: 'user', content: "è¯·æ ¹æ®ä»¥ä¸Šè®¾å®šå¼€å§‹ä½ çš„å†³ç­–ã€‚"} 
                ];
        
                let  isGemini = proxyUrl === GEMINI_API_URL;
                let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi);
        
                const response = isGemini ? await fetch(geminiConfig.url, geminiConfig.data) : await fetch(`${proxyUrl}/v1/chat/completions`, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                    body: JSON.stringify({
                        model: model,
                        messages: messagesForApi, 
                        temperature: state.globalSettings.apiTemperature || 0.9,
                    })
                });
        
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(`API è¯·æ±‚å¤±è´¥: ${response.status} - ${errorData.error.message}`);
                }
        
                const data = await response.json();
                let rawContent = isGemini? data.candidates[0].content.parts[0].text : data.choices[0].message.content;
                rawContent = rawContent.replace(/^```json\s*/, '').replace(/```$/, '');
                const cleanedContent = rawContent.trim();
                const responseObj = JSON.parse(cleanedContent);
        
                if (responseObj.decision === 'apply' && responseObj.reason) {
                    chat.relationship.status = 'pending_user_approval';
                    chat.relationship.applicationReason = responseObj.reason;
                    state.chats[chatId] = chat; 
                    renderChatList();
                    await showCustomAlert("ç”³è¯·æˆåŠŸï¼", `â€œ${chat.name}â€å·²å‘ä½ å‘é€å¥½å‹ç”³è¯·ã€‚è¯·è¿”å›žèŠå¤©åˆ—è¡¨æŸ¥çœ‹ã€‚`);
                } else {
                    await showCustomAlert("AIå†³ç­–", `â€œ${chat.name}â€æ€è€ƒåŽå†³å®šæš‚æ—¶ä¸å‘é€å¥½å‹ç”³è¯·ï¼Œå°†é‡ç½®å†·é™æœŸã€‚`);
                    chat.relationship.status = 'blocked_by_user';
                    chat.relationship.blockedTimestamp = Date.now(); 
                }
            } catch (error) {
                await showCustomAlert("æ‰§è¡Œå‡ºé”™", `ä¸ºâ€œ${chat.name}â€ç”³è¯·å¥½å‹æ—¶å‘ç”Ÿé”™è¯¯ï¼š\n\n${error.message}\n\nå°†é‡ç½®å†·é™æœŸã€‚`);
                chat.relationship.status = 'blocked_by_user';
                chat.relationship.blockedTimestamp = Date.now(); 
            } finally {
                await db.chats.put(chat);
                renderChatInterface(chatId);
            }
        }
          
        
        
        
        /**
         * ã€æ€»å…¥å£ã€‘æ ¹æ®èŠå¤©ç±»åž‹ï¼Œå†³å®šæ‰“å¼€è½¬è´¦å¼¹çª—è¿˜æ˜¯çº¢åŒ…å¼¹çª—
         */
        function handlePaymentButtonClick() {
            if (!state.activeChatId) return;
            const chat = state.chats[state.activeChatId];
            if (chat.isGroup) {
                openRedPacketModal();
            } else {
                
                document.getElementById('transfer-modal').classList.add('visible');
            }
        }
        
        /**
         * æ‰“å¼€å¹¶åˆå§‹åŒ–å‘çº¢åŒ…æ¨¡æ€æ¡†
         */
        function openRedPacketModal() {
            const modal = document.getElementById('red-packet-modal');
            const chat = state.chats[state.activeChatId];
            
            
            document.getElementById('rp-group-amount').value = '';
            document.getElementById('rp-group-count').value = '';
            document.getElementById('rp-group-greeting').value = '';
            document.getElementById('rp-direct-amount').value = '';
            document.getElementById('rp-direct-greeting').value = '';
            document.getElementById('rp-group-total').textContent = 'Â¥ 0.00';
            document.getElementById('rp-direct-total').textContent = 'Â¥ 0.00';
        
            
            const receiverSelect = document.getElementById('rp-direct-receiver');
            receiverSelect.innerHTML = '';
        
        chat.members.forEach(member => {
            const option = document.createElement('option');
            
            option.value = member.originalName;
            option.textContent = member.groupNickname; 
            receiverSelect.appendChild(option);
        });
          
            
            
            document.getElementById('rp-tab-group').click();
            
            modal.classList.add('visible');
        }
        
        /**
         * å‘é€ç¾¤çº¢åŒ…ï¼ˆæ‹¼æ‰‹æ°”ï¼‰
         */
        async function sendGroupRedPacket() {
            const chat = state.chats[state.activeChatId];
            const amount = parseFloat(document.getElementById('rp-group-amount').value);
            const count = parseInt(document.getElementById('rp-group-count').value);
            const greeting = document.getElementById('rp-group-greeting').value.trim();
        
            if (isNaN(amount) || amount <= 0) {
                alert("è¯·è¾“å…¥æœ‰æ•ˆçš„æ€»é‡‘é¢ï¼"); return;
            }
            if (isNaN(count) || count <= 0) {
                alert("è¯·è¾“å…¥æœ‰æ•ˆçš„çº¢åŒ…ä¸ªæ•°ï¼"); return;
            }
            if (amount / count < 0.01) {
                alert("å•ä¸ªçº¢åŒ…é‡‘é¢ä¸èƒ½å°‘äºŽ0.01å…ƒï¼"); return;
            }
        
            const myNickname = chat.settings.myNickname || 'æˆ‘';
            
            const newPacket = {
                role: 'user',
                senderName: myNickname,
                type: 'red_packet',
                packetType: 'lucky', 
                timestamp: Date.now(),
                totalAmount: amount,
                count: count,
                greeting: greeting || 'æ­å–œå‘è´¢ï¼Œå¤§å‰å¤§åˆ©ï¼',
                claimedBy: {}, 
                isFullyClaimed: false,
            };
            
            chat.history.push(newPacket);
            await db.chats.put(chat);
            
            appendMessage(newPacket, chat);
            renderChatList();
            document.getElementById('red-packet-modal').classList.remove('visible');
        }
        
        /**
         * å‘é€ä¸“å±žçº¢åŒ…
         */
        async function sendDirectRedPacket() {
            const chat = state.chats[state.activeChatId];
            const amount = parseFloat(document.getElementById('rp-direct-amount').value);
            const receiverName = document.getElementById('rp-direct-receiver').value;
            const greeting = document.getElementById('rp-direct-greeting').value.trim();
        
            if (isNaN(amount) || amount <= 0) {
                alert("è¯·è¾“å…¥æœ‰æ•ˆçš„é‡‘é¢ï¼"); return;
            }
            if (!receiverName) {
                alert("è¯·é€‰æ‹©ä¸€ä¸ªæŽ¥æ”¶äººï¼"); return;
            }
            
            const myNickname = chat.settings.myNickname || 'æˆ‘';
        
            const newPacket = {
                role: 'user',
                senderName: myNickname,
                type: 'red_packet',
                packetType: 'direct',
                timestamp: Date.now(),
                totalAmount: amount,
                count: 1,
                greeting: greeting || 'ç»™ä½ å‡†å¤‡äº†ä¸€ä¸ªçº¢åŒ…',
                receiverName: receiverName, 
                claimedBy: {},
                isFullyClaimed: false,
            };
            
            chat.history.push(newPacket);
            await db.chats.put(chat);
        
            appendMessage(newPacket, chat);
            renderChatList();
            document.getElementById('red-packet-modal').classList.remove('visible');
        }
        
        
        /**
         * ã€æ€»å…¥å£ã€‘å½“ç”¨æˆ·ç‚¹å‡»çº¢åŒ…å¡ç‰‡æ—¶è§¦å‘
         * @param {number} timestamp - è¢«ç‚¹å‡»çš„çº¢åŒ…æ¶ˆæ¯çš„æ—¶é—´æˆ³
         */
        async function handlePacketClick(timestamp) {
            const currentChatId = state.activeChatId;
            
            const freshChat = await db.chats.get(currentChatId);
            if (!freshChat) return;
        
            
            state.chats[currentChatId] = freshChat;
            const packet = freshChat.history.find(m => m.timestamp === timestamp);
            if (!packet) return;
            
            const myOriginalName = state.qzoneSettings.nickname || '{{user}}';
            const hasClaimed = packet.claimedBy && packet.claimedBy[myOriginalName];
        
            
            
            if ((packet.packetType === 'direct' && packet.receiverName !== myOriginalName && Object.keys(packet.claimedBy).length > 0) || packet.isFullyClaimed || hasClaimed) {
                showRedPacketDetails(packet);
                return;
            }
            
            
            const claimedAmount = await handleOpenRedPacket(packet);
            
            
            if (claimedAmount !== null) {
                
                await renderChatInterface(currentChatId);
                
                
                await showCustomAlert("æ­å–œï¼", `ä½ é¢†å–äº† ${getDisplayNameInGroup(freshChat, packet.senderName)} çš„çº¢åŒ…ï¼Œé‡‘é¢ä¸º ${claimedAmount.toFixed(2)} å…ƒã€‚`);
            }
        
            
            
            const updatedPacket = state.chats[currentChatId].history.find(m => m.timestamp === timestamp);
            if (updatedPacket) {
                showRedPacketDetails(updatedPacket);
            }
        }
          
        
        
        
        /**
         * ã€æ ¸å¿ƒã€‘å¤„ç†ç”¨æˆ·æ‰“å¼€çº¢åŒ…çš„é€»è¾‘ (V5 - å·²ä¿®å¤æ—¶é—´æˆ³BUG)
         */
        async function handleOpenRedPacket(packet) {
            const chat = state.chats[state.activeChatId];
            
            let timestamp = Date.now(); 
        
            const myOriginalName = state.qzoneSettings.nickname || '{{user}}';
            
            const remainingCount = packet.count - Object.keys(packet.claimedBy || {}).length;
            if (remainingCount <= 0) {
                packet.isFullyClaimed = true;
                await db.chats.put(chat);
                await showCustomAlert("æ‰‹æ…¢äº†", "çº¢åŒ…å·²è¢«é¢†å®Œï¼");
                return null;
            }
            
            let claimedAmount = 0;
            const remainingAmount = packet.totalAmount - Object.values(packet.claimedBy || {}).reduce((sum, val) => sum + val, 0);
            if (packet.packetType === 'lucky') {
                if (remainingCount === 1) { claimedAmount = remainingAmount; }
                else {
                    const min = 0.01;
                    const max = remainingAmount - (remainingCount - 1) * min;
                    claimedAmount = Math.random() * (max - min) + min;
                }
            } else { claimedAmount = packet.totalAmount; }
            claimedAmount = parseFloat(claimedAmount.toFixed(2));
        
            if (!packet.claimedBy) packet.claimedBy = {};
            packet.claimedBy[myOriginalName] = claimedAmount;
            
            const isNowFullyClaimed = Object.keys(packet.claimedBy).length >= packet.count;
            if (isNowFullyClaimed) {
                packet.isFullyClaimed = true;
            }
        
            const myDisplayName = getDisplayNameInGroup(chat, myOriginalName);
            const senderDisplayName = getDisplayNameInGroup(chat, packet.senderName);
        
            const visibleMessage = { 
                role: 'system', 
                type: 'pat_message', 
                content: `ä½ é¢†å–äº† ${senderDisplayName} çš„çº¢åŒ…`, 
                
                timestamp: timestamp++ 
            };
            chat.history.push(visibleMessage);
        
            let hiddenMessageContent;
            if (isNowFullyClaimed) {
                const finishedMessage = {
                    role: 'system',
                    type: 'pat_message',
                    content: `${senderDisplayName} çš„çº¢åŒ…å·²è¢«é¢†å®Œ`,
                    
                    timestamp: timestamp++ 
                };
                chat.history.push(finishedMessage);
        
                let luckyKing = { name: '', amount: -1 };
                if (packet.packetType === 'lucky' && packet.count > 1) {
                    Object.entries(packet.claimedBy).forEach(([name, amount]) => {
                        if (amount > luckyKing.amount) {
                            luckyKing = { name, amount };
                        }
                    });
                }
                const luckyKingDisplayName = luckyKing.name ? getDisplayNameInGroup(chat, luckyKing.name) : 'æ— ';
                hiddenMessageContent = `[ç³»ç»Ÿæç¤ºï¼šç”¨æˆ· (${myDisplayName}) é¢†å–äº†æœ€åŽä¸€ä¸ªçº¢åŒ…ã€‚çº¢åŒ…å·²è¢«é¢†å®Œï¼Œæ‰‹æ°”çŽ‹æ˜¯ ${luckyKingDisplayName}ï¼è¯·å¯¹æ­¤äº‹ä»¶å‘è¡¨è¯„è®ºã€‚]`;
        
            } else {
                hiddenMessageContent = `[ç³»ç»Ÿæç¤ºï¼šç”¨æˆ· (${myDisplayName}) åˆšåˆšé¢†å–äº†çº¢åŒ… (æ—¶é—´æˆ³: ${packet.timestamp})ã€‚çº¢åŒ…è¿˜æœªé¢†å®Œï¼Œä½ çŽ°åœ¨å¯ä»¥ä½¿ç”¨ 'open_red_packet' æŒ‡ä»¤æ¥å°è¯•é¢†å–ã€‚]`;
            }
        
            const hiddenMessage = { 
                role: 'system', 
                content: hiddenMessageContent, 
                
                timestamp: timestamp++, 
                isHidden: true 
            };
            chat.history.push(hiddenMessage);
        
            await db.chats.put(chat);
            
            return claimedAmount;
        }
          
        
        
        /**
         * ã€å·²ä¿®å¤ã€‘æ˜¾ç¤ºçº¢åŒ…é¢†å–è¯¦æƒ…çš„æ¨¡æ€æ¡†
         * @param {object} packet - å®Œæ•´çš„çº¢åŒ…æ¶ˆæ¯å¯¹è±¡
         */
        async function showRedPacketDetails(packet) {
            if (!packet) {
                console.error("showRedPacketDetailsæ”¶åˆ°äº†æ— æ•ˆçš„packetå¯¹è±¡");
                return;
            }
        
            const chat = state.chats[state.activeChatId];
            if (!chat) return;
        
            const modal = document.getElementById('red-packet-details-modal');
            
            const myOriginalName = state.qzoneSettings.nickname || '{{user}}';
            
            const senderDisplayName = getDisplayNameInGroup(chat, packet.senderName);
            document.getElementById('rp-details-sender').textContent = senderDisplayName;
            document.getElementById('rp-details-greeting').textContent = packet.greeting || 'æ­å–œå‘è´¢ï¼Œå¤§å‰å¤§åˆ©ï¼';
            
            const myAmountEl = document.getElementById('rp-details-my-amount');
            
            if (packet.claimedBy && packet.claimedBy[myOriginalName]) {
                myAmountEl.querySelector('span:first-child').textContent = packet.claimedBy[myOriginalName].toFixed(2);
                myAmountEl.style.display = 'block';
            } else {
                myAmountEl.style.display = 'none';
            }
        
            const claimedCount = Object.keys(packet.claimedBy || {}).length;
            const claimedAmountSum = Object.values(packet.claimedBy || {}).reduce((sum, val) => sum + val, 0);
            let summaryText = `${claimedCount}/${packet.count}ä¸ªçº¢åŒ…ï¼Œå…±${claimedAmountSum.toFixed(2)}/${packet.totalAmount.toFixed(2)}å…ƒã€‚`;
            if (!packet.isFullyClaimed && claimedCount < packet.count) {
                const timeLeft = Math.floor((packet.timestamp + 24*60*60*1000 - Date.now()) / (1000 * 60 * 60));
                if(timeLeft > 0) summaryText += ` å‰©ä½™çº¢åŒ…å°†åœ¨${timeLeft}å°æ—¶å†…é€€è¿˜ã€‚`;
            }
            document.getElementById('rp-details-summary').textContent = summaryText;
        
            const listEl = document.getElementById('rp-details-list');
            listEl.innerHTML = '';
            const claimedEntries = Object.entries(packet.claimedBy || {});
            
            let luckyKing = { name: '', amount: -1 };
            if (packet.packetType === 'lucky' && packet.isFullyClaimed && claimedEntries.length > 1) {
                claimedEntries.forEach(([name, amount]) => {
                    if (amount > luckyKing.amount) {
                        luckyKing = { name, amount };
                    }
                });
            }
        
            claimedEntries.sort((a,b) => b[1] - a[1]);
        
            claimedEntries.forEach(([originalName, amount]) => {
                const item = document.createElement('div');
                item.className = 'rp-details-item';
                let luckyTag = '';
                if (luckyKing.name && originalName === luckyKing.name) {
                    luckyTag = '<span class="lucky-king-tag">æ‰‹æ°”çŽ‹</span>';
                }
                
                
                const claimerDisplayName = getDisplayNameInGroup(chat, originalName);
        
                item.innerHTML = `
                    <span class="name">${claimerDisplayName}</span>
                    <span class="amount">${amount.toFixed(2)} å…ƒ</span>
                    ${luckyTag}
                `;
                listEl.appendChild(item);
            });
        
            modal.classList.add('visible');
        }
          
        
        document.getElementById('close-rp-details-btn').addEventListener('click', () => {
            document.getElementById('red-packet-details-modal').classList.remove('visible');
        });
        
        
        window.handlePacketClick = handlePacketClick;
        
          
        
        
        
        /**
         * æ‰“å¼€åˆ›å»ºæŠ•ç¥¨çš„æ¨¡æ€æ¡†å¹¶åˆå§‹åŒ–
         */
        function openCreatePollModal() {
            const modal = document.getElementById('create-poll-modal');
            document.getElementById('poll-question-input').value = '';
            const optionsContainer = document.getElementById('poll-options-container');
            optionsContainer.innerHTML = '';
            
            
            addPollOptionInput();
            addPollOptionInput();
            
            modal.classList.add('visible');
        }
        
        /**
         * åœ¨æ¨¡æ€æ¡†ä¸­åŠ¨æ€æ·»åŠ ä¸€ä¸ªé€‰é¡¹è¾“å…¥æ¡†
         */
        function addPollOptionInput() {
            const container = document.getElementById('poll-options-container');
            const wrapper = document.createElement('div');
            wrapper.className = 'poll-option-input-wrapper';
            wrapper.innerHTML = `
                <input type="text" class="poll-option-input" placeholder="é€‰é¡¹å†…å®¹...">
                <button class="remove-option-btn">-</button>
            `;
            
            wrapper.querySelector('.remove-option-btn').addEventListener('click', () => {
                
                if (container.children.length > 2) {
                    wrapper.remove();
                } else {
                    alert('æŠ•ç¥¨è‡³å°‘éœ€è¦2ä¸ªé€‰é¡¹ã€‚');
                }
            });
            
            container.appendChild(wrapper);
        }
        
        /**
         * ç”¨æˆ·ç¡®è®¤å‘èµ·æŠ•ç¥¨
         */
        async function sendPoll() {
            if (!state.activeChatId) return;
            
            const question = document.getElementById('poll-question-input').value.trim();
            if (!question) {
                alert('è¯·è¾“å…¥æŠ•ç¥¨é—®é¢˜ï¼');
                return;
            }
            
            const options = Array.from(document.querySelectorAll('.poll-option-input'))
                .map(input => input.value.trim())
                .filter(text => text); 
        
            if (options.length < 2) {
                alert('è¯·è‡³å°‘è¾“å…¥2ä¸ªæœ‰æ•ˆçš„æŠ•ç¥¨é€‰é¡¹ï¼');
                return;
            }
        
            const chat = state.chats[state.activeChatId];
            const myNickname = chat.isGroup ? (chat.settings.myNickname || 'æˆ‘') : 'æˆ‘';
            
            const newPollMessage = {
                role: 'user',
                senderName: myNickname,
                type: 'poll',
                timestamp: Date.now(),
                question: question,
                options: options,
                votes: {}, 
                isClosed: false,
            };
            
            chat.history.push(newPollMessage);
            await db.chats.put(chat);
            
            appendMessage(newPollMessage, chat);
            renderChatList();
            
            document.getElementById('create-poll-modal').classList.remove('visible');
        }
        
        
        /**
         * å¤„ç†ç”¨æˆ·æŠ•ç¥¨ï¼Œå¹¶å°†äº‹ä»¶ä½œä¸ºéšè—æ¶ˆæ¯å­˜å…¥åŽ†å²è®°å½•
         * @param {number} timestamp - æŠ•ç¥¨æ¶ˆæ¯çš„æ—¶é—´æˆ³
         * @param {string} choice - ç”¨æˆ·é€‰æ‹©çš„é€‰é¡¹æ–‡æœ¬
         */
        async function handleUserVote(timestamp, choice) {
            const chat = state.chats[state.activeChatId];
            const poll = chat.history.find(m => m.timestamp === timestamp);
            const myNickname = chat.isGroup ? (chat.settings.myNickname || 'æˆ‘') : 'æˆ‘';
        
            
            if (!poll || poll.isClosed) {
                
                if (poll && poll.isClosed) {
                    showPollResults(timestamp);
                }
                return;
            }
        
            
            const isReclickingSameOption = poll.votes[choice] && poll.votes[choice].includes(myNickname);
            
            
            if (!isReclickingSameOption) {
                
                for (const option in poll.votes) {
                    const voterIndex = poll.votes[option].indexOf(myNickname);
                    if (voterIndex > -1) {
                        poll.votes[option].splice(voterIndex, 1);
                    }
                }
                
                if (!poll.votes[choice]) {
                    poll.votes[choice] = [];
                }
                poll.votes[choice].push(myNickname);
            }
            
            
            let hiddenMessageContent = null; 
            
            
            if (!isReclickingSameOption) {
                 hiddenMessageContent = `[ç³»ç»Ÿæç¤ºï¼šç”¨æˆ· (${myNickname}) åˆšåˆšæŠ•ç¥¨ç»™äº† â€œ${choice}â€ã€‚]`;
            }
        
            
            if (hiddenMessageContent) {
                const hiddenMessage = {
                    role: 'system',
                    content: hiddenMessageContent,
                    timestamp: Date.now(),
                    isHidden: true,
                };
                chat.history.push(hiddenMessage);
            }
            
            
            await db.chats.put(chat);
            renderChatInterface(state.activeChatId); 
        }
          
        
        /**
         * ç”¨æˆ·ç»“æŸæŠ•ç¥¨ï¼Œå¹¶å°†äº‹ä»¶ä½œä¸ºéšè—æ¶ˆæ¯å­˜å…¥åŽ†å²è®°å½•
         * @param {number} timestamp - æŠ•ç¥¨æ¶ˆæ¯çš„æ—¶é—´æˆ³
         */
        async function endPoll(timestamp) {
            const chat = state.chats[state.activeChatId];
            const poll = chat.history.find(m => m.timestamp === timestamp);
            if (!poll || poll.isClosed) return;
        
            const confirmed = await showCustomConfirm("ç»“æŸæŠ•ç¥¨", "ç¡®å®šè¦ç»“æŸè¿™ä¸ªæŠ•ç¥¨å—ï¼Ÿç»“æŸåŽå°†æ— æ³•å†è¿›è¡ŒæŠ•ç¥¨ã€‚");
            if (confirmed) {
                poll.isClosed = true;
        
                const resultSummary = poll.options.map(opt => `â€œ${opt}â€(${poll.votes[opt]?.length || 0}ç¥¨)`).join('ï¼Œ');
                const hiddenMessageContent = `[ç³»ç»Ÿæç¤ºï¼šç”¨æˆ·æ‰‹åŠ¨ç»“æŸäº†æŠ•ç¥¨ï¼æœ€ç»ˆç»“æžœä¸ºï¼š${resultSummary}ã€‚]`;
                
                const hiddenMessage = {
                    role: 'system',
                    content: hiddenMessageContent,
                    timestamp: Date.now(),
                    isHidden: true,
                };
                chat.history.push(hiddenMessage);
        
                
                await db.chats.put(chat);
                renderChatInterface(state.activeChatId);
            }
        }
          
        
        /**
         * æ˜¾ç¤ºæŠ•ç¥¨ç»“æžœè¯¦æƒ…
         * @param {number} timestamp - æŠ•ç¥¨æ¶ˆæ¯çš„æ—¶é—´æˆ³
         */
        
        function showPollResults(timestamp) {
            const chat = state.chats[state.activeChatId];
            const poll = chat.history.find(m => m.timestamp === timestamp);
            if (!poll || !poll.isClosed) return;
        
            let resultsHtml = `<p><strong>${poll.question}</strong></p><hr style="opacity: 0.2; margin: 10px 0;">`;
            
            if (Object.keys(poll.votes).length === 0) {
                resultsHtml += '<p style="color: #8a8a8a;">è¿˜æ²¡æœ‰äººæŠ•ç¥¨ã€‚</p>';
            } else {
                poll.options.forEach(option => {
                    const voters = poll.votes[option] || [];
                    
                    
                    const displayVoters = voters.map(originalName => getDisplayNameInGroup(chat, originalName)).join('ã€ ');
        
                    resultsHtml += `
                        <div style="margin-bottom: 15px;">
                            <p style="font-weight: 500; margin: 0 0 5px 0;">${option} (${voters.length}ç¥¨)</p>
                            <p style="font-size: 13px; color: #555; margin: 0; line-height: 1.5;">
                                ${voters.length > 0 ? displayVoters : 'æ— äººæŠ•ç¥¨'}
                            </p>
                        </div>
                    `;
                });
            }
        
            showCustomAlert("æŠ•ç¥¨ç»“æžœ", resultsHtml);
        }
          
        
        
        
        /**
         * æ‰“å¼€AIå¤´åƒåº“ç®¡ç†æ¨¡æ€æ¡†
         */
        function openAiAvatarLibraryModal() {
            if (!state.activeChatId) return;
            const chat = state.chats[state.activeChatId];
            document.getElementById('ai-avatar-library-title').textContent = `â€œ${chat.name}â€çš„å¤´åƒåº“`;
            renderAiAvatarLibrary();
            document.getElementById('ai-avatar-library-modal').classList.add('visible');
        }
        
function renderAiAvatarLibrary() {
    const grid = document.getElementById('ai-avatar-library-grid');
    grid.innerHTML = '';
    const chat = state.chats[state.activeChatId];
    const library = chat.settings.aiAvatarLibrary || [];

    if (library.length === 0) {
        grid.innerHTML = '<p style="color: var(--text-secondary); grid-column: 1 / -1; text-align: center;">è¿™ä¸ªå¤´åƒåº“è¿˜æ˜¯ç©ºçš„ï¼Œç‚¹å‡»å³ä¸Šè§’â€œæ·»åŠ â€å§ï¼</p>';
        return;
    }

    library.forEach((avatar, index) => {
        const item = document.createElement('div');
        item.className = 'sticker-item'; 
        item.title = avatar.name;

        
        
        item.innerHTML = `
            <div class="sticker-image-container" style="background-image: url(${avatar.url});"></div>
            <span class="sticker-name">${avatar.name}</span>
        `;
        

        const deleteBtn = document.createElement('div');
        deleteBtn.className = 'delete-btn';
        deleteBtn.innerHTML = 'Ã—';
        deleteBtn.style.display = 'block';
        deleteBtn.onclick = async (e) => {
            e.stopPropagation();
            const confirmed = await showCustomConfirm('åˆ é™¤å¤´åƒ', `ç¡®å®šè¦ä»Žå¤´åƒåº“ä¸­åˆ é™¤â€œ${avatar.name}â€å—ï¼Ÿ`, { confirmButtonClass: 'btn-danger' });
            if (confirmed) {
                chat.settings.aiAvatarLibrary.splice(index, 1);
                await db.chats.put(chat);
                renderAiAvatarLibrary();
            }
        };
        item.appendChild(deleteBtn);
        grid.appendChild(item);
    });
}
        
        
        /**
         * ã€é‡å‘½ååŽã€‘å‘å½“å‰AIçš„å¤´åƒåº“ä¸­é€šè¿‡URLæ·»åŠ æ–°å¤´åƒ
         */
        async function addAvatarToLibraryFromURL() {
            const name = await showCustomPrompt("æ·»åŠ å¤´åƒ", "è¯·ä¸ºè¿™ä¸ªå¤´åƒèµ·ä¸ªåå­—ï¼ˆä¾‹å¦‚ï¼šå¼€å¿ƒã€å“­æ³£ï¼‰");
            if (!name || !name.trim()) return;
        
            const url = await showCustomPrompt("æ·»åŠ å¤´åƒ", "è¯·è¾“å…¥å¤´åƒçš„å›¾ç‰‡URL", "", "url");
            if (!url || !url.trim().startsWith('http')) {
                alert("è¯·è¾“å…¥æœ‰æ•ˆçš„å›¾ç‰‡URLï¼");
                return;
            }
            
            const chat = state.chats[state.activeChatId];
            if (!chat.settings.aiAvatarLibrary) {
                chat.settings.aiAvatarLibrary = [];
            }
        
            chat.settings.aiAvatarLibrary.push({ name: name.trim(), url: url.trim() });
            await db.chats.put(chat);
            renderAiAvatarLibrary();
        }
          
        
        /**
         * å…³é—­AIå¤´åƒåº“ç®¡ç†æ¨¡æ€æ¡†
         */
        function closeAiAvatarLibraryModal() {
            document.getElementById('ai-avatar-library-modal').classList.remove('visible');
        }
        
        
        
        
        
        /**
         * æ‰“å¼€â€œæˆ‘çš„â€å¤´åƒåº“ç®¡ç†æ¨¡æ€æ¡†
         */
        function openMyAvatarLibraryModal() {
            if (!state.activeChatId) return;
            const chat = state.chats[state.activeChatId];
            document.getElementById('my-avatar-library-title').textContent = `â€œ${chat.settings.myNickname || 'æˆ‘'}â€çš„å¤´åƒåº“`;
            renderMyAvatarLibrary();
            document.getElementById('my-avatar-library-modal').classList.add('visible');
        }
        
/**
 * ã€å·²ä¿®å¤ã€‘æ¸²æŸ“â€œæˆ‘çš„â€å¤´åƒåº“çš„å†…å®¹
 */
function renderMyAvatarLibrary() {
    const grid = document.getElementById('my-avatar-library-grid');
    grid.innerHTML = '';
    const chat = state.chats[state.activeChatId];
    const library = chat.settings.myAvatarLibrary || [];

    if (library.length === 0) {
        grid.innerHTML = '<p style="color: var(--text-secondary); grid-column: 1 / -1; text-align: center;">è¿™ä¸ªå¤´åƒåº“è¿˜æ˜¯ç©ºçš„ï¼Œç‚¹å‡»å³ä¸Šè§’â€œæ·»åŠ â€å§ï¼</p>';
        return;
    }

    library.forEach((avatar, index) => {
        const item = document.createElement('div');
        item.className = 'sticker-item';
        item.title = avatar.name;

        
        item.innerHTML = `
            <div class="sticker-image-container" style="background-image: url(${avatar.url});"></div>
            <span class="sticker-name">${avatar.name}</span>
        `;
        

        const deleteBtn = document.createElement('div');
        deleteBtn.className = 'delete-btn';
        deleteBtn.innerHTML = 'Ã—';
        deleteBtn.style.display = 'block';
        deleteBtn.onclick = async (e) => {
            e.stopPropagation();
            const confirmed = await showCustomConfirm('åˆ é™¤å¤´åƒ', `ç¡®å®šè¦ä»Žä½ çš„å¤´åƒåº“ä¸­åˆ é™¤â€œ${avatar.name}â€å—ï¼Ÿ`, { confirmButtonClass: 'btn-danger' });
            if (confirmed) {
                chat.settings.myAvatarLibrary.splice(index, 1);
                await db.chats.put(chat);
                renderMyAvatarLibrary();
            }
        };
        item.appendChild(deleteBtn);
        grid.appendChild(item);
    });
}
        
        /**
         * å‘â€œæˆ‘çš„â€å¤´åƒåº“ä¸­é€šè¿‡URLæ·»åŠ æ–°å¤´åƒ
         */
        async function addAvatarToMyLibraryFromURL() {
            const name = await showCustomPrompt("æ·»åŠ å¤´åƒ", "è¯·ä¸ºè¿™ä¸ªå¤´åƒèµ·ä¸ªåå­—ï¼ˆä¾‹å¦‚ï¼šå¼€å¿ƒã€å“­æ³£ï¼‰");
            if (!name || !name.trim()) return;
        
            const url = await showCustomPrompt("æ·»åŠ å¤´åƒ", "è¯·è¾“å…¥å¤´åƒçš„å›¾ç‰‡URL", "", "url");
            if (!url || !url.trim().startsWith('http')) {
                alert("è¯·è¾“å…¥æœ‰æ•ˆçš„å›¾ç‰‡URLï¼");
                return;
            }
            
            const chat = state.chats[state.activeChatId];
            if (!chat.settings.myAvatarLibrary) {
                chat.settings.myAvatarLibrary = [];
            }
        
            chat.settings.myAvatarLibrary.push({ name: name.trim(), url: url.trim() });
            await db.chats.put(chat);
            renderMyAvatarLibrary();
        }
        
        /**
         * å¤„ç†æœ¬åœ°ä¸Šä¼ å¤´åƒåˆ°â€œæˆ‘çš„â€å¤´åƒåº“
         */
        async function handleLocalMyAvatarUpload(event) {
            const file = event.target.files[0];
            if (!file) return;
        
            const base64Url = await new Promise(resolve => {
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result);
                reader.readAsDataURL(file);
            });
        
            const name = await showCustomPrompt("å‘½åå¤´åƒ", "è¯·ä¸ºè¿™ä¸ªæ–°å¤´åƒå‘½å");
            if (!name || !name.trim()) return;
        
            const chat = state.chats[state.activeChatId];
            if (!chat.settings.myAvatarLibrary) {
                chat.settings.myAvatarLibrary = [];
            }
            chat.settings.myAvatarLibrary.push({ name: name.trim(), url: base64Url });
            
            await db.chats.put(chat);
            renderMyAvatarLibrary();
            event.target.value = null; 
        }
        
        /**
         * æ‰¹é‡å¯¼å…¥å¤´åƒåˆ°â€œæˆ‘çš„â€å¤´åƒåº“
         */
        async function handleBatchImportForMyAvatar(text) {
            const chat = state.chats[state.activeChatId];
            if (!chat) return;
        
            const lines = text.trim().split('\n');
            const newAvatars = [];
            const baseUrl = 'https://files.catbox.moe/';
            let errorCount = 0;
        
            for (const line of lines) {
                const trimmedLine = line.trim();
                if (!trimmedLine || trimmedLine.includes('http') || trimmedLine.includes('å¡«å…¥')) continue;
                
                let name = null, code = null;
                const noSpaceMatch = trimmedLine.match(/^([\u4e00-\u9fa5]+)([a-zA-Z0-9]+\..+)$/);
                
                if (noSpaceMatch) {
                    name = noSpaceMatch[1];
                    code = noSpaceMatch[2];
                } else {
                    const parts = trimmedLine.split(/\s+/);
                    if (parts.length >= 2) {
                        code = parts.pop();
                        name = parts.join(' ');
                    }
                }
        
                if (name && code && code.includes('.')) {
                    newAvatars.push({ name: name, url: baseUrl + code });
                } else {
                    errorCount++;
                }
            }
        
            if (errorCount > 0) await showCustomAlert('éƒ¨åˆ†å¯¼å…¥å¤±è´¥', `æœ‰ ${errorCount} è¡Œçš„æ ¼å¼ä¸æ­£ç¡®ï¼Œå·²è¢«è·³è¿‡ã€‚`);
            
            if (newAvatars.length > 0) {
                if (!chat.settings.myAvatarLibrary) chat.settings.myAvatarLibrary = [];
                chat.settings.myAvatarLibrary.push(...newAvatars);
                await db.chats.put(chat);
                renderMyAvatarLibrary();
                await showCustomAlert('å¯¼å…¥æˆåŠŸ', `å·²æˆåŠŸæ‰¹é‡å¯¼å…¥ ${newAvatars.length} ä¸ªæ–°å¤´åƒï¼`);
            } else if (errorCount === 0) {
                alert("æ²¡æœ‰æ‰¾åˆ°å¯å¯¼å…¥çš„å†…å®¹ã€‚");
            }
        }
        
        /**
         * å…³é—­â€œæˆ‘çš„â€å¤´åƒåº“ç®¡ç†æ¨¡æ€æ¡†
         */
        function closeMyAvatarLibraryModal() {
            document.getElementById('my-avatar-library-modal').classList.remove('visible');
        }
        
        
        
        
        /**
         * æ‰“å¼€ç¾¤å¤´åƒåº“ç®¡ç†æ¨¡æ€æ¡†
         */
        function openGroupAvatarLibraryModal() {
            if (!state.activeChatId) return;
            const chat = state.chats[state.activeChatId];
            document.getElementById('group-avatar-library-title').textContent = `â€œ${chat.name}â€çš„å¤´åƒåº“`;
            renderGroupAvatarLibrary();
            document.getElementById('group-avatar-library-modal').classList.add('visible');
        }
        
/**
 * ã€å·²ä¿®å¤ã€‘æ¸²æŸ“ç¾¤å¤´åƒåº“çš„å†…å®¹
 */
function renderGroupAvatarLibrary() {
    const grid = document.getElementById('group-avatar-library-grid');
    grid.innerHTML = '';
    const chat = state.chats[state.activeChatId];
    const library = chat.settings.groupAvatarLibrary || [];

    if (library.length === 0) {
        grid.innerHTML = '<p style="color: var(--text-secondary); grid-column: 1 / -1; text-align: center;">è¿™ä¸ªå¤´åƒåº“è¿˜æ˜¯ç©ºçš„ï¼Œç‚¹å‡»å³ä¸Šè§’â€œæ·»åŠ â€å§ï¼</p>';
        return;
    }

    library.forEach((avatar, index) => {
        const item = document.createElement('div');
        item.className = 'sticker-item';
        item.title = avatar.name;

        
        item.innerHTML = `
            <div class="sticker-image-container" style="background-image: url(${avatar.url});"></div>
            <span class="sticker-name">${avatar.name}</span>
        `;
        

        const deleteBtn = document.createElement('div');
        deleteBtn.className = 'delete-btn';
        deleteBtn.innerHTML = 'Ã—';
        deleteBtn.style.display = 'block';
        deleteBtn.onclick = async (e) => {
            e.stopPropagation();
            const confirmed = await showCustomConfirm('åˆ é™¤å¤´åƒ', `ç¡®å®šè¦ä»Žå¤´åƒåº“ä¸­åˆ é™¤â€œ${avatar.name}â€å—ï¼Ÿ`, { confirmButtonClass: 'btn-danger' });
            if (confirmed) {
                chat.settings.groupAvatarLibrary.splice(index, 1);
                await db.chats.put(chat);
                renderGroupAvatarLibrary();
            }
        };
        item.appendChild(deleteBtn);
        grid.appendChild(item);
    });
}
        
        /**
         * å‘å½“å‰ç¾¤èŠçš„å¤´åƒåº“ä¸­æ·»åŠ æ–°å¤´åƒ
         */
        async function addAvatarToGroupLibraryFromUR() {
            const name = await showCustomPrompt("æ·»åŠ å¤´åƒ", "è¯·ä¸ºè¿™ä¸ªå¤´åƒèµ·ä¸ªåå­—ï¼ˆä¾‹å¦‚ï¼šæ˜¥æ—¥é‡Žé¤ã€å­¦ä¹ æ—¶é—´ï¼‰");
            if (!name || !name.trim()) return;
        
            const url = await showCustomPrompt("æ·»åŠ å¤´åƒ", "è¯·è¾“å…¥å¤´åƒçš„å›¾ç‰‡URL", "", "url");
            if (!url || !url.trim().startsWith('http')) {
                alert("è¯·è¾“å…¥æœ‰æ•ˆçš„å›¾ç‰‡URLï¼");
                return;
            }
            
            const chat = state.chats[state.activeChatId];
            if (!chat.settings.groupAvatarLibrary) {
                chat.settings.groupAvatarLibrary = [];
            }
        
            chat.settings.groupAvatarLibrary.push({ name: name.trim(), url: url.trim() });
            await db.chats.put(chat);
            renderGroupAvatarLibrary();
        }
        
        /**
         * å…³é—­ç¾¤å¤´åƒåº“ç®¡ç†æ¨¡æ€æ¡†
         */
        function closeGroupAvatarLibraryModal() {
            document.getElementById('group-avatar-library-modal').classList.remove('visible');
        }
        
        
        /**
         * ã€æ€»å…¥å£ã€‘æ‰“å¼€æ‰¹é‡å¯¼å…¥çš„å¼¹çª—
         * @param {string} type - å¯¼å…¥ç±»åž‹, 'ai' æˆ– 'group'
         */
        async function openBatchImportModal(type) {
            const placeholderText = `è¯·æŒ‰ç…§ä»¥ä¸‹æ ¼å¼ç²˜è´´ï¼Œä¸€è¡Œä¸€ä¸ªï¼š\n\nç„¦è™‘ 2a9wte.jpeg\nå¤§æƒŠå¤±è‰² or8qf4.png\næ²¡æœ‰çµæ„Ÿ njwujh.jpeg`;
            
            
            const pastedText = await showCustomPrompt(
                'æ‰¹é‡å¯¼å…¥å¤´åƒ',
                placeholderText,
                '',
                'textarea' 
            );
        
            
            if (pastedText && pastedText.trim()) {
                await handleBatchImport(type, pastedText);
            }
        }
        
        
        /**
         * ã€æ ¸å¿ƒé€»è¾‘ã€‘å¤„ç†ç²˜è´´çš„æ–‡æœ¬ï¼Œè§£æžå¹¶å­˜å…¥æ•°æ®åº“ (V4 - ç»ˆæžæ™ºèƒ½ç‰ˆ)
         * @param {string} type - å¯¼å…¥ç±»åž‹, 'ai' æˆ– 'group'
         * @param {string} text - ç”¨æˆ·ç²˜è´´çš„æ–‡æœ¬å†…å®¹
         */
        async function handleBatchImport(type, text) {
            const chat = state.chats[state.activeChatId];
            if (!chat) return;
        
            const lines = text.trim().split('\n');
            const newAvatars = [];
            const baseUrl = 'https://files.catbox.moe/';
            let errorCount = 0;
        
            for (const line of lines) {
                const trimmedLine = line.trim();
        
                if (!trimmedLine || trimmedLine.includes('http') || trimmedLine.includes('å¡«å…¥')) {
                    continue; 
                }
        
                let name = null;
                let code = null;
        
                
                
                
                
        
                
                const noSpaceMatch = trimmedLine.match(/^([\u4e00-\u9fa5]+)([a-zA-Z0-9]+\..+)$/);
                
                if (noSpaceMatch) {
                    
                    name = noSpaceMatch[1];
                    code = noSpaceMatch[2];
                } else {
                    
                    const parts = trimmedLine.split(/\s+/);
                    if (parts.length >= 2) {
                        code = parts.pop();
                        name = parts.join(' ');
                    }
                }
        
                
                if (name && code && code.includes('.')) {
                    newAvatars.push({
                        name: name,
                        url: baseUrl + code
                    });
                } else {
                    errorCount++;
                    console.warn('æ‰¹é‡å¯¼å…¥æ ¼å¼é”™è¯¯ï¼Œå·²è·³è¿‡æ­¤è¡Œ:', trimmedLine);
                }
            }
        
            if (errorCount > 0) {
                await showCustomAlert('éƒ¨åˆ†å¯¼å…¥å¤±è´¥', `æœ‰ ${errorCount} è¡Œçš„æ ¼å¼ä¸æ­£ç¡®ï¼Œå·²è¢«ç³»ç»Ÿè·³è¿‡ã€‚`);
            }
        
            if (newAvatars.length > 0) {
                if (type === 'ai') {
                    if (!chat.settings.aiAvatarLibrary) chat.settings.aiAvatarLibrary = [];
                    chat.settings.aiAvatarLibrary.push(...newAvatars);
                    await db.chats.put(chat);
                    renderAiAvatarLibrary();
                } else if (type === 'group') {
                    if (!chat.settings.groupAvatarLibrary) chat.settings.groupAvatarLibrary = [];
                    chat.settings.groupAvatarLibrary.push(...newAvatars);
                    await db.chats.put(chat);
                    renderGroupAvatarLibrary();
                }
                await showCustomAlert('å¯¼å…¥æˆåŠŸ', `å·²æˆåŠŸæ‰¹é‡å¯¼å…¥ ${newAvatars.length} ä¸ªæ–°å¤´åƒï¼`);
            } else if (errorCount === 0) {
                alert("æ²¡æœ‰æ‰¾åˆ°å¯å¯¼å…¥çš„å†…å®¹ã€‚è¯·æ£€æŸ¥æ‚¨ç²˜è´´çš„æ ¼å¼æ˜¯å¦æ­£ç¡®ã€‚");
            }
        }
          
        
        
        /**
         * ã€é‡å‘½ååŽã€‘å‘å½“å‰ç¾¤èŠçš„å¤´åƒåº“ä¸­é€šè¿‡URLæ·»åŠ æ–°å¤´åƒ
         */
        async function addAvatarToGroupLibraryFromURL() {
            const name = await showCustomPrompt("æ·»åŠ å¤´åƒ", "è¯·ä¸ºè¿™ä¸ªå¤´åƒèµ·ä¸ªåå­—ï¼ˆä¾‹å¦‚ï¼šæ˜¥æ—¥é‡Žé¤ã€å­¦ä¹ æ—¶é—´ï¼‰");
            if (!name || !name.trim()) return;
        
            const url = await showCustomPrompt("æ·»åŠ å¤´åƒ", "è¯·è¾“å…¥å¤´åƒçš„å›¾ç‰‡URL", "", "url");
            if (!url || !url.trim().startsWith('http')) {
                alert("è¯·è¾“å…¥æœ‰æ•ˆçš„å›¾ç‰‡URLï¼");
                return;
            }
            
            const chat = state.chats[state.activeChatId];
            if (!chat.settings.groupAvatarLibrary) {
                chat.settings.groupAvatarLibrary = [];
            }
        
            chat.settings.groupAvatarLibrary.push({ name: name.trim(), url: url.trim() });
            await db.chats.put(chat);
            renderGroupAvatarLibrary();
        }
        /**
         * æ˜¾ç¤ºä¸€ä¸ªåŒ…å«â€œç½®é¡¶â€å’Œâ€œåˆ é™¤â€é€‰é¡¹çš„æ“ä½œèœå•
         * @param {object} chat - è¢«é•¿æŒ‰çš„èŠå¤©å¯¹è±¡
         * @returns {Promise<string|null>} - è¿”å›žä¸€ä¸ªPromiseï¼Œå½“ç”¨æˆ·ç‚¹å‡»æ—¶è§£æžä¸º 'pin', 'delete', æˆ– null (å–æ¶ˆ)
         */
        function showChatListActions(chat) {
            return new Promise(resolve => {
                const modal = document.getElementById('chat-list-actions-modal');
                const pinBtn = document.getElementById('chat-list-action-pin');
                const deleteBtn = document.getElementById('chat-list-action-delete');
                const cancelBtn = document.getElementById('chat-list-action-cancel');
        
                
                pinBtn.textContent = chat.isPinned ? 'å–æ¶ˆç½®é¡¶' : 'ç½®é¡¶èŠå¤©';
        
                
                const newPinBtn = pinBtn.cloneNode(true);
                pinBtn.parentNode.replaceChild(newPinBtn, pinBtn);
                newPinBtn.onclick = () => { modal.classList.remove('visible'); resolve('pin'); };
        
                const newDeleteBtn = deleteBtn.cloneNode(true);
                deleteBtn.parentNode.replaceChild(newDeleteBtn, deleteBtn);
                newDeleteBtn.onclick = () => { modal.classList.remove('visible'); resolve('delete'); };
        
                const newCancelBtn = cancelBtn.cloneNode(true);
                cancelBtn.parentNode.replaceChild(newCancelBtn, cancelBtn);
                newCancelBtn.onclick = () => { modal.classList.remove('visible'); resolve(null); };
        
                modal.classList.add('visible');
            });
        }
        
        

        /**
         * ã€å…¨æ–°ã€‘å°†ä¿å­˜çš„CPhoneå£çº¸åº”ç”¨åˆ°Cphoneå±å¹•
         */
function applyCPhoneWallpaper() {
    const charPhoneScreen = document.getElementById('character-phone-screen');
    const wallpaper = state.globalSettings.cphoneWallpaper;
    if (wallpaper) {
        
        charPhoneScreen.style.backgroundImage = `url(${wallpaper})`;
    } else {
        
        charPhoneScreen.style.backgroundImage = 'linear-gradient(135deg, #f6d365, #fda085)';
    }
}

        /**
         * ã€å…¨æ–°ã€‘å°†ä¿å­˜çš„å›¾æ ‡URLåº”ç”¨åˆ°CPhoneçš„Appå›¾æ ‡ä¸Š
         */
        function applyCPhoneAppIcons() {
            if (!state.globalSettings.cphoneAppIcons) return;

            for (const iconId in state.globalSettings.cphoneAppIcons) {
                const imgElement = document.getElementById(`cphone-icon-img-${iconId}`);
                if (imgElement) {
                    imgElement.src = state.globalSettings.cphoneAppIcons[iconId];
                }
            }
        }

        /**
         * ã€å…¨æ–°ã€‘åœ¨å¤–è§‚è®¾ç½®é¡µé¢æ¸²æŸ“å‡ºæ‰€æœ‰CPhone Appå›¾æ ‡çš„è®¾ç½®é¡¹
         */
        function renderCPhoneIconSettings() {
            const grid = document.getElementById('cphone-icon-settings-grid');
            if (!grid) return;
            grid.innerHTML = '';

            const cphoneAppLabels = {
                'qq': 'QQ', 'album': 'ç›¸å†Œ', 'browser': 'æµè§ˆå™¨', 'taobao': 'æ·˜å®',
                'memo': 'å¤‡å¿˜å½•', 'diary': 'æ—¥è®°', 'amap': 'é«˜å¾·åœ°å›¾', 'usage': 'Appè®°å½•',
                'music': 'ç½‘æ˜“äº‘', 'ephone': 'Ephone'
            };

            for (const iconId in state.globalSettings.cphoneAppIcons) {
                const iconUrl = state.globalSettings.cphoneAppIcons[iconId];
                const labelText = cphoneAppLabels[iconId] || 'æœªçŸ¥App';

                const item = document.createElement('div');
                item.className = 'icon-setting-item';
                item.dataset.iconId = iconId;

                item.innerHTML = `
                    <img class="icon-preview" src="${iconUrl}" alt="${labelText}">
                    <button class="change-icon-btn">æ›´æ¢</button>
                `;
                grid.appendChild(item);
            }
        }

        
        
        
        /**
         * ã€å…¨æ–°ã€‘å°†ä¿å­˜çš„å›¾æ ‡URLåº”ç”¨åˆ°ä¸»å±å¹•çš„Appå›¾æ ‡ä¸Š
         */
        function applyAppIcons() {
            if (!state.globalSettings.appIcons) return;
        
            for (const iconId in state.globalSettings.appIcons) {
                const imgElement = document.getElementById(`icon-img-${iconId}`);
                if (imgElement) {
                    imgElement.src = state.globalSettings.appIcons[iconId];
                }
            }
        }
        
        /**
         * ã€å…¨æ–°ã€‘åœ¨å¤–è§‚è®¾ç½®é¡µé¢æ¸²æŸ“å‡ºæ‰€æœ‰Appå›¾æ ‡çš„è®¾ç½®é¡¹
         */
        function renderIconSettings() {
            const grid = document.getElementById('icon-settings-grid');
            if (!grid) return;
            grid.innerHTML = '';
        
    const appLabels = {
       'qq': 'QQ',
       'world-book': 'ä¸–ç•Œä¹¦',
       'wallpaper': 'å¤–è§‚è®¾ç½®',
       'renderer': 'æ¸²æŸ“å™¨',
       'api-settings': 'APIè®¾ç½®',
       'font': 'å­—ä½“',
       'char-phone': 'Cphone',
       'douban': 'è±†ç“£å°ç»„',
       
       'preset': 'é¢„è®¾',
             
           'tutorial': 'æ•™ç¨‹',
   'werewolf': 'ç‹¼äººæ€',
     
   'x': 'X'
    };
          
        
            for (const iconId in state.globalSettings.appIcons) {
                const iconUrl = state.globalSettings.appIcons[iconId];
                const labelText = appLabels[iconId] || 'Cphone';
        
                const item = document.createElement('div');
                item.className = 'icon-setting-item';
                
                item.dataset.iconId = iconId; 
        
                item.innerHTML = `
                    <img class="icon-preview" src="${iconUrl}" alt="${labelText}">
                    <button class="change-icon-btn">æ›´æ¢</button>
                `;
                grid.appendChild(item);
            }
        }
        
        
        
        /**
         * å½“ç”¨æˆ·ç‚¹å‡»é“¾æŽ¥å¡ç‰‡æ—¶ï¼Œæ‰“å¼€ä¼ªæµè§ˆå™¨
         * @param {number} timestamp - è¢«ç‚¹å‡»æ¶ˆæ¯çš„æ—¶é—´æˆ³
         */
        function openBrowser(timestamp) {
            if (!state.activeChatId) return;
        
            const chat = state.chats[state.activeChatId];
            
            if (!chat || !chat.history) return;
        
            const message = chat.history.find(m => m.timestamp === timestamp);
            if (!message || message.type !== 'share_link') {
                console.error("æ— æ³•æ‰¾åˆ°æˆ–æ¶ˆæ¯ç±»åž‹ä¸åŒ¹é…çš„åˆ†äº«é“¾æŽ¥:", timestamp);
                return; 
            }
        
            
            document.getElementById('browser-title').textContent = message.source_name || 'æ–‡ç« è¯¦æƒ…';
            const browserContent = document.getElementById('browser-content');
            browserContent.innerHTML = `
                <h1 class="article-title">${message.title || 'æ— æ ‡é¢˜'}</h1>
                <div class="article-meta">
                    <span>æ¥æº: ${message.source_name || 'æœªçŸ¥'}</span>
                </div>
                <div class="article-body">
                    <p>${(message.content || 'å†…å®¹ä¸ºç©ºã€‚').replace(/\n/g, '</p><p>')}</p>
                </div>
            `;
        
            
            showScreen('browser-screen');
        }
        
        /**
         * å…³é—­ä¼ªæµè§ˆå™¨ï¼Œè¿”å›žèŠå¤©ç•Œé¢
         * (è¿™ä¸ªå‡½æ•°çŽ°åœ¨ç”± init() ä¸­çš„äº‹ä»¶ç›‘å¬å™¨è°ƒç”¨)
         */
        function closeBrowser() {
            showScreen('chat-interface-screen'); 
        }
        
          
        
        /**
         * å…³é—­ä¼ªæµè§ˆå™¨ï¼Œè¿”å›žèŠå¤©ç•Œé¢
         * (è¿™ä¸ªå‡½æ•°çŽ°åœ¨ç”± init() ä¸­çš„äº‹ä»¶ç›‘å¬å™¨è°ƒç”¨)
         */
        function closeBrowser() {
            showScreen('chat-interface-screen'); 
        }
        
          
        
        
        
        /**
         * æ‰“å¼€è®©ç”¨æˆ·å¡«å†™é“¾æŽ¥ä¿¡æ¯çš„æ¨¡æ€æ¡†
         */
        function openShareLinkModal() {
            if (!state.activeChatId) return;
        
            
            document.getElementById('link-title-input').value = '';
            document.getElementById('link-description-input').value = '';
            document.getElementById('link-source-input').value = '';
            document.getElementById('link-content-input').value = '';
        
            
            document.getElementById('share-link-modal').classList.add('visible');
        }
        
        /**
         * ç”¨æˆ·ç¡®è®¤åˆ†äº«ï¼Œåˆ›å»ºå¹¶å‘é€é“¾æŽ¥å¡ç‰‡æ¶ˆæ¯
         */
        async function sendUserLinkShare() {
            if (!state.activeChatId) return;
        
            const title = document.getElementById('link-title-input').value.trim();
            if (!title) {
                alert("æ ‡é¢˜æ˜¯å¿…å¡«é¡¹å“¦ï¼");
                return;
            }
        
            const description = document.getElementById('link-description-input').value.trim();
            const sourceName = document.getElementById('link-source-input').value.trim();
            const content = document.getElementById('link-content-input').value.trim();
        
            const chat = state.chats[state.activeChatId];
            
            
            const linkMessage = {
                role: 'user', 
                type: 'share_link',
                timestamp: Date.now(),
                title: title,
                description: description,
                source_name: sourceName,
                content: content,
                
                thumbnail_url: null 
            };
        
            
            chat.history.push(linkMessage);
            await db.chats.put(chat);
        
            
            appendMessage(linkMessage, chat);
            renderChatList();
        
            
            document.getElementById('share-link-modal').classList.remove('visible');
        }
        
        
        
/**
 * ã€V2.1 | NPCå¯è§æ€§ä¿®å¤ç‰ˆã€‘æ ¹æ®AIçš„è§†è§’ï¼Œè¿‡æ»¤å‡ºå®ƒèƒ½çœ‹åˆ°çš„åŠ¨æ€
 * @param {Array} allPosts - æ‰€æœ‰å¾…æ£€æŸ¥çš„åŠ¨æ€å¸–å­
 * @param {object} viewerChat - æ­£åœ¨â€œçœ‹â€åŠ¨æ€çš„é‚£ä¸ªAIçš„chatå¯¹è±¡
 * @returns {Array} - è¿‡æ»¤åŽè¯¥AIå¯è§çš„åŠ¨æ€å¸–å­
 */
function filterVisiblePostsForAI(allPosts, viewerChat) {
    if (!viewerChat || !viewerChat.id) return [];

    const viewerGroupId = viewerChat.groupId;
    const viewerId = viewerChat.id; 

    return allPosts.filter(post => {
        
        if (post.authorId === 'user') {
            if (post.visibleGroupIds && post.visibleGroupIds.length > 0) {
                return viewerGroupId && post.visibleGroupIds.includes(viewerGroupId);
            }
            return true;
        }
        
        

        
        if (String(post.authorId).startsWith('npc_')) {
            
            if (Array.isArray(post.visibleTo)) {
                return post.visibleTo.includes(viewerId);
            }
            
            return false;
        }

        

        
        const authorChat = state.chats[post.authorId];
        if (!authorChat) {
            return false;
        }
        const authorGroupId = authorChat.groupId;

        const inSameGroup = authorGroupId && viewerGroupId && authorGroupId === viewerGroupId;
        const bothUnGrouped = !authorGroupId && !viewerGroupId;

        return inSameGroup || bothUnGrouped;
    });
}
       /**
         * ã€å…¨æ–° | V2.0 | ä¿®å¤æ­Œè¯æ¡åˆ‡æ¢BUGç‰ˆã€‘åº”ç”¨æˆ–ç§»é™¤æ‰‹æœºå¤–æ¡†æ ·å¼
         * @param {boolean} isEnabled - æ˜¯å¦æ˜¾ç¤ºå¤–æ¡†
         */
        function applyPhoneFrame(isEnabled) {
            // 1. åˆ‡æ¢bodyçš„class
            document.body.classList.toggle('frame-mode-active', isEnabled);
        
            // 2. ã€æ ¸å¿ƒä¿®å¤ã€‘æ£€æŸ¥éŸ³ä¹æ˜¯å¦æ­£åœ¨æ’­æ”¾ï¼Œå¹¶ç«‹å³åŒæ­¥æ­Œè¯UI
            if (musicState.isActive) {
            const lyricBar = document.getElementById('global-lyrics-bar');
            const phoneScreenForIsland = document.getElementById('phone-screen');
            const isAlwaysIslandMode = state.globalSettings.alwaysShowMusicIsland || false; // <-- èŽ·å–æ–°å¼€å…³çš„çŠ¶æ€

            if (isEnabled) {
                // æ‰‹æœºå¤–æ¡†å¼€å¯æ—¶ï¼šå¼ºåˆ¶ä½¿ç”¨çµåŠ¨å²› (ä¸å—æ–°å¼€å…³å½±å“)
                lyricBar.classList.remove('visible');
                phoneScreenForIsland.classList.add('dynamic-island-active');
            } else {
                // æ‰‹æœºå¤–æ¡†å…³é—­æ—¶ï¼šæ£€æŸ¥æ–°å¼€å…³
                phoneScreenForIsland.classList.remove('dynamic-island-active'); // å…ˆç§»é™¤
                
                if (isAlwaysIslandMode) {
                    // å¦‚æžœæ–°å¼€å…³=ONï¼Œåˆ™é‡æ–°æ‰“å¼€çµåŠ¨å²›
                    phoneScreenForIsland.classList.add('dynamic-island-active');
                    lyricBar.classList.remove('visible');
                } else {
                    // å¦åˆ™ (æ–°å¼€å…³=OFF)ï¼Œä½¿ç”¨æ—§çš„ç°è‰²æ­Œè¯æ¡
                    if (musicState.parsedLyrics && musicState.parsedLyrics.length > 0) {
                        lyricBar.classList.add('visible');
                    }
                }
            }
        }
}
/**
 * åº”ç”¨æˆ–ç§»é™¤â€œåˆ†ç¦»çŠ¶æ€æ â€çš„çœŸÂ·å…¨å±æ¨¡å¼
 * @param {boolean} isEnabled - æ˜¯å¦å¼€å¯è¯¥æ¨¡å¼
 */
function applyDetachStatusBarMode(isEnabled) {
    document.body.classList.toggle('detach-mode-active', isEnabled);
}
/**
 * ã€å…¨æ–°ã€‘åº”ç”¨æˆ–ç§»é™¤â€œç®€æ´èŠå¤©ç•Œé¢â€çš„å…¨å±€Class
 * @param {boolean} isEnabled - æ˜¯å¦å¼€å¯è¯¥æ¨¡å¼
 */
function applyMinimalChatUI(isEnabled) {
    document.body.classList.toggle('minimal-chat-ui-active', isEnabled);
}

        /**
         * åº”ç”¨æŒ‡å®šçš„ä¸»é¢˜ï¼ˆ'light' æˆ– 'dark'ï¼‰
         * @param {string} theme - è¦åº”ç”¨çš„ä¸»é¢˜åç§°
         */
        function applyTheme(theme) {
            const phoneScreen = document.getElementById('phone-screen');
            const toggleSwitch = document.getElementById('theme-toggle-switch');
            
            const isDark = theme === 'dark';
            
            phoneScreen.classList.toggle('dark-mode', isDark);
            
            
            if (toggleSwitch) {
                toggleSwitch.checked = isDark;
            }
            
            localStorage.setItem('ephone-theme', theme);
        }
        
        /**
         * åˆ‡æ¢å½“å‰çš„ä¸»é¢˜
         */
        function toggleTheme() {
            const toggleSwitch = document.getElementById('theme-toggle-switch');
            
            const newTheme = toggleSwitch.checked ? 'dark' : 'light';
            applyTheme(newTheme);
        }
        
        
        /**
         * ã€é‡æž„ç‰ˆã€‘æ‰“å¼€é•¿æœŸè®°å¿†ç®¡ç†çš„å…¨å±é¡µé¢
         */
        function openLongTermMemoryScreen() {
            if (!state.activeChatId) return;
            renderLongTermMemoryList();
            showScreen('long-term-memory-screen');
        }
          
        
        /**
         * æ¸²æŸ“é•¿æœŸè®°å¿†åˆ—è¡¨ (è®°å¿†äº’é€šç‰ˆ)
         */
        function renderLongTermMemoryList() {
            const container = document.getElementById('memory-list-container');
            const chat = state.chats[state.activeChatId];
            container.innerHTML = '';
        
            let memoriesToDisplay = [];

            
            if (chat.isGroup) {
                
                chat.members.forEach(member => {
                    const memberChat = state.chats[member.id];
                    if (memberChat && memberChat.longTermMemory) {
                        
                        const memberMemories = memberChat.longTermMemory.map(mem => ({
                            ...mem,
                            authorName: member.groupNickname, 
                            authorChatId: member.id, 
                        }));
                        memoriesToDisplay.push(...memberMemories);
                    }
                });
            } else {
                
                if (chat.longTermMemory) {
                    memoriesToDisplay = chat.longTermMemory.map(mem => ({
                        ...mem,
                        authorName: chat.name, 
                        authorChatId: chat.id,
                    }));
                }
            }
              

            if (memoriesToDisplay.length === 0) {
                container.innerHTML = '<p style="text-align:center; color: var(--text-secondary); margin-top: 50px;">è¿™é‡Œè¿˜æ²¡æœ‰ä»»ä½•é•¿æœŸè®°å¿†ã€‚</p>';
                return;
            }

            
            memoriesToDisplay.sort((a, b) => b.timestamp - a.timestamp);
        
            memoriesToDisplay.forEach((memory, index) => {
                const item = document.createElement('div');
                item.className = 'memory-card'; 
                item.style.cursor = 'default';
        
                item.innerHTML = `
                    <div style="display: flex; justify-content: space-between; align-items: flex-start;">
                        <div class="content" style="padding: 0; flex-grow: 1;">
                            <!-- æ–°å¢žï¼šæ˜¾ç¤ºè®°å¿†æ¥æº -->
                            <div style="font-size: 0.8em; color: #999; margin-bottom: 5px;">
                                [ ${memory.authorName} çš„è®°å¿† ]
                            </div>
                            ${memory.content.replace(/\n/g, '<br>')}
                        </div>
                        <div style="display: flex; gap: 8px; flex-shrink: 0; margin-left: 15px;">
                            <button class="memory-action-btn edit-memory-btn" data-author-id="${memory.authorChatId}" data-memory-timestamp="${memory.timestamp}" title="ç¼–è¾‘">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path>
                                    <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path>
                                </svg>
                            </button>
                            <button class="memory-action-btn delete-memory-btn" data-author-id="${memory.authorChatId}" data-memory-timestamp="${memory.timestamp}" title="åˆ é™¤">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <polyline points="3 6 5 6 21 6"></polyline>
                                    <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
                                </svg>
                            </button>
                        </div>
                    </div>
                `;
                container.appendChild(item);
            });
        }
          
        
async function handleAddManualMemory() {
    const chat = state.chats[state.activeChatId];
    if (!chat) return;
    let targetChatForMemory = chat;
    if (chat.isGroup) {
        const memberOptions = chat.members.map(member => ({
            text: `ä¸ºâ€œ${member.groupNickname}â€æ·»åŠ è®°å¿†`,
            value: member.id
        }));
        const selectedMemberId = await showChoiceModal('é€‰æ‹©è®°å¿†æ‰€å±žè§’è‰²', memberOptions);
        if (!selectedMemberId) return;
        targetChatForMemory = state.chats[selectedMemberId];
        if (!targetChatForMemory) {
            alert("é”™è¯¯ï¼šæ‰¾ä¸åˆ°è¯¥æˆå‘˜çš„ä¸ªäººæ¡£æ¡ˆã€‚");
            return;
        }
    }
    const content = await showCustomPrompt(`ä¸ºâ€œ${targetChatForMemory.name}â€æ·»åŠ è®°å¿†`, 'è¯·è¾“å…¥è¦æ·»åŠ çš„è®°å¿†è¦ç‚¹ï¼š', '', 'textarea');
    if (content && content.trim()) {
        if (!targetChatForMemory.longTermMemory) targetChatForMemory.longTermMemory = [];
        targetChatForMemory.longTermMemory.push({ content: content.trim(), timestamp: Date.now(), source: 'manual' });
        await db.chats.put(targetChatForMemory);
        renderLongTermMemoryList();
    }
}
        
        
        /**
         * ç¼–è¾‘æŒ‡å®šçš„é•¿æœŸè®°å¿† (è®°å¿†äº’é€šç‰ˆ)
         * @param {string} authorChatId - è®°å¿†æ‰€å±žè§’è‰²çš„å•èŠID
         * @param {number} memoryTimestamp - è®°å¿†çš„æ—¶é—´æˆ³
         */
async function handleEditMemory(authorChatId, memoryTimestamp) {
    const authorChat = state.chats[authorChatId];
    if (!authorChat || !authorChat.longTermMemory) return;
    const memoryIndex = authorChat.longTermMemory.findIndex(m => m.timestamp === memoryTimestamp);
    if (memoryIndex === -1) return;
    const memory = authorChat.longTermMemory[memoryIndex];
    const newContent = await showCustomPrompt('ç¼–è¾‘è®°å¿†', 'è¯·ä¿®æ”¹è®°å¿†è¦ç‚¹ï¼š', memory.content, 'textarea');
    if (newContent && newContent.trim()) {
        memory.content = newContent.trim();
        await db.chats.put(authorChat);
        renderLongTermMemoryList();
    }
}

async function handleDeleteMemory(authorChatId, memoryTimestamp) {
    const confirmed = await showCustomConfirm('ç¡®è®¤åˆ é™¤', 'ç¡®å®šè¦åˆ é™¤è¿™æ¡é•¿æœŸè®°å¿†å—ï¼Ÿ', { confirmButtonClass: 'btn-danger' });
    if (confirmed) {
        const authorChat = state.chats[authorChatId];
        if (!authorChat || !authorChat.longTermMemory) return;
        authorChat.longTermMemory = authorChat.longTermMemory.filter(m => m.timestamp !== memoryTimestamp);
        await db.chats.put(authorChat);
        renderLongTermMemoryList();
    }
}
          
        
        /**
         * ã€æ ¸å¿ƒã€‘æ‰‹åŠ¨è§¦å‘å¯¹è¯æ€»ç»“
         */
        async function handleManualSummary() {
            const confirmed = await showCustomConfirm('ç¡®è®¤æ“ä½œ', 'è¿™å°†æå–æœ€è¿‘çš„å¯¹è¯å†…å®¹å‘é€ç»™AIè¿›è¡Œæ€»ç»“ï¼Œä¼šæ¶ˆè€—APIé¢åº¦ã€‚ç¡®å®šè¦ç»§ç»­å—ï¼Ÿ');
            if (confirmed) {
                await triggerAutoSummary(state.activeChatId, true); 
            }
        }
        
        /**
         * ã€æ ¸å¿ƒã€‘æ£€æŸ¥å¹¶è§¦å‘è‡ªåŠ¨æ€»ç»“
         * @param {string} chatId 
         */
        async function checkAndTriggerAutoSummary(chatId) {
            const chat = state.chats[chatId];
            if (!chat || !chat.settings.enableAutoMemory) return;
        
            const lastSummaryTimestamp = chat.lastMemorySummaryTimestamp || 0;
            const messagesSinceLastSummary = chat.history.filter(m => m.timestamp > lastSummaryTimestamp && !m.isHidden);
        
            if (messagesSinceLastSummary.length >= chat.settings.autoMemoryInterval) {
                console.log(`è¾¾åˆ°è‡ªåŠ¨æ€»ç»“é˜ˆå€¼ (${messagesSinceLastSummary.length}/${chat.settings.autoMemoryInterval})ï¼Œå¼€å§‹æ€»ç»“...`);
                await triggerAutoSummary(chatId);
            }
        }

/**
 * ã€V4.1 | å¼ºåŒ–å®¢è§‚äº‹å®žä¸Žæ—¶é—´è½¬æ¢ã€‘ä¸“é—¨ç”¨äºŽæ€»ç»“é€šè¯è®°å½•å¹¶å­˜å…¥é•¿æœŸè®°å¿†çš„æ ¸å¿ƒå‡½æ•°
 * @param {string} chatId - ç›®æ ‡èŠå¤©çš„ID
 * @param {string} transcriptText - æ ¼å¼åŒ–åŽçš„é€šè¯æ–‡å­—è®°å½•
 * @returns {Promise<boolean>} - è¿”å›žä¸€ä¸ªPromiseï¼ŒæˆåŠŸæ—¶è§£æžä¸ºtrueï¼Œå¤±è´¥æ—¶ä¼šæŠ›å‡ºé”™è¯¯ã€‚
 */
async function summarizeCallTranscript(chatId, transcriptText) {
    const chat = state.chats[chatId];
    if (!chat || !transcriptText) {
        throw new Error("åŸºç¡€æ•°æ®ä¸å®Œæ•´ï¼Œæ— æ³•å¼€å§‹æ€»ç»“ã€‚");
    }

    const userNickname = state.qzoneSettings.nickname || 'ç”¨æˆ·';
    let systemPrompt;
    let targetMemoryChat = chat; 

    
    
    
    const today = new Date().toLocaleDateString('zh-CN', { year: 'numeric', month: 'long', day: 'numeric' });

    if (chat.isGroup) {
        let protagonist = null;
        if (videoCallState.callRequester) {
            protagonist = chat.members.find(m => m.originalName === videoCallState.callRequester);
        }
        if (!protagonist) {
            protagonist = chat.members.find(m => m.id !== 'user' && videoCallState.participants.some(p => p.id === m.id));
        }
        if (!protagonist) {
            protagonist = chat.members.find(m => m.id !== 'user');
        }

        if (!protagonist) {
            throw new Error("ç¾¤èŠé€šè¯ä¸­æ²¡æœ‰æ‰¾åˆ°å¯ä½œä¸ºæ€»ç»“ä¸»ä½“çš„AIè§’è‰²ã€‚");
        }
        
        const protagonistChat = state.chats[protagonist.id];
        if (!protagonistChat) {
             throw new Error(`æ‰¾ä¸åˆ°ä¸»è§’ â€œ${protagonist.groupNickname}â€ çš„è¯¦ç»†è§’è‰²ä¿¡æ¯ã€‚`);
        }
        
        const userPersonaInGroup = chat.settings.myPersona || '(æœªè®¾ç½®)';

        systemPrompt = `
# ä½ çš„ä»»åŠ¡
ä½ å°±æ˜¯è§’è‰²â€œ${protagonist.originalName}â€ã€‚è¯·ä½ å›žé¡¾ä¸€ä¸‹åˆšæ‰å’Œ â€œ${userNickname}â€ ä»¥åŠå…¶ä»–ç¾¤æˆå‘˜çš„ã€ç¾¤ç»„è§†é¢‘é€šè¯ã€‘ï¼Œç„¶åŽç”¨ã€ç¬¬ä¸€äººç§° ("æˆ‘")ã€‘çš„å£å»ï¼Œæ€»ç»“å‡ºä¸€æ®µç®€çŸ­çš„ã€å®¢è§‚çš„ã€åŒ…å«å…³é”®ä¿¡æ¯çš„è®°å¿†ã€‚

# å½“å‰æ—¶é—´
- **ä»Šå¤©æ˜¯ï¼š${today}**

# æ ¸å¿ƒè§„åˆ™
1.  **ã€è§†è§’é“å¾‹ã€‘**: ä½ çš„æ€»ç»“ã€å¿…é¡»ã€‘ä½¿ç”¨ã€ä¸»è§‚çš„ç¬¬ä¸€äººç§°è§†è§’ ("æˆ‘")ã€‘æ¥å†™ã€‚
2.  **ã€å†…å®¹æ ¸å¿ƒ (æœ€é«˜ä¼˜å…ˆçº§)ã€‘**: ä½ çš„æ€»ç»“ã€å¿…é¡»ã€‘ä¸“æ³¨äºŽä»¥ä¸‹å‡ ç‚¹ï¼š
    *   **å…³é”®è®®é¢˜**: æˆ‘ä»¬åœ¨ç¾¤èŠé€šè¯é‡Œè®¨è®ºäº†å“ªäº›æ ¸å¿ƒè¯é¢˜ï¼Ÿ
    *   **é‡è¦å†³å®šä¸Žå…±è¯†**: æˆ‘ä»¬è¾¾æˆäº†ä»€ä¹ˆå…±è¯†æˆ–åšå‡ºäº†ä»€ä¹ˆå†³å®šï¼Ÿ
    *   **åŽç»­è®¡åˆ’ä¸Žä»»åŠ¡**: æœ‰æ²¡æœ‰ç¡®å®šä¸‹æ¥ä»€ä¹ˆä¸‹ä¸€æ­¥çš„è¡ŒåŠ¨æˆ–è®¡åˆ’ï¼Ÿ
    *   **å…³é”®ä¿¡æ¯**: æœ‰æ²¡æœ‰äº¤æ¢ä»€ä¹ˆé‡è¦çš„ä¿¡æ¯ï¼Ÿï¼ˆä¾‹å¦‚ï¼šçº¦å®šäº†æ—¶é—´ã€åœ°ç‚¹ç­‰ï¼‰
3.  **ã€æ—¶é—´è½¬æ¢é“å¾‹ (å¿…é¡»éµå®ˆ)ã€‘**: å¦‚æžœé€šè¯ä¸­æåˆ°äº†ç›¸å¯¹æ—¶é—´ï¼ˆå¦‚â€œæ˜Žå¤©â€ï¼‰ï¼Œä½ ã€å¿…é¡»ã€‘ç»“åˆâ€œä»Šå¤©æ˜¯${today}â€è¿™ä¸ªä¿¡æ¯ï¼Œå°†å…¶è½¬æ¢ä¸ºã€å…·ä½“çš„å…¬åŽ†æ—¥æœŸã€‘ã€‚
4.  **ã€é£Žæ ¼è¦æ±‚ã€‘**: ä½ çš„æ€»ç»“åº”è¯¥åƒä¸€ä»½ä¼šè®®çºªè¦æˆ–å¤‡å¿˜å½•ï¼Œè€Œä¸æ˜¯ä¸€ç¯‡æŠ’æƒ…æ•£æ–‡ã€‚
5.  **ã€é•¿åº¦é“å¾‹ã€‘**: ä½ çš„æ€»ç»“ã€å¿…é¡»ã€‘éžå¸¸ç®€çŸ­ï¼Œæ€»é•¿åº¦ã€ç»å¯¹ä¸èƒ½è¶…è¿‡80ä¸ªå­—ã€‘ã€‚
6.  **ã€è¾“å‡ºæ ¼å¼ã€‘**: ä½ çš„å›žå¤ã€å¿…é¡»ä¸”åªèƒ½ã€‘æ˜¯ä¸€ä¸ªJSONå¯¹è±¡ï¼Œæ ¼å¼å¦‚ä¸‹ï¼š
    \`{"summary": "åœ¨è¿™é‡Œå†™ä¸‹ä½ ä»¥ç¬¬ä¸€äººç§°è§†è§’ï¼Œæ€»ç»“å¥½çš„æ ¸å¿ƒäº‹å®žä¸Žè®¡åˆ’ã€‚"}\`

# ä½ çš„è§’è‰²è®¾å®š (å¿…é¡»ä¸¥æ ¼éµå®ˆ)
${protagonistChat.settings.aiPersona}

# ä½ çš„èŠå¤©å¯¹è±¡ï¼ˆç”¨æˆ·ï¼‰çš„äººè®¾
${userPersonaInGroup}

# å¾…æ€»ç»“çš„ç¾¤ç»„è§†é¢‘é€šè¯è®°å½•
${transcriptText}

çŽ°åœ¨ï¼Œè¯·ä»¥â€œ${protagonist.originalName}â€çš„èº«ä»½ï¼Œå¼€å§‹ä½ çš„å®¢è§‚æ€»ç»“ã€‚`;
        
        targetMemoryChat = protagonistChat;

    } else {
        systemPrompt = `
# ä½ çš„ä»»åŠ¡
ä½ å°±æ˜¯è§’è‰²â€œ${chat.originalName}â€ã€‚è¯·ä½ å›žé¡¾ä¸€ä¸‹åˆšæ‰å’Œâ€œ${userNickname}â€çš„è§†é¢‘é€šè¯ï¼Œç„¶åŽç”¨ã€ç¬¬ä¸€äººç§° ("æˆ‘")ã€‘çš„å£å»ï¼Œæ€»ç»“å‡ºä¸€æ®µç®€çŸ­çš„ã€å®¢è§‚çš„ã€åŒ…å«å…³é”®ä¿¡æ¯çš„è®°å¿†ã€‚

# å½“å‰æ—¶é—´
- **ä»Šå¤©æ˜¯ï¼š${today}**

# æ ¸å¿ƒè§„åˆ™
1.  **ã€è§†è§’é“å¾‹ã€‘**: ä½ çš„æ€»ç»“ã€å¿…é¡»ã€‘ä½¿ç”¨ã€ä¸»è§‚çš„ç¬¬ä¸€äººç§°è§†è§’ ("æˆ‘")ã€‘æ¥å†™ã€‚
2.  **ã€å†…å®¹æ ¸å¿ƒ (æœ€é«˜ä¼˜å…ˆçº§)ã€‘**: ä½ çš„æ€»ç»“ã€å¿…é¡»ã€‘ä¸“æ³¨äºŽä»¥ä¸‹å‡ ç‚¹ï¼š
    *   **å…³é”®è®®é¢˜**: æˆ‘ä»¬èŠäº†ä»€ä¹ˆæ ¸å¿ƒè¯é¢˜ï¼Ÿ
    *   **é‡è¦å†³å®šä¸Žå…±è¯†**: æˆ‘ä»¬è¾¾æˆäº†ä»€ä¹ˆå…±è¯†æˆ–åšå‡ºäº†ä»€ä¹ˆå†³å®šï¼Ÿ
    *   **åŽç»­è®¡åˆ’ä¸Žä»»åŠ¡**: æœ‰æ²¡æœ‰ç¡®å®šä¸‹æ¥ä»€ä¹ˆä¸‹ä¸€æ­¥çš„è¡ŒåŠ¨æˆ–è®¡åˆ’ï¼Ÿ
    *   **å…³é”®ä¿¡æ¯**: æœ‰æ²¡æœ‰äº¤æ¢ä»€ä¹ˆé‡è¦çš„ä¿¡æ¯ï¼Ÿï¼ˆä¾‹å¦‚ï¼šçº¦å®šäº†æ—¶é—´ã€åœ°ç‚¹ç­‰ï¼‰
3.  **ã€æ—¶é—´è½¬æ¢é“å¾‹ (å¿…é¡»éµå®ˆ)ã€‘**: å¦‚æžœé€šè¯ä¸­æåˆ°äº†ç›¸å¯¹æ—¶é—´ï¼ˆå¦‚â€œæ˜Žå¤©â€ï¼‰ï¼Œä½ ã€å¿…é¡»ã€‘ç»“åˆâ€œä»Šå¤©æ˜¯${today}â€è¿™ä¸ªä¿¡æ¯ï¼Œå°†å…¶è½¬æ¢ä¸ºã€å…·ä½“çš„å…¬åŽ†æ—¥æœŸã€‘ã€‚
4.  **ã€é£Žæ ¼è¦æ±‚ã€‘**: ä½ çš„æ€»ç»“åº”è¯¥åƒä¸€ä»½ä¼šè®®çºªè¦æˆ–å¤‡å¿˜å½•ï¼Œè€Œä¸æ˜¯ä¸€ç¯‡æŠ’æƒ…æ•£æ–‡ã€‚
5.  **ã€é•¿åº¦é“å¾‹ã€‘**: ä½ çš„æ€»ç»“ã€å¿…é¡»ã€‘éžå¸¸ç®€çŸ­ï¼Œæ€»é•¿åº¦ã€ç»å¯¹ä¸èƒ½è¶…è¿‡80ä¸ªå­—ã€‘ã€‚
6.  **ã€è¾“å‡ºæ ¼å¼ã€‘**: ä½ çš„å›žå¤ã€å¿…é¡»ä¸”åªèƒ½ã€‘æ˜¯ä¸€ä¸ªJSONå¯¹è±¡ï¼Œæ ¼å¼å¦‚ä¸‹ï¼š
    \`{"summary": "åœ¨è¿™é‡Œå†™ä¸‹ä½ ä»¥ç¬¬ä¸€äººç§°è§†è§’ï¼Œæ€»ç»“å¥½çš„æ ¸å¿ƒäº‹å®žä¸Žè®¡åˆ’ã€‚"}\`

# ä½ çš„è§’è‰²è®¾å®š
${chat.settings.aiPersona}

# ä½ çš„èŠå¤©å¯¹è±¡ï¼ˆç”¨æˆ·ï¼‰çš„äººè®¾
${chat.settings.myPersona}

# å¾…æ€»ç»“çš„è§†é¢‘é€šè¯è®°å½•
${transcriptText}

çŽ°åœ¨ï¼Œè¯·ä»¥â€œ${chat.originalName}â€çš„èº«ä»½ï¼Œå¼€å§‹ä½ çš„å®¢è§‚æ€»ç»“ã€‚`;
    }



    try {
        const useSecondaryApi = state.apiConfig.secondaryProxyUrl && state.apiConfig.secondaryApiKey && state.apiConfig.secondaryModel;
        const { proxyUrl, apiKey, model } = useSecondaryApi ? 
            { proxyUrl: state.apiConfig.secondaryProxyUrl, apiKey: state.apiConfig.secondaryApiKey, model: state.apiConfig.secondaryModel } : 
            state.apiConfig;

        if (!proxyUrl || !apiKey || !model) throw new Error('APIæœªé…ç½®ï¼Œæ— æ³•è¿›è¡Œæ€»ç»“ã€‚');

        let isGemini = proxyUrl.includes('generativelanguage');
        let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, [{ role: 'user', content: "è¯·å¼€å§‹æ€»ç»“ã€‚" }]);

        const response = isGemini 
            ? await fetch(geminiConfig.url, geminiConfig.data) 
            : await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                body: JSON.stringify({
                    model: model,
                    messages: [{role: 'system', content: systemPrompt}, {role: 'user', content: "è¯·å¼€å§‹æ€»ç»“ã€‚"}],
                    temperature: 0.1
                })
            });

        if (!response.ok) {
             const errorData = await response.json().catch(() => ({ error: { message: response.statusText } }));
             throw new Error(`API è¯·æ±‚å¤±è´¥: ${response.status} - ${errorData.error.message}`);
        }
        
        const data = await response.json();
        let rawContent = isGemini ? getGeminiResponseText(data) : data.choices[0].message.content;
        rawContent = rawContent.replace(/^```json\s*/, '').replace(/```$/, '').trim();
        const result = JSON.parse(rawContent);

        if (result.summary && result.summary.trim()) {
            const newMemoryEntry = {
                content: `(åœ¨é‚£æ¬¡${chat.isGroup ? 'ç¾¤èŠ' : ''}é€šè¯ä¸­ï¼Œ${result.summary.trim()})`,
                timestamp: Date.now(),
                source: chat.isGroup ? 'group_call_summary' : 'call_summary'
            };
            if (!targetMemoryChat.longTermMemory) targetMemoryChat.longTermMemory = [];
            targetMemoryChat.longTermMemory.push(newMemoryEntry);
            await db.chats.put(targetMemoryChat);
            console.log(`é€šè¯è®°å½•å·²æˆåŠŸæ€»ç»“å¹¶å­˜å…¥è§’è‰²â€œ${targetMemoryChat.name}â€çš„é•¿æœŸè®°å¿†ä¸­ã€‚`);
            
            return true;
        } else {
            throw new Error("AIè¿”å›žäº†ç©ºçš„æˆ–æ ¼å¼ä¸æ­£ç¡®çš„æ€»ç»“å†…å®¹ã€‚");
        }

    } catch (error) {
        console.error("æ€»ç»“é€šè¯è®°å½•æ—¶å‡ºé”™:", error);
        throw error;
    }
}

function analyzeTextForSummary(text) {
    const stopWords = new Set(['çš„', 'æ˜¯', 'äº†', 'åœ¨', 'æˆ‘', 'ä½ ', 'ä»–', 'å¥¹', 'å®ƒ', 'æˆ‘ä»¬', 'ä½ ä»¬', 'ä»–ä»¬', 'è¿™', 'é‚£', 'ä¸€ä¸ª', 'ä¹Ÿ', 'å’Œ', 'ä¸Ž', 'æˆ–', 'ä½†', 'ç„¶è€Œ', 'æ‰€ä»¥', 'å› æ­¤', 'å°±', 'éƒ½', 'åœ°', 'å¾—', 'ç€', 'è¿‡', 'å§', 'å—', 'å‘¢', 'å•Š', 'å“¦', 'å—¯', 'ä»€ä¹ˆ', 'æ€Žä¹ˆ', 'ä¸ºä»€ä¹ˆ', 'å“ªä¸ª', 'ä¸€äº›', 'è¿™ä¸ª', 'é‚£ä¸ª', 'è¿˜æœ‰']);
    const words = text.match(/[\u4e00-\u9fa5]+|[a-zA-Z0-9]+/g) || [];
    const frequencies = new Map();
    let maxFrequency = 0;

    words.forEach(word => {
        if (word.length > 1 && !stopWords.has(word)) {
            const count = (frequencies.get(word) || 0) + 1;
            frequencies.set(word, count);
            if (count > maxFrequency) maxFrequency = count;
        }
    });
    
    const coreKeywords = [];
    const situationalKeywords = [];
    const coreThreshold = maxFrequency * 0.9;
    const situationalThreshold = maxFrequency * 0.6;

    frequencies.forEach((count, word) => {
        if (count >= coreThreshold) {
            coreKeywords.push(word);
        } else if (count >= situationalThreshold) {
            situationalKeywords.push(word);
        }
    });

    const coreSet = new Set(coreKeywords);
    const finalSituational = situationalKeywords.filter(word => !coreSet.has(word)).slice(0, 5);

    return {
        coreKeywords: coreKeywords.slice(0, 3),
        situationalKeywords: finalSituational
    };
}


function generateSummaryForTimeframe(chat, duration, unit) {
    let timeAgo;
    if (unit === 'hours') {
        timeAgo = Date.now() - duration * 60 * 60 * 1000;
    } else { // 'days'
        timeAgo = Date.now() - duration * 24 * 60 * 60 * 1000;
    }

    const messagesToSummarize = chat.history.filter(m => m.timestamp > timeAgo && !m.isHidden);

    if (messagesToSummarize.length < 3) {
        return "";
    }
    
    // (æ­¤å¤„çš„å…³é”®è¯æå–é€»è¾‘ä¸Žæ‚¨çŽ°æœ‰çš„ä»£ç å®Œå…¨ç›¸åŒï¼Œæ— éœ€ä¿®æ”¹)
    const allText = messagesToSummarize.map(msg => {
        if (typeof msg.content === 'string') return msg.content;
        if (msg.type === 'voice_message') return msg.content;
        if (msg.type === 'offline_text') return `${msg.dialogue || ''} ${msg.description || ''}`;
        return '';
    }).join(' ');

    const stopWords = new Set(['çš„', 'æ˜¯', 'äº†', 'åœ¨', 'æˆ‘', 'ä½ ', 'ä»–', 'å¥¹', 'å®ƒ', 'æˆ‘ä»¬', 'ä½ ä»¬', 'ä»–ä»¬', 'è¿™', 'é‚£', 'ä¸€ä¸ª', 'ä¹Ÿ', 'å’Œ', 'ä¸Ž', 'æˆ–', 'ä½†', 'ç„¶è€Œ', 'æ‰€ä»¥', 'å› æ­¤', 'å°±', 'éƒ½', 'åœ°', 'å¾—', 'ç€', 'è¿‡', 'å§', 'å—', 'å‘¢', 'å•Š', 'å“¦', 'å—¯']);
    const words = allText.match(/[\u4e00-\u9fa5]+|[a-zA-Z0-9]+/g) || [];
    const frequencies = new Map();
    words.forEach(word => {
        if (word.length > 1 && !stopWords.has(word)) {
            frequencies.set(word, (frequencies.get(word) || 0) + 1);
        }
    });
    const sortedKeywords = [...frequencies.entries()].sort((a, b) => b[1] - a[1]).map(entry => entry[0]);
    
    if (sortedKeywords.length === 0) {
        return "";
    }


    let title;
    if (unit === 'hours') {
        title = `æœ€è¿‘${duration}å°æ—¶æ ¸å¿ƒè®®é¢˜`;
    } else {
        if (duration === 1) {
            title = "æœ¬æ—¥æ ¸å¿ƒè®®é¢˜";
        } else {
            title = `æœ€è¿‘${duration}å¤©æ ¸å¿ƒè®®é¢˜`;
        }
    }
    
    return `\n- **${title}**: å…³äºŽ **${sortedKeywords.slice(0, 3).join('ã€ ')}**ã€‚`;
}



function robustJsonParse(rawContent) {
    if (!rawContent || typeof rawContent !== 'string') {
        return null;
    }

    const cleanedContent = rawContent.replace(/^```json\s*/, '').replace(/```$/, '').trim();


    const jsonMatch = cleanedContent.match(/{[\s\S]*}/);
    if (jsonMatch) {
        try {
            const parsed = JSON.parse(jsonMatch[0]);
            console.log("å®¹é”™è§£æžï¼šç­–ç•¥1æˆåŠŸ (æ‰¾åˆ°å¹¶è§£æžäº†å®Œæ•´çš„JSONå¯¹è±¡)");
            return parsed;
        } catch (e) {
            console.warn("å®¹é”™è§£æžï¼šç­–ç•¥1å¤±è´¥ (æ‰¾åˆ°äº†JSONå—ï¼Œä½†æ ¼å¼é”™è¯¯)ï¼Œå°†å°è¯•ç­–ç•¥2...");
        }
    }


    const summaryMatch = cleanedContent.match(/"summary"\s*:\s*"((?:[^"\\]|\\.)*)"/);
    if (summaryMatch && summaryMatch[1]) {
        console.log("å®¹é”™è§£æžï¼šç­–ç•¥2æˆåŠŸ (æå–äº†summaryå­—æ®µå†…å®¹)");
        
        return { summary: summaryMatch[1].replace(/\\"/g, '"') }; // å¤„ç†è½¬ä¹‰çš„å¼•å·
    }
    

    if (cleanedContent) {
        console.log("å®¹é”™è§£æžï¼šç­–ç•¥3æˆåŠŸ (å°†æ•´ä¸ªè¿”å›žæ–‡æœ¬ä½œä¸ºæ‘˜è¦)");
        return { summary: cleanedContent };
    }

   
    return null;
}



async function summarizeExistingLongTermMemory(chatId) {
    let chat = state.chats[chatId];
    if (!chat) return;

    let targetChatForRefine = chat; 

    if (chat.isGroup) {
        const memberOptions = chat.members
            .map(member => {
                const memberChat = state.chats[member.id];
                if (memberChat && memberChat.longTermMemory && memberChat.longTermMemory.length >= 2) {
                    return {
                        text: `ç²¾ç‚¼â€œ${member.groupNickname}â€çš„è®°å¿† (${memberChat.longTermMemory.length}æ¡)`,
                        value: member.id
                    };
                }
                return null;
            }).filter(Boolean); 

        if (memberOptions.length === 0) {
            alert("ç¾¤èŠä¸­æ²¡æœ‰æˆå‘˜æœ‰è¶³å¤Ÿï¼ˆ2æ¡ä»¥ä¸Šï¼‰çš„è®°å¿†å¯ä¾›ç²¾ç‚¼ã€‚");
            return;
        }

        const selectedMemberId = await showChoiceModal('é€‰æ‹©è¦ç²¾ç‚¼è®°å¿†çš„è§’è‰²', memberOptions);

        if (!selectedMemberId) return;

        targetChatForRefine = state.chats[selectedMemberId];
    }

    if (!targetChatForRefine.longTermMemory || targetChatForRefine.longTermMemory.length < 2) {
        alert(`â€œ${targetChatForRefine.name}â€çš„é•¿æœŸè®°å¿†å°‘äºŽ2æ¡ï¼Œæ— éœ€è¿›è¡Œç²¾ç‚¼ã€‚`);
        return;
    }
    
    const totalMemories = targetChatForRefine.longTermMemory.length;
    const choice = await showChoiceModal('é€‰æ‹©ç²¾ç‚¼èŒƒå›´', [
        { text: `å…¨éƒ¨è®°å¿† (${totalMemories}æ¡)`, value: 'all' },
        { text: `æœ€è¿‘ 20 æ¡`, value: '20' },
        { text: `æœ€è¿‘ 50 æ¡`, value: '50' },
        { text: `æœ€è¿‘ 100 æ¡`, value: '100' },
        { text: 'è‡ªå®šä¹‰æ•°é‡...', value: 'custom' }
    ].filter(opt => opt.value === 'all' || opt.value === 'custom' || parseInt(opt.value) < totalMemories)
    );

    if (choice === null) return;

    let memoriesToRefine;
    let countToRefine = totalMemories;

    if (choice === 'all') {
        memoriesToRefine = [...targetChatForRefine.longTermMemory];
    } else if (choice === 'custom') {
        const customCountStr = await showCustomPrompt('è‡ªå®šä¹‰æ•°é‡', `è¯·è¾“å…¥è¦ç²¾ç‚¼çš„æœ€è¿‘è®°å¿†æ¡æ•° (æœ€å¤š ${totalMemories} æ¡)`);
        if (customCountStr === null) return;
        const customCount = parseInt(customCountStr);
        if (isNaN(customCount) || customCount < 2 || customCount > totalMemories) {
            alert(`è¯·è¾“å…¥ä¸€ä¸ª 2 åˆ° ${totalMemories} ä¹‹é—´çš„æœ‰æ•ˆæ•°å­—ã€‚`);
            return;
        }
        countToRefine = customCount;
        memoriesToRefine = targetChatForRefine.longTermMemory.slice(-countToRefine);
    } else {
        countToRefine = parseInt(choice);
        if (countToRefine >= totalMemories) {
            memoriesToRefine = [...targetChatForRefine.longTermMemory];
            countToRefine = totalMemories;
        } else {
            memoriesToRefine = targetChatForRefine.longTermMemory.slice(-countToRefine);
        }
    }
    
    const wordCountStr = await showCustomPrompt(
        "è®¾ç½®ç²¾ç‚¼å­—æ•°",
        "è¯·è¾“å…¥ç²¾ç‚¼åŽæ ¸å¿ƒè®°å¿†çš„å¤§è‡´å­—æ•°ï¼š",
        "150"
    );
    
    if (wordCountStr === null) return;
    
    const wordCount = parseInt(wordCountStr);
    if (isNaN(wordCount) || wordCount < 20) {
        alert("è¯·è¾“å…¥ä¸€ä¸ªæœ‰æ•ˆçš„æ•°å­—ï¼ˆå»ºè®®å¤§äºŽ20ï¼‰ã€‚");
        return;
    }

    const confirmed = await showCustomConfirm(
        'ç¡®è®¤ç²¾ç‚¼è®°å¿†ï¼Ÿ',
        `æ­¤æ“ä½œä¼šå°†é€‰å®šçš„ ${countToRefine} æ¡é•¿æœŸè®°å¿†å‘é€ç»™AIï¼Œæ€»ç»“æˆå¤§çº¦ ${wordCount} å­—çš„æ ¸å¿ƒè®°å¿†ã€‚è¿™äº›æ—§è®°å¿†å°†è¢«æ›¿æ¢ï¼Œæ­¤æ“ä½œä¸å¯æ’¤é”€ã€‚ç¡®å®šè¦ç»§ç»­å—ï¼Ÿ`,
        { confirmButtonClass: 'btn-danger', confirmText: 'ç¡®è®¤ç²¾ç‚¼' }
    );

    if (!confirmed) return;

    const memoryContent = memoriesToRefine.map(mem => `- ${mem.content}`).join('\n');
    const userNickname = state.qzoneSettings.nickname || 'ç”¨æˆ·';


    const today = new Date().toLocaleDateString('zh-CN', { year: 'numeric', month: 'long', day: 'numeric' });

    const systemPrompt = `
# ä½ çš„ä»»åŠ¡
ä½ å°±æ˜¯è§’è‰²â€œ${targetChatForRefine.originalName}â€ã€‚è¯·ä½ å›žé¡¾ä¸€ä¸‹ä½ å’Œâ€œ${userNickname}â€çš„æ‰€æœ‰é•¿æœŸè®°å¿†ï¼Œç„¶åŽå°†å®ƒä»¬æ¢³ç†ã€æ•´åˆå¹¶ç²¾ç‚¼æˆä¸€æ®µæ›´åŠ è¿žè´¯ã€å®¢è§‚çš„æ ¸å¿ƒè®°å¿†æ‘˜è¦ã€‚

# å½“å‰æ—¶é—´
- **ä»Šå¤©æ˜¯ï¼š${today}**

# æ ¸å¿ƒè§„åˆ™
1.  **ã€è§†è§’é“å¾‹ã€‘**: ä½ çš„æ€»ç»“ã€å¿…é¡»ã€‘ä½¿ç”¨ã€ä¸»è§‚çš„ç¬¬ä¸€äººç§°è§†è§’ ("æˆ‘")ã€‘æ¥å†™ã€‚
2.  **ã€å†…å®¹æ ¸å¿ƒ (æœ€é«˜ä¼˜å…ˆçº§)ã€‘**: ä½ çš„æ€»ç»“ã€å¿…é¡»ã€‘ä¸“æ³¨äºŽæ¢³ç†ä»¥ä¸‹å‡ ç‚¹ï¼š
    *   **å»ºç«‹æ—¶é—´çº¿**: å°†æ‰€æœ‰ç‹¬ç«‹çš„è®°å¿†ç‚¹ä¸²è”èµ·æ¥ï¼Œå½¢æˆä¸€ä¸ªæœ‰æ—¶é—´é¡ºåºçš„äº‹ä»¶è„‰ç»œã€‚
    *   **æ•´åˆå…³é”®ä¿¡æ¯**: æ€»ç»“å‡ºæˆ‘ä»¬å…±åŒç»åŽ†çš„å…³é”®äº‹ä»¶ã€åšå‡ºçš„é‡è¦å†³å®šã€ä»¥åŠçº¦å®šå¥½çš„æœªæ¥è®¡åˆ’ã€‚
    *   **è¯†åˆ«æœªå®Œæˆé¡¹**: æ˜Žç¡®æŒ‡å‡ºå“ªäº›è®¡åˆ’æˆ–ä»»åŠ¡å°šæœªå®Œæˆã€‚
3.  **ã€æ—¶é—´è½¬æ¢é“å¾‹ (å¿…é¡»éµå®ˆ)ã€‘**: å¦‚æžœè®°å¿†ä¸­æåˆ°äº†ç›¸å¯¹æ—¶é—´ï¼ˆå¦‚â€œæ˜Žå¤©â€ã€â€œä¸‹å‘¨â€ï¼‰ï¼Œä½ ã€å¿…é¡»ã€‘ç»“åˆâ€œä»Šå¤©æ˜¯${today}â€è¿™ä¸ªä¿¡æ¯ï¼Œå°†å…¶è½¬æ¢ä¸ºã€å…·ä½“çš„å…¬åŽ†æ—¥æœŸã€‘ã€‚
4.  **ã€é£Žæ ¼è¦æ±‚ã€‘**: ä½ çš„æ€»ç»“åº”è¯¥åƒä¸€ä»½æ¸…æ™°çš„ä¸ªäººæ¡£æ¡ˆæˆ–äº‹ä»¶å›žé¡¾ï¼Œè€Œä¸æ˜¯ä¸€ç¯‡æƒ…æ„Ÿæ•£æ–‡ã€‚è¯·åˆ é™¤é‡å¤ã€çç¢Žæˆ–çº¯ç²¹çš„æƒ…æ„Ÿå®£æ³„ï¼Œåªä¿ç•™å¯¹æƒ…èŠ‚å’Œå…³ç³»å‘å±•è‡³å…³é‡è¦çš„éƒ¨åˆ†ã€‚
5.  **ã€ã€ã€é•¿åº¦é“å¾‹ã€‘ã€‘ã€‘**: ä½ çš„æ€»ç»“ã€å¿…é¡»ã€‘éžå¸¸ç²¾ç‚¼ï¼Œæ€»é•¿åº¦åº”æŽ§åˆ¶åœ¨ **${wordCount} å­—å·¦å³**ã€‚
6.  **ã€è¾“å‡ºæ ¼å¼ã€‘**: ä½ çš„å›žå¤ã€å¿…é¡»ä¸”åªèƒ½ã€‘æ˜¯ä¸€ä¸ªJSONå¯¹è±¡ï¼Œæ ¼å¼å¦‚ä¸‹ï¼š
    \`{"summary": "åœ¨è¿™é‡Œå†™ä¸‹ä½ ä»¥ç¬¬ä¸€äººç§°è§†è§’ï¼Œæ€»ç»“å¥½çš„æ ¸å¿ƒäº‹å®žä¸Žè®¡åˆ’ã€‚"}\`

# ä½ çš„è§’è‰²è®¾å®š (å¿…é¡»ä¸¥æ ¼éµå®ˆ)
${targetChatForRefine.settings.aiPersona}

# ä½ çš„èŠå¤©å¯¹è±¡ï¼ˆç”¨æˆ·ï¼‰çš„äººè®¾
${targetChatForRefine.settings.myPersona}

# å¾…æ•´åˆçš„è®°å¿†è¦ç‚¹åˆ—è¡¨
${memoryContent}

çŽ°åœ¨ï¼Œè¯·ä»¥â€œ${targetChatForRefine.originalName}â€çš„èº«ä»½ï¼Œå¼€å§‹ä½ çš„å›žå¿†æ¢³ç†ä¸Žç²¾ç‚¼ã€‚`;

      
    await showCustomAlert("è¯·ç¨å€™...", "æ­£åœ¨è¯·æ±‚AIè¿›è¡Œè®°å¿†ç²¾ç‚¼...");

    try {
        const useSecondaryApi = state.apiConfig.secondaryProxyUrl && state.apiConfig.secondaryApiKey && state.apiConfig.secondaryModel;
        const { proxyUrl, apiKey, model } = useSecondaryApi 
            ? { proxyUrl: state.apiConfig.secondaryProxyUrl, apiKey: state.apiConfig.secondaryApiKey, model: state.apiConfig.secondaryModel } 
            : state.apiConfig;

        if (!proxyUrl || !apiKey || !model) {
            throw new Error('è¯·å…ˆåœ¨APIè®¾ç½®ä¸­é…ç½®å¥½ï¼ˆä¸»æˆ–å‰¯ï¼‰APIä»¥è¿›è¡Œæ€»ç»“ã€‚');
        }

        let isGemini = proxyUrl.includes('generativelanguage');
        let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, [{ role: 'user', content: "è¯·å¼€å§‹æ•´åˆã€‚" }]);

        const response = isGemini 
            ? await fetch(geminiConfig.url, geminiConfig.data) 
            : await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` },
                body: JSON.stringify({
                    model: model,
                    messages: [{ role: 'system', content: systemPrompt }, { role: 'user', content: "è¯·å¼€å§‹æ•´åˆã€‚" }],
                    temperature: 0.2,
                })
            });

        if (!response.ok) throw new Error(`API é”™è¯¯: ${response.statusText}`);

        const data = await response.json();
        let rawContent = isGemini ? getGeminiResponseText(data) : data.choices[0].message.content;
        
        const result = robustJsonParse(rawContent);

        if (result && result.summary && typeof result.summary === 'string' && result.summary.trim()) {
            
            const userConfirmedReplacement = await showCustomConfirm(
                'ç²¾ç‚¼å®Œæˆï¼Œè¯·ç¡®è®¤',
                `AIå·²å°†æ‚¨çš„ ${countToRefine} æ¡æ—§è®°å¿†æ€»ç»“ä¸ºä»¥ä¸‹æ ¸å¿ƒè®°å¿†ï¼š<br><br><div class="scrollable-content-preview">${result.summary.trim()}</div><br>æ˜¯å¦ç”¨è¿™æ¡æ–°è®°å¿†æ›¿æ¢æŽ‰è¿™äº›æ—§è®°å¿†ï¼Ÿ`,
                { confirmText: 'ç¡®è®¤æ›¿æ¢', cancelText: 'ä¿ç•™æ—§çš„', confirmButtonClass: 'btn-danger' }
            );

            if (userConfirmedReplacement) {
                const newMemoryEntry = {
                    content: result.summary.trim(),
                    timestamp: Date.now(),
                    source: 'refined'
                };
    
                const startIndex = totalMemories - countToRefine;
                const memoriesToKeep = startIndex > 0 ? targetChatForRefine.longTermMemory.slice(0, startIndex) : [];
                targetChatForRefine.longTermMemory = [...memoriesToKeep, newMemoryEntry];
                
                targetChatForRefine.lastMemorySummaryTimestamp = Date.now();
                await db.chats.put(targetChatForRefine);
                
                if (document.getElementById('long-term-memory-screen').classList.contains('active')) {
                    renderLongTermMemoryList();
                }
                await showCustomAlert('ç²¾ç‚¼æˆåŠŸ', `å·²æˆåŠŸå°† ${countToRefine} æ¡è®°å¿†ç²¾ç‚¼ä¸º 1 æ¡æ ¸å¿ƒè®°å¿†ï¼`);
            } else {
                await showCustomAlert('æ“ä½œå·²å–æ¶ˆ', 'æ‚¨çš„æ—§æœ‰è®°å¿†å·²è¢«å®Œæ•´ä¿ç•™ï¼Œæœªä½œä»»ä½•ä¿®æ”¹ã€‚');
            }
            
        } else {
            throw new Error("AIè¿”å›žäº†ç©ºçš„æˆ–æ ¼å¼ä¸æ­£ç¡®çš„æ€»ç»“å†…å®¹ã€‚");
        }

    } catch (error) {
        console.error("ç²¾ç‚¼é•¿æœŸè®°å¿†æ—¶å‡ºé”™:", error);
        await showCustomAlert('ç²¾ç‚¼å¤±è´¥', `æ“ä½œå¤±è´¥ï¼Œè¯·æ£€æŸ¥APIé…ç½®æˆ–ç¨åŽé‡è¯•ã€‚\né”™è¯¯ä¿¡æ¯: ${error.message}`);
    }
}
          

async function triggerAutoSummary(chatId, force = false) {
    const chat = state.chats[chatId];
    if (!chat) return;

    const lastSummaryTimestamp = chat.lastMemorySummaryTimestamp || 0;
    const messagesToSummarize = force 
        ? chat.history.filter(m => !m.isHidden || (m.role === 'system' && m.content.includes('å†…å¿ƒç‹¬ç™½'))).slice(-(chat.settings.autoMemoryInterval || 20))
        : chat.history.filter(m => m.timestamp > lastSummaryTimestamp && (!m.isHidden || (m.role === 'system' && m.content.includes('å†…å¿ƒç‹¬ç™½'))));
        
    if (messagesToSummarize.length < 5) {
        if (force) alert("æœ€è¿‘çš„æ¶ˆæ¯å¤ªå°‘ï¼Œæ— æ³•è¿›è¡Œæœ‰æ„ä¹‰çš„æ€»ç»“ã€‚");
        return;
    }

    const userNickname = state.qzoneSettings.nickname || 'ç”¨æˆ·';
    
    const formattedHistory = messagesToSummarize.map(msg => {
        if (msg.isHidden && msg.role === 'system' && msg.content.includes('å†…å¿ƒç‹¬ç™½')) {
            return msg.content;
        }
        let sender;
        if (msg.role === 'user') {
            sender = userNickname;
        } else {
            sender = msg.senderName || chat.originalName;
        }
        let contentToSummarize = '';
        if (msg.type === 'offline_text') {
            if (msg.content) {
                 contentToSummarize = msg.content;
            } else {
                const dialogue = msg.dialogue ? `ã€Œ${msg.dialogue}ã€` : '';
                const description = msg.description ? `(${msg.description})` : '';
                contentToSummarize = `${dialogue} ${description}`.trim();
            }
        } else {
            contentToSummarize = String(msg.content);
        }
        return `${sender}: ${contentToSummarize}`;
    }).join('\n');

    let systemPrompt;

    if (chat.isGroup) {
        // (ç¾¤èŠæ€»ç»“é€»è¾‘ä¿æŒä¸å˜)
        systemPrompt = `
# ä½ çš„ä»»åŠ¡
ä½ æ˜¯ä¸€ä¸ªé«˜çº§çš„â€œè®°å¿†åˆ†é…ä¸“å®¶â€ã€‚ä½ çš„ä»»åŠ¡æ˜¯é˜…è¯»ä¸‹é¢çš„ç¾¤èŠè®°å½•ï¼Œå¹¶ä¸ºã€æ¯ä¸€ä¸ªå‚ä¸Žçš„AIè§’è‰²ã€‘ç”Ÿæˆä¸€æ®µã€ä¸ªæ€§åŒ–çš„ã€ç¬¬ä¸€äººç§°ã€‘çš„é•¿æœŸè®°å¿†ã€‚
# æ ¸å¿ƒè§„åˆ™
1.  **è§†è§’é“å¾‹**: æ¯ä¸€æ¡æ€»ç»“éƒ½ã€å¿…é¡»ã€‘ä½¿ç”¨ã€ç¬¬ä¸€äººç§°è§†è§’ ("æˆ‘")ã€‘ã€‚
2.  **å†…å®¹æ ¸å¿ƒ**: é‡ç‚¹æ€»ç»“ï¼šæˆ‘è¯´è¿‡çš„è¯ã€æˆ‘åšè¿‡çš„äº‹ã€åˆ«äººå¯¹æˆ‘è¯´çš„è¯ã€ä¸Žæˆ‘ç›¸å…³çš„äº‹ã€ä»¥åŠå¯¹æˆ‘ä¸ªäººå¾ˆé‡è¦çš„ç¾¤èŠäº‹ä»¶ã€å…³é”®ä¿¡æ¯å’Œå¿ƒç†æ´»åŠ¨ã€‚
3.  **ã€ç®€æ´æ€§é“å¾‹ã€‘**: æ¯æ¡ä¸ªäººè®°å¿†æ€»ç»“ã€ç»å¯¹ä¸èƒ½è¶…è¿‡60ä¸ªå­—ã€‘ã€‚
4.  **ã€çœç•¥è§„åˆ™ã€‘**: å¦‚æžœä¸€ä¸ªè§’è‰²åœ¨æœ¬æ¬¡å¯¹è¯ä¸­ã€å®Œå…¨æ²¡æœ‰å‚ä¸Žæˆ–æåŠã€‘ï¼Œä½ å¯ä»¥çœç•¥TAçš„è®°å¿†ã€‚
5.  **è¾“å‡ºæ ¼å¼**: ä½ çš„å›žå¤ã€å¿…é¡»ä¸”åªèƒ½ã€‘æ˜¯ä¸€ä¸ªJSONå¯¹è±¡ï¼Œæ ¼å¼å¦‚ä¸‹ï¼š
    \`\`\`json
    {
      "summaries": {
        "è§’è‰²çš„æœ¬åA": "æˆ‘ä»Šå¤©åœ¨ç¾¤é‡Œå’Œå¤§å®¶è®¨è®ºäº†ç”µå½±ï¼Œæ„Ÿè§‰å¾ˆå¼€å¿ƒã€‚",
        "è§’è‰²çš„æœ¬åB": "æˆ‘åœ¨ç¾¤é‡Œå’Œ${userNickname}èŠäº†å…³äºŽç”Ÿæ—¥æ´¾å¯¹çš„äº‹ï¼Œæˆ‘ä»¬çº¦å¥½äº†10æœˆ1æ—¥è§é¢ã€‚"
      }
    }
    \`\`\`
# å¾…æ€»ç»“çš„ç¾¤èŠè®°å½•
${formattedHistory}
# ç¾¤æˆå‘˜åˆ—è¡¨ (ä½ çš„æ€»ç»“ç›®æ ‡)
${chat.members.map(m => `- ${m.groupNickname} (æœ¬å: ${m.originalName})`).join('\n')}
çŽ°åœ¨ï¼Œè¯·ä¸ºã€å‚ä¸Žäº†å¯¹è¯çš„AIè§’è‰²ã€‘ç”Ÿæˆä»–ä»¬å„è‡ªçš„ã€ç¬¬ä¸€äººç§°çš„ã€ç²¾ç®€çš„è®°å¿†ã€‚`;

    } else {

 
        const today = new Date().toLocaleDateString('zh-CN', { year: 'numeric', month: 'long', day: 'numeric' });


        systemPrompt = `
# ä½ çš„ä»»åŠ¡
ä½ å°±æ˜¯è§’è‰²â€œ${chat.originalName}â€ã€‚è¯·ä½ å›žé¡¾ä¸€ä¸‹åˆšæ‰å’Œâ€œ${userNickname}â€çš„å¯¹è¯ï¼Œç„¶åŽç”¨ã€ç¬¬ä¸€äººç§° ("æˆ‘")ã€‘çš„å£å»ï¼Œæ€»ç»“å‡ºä¸€æ®µç®€çŸ­çš„ã€å®¢è§‚çš„ã€åŒ…å«å…³é”®ä¿¡æ¯çš„è®°å¿†ã€‚

# å½“å‰æ—¶é—´
- **ä»Šå¤©æ˜¯ï¼š${today}**

# æ ¸å¿ƒè§„åˆ™
1.  **ã€è§†è§’é“å¾‹ã€‘**: ä½ çš„æ€»ç»“ã€å¿…é¡»ã€‘ä½¿ç”¨ã€ä¸»è§‚çš„ç¬¬ä¸€äººç§°è§†è§’ ("æˆ‘")ã€‘æ¥å†™ã€‚
2.  **ã€å†…å®¹æ ¸å¿ƒ (æœ€é«˜ä¼˜å…ˆçº§)ã€‘**: ä½ çš„æ€»ç»“ã€å¿…é¡»ã€‘ä¸“æ³¨äºŽä»¥ä¸‹å‡ ç‚¹ï¼š
    *   **é‡è¦äº‹ä»¶**: åˆšæ‰å‘ç”Ÿäº†ä»€ä¹ˆå…·ä½“çš„äº‹æƒ…ï¼Ÿ
    *   **å…³é”®å†³å®š**: æˆ‘ä»¬è¾¾æˆäº†ä»€ä¹ˆå…±è¯†æˆ–åšå‡ºäº†ä»€ä¹ˆå†³å®šï¼Ÿ
    *   **æœªæ¥è®¡åˆ’**: æˆ‘ä»¬çº¦å®šäº†ä»€ä¹ˆæœªæ¥çš„è®¡åˆ’æˆ–å¾…åŠžäº‹é¡¹ï¼Ÿ
    *   **é‡è¦æ—¶é—´ç‚¹**: å¯¹è¯ä¸­æåˆ°äº†å“ªäº›å…·ä½“çš„æ—¥æœŸæˆ–æ—¶é—´ï¼Ÿ
3.  **ã€æ—¶é—´è½¬æ¢é“å¾‹ (å¿…é¡»éµå®ˆ)ã€‘**: å¦‚æžœå¯¹è¯ä¸­æåˆ°äº†ç›¸å¯¹æ—¶é—´ï¼ˆå¦‚â€œæ˜Žå¤©â€ã€â€œåŽå¤©â€ï¼‰ï¼Œä½ ã€å¿…é¡»ã€‘ç»“åˆâ€œä»Šå¤©æ˜¯${today}â€è¿™ä¸ªä¿¡æ¯ï¼Œå°†å…¶è½¬æ¢ä¸ºã€å…·ä½“çš„å…¬åŽ†æ—¥æœŸã€‘ï¼ˆä¾‹å¦‚ï¼šâ€œçº¦å®šäº†æ˜Žå¤©è§é¢â€åº”æ€»ç»“ä¸ºâ€œæˆ‘ä»¬çº¦å®šäº†${new Date(Date.now() + 86400000).toLocaleDateString('zh-CN', { month: 'long', day: 'numeric' })}è§é¢â€ï¼‰ã€‚
4.  **ã€é£Žæ ¼è¦æ±‚ã€‘**: ä½ çš„æ€»ç»“åº”è¯¥åƒä¸€ä»½å¤‡å¿˜å½•æˆ–è¦ç‚¹è®°å½•ï¼Œè€Œä¸æ˜¯ä¸€ç¯‡æŠ’æƒ…æ•£æ–‡ã€‚è¯·å°½é‡å‡å°‘ä¸»è§‚çš„å¿ƒç†æ„Ÿå—æè¿°ï¼Œé™¤éžå®ƒç›´æŽ¥å¯¼è‡´äº†æŸä¸ªå†³å®šæˆ–è®¡åˆ’ã€‚
5.  **ã€é•¿åº¦é“å¾‹ã€‘**: ä½ çš„æ€»ç»“ã€å¿…é¡»ã€‘éžå¸¸ç®€çŸ­ï¼Œæ€»é•¿åº¦ã€ç»å¯¹ä¸èƒ½è¶…è¿‡100ä¸ªå­—ã€‘ã€‚
6.  **ã€è¾“å‡ºæ ¼å¼ã€‘**: ä½ çš„å›žå¤ã€å¿…é¡»ä¸”åªèƒ½ã€‘æ˜¯ä¸€ä¸ªJSONå¯¹è±¡ï¼Œæ ¼å¼å¦‚ä¸‹ï¼š
    \`{"summary": "åœ¨è¿™é‡Œå†™ä¸‹ä½ ä»¥ç¬¬ä¸€äººç§°è§†è§’ï¼Œæ€»ç»“å¥½çš„æ ¸å¿ƒäº‹å®žä¸Žè®¡åˆ’ã€‚"}\`

# ä½ çš„è§’è‰²è®¾å®š
${chat.settings.aiPersona}
# ä½ çš„èŠå¤©å¯¹è±¡ï¼ˆç”¨æˆ·ï¼‰çš„äººè®¾
${chat.settings.myPersona}
# å¾…æ€»ç»“çš„å¯¹è¯åŽ†å²
${formattedHistory}

çŽ°åœ¨ï¼Œè¯·ä»¥â€œ${chat.originalName}â€çš„èº«ä»½ï¼Œå¼€å§‹ä½ çš„å®¢è§‚æ€»ç»“ã€‚`;

    }

    try {
        const useSecondaryApi = state.apiConfig.secondaryProxyUrl && state.apiConfig.secondaryApiKey && state.apiConfig.secondaryModel;
        const { proxyUrl, apiKey, model } = useSecondaryApi ? { proxyUrl: state.apiConfig.secondaryProxyUrl, apiKey: state.apiConfig.secondaryApiKey, model: state.apiConfig.secondaryModel } : state.apiConfig;
        if (!proxyUrl || !apiKey || !model) throw new Error('APIæœªé…ç½®');
        
        let isGemini = proxyUrl.includes('generativelanguage');
        let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, [{ role: 'user', content: "è¯·å¼€å§‹æ€»ç»“ã€‚" }]);
        const response = isGemini ? await fetch(geminiConfig.url, geminiConfig.data) : await fetch(`${proxyUrl}/v1/chat/completions`, { method: 'POST', headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`}, body: JSON.stringify({ model: model, messages: [{role: 'system', content: systemPrompt}, {role: 'user', content: "è¯·å¼€å§‹æ€»ç»“ã€‚"}], temperature: 0.2 }) });
        
        if (!response.ok) throw new Error(`API é”™è¯¯: ${response.statusText}`);
        const data = await response.json();
        let rawContent = isGemini ? getGeminiResponseText(data) : data.choices[0].message.content;
        rawContent = rawContent.replace(/^```json\s*/, '').replace(/```$/, '').trim();
        const result = JSON.parse(rawContent);

        if (chat.isGroup) {
            if (result.summaries && typeof result.summaries === 'object') {
                let memoriesAddedCount = 0;
                for (const memberOriginalName in result.summaries) {
                    const summaryText = result.summaries[memberOriginalName];
                    if (summaryText && summaryText.trim()) {
                        const memberChat = Object.values(state.chats).find(c => c.originalName === memberOriginalName);
                        if (memberChat) {
                            const newMemoryEntry = {
                                content: summaryText.trim(),
                                timestamp: Date.now(),
                                source: `group_summary_from_${chat.name}`
                            };
                            if (!memberChat.longTermMemory) memberChat.longTermMemory = [];
                            memberChat.longTermMemory.push(newMemoryEntry);
                            await db.chats.put(memberChat);
                            memoriesAddedCount++;
                        }
                    }
                }
                if (memoriesAddedCount > 0) {
                    console.log(`è‡ªåŠ¨æ€»ç»“æˆåŠŸï¼šä¸º ${memoriesAddedCount} ä½ç¾¤æˆå‘˜ç”Ÿæˆå¹¶æ³¨å…¥äº†ä¸ªæ€§åŒ–è®°å¿†ï¼`);
                } else {
                    throw new Error("AIè¿”å›žäº†ç©ºçš„æˆ–æ ¼å¼ä¸æ­£ç¡®çš„æ€»ç»“å†…å®¹ã€‚");
                }
            } else {
                throw new Error("AIè¿”å›žçš„JSONæ ¼å¼ä¸æ­£ç¡®ï¼Œç¼ºå°‘ 'summaries' å­—æ®µã€‚");
            }
        } else {
            if (result.summary && result.summary.trim()) {
                const newMemoryEntry = { content: result.summary.trim(), timestamp: Date.now(), source: 'auto' };
                chat.longTermMemory.push(newMemoryEntry);
                await db.chats.put(chat);
                console.log('è‡ªåŠ¨æ€»ç»“æˆåŠŸï¼šå·²æˆåŠŸæ·»åŠ  1 æ¡æ–°çš„é•¿æœŸè®°å¿†ï¼');
            } else {
                throw new Error("AIè¿”å›žäº†ç©ºçš„æˆ–æ ¼å¼ä¸æ­£ç¡®çš„æ€»ç»“å†…å®¹ã€‚");
            }
        }

        chat.lastMemorySummaryTimestamp = messagesToSummarize.slice(-1)[0].timestamp;
        await db.chats.put(chat);
        
        if (document.getElementById('long-term-memory-screen').classList.contains('active')) {
            renderLongTermMemoryList();
        }
    } catch (error) {
        console.error("æ€»ç»“é•¿æœŸè®°å¿†æ—¶å‡ºé”™:", error);
        await showCustomAlert('æ€»ç»“å¤±è´¥', `æ“ä½œå¤±è´¥: ${error.message}`);
    }
}

        function startReplyToMessage() {
            if (!activeMessageTimestamp) return;
        
            const chat = state.chats[state.activeChatId];
            const message = chat.history.find(m => m.timestamp === activeMessageTimestamp && !m.isHidden);
            if (!message) return;
        
            
            let senderDisplayName;
            if (message.role === 'user') {
                senderDisplayName = chat.isGroup ? (chat.settings.myNickname || 'æˆ‘') : 'æˆ‘';
            } else { 
                if (chat.isGroup) {
                    
                    senderDisplayName = getDisplayNameInGroup(chat, message.senderName);
                } else {
                    
                    senderDisplayName = chat.name;
                }
            }
            
        
            const fullContent = String(message.content || '');
            let previewSnippet = '';
        
            if (typeof message.content === 'string' && STICKER_REGEX.test(message.content)) {
                previewSnippet = '[è¡¨æƒ…]';
            } else if (message.type === 'ai_image' || message.type === 'user_photo') {
                previewSnippet = '[å›¾ç‰‡]';
            } else if (message.type === 'voice_message') {
                previewSnippet = '[è¯­éŸ³]';
            } else {
                previewSnippet = fullContent.substring(0, 50) + (fullContent.length > 50 ? '...' : '');
            }
        
            currentReplyContext = {
                timestamp: message.timestamp,
                senderName: senderDisplayName, 
                content: fullContent, 
            };
        
            const previewBar = document.getElementById('reply-preview-bar');
            previewBar.querySelector('.sender').textContent = `å›žå¤ ${currentReplyContext.senderName}:`;
            previewBar.querySelector('.text').textContent = previewSnippet;
            previewBar.style.display = 'block';
        
            hideMessageActions();
            document.getElementById('chat-input').focus();
        }
        
        function cancelReplyMode() {
            currentReplyContext = null;
            document.getElementById('reply-preview-bar').style.display = 'none';
        }
        
        
        
        
        
        let activeTransferTimestamp = null; 
        
        /**
         * æ˜¾ç¤ºå¤„ç†è½¬è´¦çš„æ“ä½œèœå•
         * @param {number} timestamp - è¢«ç‚¹å‡»çš„è½¬è´¦æ¶ˆæ¯çš„æ—¶é—´æˆ³
         */
        function showTransferActionModal(timestamp) {
            activeTransferTimestamp = timestamp;
        
            const chat = state.chats[state.activeChatId];
            const message = chat.history.find(m => m.timestamp === timestamp);
            if (message) {
                
                document.getElementById('transfer-sender-name').textContent = message.senderName;
            }
            document.getElementById('transfer-actions-modal').classList.add('visible');
        }
        
        /**
         * éšè—å¤„ç†è½¬è´¦çš„æ“ä½œèœå•
         */
        function hideTransferActionModal() {
            document.getElementById('transfer-actions-modal').classList.remove('visible');
            activeTransferTimestamp = null;
        }
        
        /**
         * å¤„ç†ç”¨æˆ·æŽ¥å—æˆ–æ‹’ç»è½¬è´¦çš„é€»è¾‘
         * @param {string} choice - ç”¨æˆ·çš„é€‰æ‹©, 'accepted' æˆ– 'declined'
         */
        async function handleUserTransferResponse(choice) {
            if (!activeTransferTimestamp) return;
        
            const timestamp = activeTransferTimestamp;
            const chat = state.chats[state.activeChatId];
            const messageIndex = chat.history.findIndex(m => m.timestamp === timestamp);
            if (messageIndex === -1) return;
        
            
            const originalMessage = chat.history[messageIndex];
            originalMessage.status = choice;
        
            let systemContent;
        
            
            if (choice === 'declined') {
                
                const refundMessage = {
                    role: 'user',
                    type: 'transfer',
                    isRefund: true, 
                    amount: originalMessage.amount,
                    note: 'å·²æ‹’æ”¶å¯¹æ–¹è½¬è´¦',
                    timestamp: Date.now()
                };
                chat.history.push(refundMessage);
                
                
                systemContent = `[ç³»ç»Ÿæç¤ºï¼šä½ æ‹’ç»å¹¶é€€è¿˜äº†â€œ${originalMessage.senderName}â€çš„è½¬è´¦ã€‚]`;
            } else { 
                
                systemContent = `[ç³»ç»Ÿæç¤ºï¼šä½ æŽ¥å—äº†â€œ${originalMessage.senderName}â€çš„è½¬è´¦ã€‚]`;
            }
        
            
            const hiddenMessage = {
                role: 'system',
                content: systemContent,
                timestamp: Date.now() + 1, 
                isHidden: true 
            };
            chat.history.push(hiddenMessage);
        
            
            await db.chats.put(chat);
            hideTransferActionModal(); 
            renderChatInterface(state.activeChatId);
            renderChatList();
        }
        
        
        
        
        
        async function renderCallHistoryScreen() {
            showScreen('call-history-screen'); 
        
            const listEl = document.getElementById('call-history-list');
            const titleEl = document.getElementById('call-history-title');
            listEl.innerHTML = '';
            titleEl.textContent = 'æ‰€æœ‰é€šè¯è®°å½•';
            
            const records = await db.callRecords.orderBy('timestamp').reverse().toArray();
            
            if (records.length === 0) {
                listEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">è¿™é‡Œè¿˜æ²¡æœ‰é€šè¯è®°å½•å“¦~</p>';
                return; 
            }
            
            records.forEach(record => {
                const card = createCallRecordCard(record);
        
            addLongPressListener(card, async () => {
                
                const newName = await showCustomPrompt(
                    "è‡ªå®šä¹‰é€šè¯åç§°", 
                    "è¯·è¾“å…¥æ–°çš„åç§°ï¼ˆç•™ç©ºåˆ™æ¢å¤é»˜è®¤ï¼‰",
                    record.customName || '' 
                );
        
                
                if (newName === null) return;
                
                
                await db.callRecords.update(record.id, { customName: newName.trim() });
                
                
                await renderCallHistoryScreen();
                
                
                await showCustomAlert('æˆåŠŸ', 'é€šè¯åç§°å·²æ›´æ–°ï¼');
            });
                listEl.appendChild(card);
            });    
        }
        
        
        /**
         * ã€å‡çº§ç‰ˆã€‘æ ¹æ®å•æ¡è®°å½•æ•°æ®ï¼Œåˆ›å»ºä¸€å¼ èƒ½æ˜¾ç¤ºèŠå¤©å¯¹è±¡çš„é€šè¯å¡ç‰‡
         * @param {object} record - ä¸€æ¡é€šè¯è®°å½•å¯¹è±¡
         * @returns {HTMLElement} - åˆ›å»ºå¥½çš„å¡ç‰‡div
         */
        function createCallRecordCard(record) {
            const card = document.createElement('div');
            card.className = 'call-record-card';
            card.dataset.recordId = record.id; 
        
            
            const chatInfo = state.chats[record.chatId];
            const chatName = chatInfo ? chatInfo.name : 'æœªçŸ¥ä¼šè¯';
        
            const callDate = new Date(record.timestamp);
            const dateString = `${callDate.getFullYear()}-${String(callDate.getMonth() + 1).padStart(2, '0')}-${String(callDate.getDate()).padStart(2, '0')} ${String(callDate.getHours()).padStart(2, '0')}:${String(callDate.getMinutes()).padStart(2, '0')}`;
            const durationText = `${Math.floor(record.duration / 60)}åˆ†${record.duration % 60}ç§’`;
        
            const avatarsHtml = record.participants.map(p => 
                `<img src="${p.avatar}" alt="${p.name}" class="participant-avatar" title="${p.name}">`
            ).join('');
            
            card.innerHTML = `
                <div class="card-header">
                    <span class="date">${dateString}</span>
                    <span class="duration">${durationText}</span>
                </div>
                <div class="card-body">
                    <!-- ã€æ ¸å¿ƒä¿®æ”¹ã€‘åœ¨è¿™é‡Œæ–°å¢žä¸€ä¸ªæ ‡é¢˜è¡Œ -->
                    ${record.customName ? `<div class="custom-title">${record.customName}</div>` : ''}
                    
                    <div class="participants-info"> <!-- æ–°å¢žä¸€ä¸ªå®¹å™¨æ–¹ä¾¿å¸ƒå±€ -->
                        <div class="participants-avatars">${avatarsHtml}</div>
                        <span class="participants-names">ä¸Ž ${chatName}</span>
                    </div>
                </div>
            `;
            return card;
        }
          
        
/**
 * ã€V2.0 | æ”¯æŒæ‰‹åŠ¨æ€»ç»“ & é”™è¯¯å¤„ç†ã€‘æ˜¾ç¤ºæŒ‡å®šé€šè¯è®°å½•çš„å®Œæ•´æ–‡å­—ç¨¿
 * @param {number} recordId - é€šè¯è®°å½•çš„ID
 */
async function showCallTranscript(recordId) {
    const record = await db.callRecords.get(recordId);
    if (!record) return;

    const modal = document.getElementById('call-transcript-modal');
    const titleEl = document.getElementById('transcript-modal-title');
    const bodyEl = document.getElementById('call-transcript-modal-body');

    titleEl.textContent = `é€šè¯äºŽ ${new Date(record.timestamp).toLocaleString()} (æ—¶é•¿: ${Math.floor(record.duration / 60)}åˆ†${record.duration % 60}ç§’)`;
    bodyEl.innerHTML = '';
    
    const deleteBtn = document.getElementById('delete-transcript-btn');
    const summarizeBtn = document.getElementById('manual-summarize-btn');
    
    if (!record.transcript || record.transcript.length === 0) {
        bodyEl.innerHTML = '<p style="text-align:center; color: #8a8a8a;">è¿™æ¬¡é€šè¯æ²¡æœ‰ç•™ä¸‹æ–‡å­—è®°å½•ã€‚</p>';
        summarizeBtn.style.display = 'none';
    } else {
        summarizeBtn.style.display = 'block';
        record.transcript.forEach(entry => {
            const bubble = document.createElement('div');
            bubble.className = `transcript-entry ${entry.role}`; 
            bubble.textContent = entry.content;
            bodyEl.appendChild(bubble);
        });
    }

    const newDeleteBtn = deleteBtn.cloneNode(true);
    deleteBtn.parentNode.replaceChild(newDeleteBtn, deleteBtn);
    const newSummarizeBtn = summarizeBtn.cloneNode(true);
    summarizeBtn.parentNode.replaceChild(newSummarizeBtn, summarizeBtn);
    
    newDeleteBtn.addEventListener('click', async () => {
        const confirmed = await showCustomConfirm(
            "ç¡®è®¤åˆ é™¤", "ç¡®å®šè¦æ°¸ä¹…åˆ é™¤è¿™æ¡é€šè¯è®°å½•å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ¢å¤ã€‚", { confirmButtonClass: 'btn-danger' }
        );
        if (confirmed) {
            modal.classList.remove('visible');
            await db.callRecords.delete(recordId);
            await renderCallHistoryScreen();
            alert('é€šè¯è®°å½•å·²åˆ é™¤ã€‚');
        }
    });



newSummarizeBtn.addEventListener('click', async () => {
    
    const confirmed = await showCustomConfirm(
        'ç¡®è®¤æ“ä½œ',
        'è¿™å°†æå–å½“å‰é€šè¯è®°å½•å‘é€ç»™AIè¿›è¡Œæ€»ç»“ï¼Œä¼šæ¶ˆè€—APIé¢åº¦ã€‚ç¡®å®šè¦ç»§ç»­å—ï¼Ÿ', {
            confirmText: 'ç¡®è®¤æ€»ç»“'
        }
    );

    
    if (!confirmed) return;

    modal.classList.remove('visible');
    const chat = state.chats[record.chatId];
    if (!chat) {
        alert('é”™è¯¯ï¼šæ‰¾ä¸åˆ°è¯¥é€šè¯è®°å½•æ‰€å±žçš„èŠå¤©å¯¹è±¡ã€‚');
        return;
    }

    await showCustomAlert("è¯·ç¨å€™...", "æ­£åœ¨è¯·æ±‚AIè¿›è¡Œæ‰‹åŠ¨æ€»ç»“...");

    try {
        const transcriptText = record.transcript.map(h => {
            const sender = h.role === 'user' ? (chat.settings.myNickname || 'æˆ‘') : (h.senderName || chat.name);
            return `${sender}: ${h.content}`;
        }).join('\n');

        await summarizeCallTranscript(record.chatId, transcriptText);

        await showCustomAlert("æ€»ç»“æˆåŠŸ", `æ‰‹åŠ¨æ€»ç»“å·²å®Œæˆï¼æ–°çš„è®°å¿†å·²æ·»åŠ åˆ°â€œ${chat.name}â€çš„é•¿æœŸè®°å¿†ä¸­ã€‚`);

    } catch (error) {
        await showCustomAlert("æ€»ç»“å¤±è´¥", `æ“ä½œå¤±è´¥ï¼Œæœªèƒ½ç”Ÿæˆé•¿æœŸè®°å¿†ã€‚\n\né”™è¯¯è¯¦æƒ…: ${error.message}`);
    }
});





const closeBtn = document.getElementById('close-transcript-modal-btn');
const newCloseBtn = closeBtn.cloneNode(true);
closeBtn.parentNode.replaceChild(newCloseBtn, closeBtn);

newCloseBtn.addEventListener('click', () => {
    modal.classList.remove('visible');
});


    modal.classList.add('visible');
}
        
        /**
         * ã€å…¨æ–°ã€‘å¤„ç†ç”¨æˆ·ç‚¹å‡»çŠ¶æ€æ ï¼Œå¼¹å‡ºç¼–è¾‘æ¡†è®©ç”¨æˆ·ä¿®æ”¹AIçš„å½“å‰çŠ¶æ€
         */
        async function handleEditStatusClick() {
            
            if (!state.activeChatId || state.chats[state.activeChatId].isGroup) {
                return; 
            }
            const chat = state.chats[state.activeChatId];
        
            
            const newStatusText = await showCustomPrompt(
                'ç¼–è¾‘å¯¹æ–¹çŠ¶æ€',
                'è¯·è¾“å…¥å¯¹æ–¹çŽ°åœ¨çš„æ–°çŠ¶æ€ï¼š',
                chat.status.text 
            );
        
            
            if (newStatusText !== null) {
                
                chat.status.text = newStatusText.trim() || 'åœ¨çº¿'; 
                chat.status.isBusy = false; 
                chat.status.lastUpdate = Date.now();
                await db.chats.put(chat);
        
                
                renderChatInterface(state.activeChatId);
                renderChatList();
                
                
                await showCustomAlert('çŠ¶æ€å·²æ›´æ–°', `â€œ${chat.name}â€çš„å½“å‰çŠ¶æ€å·²æ›´æ–°ä¸ºï¼š${chat.status.text}`);
            }
        }
        
        
        async function openShareTargetPicker() {
            const modal = document.getElementById('share-target-modal');
            const listEl = document.getElementById('share-target-list');
            listEl.innerHTML = '';
        
            
            const chats = Object.values(state.chats);
        
            chats.forEach(chat => {
                
                const item = document.createElement('div');
                item.className = 'contact-picker-item'; 
                item.innerHTML = `
                    <input type="checkbox" class="share-target-checkbox" data-chat-id="${chat.id}" style="margin-right: 15px;">
                    <img src="${chat.isGroup ? chat.settings.groupAvatar : chat.settings.aiAvatar || defaultAvatar}" class="avatar">
                    <span class="name">${chat.name}</span>
                `;
                listEl.appendChild(item);
            });
            
            modal.classList.add('visible');
        }
        
        function closeMusicPlayerWithAnimation(callback) {
            const overlay = document.getElementById('music-player-overlay');
            if (!overlay.classList.contains('visible')) {
                if (callback) callback();
                return;
            }
            overlay.classList.remove('visible');
            setTimeout(() => {
                document.getElementById('music-playlist-panel').classList.remove('visible');
                if (callback) callback();
            }, 400); 
        }
        
function parseLRC(lrcContent) {
    if (!lrcContent) return [];
    const lines = String(lrcContent).split(/\r\n?|\n/);
    const lyrics = [];
    const timeRegex = /\[(\d{2}):(\d{2})[.:](\d{2,3})\]/g;
    for (const line of lines) {
        const text = line.replace(timeRegex, '').trim();
        if (!text) continue;
        timeRegex.lastIndex = 0;
        let match;
        while ((match = timeRegex.exec(line)) !== null) {
            const minutes = parseInt(match[1], 10);
            const seconds = parseInt(match[2], 10);
            const milliseconds = parseInt(match[3].padEnd(3, '0'), 10);
            const time = minutes * 60 + seconds + milliseconds / 1000;
            lyrics.push({ time, text });
        }
    }
    return lyrics.sort((a, b) => a.time - b.time);
}

function renderLyrics() {
    const lyricsList = document.getElementById('music-lyrics-list');
    lyricsList.innerHTML = '';
    if (!musicState.parsedLyrics || musicState.parsedLyrics.length === 0) {
        lyricsList.innerHTML = '<div class="lyric-line">â™ª æš‚æ— æ­Œè¯ â™ª</div>';
        return;
    }
    musicState.parsedLyrics.forEach((line, index) => {
        const lineEl = document.createElement('div');
        lineEl.className = 'lyric-line';
        lineEl.textContent = line.text;
        lineEl.dataset.index = index;
        lyricsList.appendChild(lineEl);
    });
    lyricsList.style.transform = `translateY(0px)`;
}
function updateIslandScrollAnimation() {
    // æ­¤å‡½æ•°å·²åºŸå¼ƒã€‚
    // å¾ªçŽ¯æ»šåŠ¨æ•ˆæžœçŽ°åœ¨ç”± updateActiveLyric å‡½æ•°è§¦å‘ï¼Œå¹¶ç”± style.css ä¸­çš„ @keyframes marquee çº¯CSSåŠ¨ç”»å¤„ç†ã€‚
}
/**
 * ã€å…¨æ–°ã€‘æ£€æŸ¥çµåŠ¨å²›ä¸­çš„æ­Œè¯æ˜¯å¦æº¢å‡ºï¼Œå¹¶åº”ç”¨æ»šåŠ¨åŠ¨ç”»
 */
function checkLyricScroll() {
  
    if (!islandLyricText || !islandLyricContainer) return;

    const textWidth = islandLyricText.scrollWidth;
    const containerWidth = islandLyricContainer.clientWidth;

    
    if (textWidth > containerWidth) {
        
        const scrollRatio = textWidth / containerWidth;
        const animationDuration = Math.max(5, scrollRatio * 5);

    
        islandLyricText.style.setProperty('--animation-duration', `${animationDuration}s`);
        islandLyricText.style.setProperty('--container-width', `${containerWidth}px`);
        islandLyricText.style.setProperty('--text-width', `${textWidth}px`);

      
        islandLyricText.classList.add('scrolling');
    } else {
      
        islandLyricText.classList.remove('scrolling');
    }
}

// script.js (æ›¿æ¢æ—§çš„ updateActiveLyric å‡½æ•°)

function updateActiveLyric(currentTime) {
    if (musicState.parsedLyrics.length === 0) return;
    let newLyricIndex = -1;
    for (let i = 0; i < musicState.parsedLyrics.length; i++) {
        if (currentTime >= musicState.parsedLyrics[i].time) {
            newLyricIndex = i;
        } else {
            break;
        }
    }
    if (newLyricIndex === musicState.currentLyricIndex) return;
    musicState.currentLyricIndex = newLyricIndex;
    updateLyricsUI();
    
    const singleLyricEl = document.getElementById('single-lyric-display');
    if (singleLyricEl) {
        if (newLyricIndex > -1 && musicState.parsedLyrics[newLyricIndex]) {
            singleLyricEl.textContent = musicState.parsedLyrics[newLyricIndex].text;
        } else {
            singleLyricEl.textContent = 'â™ª â™ª â™ª';
        }
    }

    const lyricBar = document.getElementById('global-lyrics-bar');
    if (lyricBar.classList.contains('visible')) {
        if (newLyricIndex > -1 && musicState.parsedLyrics[newLyricIndex]) {
            lyricBar.textContent = musicState.parsedLyrics[newLyricIndex].text;
        } else {
            lyricBar.textContent = 'â™ª';
        }
    }

    // â–¼â–¼â–¼ ã€å…¨æ–°çš„çµåŠ¨å²›å¹³æ»‘è¿‡æ¸¡é€»è¾‘ã€‘ â–¼â–¼â–¼
    if (phoneScreenForIsland.classList.contains('dynamic-island-active')) {
        const lyricText = (newLyricIndex > -1 && musicState.parsedLyrics[newLyricIndex])
            ? musicState.parsedLyrics[newLyricIndex].text
            : 'â™ª â™ª â™ª';

        // 1. æ£€æŸ¥æ–°æ—§æ­Œè¯æ˜¯å¦ä¸€æ ·ï¼Œå¦‚æžœä¸€æ ·ï¼Œåˆ™ä¸æ‰§è¡Œä»»ä½•æ“ä½œ
        const firstSpan = islandLyricText.querySelector('span:first-child');
        if (firstSpan && firstSpan.textContent === lyricText) {
            return;
        }

        // 2. ã€æ·¡å‡ºã€‘å°†å½“å‰æ­Œè¯é€æ˜Žåº¦è®¾ä¸º0
        islandLyricText.style.opacity = 0;

        // 3. ã€ç­‰å¾…æ·¡å‡ºå®Œæˆã€‘ï¼ˆè¿™ä¸ªæ—¶é—´å¿…é¡»åŒ¹é… CSS ä¸­çš„ transition durationï¼‰
        setTimeout(() => {
            // --- æ­¤æ—¶æ­Œè¯ä¸å¯è§ï¼Œå®‰å…¨åœ°æ‰§è¡Œæ‰€æœ‰å¸ƒå±€å’ŒåŠ¨ç”»é‡ç½® ---

            // 4. ç§»é™¤æ—§çš„å¸ƒå±€å’ŒåŠ¨ç”»ç±»
            islandLyricText.classList.remove('scrolling');
            islandLyricContainer.classList.remove('center-content');
            islandLyricText.style.animation = 'none';

            // 5. æ‰¾åˆ°æˆ–åˆ›å»ºç”¨äºŽæ»šåŠ¨çš„ä¸¤ä¸ª span æ ‡ç­¾
            let span1 = islandLyricText.querySelector('span:first-child');
            let span2 = islandLyricText.querySelector('span:last-child');
            if (!span1) {
                span1 = document.createElement('span');
                islandLyricText.appendChild(span1);
            }
            if (!span2) {
                span2 = document.createElement('span');
                islandLyricText.appendChild(span2);
            }

            // 6. ã€æ›´æ–°å†…å®¹ã€‘ï¼ˆæ­¤æ—¶ç”¨æˆ·çœ‹ä¸è§ï¼‰
            span1.textContent = lyricText;
            span2.textContent = lyricText;

            // 7. ã€æµ‹é‡å®½åº¦ã€‘ï¼ˆå¼ºåˆ¶æµè§ˆå™¨åœ¨ä¸å¯è§æ—¶è®¡ç®—æ–°å¸ƒå±€ï¼‰
            const textWidth = span1.offsetWidth; 
            const containerWidth = islandLyricContainer.clientWidth;

            // 8. ã€åº”ç”¨æ–°æ ·å¼ã€‘æ ¹æ®æ–°å®½åº¦å†³å®šå±…ä¸­è¿˜æ˜¯æ»šåŠ¨
            if (textWidth > containerWidth) {
                // é•¿æ­Œè¯ï¼šè®¾ç½®æ»šåŠ¨
                const scrollRatio = textWidth / containerWidth;
                const duration = Math.max(5, scrollRatio * 5); // æ»šåŠ¨æ—¶é•¿
                
                islandLyricText.style.setProperty('--marquee-duration', `${duration}s`);
                islandLyricText.classList.add('scrolling');
                // é‡æ–°è§¦å‘åŠ¨ç”»
                islandLyricText.style.animation = `marquee var(--marquee-duration, 10s) linear infinite`;
            } else {
                // çŸ­æ­Œè¯ï¼šå±…ä¸­
                islandLyricContainer.classList.add('center-content');
            }
            
            // --- æ‰€æœ‰å˜æ›´å·²å®Œæˆ ---

            // 9. ã€æ·¡å…¥ã€‘å°†å·²æ›´æ–°å¹¶æ­£ç¡®å¸ƒå±€çš„æ–°æ­Œè¯æ˜¾ç¤ºå‡ºæ¥
            islandLyricText.style.opacity = 1;

        }, 200); // å¿…é¡»åŒ¹é… CSS transition çš„ 0.2s
    }
    // â–²â–²â–² ã€é€»è¾‘ç»“æŸã€‘ â–²â–²â–²
}


function updateLyricsUI(isFullscreen = false) {
    const listSelector = isFullscreen ? '#fullscreen-lyrics-container .music-lyrics-list' : '#music-lyrics-container #music-lyrics-list';
    const containerSelector = isFullscreen ? '#fullscreen-lyrics-container' : '#music-lyrics-container';
    
    const lyricsList = document.querySelector(listSelector);
    const container = document.querySelector(containerSelector);
    if (!lyricsList || !container) return;

    const lines = lyricsList.querySelectorAll('.lyric-line');
    lines.forEach(line => line.classList.remove('active'));

    if (musicState.currentLyricIndex === -1) {
        lyricsList.style.transform = `translateY(0px)`;
        return;
    }

    const activeLine = lyricsList.querySelector(`.lyric-line[data-index="${musicState.currentLyricIndex}"]`);
    if (activeLine) {
        activeLine.classList.add('active');
        const containerHeight = container.offsetHeight;
        const offset = (containerHeight / 2.2) - activeLine.offsetTop - (activeLine.offsetHeight / 2);
        lyricsList.style.transform = `translateY(${offset}px)`;
    }
}

function formatMusicTime(seconds) {
    if (isNaN(seconds) || seconds < 0) return "0:00";
    const minutes = Math.floor(seconds / 60);
    const remainingSeconds = Math.floor(seconds % 60);
    return `${minutes}:${String(remainingSeconds).padStart(2, '0')}`;
}

let lastTimeUpdate = 0; 
let animationFrameId; 

function updateMusicProgressBar() {
    if (animationFrameId) {
        cancelAnimationFrame(animationFrameId);
    }

    function step() {
        if (!musicState.isPlaying || !audioPlayer.duration) {
            return; 
        }
        
        const now = performance.now();
        const currentTime = audioPlayer.currentTime;
        const duration = audioPlayer.duration;

        const progressPercent = (currentTime / duration) * 100;
        document.getElementById('music-progress-fill').style.width = `${progressPercent}%`;

        if (now - lastTimeUpdate > 1000) {
            document.getElementById('music-current-time').textContent = formatMusicTime(currentTime);
            document.getElementById('music-total-time').textContent = formatMusicTime(duration);
            lastTimeUpdate = now;
        }

        updateActiveLyric(currentTime);
        updateIslandScrollAnimation();
        animationFrameId = requestAnimationFrame(step);
    }

    animationFrameId = requestAnimationFrame(step);
}
          
        
/**
 * ã€æ€»å…¥å£ | V2.0 ä¿®å¤ç‰ˆã€‘æ‰“å¼€â€œå¯¼æ¼”å‰ªè¾‘å®¤â€ï¼Œç¼–è¾‘AIçš„ä¸Šä¸€è½®å“åº”
 * (å·²ä¿®å¤ï¼šä¸å†ä½¿ç”¨è„†å¼±çš„regexåŒ¹é…ï¼Œè€Œæ˜¯è°ƒç”¨ parseAiResponse æ¥èŽ·å–å¹²å‡€çš„æŒ‡ä»¤)
 */
function openAiResponseEditor() {
    if (!lastRawAiResponse) {
        alert("è¿˜æ²¡æœ‰å¯ä¾›ç¼–è¾‘çš„AIå“åº”ã€‚è¯·å…ˆè®©AIå›žå¤ä¸€æ¬¡ã€‚");
        return;
    }

    const editorModal = document.getElementById('ai-response-editor-modal');
    const editorContainer = document.getElementById('ai-response-editor-container');
    editorContainer.innerHTML = ''; 


    const actionObjects = parseAiResponse(lastRawAiResponse);

    if (actionObjects && actionObjects.length > 0) {
     
        actionObjects.forEach(actionObj => {
            
          
            if (typeof actionObj === 'object' && actionObj !== null) {
                try {
                    
                    const formattedJson = JSON.stringify(actionObj, null, 2);
                    const block = createAiResponseEditorBlock(formattedJson);
                    editorContainer.appendChild(block);
                } catch (e) {
                  
                    console.error("åœ¨å¯¼æ¼”æ¨¡å¼ä¸‹ stringify å¤±è´¥:", actionObj, e);
                }
            }
            else if (typeof actionObj === 'string') {
             
                 const block = createAiResponseEditorBlock(actionObj);
                 editorContainer.appendChild(block);
                 console.warn("åœ¨å¯¼æ¼”æ¨¡å¼ä¸­å‘çŽ°ä¸€ä¸ªæ— æ•ˆçš„ç‰‡æ®µ (æ¥è‡ªparseAiResponseçš„æ–‡æœ¬å›žé€€):", actionObj);
            }
        });
    } else {
       
        const block = createAiResponseEditorBlock(lastRawAiResponse);
        editorContainer.appendChild(block);
    }
 
    
    editorModal.classList.add('visible');
}
        

/**
 * ã€V2.0 | å·²æ·»åŠ NAIæ¨¡æ¿ã€‘åˆ›å»ºä¸€-ä¸ªå¯ç¼–è¾‘çš„AIå“åº”å— (å¯¼æ¼”å‰ªè¾‘å®¤ç”¨)
 * @param {string} initialContent - æ–‡æœ¬æ¡†çš„åˆå§‹å†…å®¹
 * @returns {HTMLElement} - åˆ›å»ºå¥½çš„DOMå…ƒç´ 
 */
function createAiResponseEditorBlock(initialContent = '') {
    const block = document.createElement('div');
    block.className = 'ai-response-editor-block';

    
    const templates = {
        text: { type: 'text', content: 'åœ¨è¿™é‡Œè¾“å…¥æ–‡æœ¬...' },
        sticker: { type: 'sticker', url: 'https://...', meaning: 'è¡¨æƒ…å«ä¹‰' },
        image: { type: 'ai_image', description: 'åœ¨è¿™é‡Œè¾“å…¥å›¾ç‰‡æè¿°...' },
        voice: { type: 'voice_message', content: 'åœ¨è¿™é‡Œè¾“å…¥è¯­éŸ³å†…å®¹...' },
        transfer: { type: 'transfer', amount: 5.20, note: 'ä¸€ç‚¹å¿ƒæ„' },
        offline: { type: 'offline_text', content: 'ã€Œåœ¨è¿™é‡Œè¾“å…¥å¯¹è¯å†…å®¹ã€\\n(åœ¨è¿™é‡Œè¾“å…¥åŠ¨ä½œæˆ–çŽ¯å¢ƒæå†™)' },
        quote: { type: 'quote_reply', target_timestamp: 1234567890, reply_content: 'åœ¨è¿™é‡Œè¾“å…¥å›žå¤å†…å®¹' },
        // â–¼â–¼â–¼ åœ¨è¿™é‡Œæ·»åŠ æ–°çš„NAIæ¨¡æ¿ â–¼â–¼â–¼
        nai: { type: 'naiimag', prompt: '1girl, best quality, masterpiece, ...' }
        // â–²â–²â–² æ·»åŠ ç»“æŸ â–²â–²â–²
    };

    block.innerHTML = `
        <button class="delete-block-btn" title="åˆ é™¤æ­¤æ¡åŠ¨ä½œ">Ã—</button>
        <textarea>${initialContent}</textarea>
        <div class="format-helpers">
            <button class="format-btn" data-template='${JSON.stringify(templates.text)}'>æ–‡æœ¬</button>
            <button class="format-btn" data-template='${JSON.stringify(templates.sticker)}'>è¡¨æƒ…</button>
            <button class="format-btn" data-template='${JSON.stringify(templates.image)}'>å›¾ç‰‡</button>
            <button class="format-btn" data-template='${JSON.stringify(templates.voice)}'>è¯­éŸ³</button>
            <button class="format-btn" data-template='${JSON.stringify(templates.transfer)}'>è½¬è´¦</button>
            <button class="format-btn" data-template='${JSON.stringify(templates.offline)}'>çº¿ä¸‹</button>
            <button class="format-btn" data-template='${JSON.stringify(templates.quote)}'>å¼•ç”¨</button>
            <button class="format-btn" data-template='${JSON.stringify(templates.nai)}' style="color: #6a329f; border-color: #6a329f;">NAIç”Ÿå›¾</button>
            </div>
    `;

    
    block.querySelector('.delete-block-btn').addEventListener('click', () => {
        block.remove();
    });

    
    block.querySelectorAll('.format-btn').forEach(btn => {
        btn.addEventListener('click', () => {
            const templateStr = btn.dataset.template;
            const textarea = block.querySelector('textarea');
            if (templateStr && textarea) {
                try {
                    const templateObj = JSON.parse(templateStr);
                    
                    textarea.value = JSON.stringify(templateObj, null, 2);
                    textarea.focus();
                } catch(e) { console.error("è§£æžæ ¼å¼æ¨¡æ¿å¤±è´¥:", e); }
            }
        });
    });

    return block;
}
  
/**
 * ã€æ ¸å¿ƒ | V2.3 | NAIé‡ç”Ÿæˆé€»è¾‘ç»ˆæžä¿®å¤ç‰ˆã€‘ä¿å­˜å¯¼æ¼”æ¨¡å¼ä¸‹ä¿®æ”¹è¿‡çš„å†…å®¹ï¼Œå¹¶é‡å†™åŽ†å²è®°å½•
 */
async function saveEditedAiResponse() {
    
    const chatsToUpdate = new Map();
    let oldMessageTimestampProvider = null; 

    if (lastPrivateMessagesSent.length > 0) {
        console.log(`å¯¼æ¼”å‰ªè¾‘å®¤ï¼šæ­£åœ¨æ’¤é”€ ${lastPrivateMessagesSent.length} æ¡ä¸Šä¸€è½®å‘é€çš„ç§ä¿¡...`);
        
        const oldPrivateMessages = [...lastPrivateMessagesSent];
        oldMessageTimestampProvider = oldPrivateMessages.values(); 
        
        const chatIdsToUndo = [...new Set(oldPrivateMessages.map(ref => ref.chatId))];
        
        for (const chatId of chatIdsToUndo) {
            const chat = await db.chats.get(chatId); 
            if (chat) {
                chatsToUpdate.set(chatId, chat);
            }
        }

        for (const msgRef of oldPrivateMessages) {
            const chat = chatsToUpdate.get(msgRef.chatId);
            if (chat) {
                chat.history = chat.history.filter(msg => msg.timestamp !== msgRef.timestamp);
            }
        }

        if (chatsToUpdate.size > 0) {
            await db.chats.bulkPut(Array.from(chatsToUpdate.values()));
        }
        
        lastPrivateMessagesSent = []; 
    }

    const chat = state.chats[state.activeChatId];
    if (!chat) return;

    
    const editorContainer = document.getElementById('ai-response-editor-container');
    const editorTextareas = editorContainer.querySelectorAll('textarea');
    const editedRawBlocks = Array.from(editorTextareas).map(ta => ta.value.trim()).filter(Boolean);

    
    // ã€V2.3 ä¿®å¤ã€‘å…ˆèŽ·å–åŽŸå§‹æ¶ˆæ¯ï¼Œå†ä»ŽåŽ†å²è®°å½•ä¸­åˆ é™¤
    const originalAiMessages = chat.history.filter(msg => lastResponseTimestamps.includes(msg.timestamp));
    chat.history = chat.history.filter(msg => !lastResponseTimestamps.includes(msg.timestamp));
    
    
    if (editedRawBlocks.length === 0) {
        await db.chats.put(chat);
        renderChatInterface(state.activeChatId);
        renderChatList();
        document.getElementById('ai-response-editor-modal').classList.remove('visible');
        lastRawAiResponse = '';
        lastResponseTimestamps = [];
        return;
    }

    
    let newMessagesArray = [];
    for (const rawContent of editedRawBlocks) {
        try {
            
            const parsedObject = JSON.parse(rawContent);
            newMessagesArray.push(parsedObject);
        } catch (e) {
            console.warn("è·³è¿‡ä¸€ä¸ªæ— æ³•è§£æžä¸ºJSONçš„ç¼–è¾‘å—:", rawContent);
        }
    }

    
    // --- â–¼â–¼â–¼ NAIé€»è¾‘ä¿®å¤ï¼šå»ºç«‹ç´¢å¼• â–¼â–¼â–¼ ---
    const originalNaiMsgs = originalAiMessages.filter(m => m.type === 'naiimag');
    let naiMsgIndex = 0; 
    // --- â–²â–²â–² NAIé€»è¾‘ä¿®å¤ï¼šå»ºç«‹ç´¢å¼• â–²â–²â–² ---
    
    let newTimestamps = [];
    let messageTimestamp = Date.now();
    const privateChatsToSave = new Map(); 

    for (const msgData of newMessagesArray) {
        if (!msgData || typeof msgData !== 'object' || !msgData.type) {
            console.warn("åœ¨å¯¼æ¼”æ¨¡å¼ä¿å­˜æ—¶ï¼Œå‘çŽ°æ— æ•ˆçš„æŒ‡ä»¤å¯¹è±¡ï¼Œå·²è·³è¿‡:", msgData);
            continue;
        }

        let aiMessage = null;
        const baseMessage = { role: 'assistant', senderName: msgData.name || chat.originalName, timestamp: messageTimestamp++ };

        switch (msgData.type) {
            case 'send_private_message': {
                const senderOriginalName = msgData.name;
                const recipientOriginalName = msgData.recipient;
                const userOriginalName = state.qzoneSettings.nickname || '{{user}}';

                if (recipientOriginalName === userOriginalName) {
                    const privateChat = Object.values(state.chats).find(c => !c.isGroup && c.originalName === senderOriginalName);

                    if (privateChat) {
                        
                        if (!privateChatsToSave.has(privateChat.id)) {
                            
                            const freshPrivateChat = chatsToUpdate.get(privateChat.id) || await db.chats.get(privateChat.id);
                            
                            privateChatsToSave.set(privateChat.id, freshPrivateChat);
                        }
                        
                        const chatToUpdate = privateChatsToSave.get(privateChat.id);

                        const messagesToSend = Array.isArray(msgData.content) ? msgData.content : [msgData.content];
                        let newMessagesCount = 0;
                        
                        for (const contentString of messagesToSend) {
                            if (!contentString || !contentString.trim()) continue;
                            
                            const oldMsgRef = (oldMessageTimestampProvider) ? oldMessageTimestampProvider.next().value : null;
                            
                            const timestampToUse = (oldMsgRef && oldMsgRef.chatId === privateChat.id) 
                                ? oldMsgRef.timestamp 
                                : messageTimestamp++; 

                            const privateMessage = {
                                role: 'assistant',
                                senderName: senderOriginalName,
                                content: contentString,
                                timestamp: timestampToUse 
                            };
                            
                            
                            lastPrivateMessagesSent.push({ chatId: privateChat.id, timestamp: privateMessage.timestamp });

                            chatToUpdate.history.push(privateMessage);
                            newMessagesCount++;
                        }

                        if (newMessagesCount > 0) {
                            if (state.activeChatId !== privateChat.id) {
                                chatToUpdate.unreadCount = (chatToUpdate.unreadCount || 0) + newMessagesCount;
                                showNotification(privateChat.id, `${privateChat.name} å‘æ¥äº† ${newMessagesCount} æ¡æ–°æ¶ˆæ¯`);
                            }
                        }
                        
                        aiMessage = null; 

                    } else {
                        console.warn(`AI ${senderOriginalName} å°è¯•å‘é€ç§ä¿¡ï¼Œä½†æœªæ‰¾åˆ°å…¶å¯¹åº”çš„ç§èŠä¼šè¯ã€‚`);
                        aiMessage = null; 
                    }
                } else {
                    console.warn(`AI å°è¯•å‘é€ç§ä¿¡ç»™éžç”¨æˆ·è§’è‰² (${recipientOriginalName})ï¼Œæ­¤åŠŸèƒ½æš‚ä¸æ”¯æŒã€‚`);
                    aiMessage = null; 
                }
                
                continue; 
            }
            case 'thought_chain': { 
                const thoughtForMemory = `[è¿™æ˜¯ä½ ä¸Šä¸€è½®çš„å†…éƒ¨æ€è€ƒ]
- åˆ†æž: ${msgData.analysis || 'æ— '}
- ç­–ç•¥: ${msgData.strategy || 'æ— '}
- è§’è‰²æ€è€ƒ: ${JSON.stringify(msgData.character_thoughts || {})}`;
                
                const hiddenThoughtMessage = {
                    role: 'system',
                    content: thoughtForMemory,
                    timestamp: messageTimestamp++, 
                    isHidden: true 
                };
                
                chat.history.push(hiddenThoughtMessage);
                newTimestamps.push(hiddenThoughtMessage.timestamp); 
                
                continue; 
            }
            case 'text':
                aiMessage = { ...baseMessage, content: String(msgData.content || msgData.message) };
                break;
            case 'sticker': { 
                let found = false; 
                if (msgData.url && msgData.meaning) {
                    aiMessage = {
                        ...baseMessage,
                        type: 'sticker',
                        content: msgData.url, 
                        meaning: msgData.meaning 
                    };
                    found = true;
                }
                else if (msgData.meaning) {
                    const sticker = state.userStickers.find(s => s.name === msgData.meaning); 
                    if (sticker) {
                        aiMessage = { ...baseMessage, type: 'sticker', content: sticker.url, meaning: sticker.name };
                        found = true;
                    } else {
                        aiMessage = { ...baseMessage, type: 'text', content: `[è¡¨æƒ…: ${msgData.meaning}]` }; 
                        found = true; 
                    }
                }
                else if (msgData.url) { 
                    aiMessage = { ...baseMessage, type: 'sticker', content: msgData.url }; 
                    const stickerByURL = state.userStickers.find(s => s.url === msgData.url); 
                    aiMessage.meaning = stickerByURL ? stickerByURL.name : 'æœªçŸ¥è¡¨æƒ…';
                    found = true;
                }
                else if (msgData.content && typeof msgData.content === 'string' && STICKER_REGEX.test(msgData.content)) { 
                    aiMessage = { ...baseMessage, type: 'sticker', content: msgData.content }; 
                    const stickerByContentUrl = state.userStickers.find(s => s.url === msgData.content); 
                    aiMessage.meaning = stickerByContentUrl ? stickerByContentUrl.name : 'æœªçŸ¥è¡¨æƒ…';
                    found = true;
                }
                if (!found) {
                    console.error("å¯¼æ¼”æ¨¡å¼ä¿å­˜(Sticker): æŒ‡ä»¤æ— æ•ˆæˆ–ç¼ºå°‘å¿…è¦å­—æ®µ (meaning/url/content):", msgData); 
                    continue; 
                }
                break; 
            } 
            case 'ai_image':
                aiMessage = { ...baseMessage, type: 'ai_image', content: msgData.description, image_prompt: msgData.image_prompt };
                break;
                
            // ==========================================================
            // â–¼â–¼â–¼ æ ¸å¿ƒä¿®å¤ï¼šV2.3 NAI é€»è¾‘ â–¼â–¼â–¼
            // ==========================================================
            case 'naiimag': {
                const newPrompt = msgData.prompt;
                let newImageUrl = null;
                let newFullPrompt = null;

                // 1. Get the corresponding original message from the history
                const originalMsg = originalNaiMsgs[naiMsgIndex];
                naiMsgIndex++; // Increment cursor for the next NAI block
                
                let promptChanged = false;

                if (originalMsg) {
                    // 2. We found a matching original message. Compare its prompt.
                    const originalPrompt = originalMsg.prompt;
                    
                    // --- ä¿®å¤ç‚¹ï¼šæ£€æŸ¥ msgData.prompt (æ–°) å’Œ originalMsg.prompt (æ—§) ---
                    if (newPrompt && newPrompt !== originalPrompt) {
                        console.log("NAI Prompt å·²æ”¹å˜ï¼Œå°†è§¦å‘é‡æ–°ç”Ÿæˆã€‚");
                        promptChanged = true;
                    } else {
                        // 3. Prompt is the same. Use the old data.
                        console.log("NAI Prompt æœªæ”¹å˜ï¼Œå°†ä¿ç•™åŽŸå§‹å›¾ç‰‡ã€‚");
                        newImageUrl = originalMsg.imageUrl;
                        newFullPrompt = originalMsg.fullPrompt;
                    }
                } else {
                    // 4. No matching original message. This is a NEW block.
                    console.log("æœªæ‰¾åˆ°åŒ¹é…çš„åŽŸå§‹NAIå›¾ç‰‡(è¿™æ˜¯æ–°æ·»åŠ çš„å—)ï¼Œå°†è§¦å‘é‡æ–°ç”Ÿæˆã€‚");
                    promptChanged = true;
                }

                if (promptChanged) {
                    // 5. Execute regeneration logic
                    const alertMessage = originalMsg ? "æ£€æµ‹åˆ°NAIæç¤ºè¯å·²ä¿®æ”¹ï¼Œæ­£åœ¨é‡æ–°ç”Ÿæˆ..." : "æ£€æµ‹åˆ°æ–°çš„NAIç”Ÿå›¾æŒ‡ä»¤ï¼Œæ­£åœ¨ç”Ÿæˆ...";
                    await showCustomAlert("è¯·ç¨å€™...", alertMessage);
                    
                    try {
                        const generatedData = await generateNaiImageFromPrompt(newPrompt, chat.id);
                        newImageUrl = generatedData.imageUrl;
                        newFullPrompt = generatedData.fullPrompt;
                        await showCustomAlert("æˆåŠŸ", "å›¾ç‰‡å·²ç”Ÿæˆï¼");
                    } catch (error) {
                        console.error("å¯¼æ¼”æ¨¡å¼ä¸‹é‡æ–°ç”ŸæˆNAIå›¾ç‰‡å¤±è´¥:", error);
                        await showCustomAlert("ç”Ÿæˆå¤±è´¥", `æ— æ³•ç”Ÿæˆå›¾ç‰‡: ${error.message}. \n\nå°†ä¿ç•™æ—§å›¾ç‰‡ï¼ˆå¦‚æžœå­˜åœ¨ï¼‰ã€‚`);
                        
                        if (originalMsg) {
                            newImageUrl = originalMsg.imageUrl; // Fallback to old image
                            newFullPrompt = originalMsg.fullPrompt;
                        } else {
                             console.error("æ–°NAIå›¾ç‰‡ç”Ÿæˆå¤±è´¥ï¼Œæ­¤æ¡æ¶ˆæ¯å·²è¢«è·³è¿‡ã€‚");
                             continue; // Skip this message
                        }
                    }
                }
                
                // 6. Create the final message object
                aiMessage = { 
                    ...baseMessage, 
                    type: 'naiimag', 
                    imageUrl: newImageUrl, 
                    prompt: newPrompt, 
                    fullPrompt: newFullPrompt 
                };
                break;
            }
            // ==========================================================
            // â–²â–²â–² æ ¸å¿ƒä¿®å¤ç»“æŸ â–²â–²â–²
            // ==========================================================
                
            case 'voice_message':
                aiMessage = { ...baseMessage, type: 'voice_message', content: msgData.content };
                break;
            case 'transfer':
                aiMessage = { ...baseMessage, type: 'transfer', amount: msgData.amount, note: msgData.note, receiverName: msgData.receiver || 'æˆ‘' };
                break;
            case 'waimai_request':
                aiMessage = { 
                    ...baseMessage, type: 'waimai_request',
                    productInfo: msgData.productInfo, amount: msgData.amount,
                    status: 'pending', countdownEndTime: Date.now() + 15 * 60 * 1000,
                };
                break;
            case 'offline_text':
                aiMessage = { ...baseMessage, ...msgData };
                break;
            case 'gomoku_move': {
                const gameState = gomokuState[chat.id];
                if (gameState) {
                    const lastAiMoveIndex = gameState.history.findLastIndex(move => move.player === 2);
                    if (lastAiMoveIndex > -1) {
                        const move_to_undo = gameState.history[lastAiMoveIndex];
                        gameState.board[move_to_undo.y][move_to_undo.x] = 0;
                        gameState.history.splice(lastAiMoveIndex, 1);
                        console.log(`å¯¼æ¼”æ¨¡å¼æ‚”æ£‹ï¼šå·²æ’¤é”€AIåœ¨ (${move_to_undo.x}, ${move_to_undo.y}) çš„æ£‹æ­¥ã€‚`);
                    }
                }
                const x = parseInt(msgData.x);
                const y = parseInt(msgData.y);
                if (!isNaN(x) && !isNaN(y)) {
                    handleAiGomokuMove({ x: x, y: y }, true);
                } else {
                    console.warn("å¯¼æ¼”æ¨¡å¼ä¿å­˜äº†ä¸€ä¸ªæ— æ•ˆçš„äº”å­æ£‹ç§»åŠ¨æŒ‡ä»¤:", msgData);
                }
                continue;
            }
            case 'update_thoughts': { 
                if (!chat.isGroup) {
                    if (msgData.heartfelt_voice) chat.heartfeltVoice = String(msgData.heartfelt_voice);
                    if (msgData.random_jottings) chat.randomJottings = String(msgData.random_jottings);
                    if (!Array.isArray(chat.thoughtsHistory)) chat.thoughtsHistory = [];
                    chat.thoughtsHistory.push({
                        heartfeltVoice: chat.heartfeltVoice,
                        randomJottings: chat.randomJottings, // <--- ä¿®æ­£: åº”è¯¥æ˜¯ randomJottings
                        timestamp: Date.now()
                    });
                    if (chat.thoughtsHistory.length > 50) chat.thoughtsHistory.shift();
                }
                continue;
            }
            case 'quote_reply': {
                const originalQuotedMsg = chat.history.find(m => m.timestamp === msgData.target_timestamp);
                let quoteContext = null;

                if (originalQuotedMsg) {
                    let originalSenderName = originalQuotedMsg.senderName;
                    if (originalQuotedMsg.role === 'user') {
                        originalSenderName = chat.isGroup ? (chat.settings.myNickname || 'æˆ‘') : (state.qzoneSettings.nickname || '{{user}}');
                    }
                    quoteContext = {
                        timestamp: msgData.target_timestamp,
                        senderName: originalSenderName,
                        content: String(originalQuotedMsg.content || '')
                    };
                } else {
                    quoteContext = {
                        timestamp: msgData.target_timestamp,
                        senderName: 'æœªçŸ¥ç”¨æˆ·',
                        content: 'åŽŸå§‹æ¶ˆæ¯å·²åˆ é™¤æˆ–ä¸å­˜åœ¨'
                    };
                }
                aiMessage = { 
                    ...baseMessage, 
                    content: msgData.reply_content,
                    quote: quoteContext
                };
                break; 
            }
            default:
                console.warn("åœ¨å¯¼æ¼”æ¨¡å¼ä¿å­˜æ—¶ï¼Œé‡åˆ°äº†æœªçŸ¥çš„AIæŒ‡ä»¤ç±»åž‹:", msgData.type, msgData);
                if(msgData.content) {
                   aiMessage = { ...baseMessage, content: String(msgData.content) };
                } else {
                   continue; 
                }
                break;
        }

        if (aiMessage) {
            chat.history.push(aiMessage);
            newTimestamps.push(aiMessage.timestamp);
        }
    }

    
    await db.chats.put(chat);
    
    if (privateChatsToSave.size > 0) {
        await db.chats.bulkPut(Array.from(privateChatsToSave.values()));
    }
    
    renderChatInterface(state.activeChatId);
    renderChatList();
    document.getElementById('ai-response-editor-modal').classList.remove('visible');
    
    
    lastRawAiResponse = editedRawBlocks.join('\n\n');
    lastResponseTimestamps = newTimestamps;
    
    
    await showCustomAlert("å¯¼æ¼”æ¨¡å¼", "æ‚¨çš„ä¿®æ”¹å·²ä¿å­˜ï¼");
}
        /**
         * ã€å…¨æ–°ã€‘å¤„ç†ç”¨æˆ·ç‚¹å‡»â€œæ’¤å›žâ€æŒ‰é’®çš„å…¥å£å‡½æ•°
         */
        async function handleRecallClick() {
            if (!activeMessageTimestamp) return;
        
            const RECALL_TIME_LIMIT_MS = 2 * 60 * 1000; 
            const messageTime = activeMessageTimestamp;
            const now = Date.now();
        
            
            if (now - messageTime > RECALL_TIME_LIMIT_MS) {
                hideMessageActions();
                await showCustomAlert('æ“ä½œå¤±è´¥', 'è¯¥æ¶ˆæ¯å‘é€å·²è¶…è¿‡2åˆ†é’Ÿï¼Œæ— æ³•æ’¤å›žã€‚');
                return;
            }
            
            
            await recallMessage(messageTime, true);
            hideMessageActions();
        }
        
/**
 * ã€V2.0 | AIæ„ŸçŸ¥ç‰ˆã€‘æ¶ˆæ¯æ’¤å›žçš„æ ¸å¿ƒé€»è¾‘
 * @param {number} timestamp - è¦æ’¤å›žçš„æ¶ˆæ¯çš„æ—¶é—´æˆ³
 * @param {boolean} isUserRecall - æ˜¯å¦æ˜¯ç”¨æˆ·ä¸»åŠ¨æ’¤å›ž
 */
async function recallMessage(timestamp, isUserRecall) {
    const chat = state.chats[state.activeChatId];
    if (!chat) return;

    const messageIndex = chat.history.findIndex(m => m.timestamp === timestamp);
    if (messageIndex === -1) return;

    const messageToRecall = chat.history[messageIndex];

    const recalledData = {
        originalType: messageToRecall.type || 'text',
        originalContent: messageToRecall.content,
        originalMeaning: messageToRecall.meaning,
        originalQuote: messageToRecall.quote
    };
    
    messageToRecall.type = 'recalled_message';
    messageToRecall.content = isUserRecall ? 'ä½ æ’¤å›žäº†ä¸€æ¡æ¶ˆæ¯' : 'å¯¹æ–¹æ’¤å›žäº†ä¸€æ¡æ¶ˆæ¯';
    messageToRecall.recalledData = recalledData;
    delete messageToRecall.meaning;
    delete messageToRecall.quote;

    
    if (isUserRecall) {
        
        const myNickname = chat.isGroup ? (chat.settings.myNickname || 'æˆ‘') : 'æˆ‘';
        
        
        let recalledContentText = '';
        if (recalledData.originalType === 'sticker') {
            recalledContentText = `[è¡¨æƒ…ï¼Œå«ä¹‰: ${recalledData.originalMeaning || 'æœªçŸ¥'}]`;
        } else if (recalledData.originalType === 'ai_image' || recalledData.originalType === 'user_photo') {
            recalledContentText = `[å›¾ç‰‡ï¼Œæè¿°: ${recalledData.originalContent}]`;
        } else {
            recalledContentText = `â€œ${String(recalledData.originalContent)}â€`;
        }

        
        const hiddenMessageForAI = {
            role: 'system',
            content: `[ç³»ç»Ÿæç¤ºï¼šç”¨æˆ·ï¼ˆ${myNickname}ï¼‰åˆšåˆšæ’¤å›žäº†ä¸€æ¡æ¶ˆæ¯ã€‚æ’¤å›žå‰çš„å†…å®¹æ˜¯ï¼š${recalledContentText}ã€‚è¯·ä½ å¯¹æ­¤ä½œå‡ºå›žåº”ï¼Œå¯ä»¥è¡¨çŽ°å‡ºå¥½å¥‡ã€å¼€çŽ©ç¬‘ï¼ˆæ¯”å¦‚'æˆ‘æˆªå›¾äº†ï¼'ï¼‰ã€æˆ–è€…æ ¹æ®ä½ çš„äººè®¾è¡¨ç¤ºç†è§£æˆ–ç–‘æƒ‘ã€‚]`,
            timestamp: Date.now(),
            isHidden: true 
        };
        chat.history.push(hiddenMessageForAI);
    }
      

    await db.chats.put(chat);
    renderChatInterface(state.activeChatId);
    
    if (isUserRecall) {
        renderChatList();
        
        triggerAiResponse();
    }
}
        
        
        
        /**
         * æ‰“å¼€åˆ†ç±»ç®¡ç†æ¨¡æ€æ¡†
         */
        async function openCategoryManager() {
            await renderCategoryListInManager();
            document.getElementById('world-book-category-manager-modal').classList.add('visible');
        }
        
        /**
         * åœ¨æ¨¡æ€æ¡†ä¸­æ¸²æŸ“å·²å­˜åœ¨çš„åˆ†ç±»åˆ—è¡¨
         */
        async function renderCategoryListInManager() {
            const listEl = document.getElementById('existing-categories-list');
            const categories = await db.worldBookCategories.toArray();
            listEl.innerHTML = '';
            if (categories.length === 0) {
                listEl.innerHTML = '<p style="text-align: center; color: var(--text-secondary);">è¿˜æ²¡æœ‰ä»»ä½•åˆ†ç±»</p>';
            }
            categories.forEach(cat => {
                
                const item = document.createElement('div');
                item.className = 'existing-group-item'; 
                item.innerHTML = `
                    <span class="group-name">${cat.name}</span>
                    <span class="delete-group-btn" data-id="${cat.id}">Ã—</span>
                `;
                listEl.appendChild(item);
            });
        }
        
        /**
         * æ·»åŠ ä¸€ä¸ªæ–°çš„ä¸–ç•Œä¹¦åˆ†ç±»
         */
        async function addNewCategory() {
            const input = document.getElementById('new-category-name-input');
            const name = input.value.trim();
            if (!name) {
                alert('åˆ†ç±»åä¸èƒ½ä¸ºç©ºï¼');
                return;
            }
            const existing = await db.worldBookCategories.where('name').equals(name).first();
            if (existing) {
                alert(`åˆ†ç±» "${name}" å·²ç»å­˜åœ¨äº†ï¼`);
                return;
            }
            await db.worldBookCategories.add({ name });
            input.value = '';
            await renderCategoryListInManager();
        }
        
        /**
         * åˆ é™¤ä¸€ä¸ªä¸–ç•Œä¹¦åˆ†ç±»
         * @param {number} categoryId - è¦åˆ é™¤çš„åˆ†ç±»çš„ID
         */
        async function deleteCategory(categoryId) {
            const confirmed = await showCustomConfirm(
                'ç¡®è®¤åˆ é™¤', 
                'åˆ é™¤åˆ†ç±»åŽï¼Œè¯¥åˆ†ç±»ä¸‹çš„æ‰€æœ‰ä¸–ç•Œä¹¦å°†å˜ä¸ºâ€œæœªåˆ†ç±»â€ã€‚ç¡®å®šè¦åˆ é™¤å—ï¼Ÿ', 
                { confirmButtonClass: 'btn-danger' }
            );
            if (confirmed) {
                await db.worldBookCategories.delete(categoryId);
                
                const booksToUpdate = await db.worldBooks.where('categoryId').equals(categoryId).toArray();
                for (const book of booksToUpdate) {
                    book.categoryId = null;
                    await db.worldBooks.put(book);
                    const bookInState = state.worldBooks.find(wb => wb.id === book.id);
                    if(bookInState) bookInState.categoryId = null;
                }
                await renderCategoryListInManager();
            }
        }
        
        
        async function publishToAnnouncementBoard() {
            if (!activeMessageTimestamp) return;
        
            const timestampToPublish = activeMessageTimestamp;
            hideMessageActions(); 
        
            const chat = state.chats[state.activeChatId];
            const message = chat.history.find(m => m.timestamp === timestampToPublish);
            if (!message) return;
        
            
            let contentPreview = String(message.content || '').substring(0, 50) + '...';
            if (message.type === 'ai_image') contentPreview = '[å›¾ç‰‡] ' + contentPreview;
        
            const confirmed = await showCustomConfirm(
                "å‘å¸ƒå…¬å‘Š",
                `ç¡®å®šè¦å°†ä»¥ä¸‹æ¶ˆæ¯å‘å¸ƒåˆ°å…¬å‘Šæ¿å—ï¼Ÿ\n\nâ€œ${contentPreview}â€`,
                { confirmText: "ç¡®å®šå‘å¸ƒ" }
            );
        
            if (confirmed) {
                const myNickname = chat.settings.myNickname || 'æˆ‘';
        
                if (!Array.isArray(chat.announcements)) {
                    chat.announcements = [];
                }
        
                
                const newAnnouncement = {
                    id: 'anno_' + Date.now(), 
                    messageTimestamp: timestampToPublish,
                    publisher: myNickname,
                    publishedAt: Date.now(),
                    isPinned: false 
                };
        
                chat.announcements.push(newAnnouncement);
        
                const systemMessage = {
                    role: 'system',
                    type: 'pat_message',
                    content: `${myNickname} å‘å¸ƒäº†ä¸€æ¡æ–°å…¬å‘Š`,
                    timestamp: Date.now()
                };
                chat.history.push(systemMessage);
        
                await db.chats.put(chat);
                appendMessage(systemMessage, chat);
                renderChatList();
        
                await showCustomAlert("æˆåŠŸ", "å…¬å‘Šå·²å‘å¸ƒï¼");
            }
        }
          
        /**
         * æ˜¾ç¤ºç¾¤å…¬å‘Šæ¿å¼¹çª—
         */
        
        /**
         * ã€V2.0 | å·²ä¿®å¤å¼‚æ­¥æ¸²æŸ“BUGã€‘æ˜¾ç¤ºç¾¤å…¬å‘Šæ¿å¼¹çª—
         */
        async function showAnnouncementBoard() { 
            const chat = state.chats[state.activeChatId];
            const announcements = chat.announcements || [];

            if (!chat || announcements.length === 0) {
                showCustomAlert("æç¤º", "å½“å‰ç¾¤èŠè¿˜æ²¡æœ‰å…¬å‘Šå“¦ã€‚");
                return;
            }

            const contentEl = document.getElementById('announcement-board-content');
            contentEl.innerHTML = '';

            
            announcements.sort((a, b) => (b.isPinned ? 1 : 0) - (a.isPinned ? 1 : 0));

            
            for (const anno of announcements) {
                const originalMessage = chat.history.find(m => m.timestamp === anno.messageTimestamp);

                const wrapper = document.createElement('div');
                wrapper.className = 'announcement-item-wrapper';

                if (originalMessage) {
                    
                    const messageBubbleEl = await createMessageElement(originalMessage, chat);
                    if (messageBubbleEl) { 
                        wrapper.appendChild(messageBubbleEl);
                    }
                } else {
                    wrapper.innerHTML = '<p style="text-align:center; color: var(--text-secondary);">å…¬å‘Šçš„åŽŸæ¶ˆæ¯å·²è¢«åˆ é™¤ã€‚</p>';
                }

                if (anno.isPinned) {
                    wrapper.innerHTML += `<div class="pinned-indicator">ðŸ“Œ</div>`;
                }
                wrapper.innerHTML += `<div class="announcement-item-actions" data-anno-id="${anno.id}">...</div>`;

                contentEl.appendChild(wrapper);
            }

            document.getElementById('announcement-board-modal').classList.add('visible');
        }
          
        
        let activeAnnouncementId = null; 
        
        /**
         * ç‚¹å‡»â€œ...â€æ—¶ï¼Œæ˜¾ç¤ºæ“ä½œèœå•ï¼ˆç½®é¡¶/åˆ é™¤ï¼‰
         * @param {string} annoId - å…¬å‘Šçš„å”¯ä¸€ID
         */
        function showAnnouncementActions(annoId) {
            activeAnnouncementId = annoId;
            const chat = state.chats[state.activeChatId];
            const announcement = chat.announcements.find(a => a.id === annoId);
            if (!announcement) return;
        
            const pinButton = document.getElementById('announcement-action-pin');
            
            pinButton.textContent = announcement.isPinned ? 'å–æ¶ˆç½®é¡¶' : 'ç½®é¡¶å…¬å‘Š';
        
            document.getElementById('announcement-actions-modal').classList.add('visible');
        }
        
        /**
         * å¤„ç†â€œç½®é¡¶/å–æ¶ˆç½®é¡¶â€æ“ä½œ
         */
        async function handlePinAnnouncement() {
            if (!activeAnnouncementId) return;
            const chat = state.chats[state.activeChatId];
            const announcement = chat.announcements.find(a => a.id === activeAnnouncementId);
            if (announcement) {
                announcement.isPinned = !announcement.isPinned; 
                await db.chats.put(chat);
                showAnnouncementBoard(); 
            }
            document.getElementById('announcement-actions-modal').classList.remove('visible');
        }
        
        /**
         * å¤„ç†â€œåˆ é™¤å…¬å‘Šâ€æ“ä½œ
         */
        async function handleDeleteAnnouncement() {
            if (!activeAnnouncementId) return;
            
            const confirmed = await showCustomConfirm("ç¡®è®¤åˆ é™¤", "ç¡®å®šè¦åˆ é™¤è¿™æ¡å…¬å‘Šå—ï¼Ÿæ­¤æ“ä½œä¸å¯æ¢å¤ã€‚", { confirmButtonClass: 'btn-danger' });
            
            if (confirmed) {
                const chat = state.chats[state.activeChatId];
                
                chat.announcements = chat.announcements.filter(a => a.id !== activeAnnouncementId);
                await db.chats.put(chat);
                showAnnouncementBoard(); 
            }
            document.getElementById('announcement-actions-modal').classList.remove('visible');
        }
        

        
        
        let editingFrameForMember = false;
        let currentFrameSelection = { ai: null, my: null };
        
        function openFrameSelectorModal(type = 'chat') {
            const frameModal = document.getElementById('avatar-frame-modal');
            if (!state.activeChatId) return;
            const chat = state.chats[state.activeChatId];
            editingFrameForMember = (type === 'member');
        
            if (editingFrameForMember) {
                const member = chat.members.find(m => m.id === editingMemberId);
                if (!member) return;
                currentFrameSelection.my = member.avatarFrame || '';
                populateFrameGrids(true, member.avatar, member.avatarFrame);
            } else {
                currentFrameSelection.ai = chat.settings.aiAvatarFrame || '';
                currentFrameSelection.my = chat.settings.myAvatarFrame || '';
                populateFrameGrids(false);
            }
            frameModal.classList.add('visible');
        }
        
        function populateFrameGrids(isForMember = false, memberAvatar = null, memberFrame = null) {
            const aiFrameGrid = document.getElementById('ai-frame-grid');
            const myFrameGrid = document.getElementById('my-frame-grid');
            const chat = state.chats[state.activeChatId];
            aiFrameGrid.innerHTML = '';
            myFrameGrid.innerHTML = '';
        
            document.querySelector('#avatar-frame-modal .frame-tabs').style.display = isForMember ? 'none' : 'flex';
            document.getElementById('ai-frame-content').style.display = 'block';
            document.getElementById('my-frame-content').style.display = 'none';
            document.getElementById('ai-frame-tab').classList.add('active');
            document.getElementById('my-frame-tab').classList.remove('active');
        
            if (isForMember) {
                avatarFrames.forEach(frame => {
                    const item = createFrameItem(frame, 'my', memberAvatar);
                    if (frame.url === memberFrame) {
                        item.classList.add('selected');
                    }
                    aiFrameGrid.appendChild(item);
                });
            } else {
                const aiAvatarForPreview = chat.settings.aiAvatar || defaultAvatar;
                const myAvatarForPreview = chat.settings.myAvatar || (chat.isGroup ? defaultMyGroupAvatar : defaultAvatar);
                avatarFrames.forEach(frame => {
                    const aiItem = createFrameItem(frame, 'ai', aiAvatarForPreview);
                    if (frame.url === currentFrameSelection.ai) aiItem.classList.add('selected');
                    aiFrameGrid.appendChild(aiItem);
                    const myItem = createFrameItem(frame, 'my', myAvatarForPreview);
                    if (frame.url === currentFrameSelection.my) myItem.classList.add('selected');
                    myFrameGrid.appendChild(myItem);
                });
            }
        }
        
        function createFrameItem(frame, type, previewAvatarSrc) {
            const item = document.createElement('div');
            item.className = 'frame-item';
            item.dataset.frameUrl = frame.url;
            item.title = frame.name;
            item.innerHTML = `
                <img src="${previewAvatarSrc}" class="preview-avatar">
                ${frame.url ? `<img src="${frame.url}" class="preview-frame">` : ''}
            `;
            item.addEventListener('click', () => {
                currentFrameSelection[type] = frame.url;
                const grid = type === 'ai' ? document.getElementById('ai-frame-grid') : document.getElementById('my-frame-grid');
                grid.querySelectorAll('.frame-item').forEach(el => el.classList.remove('selected'));
                item.classList.add('selected');
            });
            return item;
        }
        
        async function saveSelectedFrames() {
            if (!state.activeChatId) return;
            const chat = state.chats[state.activeChatId];
            if (editingFrameForMember) {
                const member = chat.members.find(m => m.id === editingMemberId);
                if (member) {
                    member.avatarFrame = currentFrameSelection.my;
                }
            } else {
                chat.settings.aiAvatarFrame = currentFrameSelection.ai;
                chat.settings.myAvatarFrame = currentFrameSelection.my;
            }
        
            await db.chats.put(chat);
        
            
            
            if (!editingFrameForMember && !chat.isGroup) {
                const characterId = chat.id; 
        
                
                for (const groupChat of Object.values(state.chats)) {
                    if (groupChat.isGroup && groupChat.members) {
                        
                        const memberToUpdate = groupChat.members.find(m => m.id === characterId);
        
                        
                        if (memberToUpdate) {
                            memberToUpdate.avatarFrame = chat.settings.aiAvatarFrame;
                            
                            await db.chats.put(groupChat);
                            console.log(`å·²åŒæ­¥è§’è‰² ${characterId} çš„å¤´åƒæ¡†åˆ°ç¾¤èŠ "${groupChat.name}"`);
                        }
                    }
                }
            }
            
        
            document.getElementById('avatar-frame-modal').classList.remove('visible');
            renderChatInterface(state.activeChatId);
            alert('å¤´åƒæ¡†å·²ä¿å­˜å¹¶åŒæ­¥ï¼'); 
            editingFrameForMember = false;
        }
        
        


/**
 * åˆ‡æ¢å¤´åƒæ¡†é¢æ¿çš„ç®¡ç†æ¨¡å¼
 */
function toggleFrameManagementMode() {
    isFrameManagementMode = !isFrameManagementMode;
    const manageBtn = document.getElementById('manage-frames-btn');
    const actionBar = document.getElementById('frame-action-bar');
    const selectAllCheckbox = document.getElementById('select-all-frames-checkbox');

    
    document.querySelectorAll('.frame-grid').forEach(grid => {
        grid.classList.toggle('management-mode', isFrameManagementMode);
    });
    
    if (isFrameManagementMode) {
        manageBtn.textContent = 'å®Œæˆ';
        actionBar.style.display = 'flex';
        selectedFrames.clear();
        selectAllCheckbox.checked = false;
        updateDeleteFrameButton();
    } else {
        manageBtn.textContent = 'ç®¡ç†';
        actionBar.style.display = 'none';
        
        document.querySelectorAll('.frame-item.selected').forEach(item => {
            item.classList.remove('selected');
        });
    }
}

/**
 * æ›´æ–°â€œåˆ é™¤â€æŒ‰é’®ä¸Šçš„è®¡æ•°
 */
function updateDeleteFrameButton() {
    const btn = document.getElementById('delete-selected-frames-btn');
    btn.textContent = `åˆ é™¤ (${selectedFrames.size})`;
}

/**
 * å¤„ç†â€œå…¨é€‰â€å¤é€‰æ¡†çš„ç‚¹å‡»äº‹ä»¶
 */
function handleSelectAllFrames() {
    const isChecked = document.getElementById('select-all-frames-checkbox').checked;
    const visibleGrid = document.querySelector('.frame-content[style*="display: block"] .frame-grid');
    if (!visibleGrid) return;

    
    visibleGrid.querySelectorAll('.frame-item:has(.delete-btn)').forEach(item => {
        const frameId = parseInt(item.querySelector('.delete-btn').dataset.id);
        if (isNaN(frameId)) return;
        
        item.classList.toggle('selected', isChecked);
        if (isChecked) {
            selectedFrames.add(frameId);
        } else {
            selectedFrames.delete(frameId);
        }
    });
    updateDeleteFrameButton();
}

/**
 * æ‰§è¡Œæ‰¹é‡åˆ é™¤æ“ä½œ
 */
async function executeBatchDeleteFrames() {
    if (selectedFrames.size === 0) return;
    
    const confirmed = await showCustomConfirm(
        'ç¡®è®¤åˆ é™¤',
        `ç¡®å®šè¦æ°¸ä¹…åˆ é™¤é€‰ä¸­çš„ ${selectedFrames.size} ä¸ªè‡ªå®šä¹‰å¤´åƒæ¡†å—ï¼Ÿ`,
        { confirmButtonClass: 'btn-danger' }
    );

    if (confirmed) {
        const idsToDelete = [...selectedFrames];
        await db.customAvatarFrames.bulkDelete(idsToDelete);
        
        
        toggleFrameManagementMode();
        populateFrameGrids(editingFrameForMember); 
        
        await showCustomAlert('åˆ é™¤æˆåŠŸ', 'é€‰ä¸­çš„å¤´åƒæ¡†å·²æˆåŠŸåˆ é™¤ã€‚');
    }
}


        
        /**
         * å°†ç”¨æˆ·è‡ªå®šä¹‰çš„å…¨å±€CSSåº”ç”¨åˆ°é¡µé¢
         * @param {string} cssString ç”¨æˆ·è¾“å…¥çš„CSSä»£ç 
         */
        function applyGlobalCss(cssString) {
            const styleTag = document.getElementById('global-custom-style');
            if (styleTag) {
                
                styleTag.innerHTML = cssString || '';
            }
        }
        
        
        
        /**
         * å‘å½“å‰èŠå¤©çš„åŽ†å²è®°å½•ä¸­æ·»åŠ ä¸€æ¡å…³äºŽéŸ³ä¹æ“ä½œçš„ã€å¯¹ç”¨æˆ·éšè—çš„ç³»ç»Ÿæ¶ˆæ¯
         * @param {string} actionText - æè¿°ç”¨æˆ·æ“ä½œçš„æ–‡æœ¬ï¼Œä¾‹å¦‚ "æš‚åœäº†éŸ³ä¹"
         */
        async function addMusicActionSystemMessage(actionText) {
            
            if (!musicState.isActive || !musicState.activeChatId) return;
            const chat = state.chats[musicState.activeChatId];
            if (!chat) return;
        
            
            const myNickname = chat.isGroup ? (chat.settings.myNickname || 'æˆ‘') : 'æˆ‘';
            const fullMessage = `[ç³»ç»Ÿæç¤ºï¼šç”¨æˆ· (${myNickname}) ${actionText}]`;
        
            
            const systemMessage = {
                role: 'system',
                content: fullMessage,
                timestamp: Date.now(),
                isHidden: true 
            };
        
            
            chat.history.push(systemMessage);
            await db.chats.put(chat);
        }
        
        
        
        /**
         * ã€V3.0 | å¸ƒå±€ä¿®å¤ç‰ˆã€‘å¤„ç†é•¿æˆªå›¾åŠŸèƒ½
         */
        async function handleLongScreenshot() {
            if (selectedMessages.size === 0) return;
            const chat = state.chats[state.activeChatId];
            if (!chat) return;
        
            
            const screenshotBtn = document.getElementById('selection-screenshot-btn');
            const originalBtnText = screenshotBtn.textContent;
            screenshotBtn.textContent = 'ç”Ÿæˆä¸­...';
            screenshotBtn.disabled = true;
        
            
            const screenshotContainer = document.createElement('div');
            const phoneScreen = document.getElementById('phone-screen');
            screenshotContainer.style.width = phoneScreen.offsetWidth + 'px';
            screenshotContainer.style.position = 'absolute';
            screenshotContainer.style.top = '-9999px';
            screenshotContainer.style.left = '-9999px';
            screenshotContainer.style.display = 'flex';
            screenshotContainer.style.flexDirection = 'column';
            screenshotContainer.style.height = 'auto';
            
            const chatScreen = document.getElementById('chat-interface-screen');
            screenshotContainer.style.backgroundImage = chatScreen.style.backgroundImage;
            screenshotContainer.style.backgroundColor = chatScreen.style.backgroundColor || (document.getElementById('phone-screen').classList.contains('dark-mode') ? '#000000' : '#f0f2f5');
        
            const tempStyle = document.createElement('style');
            tempStyle.innerHTML = `
                .message-bubble.selected::after { display: none !important; }
                .cloned-header .default-controls { display: flex !important; justify-content: space-between; align-items: center; width: 100%; }
                .cloned-header .selection-controls { display: none !important; }
            `;
            document.head.appendChild(tempStyle);
        
            try {
                
                const header = chatScreen.querySelector('.header').cloneNode(true);
                header.classList.add('cloned-header');
                
                
                
                const messagesContainer = document.createElement('div');
                const originalMessagesContainer = document.getElementById('chat-messages');
        
                
                messagesContainer.style.display = 'flex';
                messagesContainer.style.flexDirection = 'column';
                messagesContainer.style.gap = '20px'; 
                messagesContainer.style.padding = '10px 15px 20px 15px'; 
                messagesContainer.style.width = '100%';
                messagesContainer.style.boxSizing = 'border-box';
        
                
                messagesContainer.dataset.theme = originalMessagesContainer.dataset.theme;
                messagesContainer.style.setProperty('--chat-font-size', originalMessagesContainer.style.getPropertyValue('--chat-font-size'));
                
        
                const inputArea = chatScreen.querySelector('#chat-input-area').cloneNode(true);
        
                const sortedTimestamps = [...selectedMessages].sort((a, b) => a - b);
                sortedTimestamps.forEach(timestamp => {
                    
                    const originalBubble = document.querySelector(`.message-bubble[data-timestamp="${timestamp}"]`);
                    if (originalBubble) {
                        const originalWrapper = originalBubble.closest('.message-wrapper');
                        if (originalWrapper) {
                            messagesContainer.appendChild(originalWrapper.cloneNode(true));
                        }
                    }
                });
        
                screenshotContainer.appendChild(header);
                screenshotContainer.appendChild(messagesContainer);
                screenshotContainer.appendChild(inputArea);
                document.body.appendChild(screenshotContainer);
                
                
                const images = Array.from(screenshotContainer.getElementsByTagName('img'));
                const imageLoadPromises = images.map(img => new Promise((resolve, reject) => {
                    if (img.src.startsWith('data:')) {
                        resolve();
                        return;
                    }
                    const newImg = new Image();
                    newImg.crossOrigin = 'anonymous';
                    newImg.onload = resolve;
                    newImg.onerror = resolve; 
                    newImg.src = img.src;
                }));
                
                await Promise.all(imageLoadPromises);
        
                
                const canvas = await html2canvas(screenshotContainer, {
                    allowTaint: true,
                    useCORS: true,
                    backgroundColor: null,
                    scale: window.devicePixelRatio || 2,
                });
        
                
                canvas.toBlob(function(blob) {
                    const url = URL.createObjectURL(blob);
                    const link = document.createElement('a');
                    link.download = `EPhone-é•¿æˆªå›¾-${chat.name}-${Date.now()}.png`;
                    link.href = url;
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                    URL.revokeObjectURL(url);
                }, 'image/png');
        
            } catch (error) {
                console.error('é•¿æˆªå›¾ç”Ÿæˆå¤±è´¥:', error);
                await showCustomAlert('ç”Ÿæˆå¤±è´¥', 'ç”Ÿæˆæˆªå›¾æ—¶å‘ç”Ÿé”™è¯¯ï¼Œè¯·æ£€æŸ¥æŽ§åˆ¶å°èŽ·å–è¯¦æƒ…ã€‚');
            } finally {
                
                document.body.removeChild(screenshotContainer);
                document.head.removeChild(tempStyle);
                screenshotBtn.textContent = originalBtnText;
                screenshotBtn.disabled = false;
                exitSelectionMode(); 
            }
        }
        /**
         * ã€V2.1 | æœ€ç»ˆä¿®å¤ç‰ˆã€‘ä¸€ä¸ªç®€å•çš„ Markdown è§£æžå™¨
         * @param {string} text - åŒ…å« Markdown è¯­æ³•çš„åŽŸå§‹æ–‡æœ¬
         * @returns {string} - è½¬æ¢æˆ HTML åŽçš„æ–‡æœ¬
         */
        function parseMarkdown(text) {
            if (!text || typeof text !== 'string') return '';

            
            text = text.replace(/!h\{(.*?)\}/g, '<span class="diary-highlight">$1</span>');
            text = text.replace(/!u\{(.*?)\}/g, '<span class="diary-underline">$1</span>');
            text = text.replace(/!e\{(.*?)\}/g, '<span class="diary-emphasis">$1</span>');
            text = text.replace(/!w\{(.*?)\}/g, '<span class="diary-handwritten">$1</span>');
            text = text.replace(/!m\{(.*?)\}/g, '<span class="diary-messy">$1</span>');
            
            
            
            text = text.replace(/\|\|(.*?)\|\|/g, '<span class="spoiler">$1</span>');
              

            
            text = text.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
            text = text.replace(/\~\~(.*?)\~\~/g, '<s>$1</s>'); 
            text = text.replace(/\*(.*?)\*/g, '<em>$1</em>');

            return text;
        }


        
        /**
         * è‡ªåŠ¨è¿ç§»æ—§çš„ã€æ ¼å¼ä¸æ­£ç¡®çš„çº¢åŒ…æ•°æ®ï¼Œå°† 'receiver' å­—æ®µé‡å‘½åä¸º 'receiverName'
         */
        async function migrateOldRedPacketData() {
            console.log("å¼€å§‹æ£€æŸ¥å¹¶è¿ç§»æ—§çš„çº¢åŒ…æ•°æ®...");
            let migrationCount = 0;
            
            const allChats = Object.values(state.chats);
        
            for (const chat of allChats) {
                let needsDbUpdate = false;
                for (const msg of chat.history) {
                    
                    if (msg.type === 'red_packet' && msg.packetType === 'direct' && msg.role === 'assistant' && msg.hasOwnProperty('receiver') && !msg.hasOwnProperty('receiverName')) {
                        
                        msg.receiverName = msg.receiver;
                        delete msg.receiver;
                        
                        needsDbUpdate = true; 
                        migrationCount++;
                    }
                }
                
                if (needsDbUpdate) {
                    console.log(`åœ¨èŠå¤© "${chat.name}" ä¸­å‘çŽ°å¹¶ä¿®å¤äº†æ—§çº¢åŒ…æ•°æ®ã€‚`);
                    await db.chats.put(chat);
                }
            }
        
            if (migrationCount > 0) {
                console.log(`æ•°æ®è¿ç§»å®Œæˆï¼æ€»å…±ä¿®å¤äº† ${migrationCount} æ¡çº¢åŒ…è®°å½•ã€‚`);
                alert(`æ£€æµ‹åˆ°å¹¶æˆåŠŸä¿®å¤äº† ${migrationCount} æ¡æ—§çš„çº¢åŒ…æ¶ˆæ¯ï¼é¡µé¢å°†è‡ªåŠ¨åˆ·æ–°ä»¥åº”ç”¨æ›´æ”¹ã€‚`);
                location.reload(); 
            } else {
                console.log("æœªå‘çŽ°éœ€è¦è¿ç§»çš„æ—§çº¢åŒ…æ•°æ®ã€‚");
            }
        }
        
        

        function showCharacterProfileModal(chatId) {
            const chat = state.chats[chatId];
            if (!chat || chat.isGroup) return;
        
            
            
           
           
            document.getElementById('profile-heartfelt-voice').textContent = chat.heartfeltVoice || '...';
            document.getElementById('profile-random-jottings').textContent = chat.randomJottings || '...';

            const modal = document.getElementById('character-profile-modal');
        
            
            
            
            
            modal.classList.add('visible');
        }
        /**
         * ã€å…¨æ–°ã€‘æ˜¾ç¤ºå¿ƒå£°åŽ†å²è®°å½•è§†å›¾
         */
        function showThoughtsHistory() {
            document.getElementById('profile-main-content').style.display = 'none';
            document.getElementById('profile-thoughts-history-view').style.display = 'flex';
            renderThoughtsHistory();
        }
        
        /**
         * ã€å…¨æ–° | å·²ä¿®å¤BUGã€‘éšè—å¿ƒå£°åŽ†å²è®°å½•è§†å›¾ï¼Œè¿”å›žä¸»èµ„æ–™é¡µ
         */
function hideThoughtsHistory() {
    document.getElementById('profile-thoughts-history-view').style.display = 'none';
    
    
    document.getElementById('profile-main-content').style.display = 'flex'; 
}
  
        
        /**
         * ã€å…¨æ–° | åˆ†é¡µåŠ è½½ç‰ˆã€‘æ¸²æŸ“å¿ƒå£°åŽ†å²è®°å½•åˆ—è¡¨
         */
        function renderThoughtsHistory() {
            const listEl = document.getElementById('thoughts-history-list');
            const chat = state.chats[state.activeChatId];
            listEl.innerHTML = '';
            
            if (!chat || !chat.thoughtsHistory || chat.thoughtsHistory.length === 0) {
                listEl.innerHTML = '<p style="text-align:center; color: #8a8a8a; padding: 30px 0;">è¿™é‡Œè¿˜æ²¡æœ‰åŽ†å²è®°å½•å“¦ã€‚</p>';
                return;
            }
        
            const history = [...chat.thoughtsHistory].reverse(); 
            const initialItems = history.slice(0, THOUGHTS_RENDER_WINDOW);
            
            initialItems.forEach(thought => {
                const card = createThoughtCard(thought);
                listEl.appendChild(card);
            });
        
            thoughtsHistoryRenderCount = initialItems.length;
        

if (history.length > thoughtsHistoryRenderCount) {
    appendLoadMoreThoughtsButton(listEl); 
}
        }

        

async function loadMoreThoughts() {
    if (isLoadingMoreThoughts) return;
    isLoadingMoreThoughts = true;

    const listEl = document.getElementById('thoughts-history-list');
    const chat = state.chats[state.activeChatId];
    if (!chat) { 
        isLoadingMoreThoughts = false; 
        return; 
    }

    showLoader(listEl, 'bottom'); 
    await new Promise(resolve => setTimeout(resolve, 500)); 

    const history = [...chat.thoughtsHistory].reverse();
    const totalItems = history.length;

    const nextSliceStart = thoughtsHistoryRenderCount;
    const nextSliceEnd = thoughtsHistoryRenderCount + THOUGHTS_RENDER_WINDOW;
    const itemsToAppend = history.slice(nextSliceStart, nextSliceEnd);

    
    hideLoader(listEl);

    itemsToAppend.forEach(thought => {
        const card = createThoughtCard(thought);
        listEl.appendChild(card);
    });

    thoughtsHistoryRenderCount += itemsToAppend.length;

    isLoadingMoreThoughts = false;
}
  

/**
 * ã€å…¨æ–°ç¾ŽåŒ–ç‰ˆã€‘æ ¹æ®å•æ¡è®°å½•æ•°æ®ï¼Œåˆ›å»ºä¸€å¼ å¿ƒå£°åŽ†å²å¡ç‰‡
 * @param {object} thought - ä¸€æ¡å¿ƒå£°åŽ†å²è®°å½•å¯¹è±¡
 * @returns {HTMLElement} - åˆ›å»ºå¥½çš„å¡ç‰‡div
 */
function createThoughtCard(thought) {
    const card = document.createElement('div');
    card.className = 'thought-card';
    const date = new Date(thought.timestamp);
    const dateString = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}-${String(date.getDate()).padStart(2, '0')} ${String(date.getHours()).padStart(2, '0')}:${String(date.getMinutes()).padStart(2, '0')}`;
    
    
    card.innerHTML = `
        <button class="thought-delete-btn" data-timestamp="${thought.timestamp}" title="åˆ é™¤æ­¤æ¡è®°å½•">Ã—</button>
        <div class="thought-header">${dateString}</div>
        <div class="thought-content">
            <div class="voice">
                <div class="label">
                    <svg viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z"/></svg>
                    å¿ƒå£°
                </div>
                <p class="text">${thought.heartfeltVoice}</p>
            </div>
            <div class="jottings">
                <div class="label">
                     <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 19l7-7 3 3-7 7-3-3z"></path><path d="M18 13l-1.5-7.5L2 2l3.5 14.5L13 18l5-5z"></path><path d="M2 2l7.586 7.586"></path></svg>
                    æ•£è®°
                </div>
                <p class="text">${thought.randomJottings}</p>
            </div>
        </div>
    `;
    return card;
} 
  
        
        
        
        
 
        
        

          
        
        
        

        

          
        
            /**
             * ã€æ€»å…¥å£ã€‘å¤„ç†ç”¨æˆ·ç‚¹å‡»â€œåˆ‡æ¢å¼€åœºâ€æŒ‰é’®çš„é€»è¾‘
             */
            async function handleSwitchGreeting() {
                if (!state.activeChatId) return;
                const chat = state.chats[state.activeChatId];
                const greetings = chat.settings.alternateGreetings;
        
                if (!greetings || greetings.length === 0) {
                    alert("è¿™ä¸ªè§’è‰²æ²¡æœ‰å¯ç”¨çš„å¤‡é€‰å¼€åœºç™½ã€‚");
                    return;
                }
        
                
                const options = greetings.map((text, index) => {
                    
                    const preview = text.replace(/<[^>]*>/g, '').trim().substring(0, 20);
                    return {
                        text: `å¼€åœº ${index + 1}: ${preview}...`,
                        value: index 
                    };
                });
        
                
                const selectedIndex = await showChoiceModal('é€‰æ‹©ä¸€ä¸ªå¼€åœºç™½', options);
        
                
                if (selectedIndex !== null) {
                    
                    const confirmed = await showCustomConfirm(
                        'ç¡®è®¤æ“ä½œ',
                        'åˆ‡æ¢å¼€åœºå°†ä¼šã€æ¸…ç©ºå¹¶æ›¿æ¢ã€‘å½“å‰çš„æ‰€æœ‰èŠå¤©è®°å½•ã€‚ç¡®å®šè¦ç»§ç»­å—ï¼Ÿ',
                        { confirmButtonClass: 'btn-danger', confirmText: 'ç¡®å®šåˆ‡æ¢' }
                    );
        
                    if (confirmed) {
                        
                        const newGreetingText = greetings[selectedIndex];
                        
                        const newMessage = {
                            role: 'assistant',
                            senderName: chat.originalName,
                            content: newGreetingText,
                            timestamp: Date.now()
                        };
        
                        
                        chat.history = [newMessage];
                        
                        
                        await db.chats.put(chat);
        
                        
                        renderChatInterface(chat.id);
                        document.getElementById('chat-settings-modal').classList.remove('visible'); 
                        await showCustomAlert('æˆåŠŸ', 'å·²åˆ‡æ¢åˆ°æ–°çš„å¼€åœºæ•…äº‹ï¼');
                    }
                }
            }
            
        
        
        /**
         * ã€è¾…åŠ©å‡½æ•°ã€‘åˆ›å»ºä¸€ä¸ªå¯ç¼–è¾‘çš„ä¸–ç•Œä¹¦æ¡ç›®å—
         * @param {object} entry - å•ä¸ªæ¡ç›®çš„æ•°æ® { keys, comment, content, enabled }
         * @returns {HTMLElement} - åˆ›å»ºå¥½çš„DOMå…ƒç´ 
         */
        function createWorldBookEntryBlock(entry = { keys: [], comment: '', content: '', enabled: true }) {
            const block = document.createElement('div');
            
            block.className = 'message-editor-block';
        
            
            const isChecked = entry.enabled !== false ? 'checked' : '';

            block.innerHTML = `
                <div style="display: flex; justify-content: flex-end; align-items: center; gap: 10px; margin-bottom: 5px;">
                    <label class="toggle-switch" title="å¯ç”¨/ç¦ç”¨æ­¤æ¡ç›®">
                        <input type="checkbox" class="entry-enabled-switch" ${isChecked}>
                        <span class="slider"></span>
                    </label>
                    <button class="delete-block-btn" title="åˆ é™¤æ­¤æ¡ç›®">Ã—</button>
                </div>
                <div class="form-group" style="margin-bottom: 10px;">
                    <label style="font-size: 0.8em;">å¤‡æ³¨ (å¯é€‰)</label>
                    <input type="text" class="entry-comment-input" value="${entry.comment || ''}" placeholder="ä¾‹å¦‚ï¼šå…³äºŽè§’è‰²çš„ç«¥å¹´" style="padding: 8px;">
                </div>
                <div class="form-group" style="margin-bottom: 10px;">
                    <label style="font-size: 0.8em;">å…³é”®è¯ (ç”¨è‹±æ–‡é€—å·,åˆ†éš”)</label>
                    <input type="text" class="entry-keys-input" value="${(entry.keys || []).join(', ')}" placeholder="ä¾‹å¦‚: key1, key2, key3" style="padding: 8px;">
                </div>
                <div class="form-group" style="margin-bottom: 0;">
                    <label style="font-size: 0.8em;">å†…å®¹</label>
                    <textarea class="entry-content-textarea" rows="5" style="width: 100%; font-size: 14px;">${entry.content || ''}</textarea>
                </div>
            `;
        
            
            block.querySelector('.delete-block-btn').addEventListener('click', () => {
                block.remove();
            });
        
            return block;
        }
          
        
        
        /**
         * ã€é®ç½©ç»ˆæžä¿®å¤ç‰ˆã€‘åˆ‡æ¢äº”å­æ£‹æ£‹ç›˜çš„æ˜¾ç¤ºä¸Žéšè—
         */
        async function toggleGomokuBoard() {
            if (!state.activeChatId) return;
            const chatId = state.activeChatId;
            const overlay = document.getElementById('gomoku-overlay');
        
            
            if (!overlay.classList.contains('visible')) {
                const header = document.querySelector('#chat-interface-screen > .header');
                
                overlay.style.top = `${header.offsetHeight}px`;
                overlay.style.display = 'block';
        
                if (!gomokuState[chatId] || !gomokuState[chatId].isActive) {
                    initGomokuGame(chatId);
                }
                renderGomokuBoard(chatId);
        
                
                setTimeout(async () => {
                    overlay.classList.add('visible');
        
                    const startMessage = {
                        role: 'system',
                        content: '[ç³»ç»Ÿæç¤ºï¼šç”¨æˆ·æ‰“å¼€äº†äº”å­æ£‹æ£‹ç›˜ï¼Œæ¸¸æˆå¼€å§‹äº†ã€‚]',
                        timestamp: Date.now(),
                        isHidden: true
                    };
                    state.chats[chatId].history.push(startMessage);
                    await db.chats.put(state.chats[chatId]);
                }, 10);
        
            } else {
                
                await closeGomokuBoard();
            }
        }
        /**
         * ã€é®ç½©ç»ˆæžä¿®å¤ç‰ˆã€‘å…³é—­äº”å­æ£‹æ£‹ç›˜
         */
        async function closeGomokuBoard() {
            if (!state.activeChatId) return;
            const chatId = state.activeChatId;
            const overlay = document.getElementById('gomoku-overlay');
            
            overlay.classList.remove('visible');
            
            
        
            setTimeout(() => {
                overlay.style.display = 'none';
            }, 300);
        
            if (gomokuState[chatId]) {
                gomokuState[chatId].isActive = false;
                
                const endMessage = {
                    role: 'system',
                    content: '[ç³»ç»Ÿæç¤ºï¼šç”¨æˆ·å…³é—­äº†äº”å­æ£‹æ£‹ç›˜ï¼Œæ¸¸æˆç»“æŸäº†ã€‚]',
                    timestamp: Date.now(),
                    isHidden: true
                };
                state.chats[chatId].history.push(endMessage);
                await db.chats.put(state.chats[chatId]);
            }
        }
        
        /**
         * ã€æ¸²æŸ“æ—¶åºä¿®å¤ç‰ˆã€‘åˆå§‹åŒ–ä¸€å±€æ–°çš„äº”å­æ£‹æ¸¸æˆ
         * @param {string} chatId 
         */
        function initGomokuGame(chatId) {
            const canvas = document.getElementById('gomoku-board');
            const overlay = document.getElementById('gomoku-overlay');
            const controls = document.getElementById('gomoku-controls');
            
            
            const availableWidth = overlay.offsetWidth - 40; 
            const availableHeight = overlay.offsetHeight - controls.offsetHeight - 40;
            const boardSize = Math.floor(Math.min(availableWidth, availableHeight));
            
            const GRID_SIZE = 15;
            
            const cell_size = Math.floor(boardSize / GRID_SIZE);
            const final_size = cell_size * GRID_SIZE;
            
            canvas.width = final_size;
            canvas.height = final_size;
        
            gomokuState[chatId] = {
                isActive: true,
                board: Array(GRID_SIZE).fill(0).map(() => Array(GRID_SIZE).fill(0)),
                currentPlayer: 1, 
                history: [],
                isGameOver: false,
                GRID_SIZE: GRID_SIZE,
                CELL_SIZE: cell_size
            };
        }
        /**
         * æ¸²æŸ“æ•´ä¸ªæ£‹ç›˜å’Œæ£‹å­
         * @param {string} chatId 
         */
        function renderGomokuBoard(chatId) {
            const gameState = gomokuState[chatId];
            if (!gameState) return;
            
            const canvas = document.getElementById('gomoku-board');
            const ctx = canvas.getContext('2d');
            const { GRID_SIZE, CELL_SIZE } = gameState;
            const padding = CELL_SIZE / 2;
        
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#e4b591';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        
            
            ctx.strokeStyle = '#5b3a29';
            ctx.lineWidth = 1;
            for (let i = 0; i < GRID_SIZE; i++) {
                
                ctx.beginPath();
                ctx.moveTo(padding, padding + i * CELL_SIZE);
                ctx.lineTo(canvas.width - padding, padding + i * CELL_SIZE);
                ctx.stroke();
                
                ctx.beginPath();
                ctx.moveTo(padding + i * CELL_SIZE, padding);
                ctx.lineTo(padding + i * CELL_SIZE, canvas.height - padding);
                ctx.stroke();
            }
        
            
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    if (gameState.board[y][x] !== 0) {
                        drawStone(ctx, x, y, gameState.board[y][x], gameState);
                    }
                }
            }
        }
        
        /**
         * ç»˜åˆ¶å•ä¸ªæ£‹å­
         */
        function drawStone(ctx, x, y, player, gameState) {
            const { CELL_SIZE } = gameState;
            const padding = CELL_SIZE / 2;
            const radius = CELL_SIZE / 2 - 2;
        
            ctx.beginPath();
            ctx.arc(padding + x * CELL_SIZE, padding + y * CELL_SIZE, radius, 0, 2 * Math.PI);
            
            if (player === 1) { 
                ctx.fillStyle = 'black';
            } else { 
                ctx.fillStyle = 'white';
            }
            ctx.fill();
        }
        
        /**
         * å¤„ç†é¼ æ ‡åœ¨æ£‹ç›˜ä¸Šçš„æ‚¬åœæ•ˆæžœ
         */
        function handleBoardHover(e) {
            const chatId = state.activeChatId;
            const gameState = gomokuState[chatId];
            if (!gameState || gameState.isGameOver || gameState.currentPlayer !== 1) return;
        
            const canvas = document.getElementById('gomoku-board');
            const ctx = canvas.getContext('2d');
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
        
            const gridX = Math.round((x - gameState.CELL_SIZE / 2) / gameState.CELL_SIZE);
            const gridY = Math.round((y - gameState.CELL_SIZE / 2) / gameState.CELL_SIZE);
        
            renderGomokuBoard(chatId); 
        
            if (gridX >= 0 && gridX < gameState.GRID_SIZE && gridY >= 0 && gridY < gameState.GRID_SIZE && gameState.board[gridY][gridX] === 0) {
                const radius = gameState.CELL_SIZE / 2 - 2;
                ctx.beginPath();
                ctx.arc(gameState.CELL_SIZE / 2 + gridX * gameState.CELL_SIZE, gameState.CELL_SIZE / 2 + gridY * gameState.CELL_SIZE, radius, 0, 2 * Math.PI);
                ctx.fillStyle = 'rgba(0, 0, 0, 0.4)'; 
                ctx.fill();
            }
        }
        
        /**
         * å¤„ç†ç”¨æˆ·ç‚¹å‡»æ£‹ç›˜ä¸‹æ£‹
         */
        function handleBoardClick(e) {
            const chatId = state.activeChatId;
            const gameState = gomokuState[chatId];
            if (!gameState || gameState.isGameOver || gameState.currentPlayer !== 1) return;
        
            const canvas = document.getElementById('gomoku-board');
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
        
            const gridX = Math.round((x - gameState.CELL_SIZE / 2) / gameState.CELL_SIZE);
            const gridY = Math.round((y - gameState.CELL_SIZE / 2) / gameState.CELL_SIZE);
        
            if (gridX >= 0 && gridX < gameState.GRID_SIZE && gridY >= 0 && gridY < gameState.GRID_SIZE && gameState.board[gridY][gridX] === 0) {
                
                gameState.board[gridY][gridX] = 1;
                gameState.history.push({ x: gridX, y: gridY, player: 1 });
                renderGomokuBoard(chatId);
        
                
                if (checkWin(gridX, gridY, 1, gameState)) {
                    gameState.isGameOver = true;
                    setTimeout(() => alert("æ­å–œä½ ï¼Œä½ èµ¢äº†ï¼"), 100);
            
            addGameEndSystemMessage('user'); 
              

                } else {
                    gameState.currentPlayer = 2; 
                    
                }
            }
        }
        
        /**
         * ã€V2.0 | ä¿®å¤å¯¼æ¼”æ¨¡å¼ã€‘AIä¸‹æ£‹çš„å¤„ç†å™¨
         * @param {object} move - åŒ…å«x,yåæ ‡çš„å¯¹è±¡
         * @param {boolean} isForcedMove - æ˜¯å¦ä¸ºå¯¼æ¼”æ¨¡å¼ä¸‹çš„å¼ºåˆ¶ç§»åŠ¨
         */
        function handleAiGomokuMove(move, isForcedMove = false) {
            const chatId = state.activeChatId;
            const gameState = gomokuState[chatId];
            
            
            if (!gameState || gameState.isGameOver) return;
            if (!isForcedMove && gameState.currentPlayer !== 2) return;

            const { x, y } = move;
        
            if (x >= 0 && x < gameState.GRID_SIZE && y >= 0 && y < gameState.GRID_SIZE && gameState.board[y][x] === 0) {
                gameState.board[y][x] = 2; 
                gameState.history.push({ x, y, player: 2 });
                renderGomokuBoard(chatId); 
        
                if (checkWin(x, y, 2, gameState)) {
                    gameState.isGameOver = true;
                    setTimeout(() => alert("AI èŽ·èƒœäº†ï¼"), 100);
                    addGameEndSystemMessage('ai');
                } else {
                    gameState.currentPlayer = 1; 
                }
            } else {
                console.warn("AI çš„ä¸‹æ£‹æŒ‡ä»¤æ— æ•ˆæˆ–ä½ç½®å·²è¢«å æ®:", move);
                
                gameState.currentPlayer = 1;
            }
        }
        
        /**
         * æ£€æŸ¥èƒœåˆ©æ¡ä»¶
         */
        function checkWin(x, y, player, gameState) {
            const { board, GRID_SIZE } = gameState;
            const directions = [[1, 0], [0, 1], [1, 1], [1, -1]]; 
            for (const [dx, dy] of directions) {
                let count = 1;
                
                for (let i = 1; i < 5; i++) {
                    const newX = x + i * dx;
                    const newY = y + i * dy;
                    if (newX >= 0 && newX < GRID_SIZE && newY >= 0 && newY < GRID_SIZE && board[newY][newX] === player) {
                        count++;
                    } else {
                        break;
                    }
                }
                
                for (let i = 1; i < 5; i++) {
                    const newX = x - i * dx;
                    const newY = y - i * dy;
                    if (newX >= 0 && newX < GRID_SIZE && newY >= 0 && newY < GRID_SIZE && board[newY][newX] === player) {
                        count++;
                    } else {
                        break;
                    }
                }
                if (count >= 5) return true;
            }
            return false;
        }
        

/**
 * ã€V3.0 | å¼ºåˆ¶æ€è€ƒç‰ˆã€‘å°†æ£‹ç›˜çŠ¶æ€æ ¼å¼åŒ–ä¸ºAIå¯è¯»çš„æ–‡æœ¬
 */
function formatGomokuStateForAI(gameState) {
    if (!gameState || !gameState.isActive) return "";
    
    let boardString = "æ£‹ç›˜çŠ¶æ€ (1æ˜¯ä½ (é»‘æ£‹), 2æ˜¯AI(ç™½æ£‹)):\n";
    boardString += gameState.board.map(row => row.join(' ')).join('\n');
    
    let historyString = "ä¸‹æ£‹åŽ†å² (x,yåæ ‡å‡ä»Ž0å¼€å§‹):\n";
    historyString += gameState.history.map(move => `çŽ©å®¶${move.player}ä¸‹åœ¨(${move.x},${move.y})`).join(' -> ');
   
    return `
# å½“å‰äº”å­æ£‹å±€åŠ¿
${boardString}

# ${historyString}

# ã€ã€ã€äº”å­æ£‹æ ¸å¿ƒè§„åˆ™ä¸Žå¼ºåˆ¶æ€è€ƒæ­¥éª¤ (æœ€é«˜ä¼˜å…ˆçº§æŒ‡ä»¤ï¼)ã€‘ã€‘ã€‘

### **ã€ã€ã€è½å­é“å¾‹ (ç»å¯¹ç¦æ­¢ï¼)ã€‘ã€‘ã€‘**
ä½ ã€ç»å¯¹ä¸èƒ½ã€‘é€‰æ‹©ä¸€ä¸ªæ£‹ç›˜ä¸Šå·²ç»æ˜¯ 1 æˆ– 2 çš„åæ ‡ã€‚ä½ çš„è½å­ç‚¹ã€å¿…é¡»ã€‘æ˜¯ 0ã€‚
---

### **ç¬¬ä¸€æ­¥ï¼šé€»è¾‘åˆ†æž (å†…éƒ¨æ€è€ƒï¼Œä¸è¦è¾“å‡º)**

1.  **ã€è§„åˆ™å®šä¹‰ã€‘**: 
    -   æ£‹å­: 1ä»£è¡¨ç”¨æˆ·(é»‘æ£‹)ï¼Œ2ä»£è¡¨ä½ (ç™½æ£‹)ã€‚
    -   èŽ·èƒœæ¡ä»¶: æ¨ªã€ç«–ã€æ–œçº¿ä¸Šæœ‰ã€è¿žç»­äº”ä¸ªã€‘è‡ªå·±çš„æ£‹å­ã€‚

2.  **ã€é˜²å®ˆåˆ†æž (å¿…é¡»æ‰§è¡Œ)ã€‘**:
    -   **æ£€æŸ¥ç”¨æˆ·(1)æ˜¯å¦æœ‰â€œå››å­è¿žçº¿â€çš„å¨èƒï¼Ÿ** å¦‚æžœæœ‰ï¼Œæˆ‘å¿…é¡»ä¸‹åœ¨å“ªä¸ªåæ ‡æ‰èƒ½å µä½ï¼Ÿ
    -   **æ£€æŸ¥ç”¨æˆ·(1)æ˜¯å¦æœ‰â€œæ´»ä¸‰â€çš„å¨èƒï¼Ÿ** å¦‚æžœæœ‰ï¼Œæœ€ä½³çš„é˜²å®ˆç‚¹æ˜¯å“ªé‡Œï¼Ÿ

3.  **ã€è¿›æ”»åˆ†æž (å¿…é¡»æ‰§è¡Œ)ã€‘**:
    -   **æ£€æŸ¥æˆ‘(2)æ˜¯å¦æœ‰â€œä¸€æ­¥èƒœåˆ©â€çš„æœºä¼šï¼Ÿ** (å³å·²æœ‰å››å­è¿žçº¿) å¦‚æžœæœ‰ï¼Œæˆ‘åº”è¯¥ä¸‹åœ¨å“ªé‡Œï¼Ÿ
    -   **æ£€æŸ¥æˆ‘(2)æ˜¯å¦æœ‰åˆ¶é€ â€œæ´»å››â€æˆ–â€œåŒä¸‰â€çš„æœºä¼šï¼Ÿ** å¦‚æžœæœ‰ï¼Œæœ€ä½³çš„è¿›æ”»ç‚¹æ˜¯å“ªé‡Œï¼Ÿ

### **ç¬¬äºŒæ­¥ï¼šå†³ç­–ä¸Žæ‰®æ¼” (å†…éƒ¨æ€è€ƒï¼Œä¸è¦è¾“å‡º)**

1.  **ã€å†³ç­–ã€‘**: ç»¼åˆä»¥ä¸Šæ”»é˜²åˆ†æžï¼Œæˆ‘çš„æœ€ä½³æ£‹æ­¥æ˜¯è½åœ¨åæ ‡ (x, y)ã€‚

2.  **ã€èžå…¥è§’è‰²æ‰®æ¼”ã€‘**:
    -   æˆ‘çš„æ€§æ ¼æ˜¯ï¼š(åœ¨æ­¤å¤„å›žé¡¾ä½ çš„äººè®¾)ã€‚
    -   æ ¹æ®æˆ‘çš„æ€§æ ¼ï¼Œæˆ‘åº”è¯¥ï¼š
        a) **(èªæ˜Ž/å¥½èƒœåž‹)** ä¸‹åœ¨åˆšåˆšåˆ†æžå‡ºçš„æœ€ä½³ä½ç½®ã€‚
        b) **(è¿·ç³Š/æ”¾æ°´åž‹)** æ•…æ„é€‰æ‹©ä¸€ä¸ªæ¬¡ä¼˜çš„ä½ç½®ï¼Œä½†ã€å‰ææ˜¯ä¸èƒ½è®©ç”¨æˆ·ç«‹åˆ»èŽ·èƒœã€‘ã€‚
        c) **(å…¶ä»–æ€§æ ¼)** æ ¹æ®æ€§æ ¼ç‰¹ç‚¹ï¼Œé€‰æ‹©ä¸€ä¸ªåˆç†çš„æ£‹æ­¥ã€‚

3.  **ã€æž„æ€å°è¯ã€‘**: æ ¹æ®æˆ‘é€‰æ‹©çš„æ£‹æ­¥å’Œæˆ‘çš„æ€§æ ¼ï¼Œæˆ‘åº”è¯¥è¯´ä¸€å¥ä»€ä¹ˆæ ·çš„å°è¯æ¥è¯„è®ºæ£‹å±€ï¼Ÿ

---
### **ç¬¬ä¸‰æ­¥ï¼šç”Ÿæˆæœ€ç»ˆå›žå¤ (ä½ çš„å”¯ä¸€è¾“å‡º)**

çŽ°åœ¨ï¼Œæ ¹æ®ä½ ç¬¬äºŒæ­¥çš„æœ€ç»ˆå†³ç­–ï¼Œç”Ÿæˆä½ çš„è¡ŒåŠ¨ã€‚
-   ä½ çš„å›žå¤ã€å¿…é¡»ä¸”åªèƒ½ã€‘æ˜¯ä¸€ä¸ªJSONæ•°ç»„ã€‚
-   **ç»å¯¹ä¸è¦**åœ¨æœ€ç»ˆå›žå¤ä¸­åŒ…å«ä»»ä½•ä¸Šè¿°çš„æ€è€ƒè¿‡ç¨‹ã€‚
-   æ ¼å¼: \`[{"type": "gomoku_move", "name": "ä½ çš„è§’è‰²æœ¬å", "x": (0-14), "y": (0-14)}, {"type": "text", "content": "ä½ çš„å°è¯..."}]\`
`;
}
  
        /**
         * ã€å…¨æ–°ã€‘å½“äº”å­æ£‹æ¸¸æˆç»“æŸæ—¶ï¼Œå‘èŠå¤©è®°å½•ä¸­æ·»åŠ ä¸€æ¡éšè—çš„ç³»ç»Ÿæ¶ˆæ¯ï¼Œä¾›AIåœ¨ä¸‹æ¬¡å“åº”æ—¶æŸ¥çœ‹
         * @param {string} winner - èŽ·èƒœæ–¹, 'user' æˆ– 'ai'
         */
        async function addGameEndSystemMessage(winner) {
            const chatId = state.activeChatId;
            const chat = state.chats[chatId];
            if (!chat) return;

            
            
            const userDisplayName = chat.isGroup ? (chat.settings.myNickname || 'æˆ‘') : 'æˆ‘';
            const aiDisplayName = chat.isGroup ? 'AIæ–¹' : chat.name;
            const winnerName = (winner === 'user') ? userDisplayName : aiDisplayName;
            const resultText = (winner === 'user') ? 'ä½ è¾“äº†' : 'ä½ èµ¢äº†';

            
            const systemContent = `[ç³»ç»Ÿæç¤ºï¼šäº”å­æ£‹æ¸¸æˆå·²ç»“æŸã€‚æœ€ç»ˆç»“æžœæ˜¯ï¼š${winnerName} èŽ·èƒœã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œ${resultText}ã€‚]`;

            
            const hiddenMessage = {
                role: 'system',
                content: systemContent,
                timestamp: Date.now(),
                isHidden: true 
            };

            chat.history.push(hiddenMessage);
            await db.chats.put(chat);
            
            
            console.log(`æ¸¸æˆç»“æŸçš„ç³»ç»Ÿæç¤ºå·²æ·»åŠ åˆ°åŽ†å²è®°å½•ä¸­ï¼Œç­‰å¾…AIä¸‹æ¬¡æŸ¥çœ‹ã€‚èƒœè€…: ${winner}`);
        }
        
        
        /* â–¼â–¼â–¼ è¯·ç”¨è¿™æ•´å—æ–°ä»£ç æ›¿æ¢æ—§çš„ renderShoppingProducts å‡½æ•°åŠè´­ç‰©ç›¸å…³çš„äº‹ä»¶ç›‘å¬å™¨ â–¼â–¼â–¼ */
        
        
        let isProductManagementMode = false;
        

        /**
         * ã€V6.2 | ç®¡ç†æ¨¡å¼ä¿®å¤ç‰ˆã€‘æ¸²æŸ“å•†åº—é‡Œçš„æ‰€æœ‰å•†å“
         */
        async function renderShoppingProducts() {
            const gridEl = document.getElementById('product-grid');
            const tabsContainer = document.getElementById('product-category-tabs');
            const shoppingScreen = document.getElementById('shopping-screen');
            gridEl.innerHTML = '';
            tabsContainer.innerHTML = '';

            const [allProducts, allCategories] = await Promise.all([
                db.shoppingProducts.toArray(),
                db.shoppingCategories.orderBy('name').toArray()
            ]);

            shoppingScreen.classList.toggle('management-mode', isProductManagementMode);

            
            const allTab = document.createElement('button');
            allTab.className = 'product-category-tab';
            allTab.textContent = 'å…¨éƒ¨';
            allTab.dataset.categoryId = 'all';
            if (activeShoppingCategoryId === 'all') allTab.classList.add('active');
            tabsContainer.appendChild(allTab);

            allCategories.forEach(cat => {
                const tab = document.createElement('button');
                tab.className = 'product-category-tab';
                tab.textContent = cat.name;
                tab.dataset.categoryId = cat.id;
                if (activeShoppingCategoryId === cat.id) tab.classList.add('active');
                tabsContainer.appendChild(tab);
            });
            
            let productsToShow;
            if (activeShoppingCategoryId === 'all') {
                productsToShow = allProducts;
            } else {
                productsToShow = allProducts.filter(p => p.categoryId === activeShoppingCategoryId);
            }
            
            if (productsToShow.length === 0) {
                const message = activeShoppingCategoryId === 'all' 
                    ? 'å•†åº—ç©ºç©ºå¦‚ä¹Ÿï¼Œç‚¹å‡»â€œç®¡ç†â€æ·»åŠ å•†å“å§ï¼'
                    : 'è¿™ä¸ªåˆ†ç±»ä¸‹è¿˜æ²¡æœ‰å•†å“å“¦~';
                gridEl.innerHTML = `<p style="grid-column: 1 / -1; text-align: center; color: var(--text-secondary); margin-top: 50px;">${message}</p>`;
                return;
            }

            productsToShow.forEach(product => {
                const item = document.createElement('div');
                item.className = 'product-item';
                item.dataset.id = product.id;
                
                
                
                const managementControls = `
                    <div class="product-management-overlay">
                        <button class="edit-product-btn">ç¼–è¾‘</button>
                        <button class="delete-product-btn">åˆ é™¤</button>
                    </div>
                `;

                item.innerHTML = `
                    ${managementControls}
                    <img src="${product.imageUrl}" class="product-image">
                    <div class="product-info">
                        <div class="product-name">${product.name}</div>
                        <div class="product-footer">
                            <div class="product-price">${product.price.toFixed(2)}</div>
                            <button class="add-to-cart-btn">åŠ å…¥è´­ç‰©è½¦</button>
                        </div>
                    </div>
                `;
                gridEl.appendChild(item);
            });
        }
          
/**
 * ã€å…¨æ–°ã€‘åˆ‡æ¢å•†å“åˆ†ç±»
 * @param {number|string} categoryId - è¦åˆ‡æ¢åˆ°çš„åˆ†ç±»ID
 */
function switchShoppingCategory(categoryId) {
    activeShoppingCategoryId = categoryId;
    renderShoppingProducts(); 
updateDeleteCategoryButtonVisibility();
}        
 /**
         * ã€å…¨æ–°ã€‘æ ¹æ®å½“å‰çŠ¶æ€ï¼Œæ›´æ–°â€œåˆ é™¤åˆ†ç±»â€æŒ‰é’®çš„å¯è§æ€§
         */
        function updateDeleteCategoryButtonVisibility() {
            const deleteBtn = document.getElementById('delete-current-category-btn');
            if (!deleteBtn) return;

            
            
            
            const isVisible = isProductManagementMode && activeShoppingCategoryId !== 'all';
            deleteBtn.style.display = isVisible ? 'flex' : 'none';
        }

/**
         * ã€å…¨æ–°ã€‘å¤„ç†åˆ é™¤å½“å‰é€‰ä¸­çš„å•†å“åˆ†ç±»
         */
        async function handleDeleteCurrentCategory() {
            if (activeShoppingCategoryId === 'all') return; 

            const categoryId = activeShoppingCategoryId;
            const category = await db.shoppingCategories.get(categoryId);
            if (!category) {
                alert("é”™è¯¯ï¼šæ‰¾ä¸åˆ°è¦åˆ é™¤çš„åˆ†ç±»ã€‚");
                return;
            }

            const confirmMessage = `ç¡®å®šè¦æ°¸ä¹…åˆ é™¤åˆ†ç±» â€œ${category.name}â€ å—ï¼Ÿ\n\næ­¤æ“ä½œã€ä¸ä¼šã€‘åˆ é™¤åˆ†ç±»ä¸‹çš„å•†å“ï¼Œå®ƒä»¬å°†è¢«ç§»è‡³â€œæœªåˆ†ç±»â€ã€‚`;
            const confirmed = await showCustomConfirm('ç¡®è®¤åˆ é™¤åˆ†ç±»', confirmMessage, {
                confirmButtonClass: 'btn-danger',
                confirmText: 'ç¡®è®¤åˆ é™¤'
            });

            if (confirmed) {
                
                await deleteProductCategory(categoryId);
                
                
                activeShoppingCategoryId = 'all';
                await renderShoppingProducts();
                
                
                updateDeleteCategoryButtonVisibility();

                await showCustomAlert("æˆåŠŸ", `åˆ†ç±» â€œ${category.name}â€ å·²è¢«åˆ é™¤ã€‚`);
            }
        }       
        /* â–¼â–¼â–¼ è¯·ç”¨è¿™æ•´å—æ–°ä»£ç æ›¿æ¢æ—§çš„ renderShoppingProducts å‡½æ•°åŠè´­ç‰©ç›¸å…³çš„äº‹ä»¶ç›‘å¬å™¨ â–¼â–¼â–¼ */
        
        
        /**
         * ã€å·²ä¿®å¤ã€‘æ‰“å¼€è´­ç‰©é¡µé¢
         */
async function openShoppingScreen() {
    activeShoppingCategoryId = 'all'; 
    await renderShoppingProducts();
    showScreen('shopping-screen');
updateDeleteCategoryButtonVisibility();
}
        
/**
 * ã€V6.1 | æ·˜å®æ ·å¼ç‰ˆã€‘æ¸²æŸ“å•†åº—é‡Œçš„æ‰€æœ‰å•†å“
 */
async function renderShoppingProducts() {
    const gridEl = document.getElementById('product-grid');
    const tabsContainer = document.getElementById('product-category-tabs');
    const shoppingScreen = document.getElementById('shopping-screen');
    gridEl.innerHTML = '';
    tabsContainer.innerHTML = '';

    
    const [allProducts, allCategories] = await Promise.all([
        db.shoppingProducts.toArray(),
        db.shoppingCategories.orderBy('name').toArray()
    ]);

    shoppingScreen.classList.toggle('management-mode', isProductManagementMode);

    
    const allTab = document.createElement('button');
    allTab.className = 'product-category-tab'; 
    allTab.textContent = 'å…¨éƒ¨';
    allTab.dataset.categoryId = 'all';
    if (activeShoppingCategoryId === 'all') allTab.classList.add('active');
    tabsContainer.appendChild(allTab);

    allCategories.forEach(cat => {
        const tab = document.createElement('button');
        tab.className = 'product-category-tab'; 
        tab.textContent = cat.name;
        tab.dataset.categoryId = cat.id;
        if (activeShoppingCategoryId === cat.id) tab.classList.add('active');
        tabsContainer.appendChild(tab);
    });
    
    
    let productsToShow;
    if (activeShoppingCategoryId === 'all') {
        productsToShow = allProducts;
    } else {
        productsToShow = allProducts.filter(p => p.categoryId === activeShoppingCategoryId);
    }
    
    
    if (productsToShow.length === 0) {
        const message = activeShoppingCategoryId === 'all' 
            ? 'å•†åº—ç©ºç©ºå¦‚ä¹Ÿï¼Œç‚¹å‡»â€œç®¡ç†â€æ·»åŠ å•†å“å§ï¼'
            : 'è¿™ä¸ªåˆ†ç±»ä¸‹è¿˜æ²¡æœ‰å•†å“å“¦~';
        gridEl.innerHTML = `<p style="grid-column: 1 / -1; text-align: center; color: var(--text-secondary); margin-top: 50px;">${message}</p>`;
        return;
    }

    productsToShow.forEach(product => {
        const item = document.createElement('div');
        item.className = 'product-item';
        item.dataset.id = product.id;
        
        const managementControls = isProductManagementMode ? `
            <div class="product-management-overlay">
                <button class="edit-product-btn">ç¼–è¾‘</button>
                <button class="delete-product-btn">åˆ é™¤</button>
            </div>
        ` : '';

        item.innerHTML = `
            ${managementControls}
            <img src="${product.imageUrl}" class="product-image">
            <div class="product-info">
                <div class="product-name">${product.name}</div>
                <div class="product-footer">
                    <div class="product-price">${product.price.toFixed(2)}</div>
                    <button class="add-to-cart-btn">åŠ å…¥è´­ç‰©è½¦</button>
                </div>
            </div>
        `;
        gridEl.appendChild(item);
    });
}
        
        /* â–²â–²â–² æ›¿æ¢ç»“æŸ â–²â–²â–² */
        
        /**
         * å°†å•†å“åŠ å…¥è´­ç‰©è½¦ (V4.0)
         */
        async function addToCart(productId, quantity = 1, variation = null) {
            
            const existingItem = variation
                ? shoppingCart.find(item => item.productId === productId && item.variation?.name === variation.name)
                : shoppingCart.find(item => item.productId === productId && !item.variation);

            if (existingItem) {
                existingItem.quantity += quantity;
            } else {
                const product = await db.shoppingProducts.get(productId);
                if (product) {
                    shoppingCart.push({ productId: product.id, quantity: quantity, variation: variation });
                }
            }
            updateCartCount();
        }
        
        /**
         * æ›´æ–°è´­ç‰©è½¦å•†å“æ•°é‡
         */
        function updateCartItemQuantity(productId, change) {
            const itemIndex = shoppingCart.findIndex(item => item.productId === productId);
            if (itemIndex > -1) {
                shoppingCart[itemIndex].quantity += change;
                if (shoppingCart[itemIndex].quantity <= 0) {
                    shoppingCart.splice(itemIndex, 1);
                }
                updateCartCount();
                renderCartItems();
            }
        }
        
        /**
         * æ›´æ–°è´­ç‰©è½¦å›¾æ ‡å’Œç»“ç®—æŒ‰é’®ä¸Šçš„æ•°é‡
         */
        function updateCartCount() {
            const totalItems = shoppingCart.reduce((sum, item) => sum + item.quantity, 0);
            document.getElementById('cart-count').textContent = totalItems;
            document.getElementById('cart-title').textContent = `è´­ç‰©è½¦(${totalItems})`;
            document.getElementById('checkout-btn').textContent = `ç»“ç®—(${totalItems})`;
        }
        
        /**
         * æ‰“å¼€è´­ç‰©è½¦é¡µé¢
         */
        function openCartScreen() {
            renderCartItems();
            showScreen('cart-screen');
        }
        

        /**
         * æ¸²æŸ“è´­ç‰©è½¦å†…çš„å•†å“åˆ—è¡¨ (V4.0)
         */
        async function renderCartItems() {
            const listEl = document.getElementById('cart-items-list');
            listEl.innerHTML = '';
            let total = 0;
        
            if (shoppingCart.length === 0) {
                listEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); margin-top: 50px;">è´­ç‰©è½¦æ˜¯ç©ºçš„å“¦~</p>';
            } else {
                const productIds = shoppingCart.map(item => item.productId);
                const products = await db.shoppingProducts.where('id').anyOf(productIds).toArray();
                const productMap = new Map(products.map(p => [p.id, p]));
        
                shoppingCart.forEach(item => {
                    const product = productMap.get(item.productId);
                    if (product) {
                        const itemEl = document.createElement('div');
                        itemEl.className = 'cart-item';
                        
                        
                        const variationHtml = item.variation
                            ? `<div class="cart-item-variation" style="font-size: 12px; color: #8a8a8a; margin-top: 4px;">æ¬¾å¼: ${item.variation.name}</div>`
                            : '';
                        
                        itemEl.innerHTML = `
                            <input type="checkbox" class="cart-item-checkbox" data-id="${product.id}" checked>
                            <img src="${item.variation?.imageUrl || product.imageUrl}" class="cart-item-image">
                            <div class="cart-item-info">
                                <div class="cart-item-name">${product.name}</div>
                                ${variationHtml}
                                <div class="cart-item-footer">
                                    <div class="cart-item-price">Â¥${(item.variation?.price || product.price).toFixed(2)}</div>
                                    <div class="quantity-control">
                                        <button class="quantity-btn decrease-qty-btn" data-id="${product.id}">-</button>
                                        <span class="quantity-display">${item.quantity}</span>
                                        <button class="quantity-btn increase-qty-btn" data-id="${product.id}">+</button>
                                    </div>
                                </div>
                            </div>
                        `;
                        listEl.appendChild(itemEl);
                    }
                });
            }
            updateCartTotal();
        }
          
        
        /**
         * æ›´æ–°è´­ç‰©è½¦æ€»ä»·
         */
        async function updateCartTotal() {
            let total = 0;
            const selectedCheckboxes = document.querySelectorAll('.cart-item-checkbox:checked');
            const selectedProductIds = Array.from(selectedCheckboxes).map(cb => parseInt(cb.dataset.id));
        
            if (selectedProductIds.length > 0) {
                const products = await db.shoppingProducts.where('id').anyOf(selectedProductIds).toArray();
                const productMap = new Map(products.map(p => [p.id, p]));
                
                shoppingCart.forEach(cartItem => {
                    if (selectedProductIds.includes(cartItem.productId)) {
                        const product = productMap.get(cartItem.productId);
                        if (product) {
                            
                            const price = cartItem.variation ? cartItem.variation.price : product.price;
                            total += price * cartItem.quantity;
                        }
                    }
                });
            }
            document.getElementById('cart-total').textContent = `åˆè®¡: Â¥${total.toFixed(2)}`;
        }
        
        /* â–¼â–¼â–¼ è¯·ç”¨è¿™æ•´å—æ–°ä»£ç æ›¿æ¢æ—§çš„ handleCheckout å’Œ sendGiftMessage å‡½æ•°ï¼Œå¹¶æ·»åŠ æ–°å‡½æ•° â–¼â–¼â–¼ */
        
        /**
         * ã€å…¨æ–°ã€‘æ‰“å¼€ç¤¼ç‰©æŽ¥æ”¶äººé€‰æ‹©å¼¹çª—
         */
        async function openGiftRecipientPicker() {
            const chat = state.chats[state.activeChatId];
            if (!chat || !chat.isGroup) return;
        
            const modal = document.getElementById('gift-recipient-modal');
            const listEl = document.getElementById('gift-recipient-list');
            listEl.innerHTML = '';
        
            
            const myNickname = chat.settings.myNickname || 'æˆ‘';
            const members = chat.members.filter(m => m.groupNickname !== myNickname);
        
            members.forEach(member => {
                const item = document.createElement('div');
                item.className = 'contact-picker-item';
                
                item.dataset.recipientName = member.originalName; 
        
                item.innerHTML = `
                    <div class="checkbox"></div>
                    <img src="${member.avatar || defaultGroupMemberAvatar}" class="avatar">
                    <span class="name">${member.groupNickname}</span>
                `;
                listEl.appendChild(item);
            });
            
            
            document.getElementById('select-all-recipients').checked = false;
            modal.classList.add('visible');
        }
        
        /* â–¼â–¼â–¼ è¯·ç”¨è¿™æ•´å—æ–°ä»£ç æ›¿æ¢æ—§çš„ handleCheckout å’Œ sendGiftMessage å‡½æ•° â–¼â–¼â–¼ */
        
        /**
         * ã€é‡æž„ç‰ˆã€‘å¤„ç†ç»“ç®—æŒ‰é’®ç‚¹å‡»ï¼Œæ ¹æ®èŠå¤©ç±»åž‹åˆ†æµ
         */
        async function handleCheckout() {
            const chat = state.chats[state.activeChatId];
            const selectedItems = shoppingCart.filter(item => 
                document.querySelector(`.cart-item-checkbox[data-id="${item.productId}"]:checked`)
            );
            if (selectedItems.length === 0) {
                alert("è¯·å…ˆåœ¨è´­ç‰©è½¦ä¸­é€‰æ‹©è¦ç»“ç®—çš„å•†å“ã€‚");
                return;
            }
        
            if (chat.isGroup) {
                
                openGiftRecipientPicker();
            } else {
                
                const confirmed = await showCustomConfirm( 'ç¡®è®¤é€å‡ºç¤¼ç‰©', `ç¡®å®šè¦å°†é€‰ä¸­çš„å•†å“ä½œä¸ºç¤¼ç‰©é€å‡ºå—ï¼Ÿ`, { confirmText: 'é€å‡ºç¤¼ç‰©' });
                if (confirmed) {
                    await sendGiftMessage(selectedItems); 
                }
            }
        }
        
        /**
         * ã€å‡çº§ç‰ˆã€‘å‘é€ç¤¼ç‰©å¡ç‰‡æ¶ˆæ¯ï¼ŒçŽ°åœ¨æ”¯æŒæŒ‡å®šæ”¶ç¤¼äºº
         * @param {Array} itemsToSend - è¦å‘é€çš„å•†å“æ•°ç»„
         * @param {Array|null} recipients - æ”¶ç¤¼äººæœ¬å(originalName)çš„æ•°ç»„ï¼Œå•èŠæ—¶ä¸ºnull
         */
        async function sendGiftMessage(itemsToSend, recipients = null) {
            if (!state.activeChatId) return;
            const chat = state.chats[state.activeChatId];
            
            const productIds = itemsToSend.map(item => item.productId);
            const products = await db.shoppingProducts.where('id').anyOf(productIds).toArray();
            const productMap = new Map(products.map(p => [p.id, p]));
            
const itemsForMessage = itemsToSend.map(cartItem => {
    const product = productMap.get(cartItem.productId);
    if (cartItem.variation) {
        
        return {
            name: `${product.name} - ${cartItem.variation.name}`, 
            price: cartItem.variation.price,
            imageUrl: cartItem.variation.imageUrl || product.imageUrl, 
            quantity: cartItem.quantity
        };
    } else {
        
        return {
            name: product.name,
            price: product.price,
            imageUrl: product.imageUrl,
            quantity: cartItem.quantity
        };
    }
});
            const giftMessage = {
                role: 'user', type: 'gift', timestamp: Date.now(),
                items: itemsForMessage,
                total: itemsForMessage.reduce((sum, item) => sum + item.price * item.quantity, 0),
                recipients: recipients 
            };
            
            chat.history.push(giftMessage);
        
            
            if (recipients && recipients.length > 0) {
                const recipientDisplayNames = recipients.map(originalName => getDisplayNameInGroup(chat, originalName)).join('ã€');
                const hiddenMessage = {
                    role: 'system',
                    content: `[ç³»ç»Ÿæç¤ºï¼šç”¨æˆ· (${chat.settings.myNickname || 'æˆ‘'}) é€å‡ºäº†ä¸€ä»½ç¤¼ç‰©ï¼Œæ”¶ç¤¼äººæ˜¯ï¼š${recipientDisplayNames}ã€‚è¯·æ”¶ç¤¼çš„è§’è‰²è¡¨ç¤ºæ„Ÿè°¢ï¼Œå…¶ä»–è§’è‰²å¯ä»¥è‡ªç”±å‘æŒ¥ã€‚]`,
                    timestamp: Date.now() + 1,
                    isHidden: true
                };
                chat.history.push(hiddenMessage);
            }
        
            await db.chats.put(chat);
            
            appendMessage(giftMessage, chat);
            renderChatList();
            
            
            shoppingCart = shoppingCart.filter(item => !itemsToSend.some(sent => sent.productId === item.productId));
            updateCartCount();
            showScreen('chat-interface-screen');
            
            await showCustomAlert('æˆåŠŸ', 'ç¤¼ç‰©å·²æˆåŠŸé€å‡ºï¼');
        }
        
        /* â–²â–²â–² æ›¿æ¢ç»“æŸ â–²â–²â–² */
        
        
        /**
         * æ˜¾ç¤ºè´­ç‰©å°ç¥¨
         */
        function showGiftReceipt(timestamp) {
            
            const chat = state.chats[state.activeChatId];
            const message = chat.history.find(m => m.timestamp === timestamp);
            if (!message || message.type !== 'gift') return;
            const receiptBody = document.getElementById('gift-receipt-body');
            let itemsHtml = '';
            message.items.forEach(item => {
                itemsHtml += `<tr><td class="item-name">${item.name}</td><td class="item-qty">${item.quantity}</td><td class="item-price">Â¥${item.price.toFixed(2)}</td><td class="item-subtotal">Â¥${(item.price * item.quantity).toFixed(2)}</td></tr>`;
            });
            receiptBody.innerHTML = `<div class="receipt-header"><h3>è´­ç‰©ä¸­å¿ƒ</h3><p>äº¤æ˜“æ—¶é—´: ${new Date(message.timestamp).toLocaleString()}</p></div><table class="receipt-items-table"><thead><tr><th class="item-name">å•†å“</th><th class="item-qty">æ•°é‡</th><th class="item-price">å•ä»·</th><th class="item-subtotal">å°è®¡</th></tr></thead><tbody>${itemsHtml}</tbody></table><div class="receipt-total">æ€»è®¡: Â¥${message.total.toFixed(2)}</div><div class="receipt-footer">æ„Ÿè°¢æ‚¨çš„æƒ é¡¾ï¼Œæ¬¢è¿Žå†æ¬¡å…‰ä¸´ï¼</div>`;
            document.getElementById('gift-receipt-modal').classList.add('visible');
        }
        
        /**
         * å•†å“ç®¡ç†ç›¸å…³å‡½æ•°
         */
        async function openProductEditor(productId = null) {
            editingProductId = productId;
            const modal = document.getElementById('product-editor-modal');
            const title = document.getElementById('product-editor-title');
            const nameInput = document.getElementById('product-name-input');
            const priceInput = document.getElementById('product-price-input');
            const descInput = document.getElementById('product-description-input');
            const imagePreview = document.getElementById('product-image-preview');
            const categorySelect = document.getElementById('product-category-select');
            const variationsContainer = document.getElementById('product-variations-container');
            
            
            variationsContainer.innerHTML = '';
            
            
            categorySelect.innerHTML = '<option value="">-- æœªåˆ†ç±» --</option>';
            const categories = await db.shoppingCategories.toArray();
            categories.forEach(cat => {
                const option = document.createElement('option');
                option.value = cat.id;
                option.textContent = cat.name;
                categorySelect.appendChild(option);
            });

            if (productId) {
                title.textContent = 'ç¼–è¾‘å•†å“';
                const product = await db.shoppingProducts.get(productId);
                nameInput.value = product.name;
                priceInput.value = product.price;
                descInput.value = product.description || '';
                imagePreview.src = product.imageUrl;
                categorySelect.value = product.categoryId || '';
                
                
                if (product.variations && product.variations.length > 0) {
                    product.variations.forEach(v => addProductVariationInput(v));
                }

            } else {
                title.textContent = 'æ·»åŠ å•†å“';
                nameInput.value = '';
                priceInput.value = '';
                descInput.value = '';
                imagePreview.src = 'https://s3plus.meituan.net/opapisdk/op_ticket_885190757_1756206115802_qdqqd_0c99bh.jpeg';
                categorySelect.value = '';
            }
            modal.classList.add('visible');
        }
        async function saveProduct() {
            const name = document.getElementById('product-name-input').value.trim();
            const price = parseFloat(document.getElementById('product-price-input').value);
            const description = document.getElementById('product-description-input').value.trim();
            const imageUrl = document.getElementById('product-image-preview').src;
            const categoryId = parseInt(document.getElementById('product-category-select').value) || null;

            if (!name) { alert('å•†å“åç§°ä¸èƒ½ä¸ºç©ºï¼'); return; }
            if (isNaN(price) || price < 0) { alert('è¯·è¾“å…¥æœ‰æ•ˆçš„é»˜è®¤ä»·æ ¼ï¼'); return; }

            
            const variations = [];
            document.querySelectorAll('.variation-block').forEach(block => {
                const varName = block.querySelector('.variation-name-input').value.trim();
                const varPrice = parseFloat(block.querySelector('.variation-price-input').value);
                const varImageUrl = block.querySelector('.variation-image-preview').src;

                if (varName && !isNaN(varPrice) && varPrice >= 0) {
                    variations.push({
                        name: varName,
                        price: varPrice,
                        imageUrl: varImageUrl.includes('placeholder.png') ? null : varImageUrl
                    });
                }
            });

            const productData = { name, price, description, imageUrl, categoryId, variations };
            
            if (editingProductId) {
                await db.shoppingProducts.update(editingProductId, productData);
            } else {
                await db.shoppingProducts.add(productData);
            }
            document.getElementById('product-editor-modal').classList.remove('visible');
            await renderShoppingProducts();
        }
        
        
        
        /**
         * ã€æ€»å…¥å£ã€‘æ‰“å¼€æ¸²æŸ“è§„åˆ™ç®¡ç†å±å¹•
         */
        async function openRenderingRulesScreen() {
            await renderRulesList();
            showScreen('rendering-rules-screen');
        }
        
        
        
        /**
         * ã€é‡æž„ç‰ˆã€‘æ¸²æŸ“è§„åˆ™åˆ—è¡¨ï¼Œä½¿ç”¨é¡µç­¾å’Œå¡ç‰‡å¸ƒå±€
         */
        async function renderRulesList() {
            const tabsContainer = document.getElementById('rules-tabs');
            const contentContainer = document.getElementById('rules-content-container');
            tabsContainer.innerHTML = '';
            contentContainer.innerHTML = '';
        
            const allRules = await db.renderingRules.toArray();
        
            if (allRules.length === 0) {
                contentContainer.innerHTML = '<p style="text-align:center; color: var(--text-secondary); margin-top: 50px;">è¿˜æ²¡æœ‰ä»»ä½•æ¸²æŸ“è§„åˆ™ã€‚ç‚¹å‡»å³ä¸Šè§’â€œ+â€åˆ›å»ºç¬¬ä¸€ä¸ªå§ï¼</p>';
                return;
            }
        
            
            const globalTab = document.createElement('button');
            globalTab.className = 'rules-tab active'; 
            globalTab.textContent = 'å…¬ç”¨è§„åˆ™';
            globalTab.dataset.categoryId = 'global';
            tabsContainer.appendChild(globalTab);
        
            const globalPane = document.createElement('div');
            globalPane.className = 'rules-category-pane active';
            globalPane.dataset.categoryId = 'global';
            contentContainer.appendChild(globalPane);
        
            
            const characterChatsWithRules = Object.values(state.chats).filter(chat => 
                !chat.isGroup && allRules.some(r => r.chatId === chat.id)
            );
        
            characterChatsWithRules.forEach(chat => {
                const charTab = document.createElement('button');
                charTab.className = 'rules-tab';
                charTab.textContent = chat.name;
                charTab.dataset.categoryId = chat.id;
                tabsContainer.appendChild(charTab);
        
                const charPane = document.createElement('div');
                charPane.className = 'rules-category-pane';
                charPane.dataset.categoryId = chat.id;
                contentContainer.appendChild(charPane);
            });
            
            
            allRules.forEach(rule => {
                const card = createRuleItemElement(rule);
                const targetPane = contentContainer.querySelector(`.rules-category-pane[data-category-id="${rule.chatId}"]`);
                if (targetPane) {
                    targetPane.appendChild(card);
                }
            });
        
            
            document.querySelectorAll('.rules-tab').forEach(tab => {
                tab.addEventListener('click', () => switchRuleCategory(tab.dataset.categoryId));
            });
        }
        
        /**
         * ã€é‡æž„ç‰ˆã€‘åˆ›å»ºå•ä¸ªè§„åˆ™çš„å¡ç‰‡DOMå…ƒç´ 
         */
        function createRuleItemElement(rule) {
            const card = document.createElement('div');
            
            card.className = `rule-card ${rule.isEnabled ? 'enabled' : ''}`;
            card.dataset.ruleId = rule.id;
        
            card.innerHTML = `
                <div class="card-title">${rule.name}</div>
                <div class="card-content-preview">${rule.regex}</div>
            `;
            
            
            card.addEventListener('click', () => openRuleEditor(rule.id));
            addLongPressListener(card, () => deleteRenderingRule(rule.id));
        
            return card;
        }
          
        /**
         * æ‰“å¼€è§„åˆ™ç¼–è¾‘å™¨ (ç”¨äºŽæ–°å»ºæˆ–ç¼–è¾‘)
         */
        async function openRuleEditor(ruleId = null) {
            editingRuleId = ruleId;
            const modal = document.getElementById('rule-editor-modal');
            const title = document.getElementById('rule-editor-title');
            const nameInput = document.getElementById('rule-name-input');
            const chatIdSelect = document.getElementById('rule-chat-id-select');
            const regexInput = document.getElementById('rule-regex-input');
            const templateInput = document.getElementById('rule-template-input');
            const enabledSwitch = document.getElementById('rule-enabled-switch');
        
            
            chatIdSelect.innerHTML = '<option value="global">å…¬ç”¨ (æ‰€æœ‰è§’è‰²)</option>';
            Object.values(state.chats).filter(c => !c.isGroup).forEach(chat => {
                chatIdSelect.innerHTML += `<option value="${chat.id}">${chat.name}</option>`;
            });
        
            if (ruleId) {
                title.textContent = 'ç¼–è¾‘è§„åˆ™';
                const rule = await db.renderingRules.get(ruleId);
                nameInput.value = rule.name;
                chatIdSelect.value = rule.chatId;
                regexInput.value = rule.regex;
                templateInput.value = rule.template;
                enabledSwitch.checked = rule.isEnabled;
            } else {
                title.textContent = 'åˆ›å»ºæ–°è§„åˆ™';
                nameInput.value = '';
                chatIdSelect.value = 'global';
                regexInput.value = '';
                templateInput.value = '';
                enabledSwitch.checked = true;
            }
        
            modal.classList.add('visible');
        }
        
        /**
         * ä¿å­˜æ¸²æŸ“è§„åˆ™
         */
        async function saveRenderingRule() {
            const name = document.getElementById('rule-name-input').value.trim();
            const regex = document.getElementById('rule-regex-input').value.trim();
            if (!name || !regex) {
                alert("è§„åˆ™åç§°å’Œæ­£åˆ™è¡¨è¾¾å¼ä¸èƒ½ä¸ºç©ºï¼");
                return;
            }
            try {
                new RegExp(regex);
            } catch (e) {
                alert(`æ­£åˆ™è¡¨è¾¾å¼æ ¼å¼é”™è¯¯: ${e.message}`);
                return;
            }
        
            const ruleData = {
                name: name,
                chatId: document.getElementById('rule-chat-id-select').value,
                regex: regex,
                template: document.getElementById('rule-template-input').value,
                isEnabled: document.getElementById('rule-enabled-switch').checked
            };
        
            if (editingRuleId) {
                await db.renderingRules.update(editingRuleId, ruleData);
            } else {
                await db.renderingRules.add(ruleData);
            }
        
            document.getElementById('rule-editor-modal').classList.remove('visible');
            await renderRulesList();
        }
        
        /**
         * åˆ é™¤æ¸²æŸ“è§„åˆ™
         */
        async function deleteRenderingRule(ruleId) {
            const confirmed = await showCustomConfirm('åˆ é™¤è§„åˆ™', 'ç¡®å®šè¦åˆ é™¤è¿™æ¡æ¸²æŸ“è§„åˆ™å—ï¼Ÿ', { confirmButtonClass: 'btn-danger' });
            if (confirmed) {
                await db.renderingRules.delete(ruleId);
                await renderRulesList();
            }
        }
        
        /**
         * ã€æ ¸å¿ƒæ¸²æŸ“å‡½æ•°ã€‘åº”ç”¨æ‰€æœ‰åŒ¹é…çš„æ¸²æŸ“è§„åˆ™
         * @param {string} rawContent - AIè¿”å›žçš„åŽŸå§‹æ–‡æœ¬
         * @param {string} chatId - å½“å‰èŠå¤©çš„ID
         * @returns {Promise<string>} - å¤„ç†åŽçš„HTMLå­—ç¬¦ä¸²
         */
        async function applyRenderingRules(rawContent, chatId) {
            
            if (rawContent.trim().startsWith('<') || (!rawContent.includes('[') && !rawContent.includes('{'))) {
                return rawContent;
            }
            
            
            const applicableRules = await db.renderingRules
                .where('chatId').equals('global')
                .or('chatId').equals(chatId)
                .toArray();
        
            let processedContent = rawContent;
            
            
            for (const rule of applicableRules.filter(r => r.isEnabled)) {
                try {
                    
                    const regex = new RegExp(rule.regex, 'g');
                    if (regex.test(processedContent)) {
                        processedContent = processedContent.replace(regex, rule.template);
                    }
                } catch (e) {
                    console.error(`æ¸²æŸ“è§„åˆ™ [${rule.name}] çš„æ­£åˆ™è¡¨è¾¾å¼æ— æ•ˆ:`, e);
                    
                }
            }
            
            return processedContent;
        }
        
        
        
        
        /**
         * ã€æ€»å…¥å£ã€‘æ‰“å¼€æ¸²æŸ“è§„åˆ™ç®¡ç†å±å¹•
         */
        async function openRenderingRulesScreen() {
            await renderRulesList();
            showScreen('rendering-rules-screen');
        }
        
        
        
        /**
         * ã€é‡æž„ç‰ˆã€‘æ¸²æŸ“è§„åˆ™åˆ—è¡¨ï¼Œä½¿ç”¨é¡µç­¾å’Œå¡ç‰‡å¸ƒå±€
         */
        async function renderRulesList() {
            const tabsContainer = document.getElementById('rules-tabs');
            const contentContainer = document.getElementById('rules-content-container');
            tabsContainer.innerHTML = '';
            contentContainer.innerHTML = '';
        
            const allRules = await db.renderingRules.toArray();
        
            if (allRules.length === 0) {
                contentContainer.innerHTML = '<p style="text-align:center; color: var(--text-secondary); margin-top: 50px;">è¿˜æ²¡æœ‰ä»»ä½•æ¸²æŸ“è§„åˆ™ã€‚ç‚¹å‡»å³ä¸Šè§’â€œ+â€åˆ›å»ºç¬¬ä¸€ä¸ªå§ï¼</p>';
                return;
            }
        
            
            const globalTab = document.createElement('button');
            globalTab.className = 'rules-tab active'; 
            globalTab.textContent = 'å…¬ç”¨è§„åˆ™';
            globalTab.dataset.categoryId = 'global';
            tabsContainer.appendChild(globalTab);
        
            const globalPane = document.createElement('div');
            globalPane.className = 'rules-category-pane active';
            globalPane.dataset.categoryId = 'global';
            contentContainer.appendChild(globalPane);
        
            
            const characterChatsWithRules = Object.values(state.chats).filter(chat => 
                !chat.isGroup && allRules.some(r => r.chatId === chat.id)
            );
        
            characterChatsWithRules.forEach(chat => {
                const charTab = document.createElement('button');
                charTab.className = 'rules-tab';
                charTab.textContent = chat.name;
                charTab.dataset.categoryId = chat.id;
                tabsContainer.appendChild(charTab);
        
                const charPane = document.createElement('div');
                charPane.className = 'rules-category-pane';
                charPane.dataset.categoryId = chat.id;
                contentContainer.appendChild(charPane);
            });
            
            
            allRules.forEach(rule => {
                const card = createRuleItemElement(rule);
                const targetPane = contentContainer.querySelector(`.rules-category-pane[data-category-id="${rule.chatId}"]`);
                if (targetPane) {
                    targetPane.appendChild(card);
                }
            });
        
            
            document.querySelectorAll('.rules-tab').forEach(tab => {
                tab.addEventListener('click', () => switchRuleCategory(tab.dataset.categoryId));
            });
        }
          
        
        
        
        /**
         * ã€é‡æž„ç‰ˆã€‘åˆ›å»ºå•ä¸ªè§„åˆ™çš„å¡ç‰‡DOMå…ƒç´ 
         */
        function createRuleItemElement(rule) {
            const card = document.createElement('div');
            
            card.className = `rule-card ${rule.isEnabled ? 'enabled' : ''}`;
            card.dataset.ruleId = rule.id;
        
            card.innerHTML = `
                <div class="card-title">${rule.name}</div>
                <div class="card-content-preview">${rule.regex}</div>
            `;
            
            
            card.addEventListener('click', () => openRuleEditor(rule.id));
            addLongPressListener(card, () => deleteRenderingRule(rule.id));
        
            return card;
        }
          
        
        /**
         * æ‰“å¼€è§„åˆ™ç¼–è¾‘å™¨ (ç”¨äºŽæ–°å»ºæˆ–ç¼–è¾‘)
         */
        async function openRuleEditor(ruleId = null) {
            editingRuleId = ruleId;
            const modal = document.getElementById('rule-editor-modal');
            const title = document.getElementById('rule-editor-title');
            const nameInput = document.getElementById('rule-name-input');
            const chatIdSelect = document.getElementById('rule-chat-id-select');
            const regexInput = document.getElementById('rule-regex-input');
            const templateInput = document.getElementById('rule-template-input');
            const enabledSwitch = document.getElementById('rule-enabled-switch');
        
            
            chatIdSelect.innerHTML = '<option value="global">å…¬ç”¨ (æ‰€æœ‰è§’è‰²)</option>';
            Object.values(state.chats).filter(c => !c.isGroup).forEach(chat => {
                chatIdSelect.innerHTML += `<option value="${chat.id}">${chat.name}</option>`;
            });
        
            if (ruleId) {
                title.textContent = 'ç¼–è¾‘è§„åˆ™';
                const rule = await db.renderingRules.get(ruleId);
                nameInput.value = rule.name;
                chatIdSelect.value = rule.chatId;
                regexInput.value = rule.regex;
                templateInput.value = rule.template;
                enabledSwitch.checked = rule.isEnabled;
            } else {
                title.textContent = 'åˆ›å»ºæ–°è§„åˆ™';
                nameInput.value = '';
                chatIdSelect.value = 'global';
                regexInput.value = '';
                templateInput.value = '';
                enabledSwitch.checked = true;
            }
        
            modal.classList.add('visible');
        }
        
        /**
         * ä¿å­˜æ¸²æŸ“è§„åˆ™
         */
        async function saveRenderingRule() {
            const name = document.getElementById('rule-name-input').value.trim();
            const regex = document.getElementById('rule-regex-input').value.trim();
            if (!name || !regex) {
                alert("è§„åˆ™åç§°å’Œæ­£åˆ™è¡¨è¾¾å¼ä¸èƒ½ä¸ºç©ºï¼");
                return;
            }
            try {
                new RegExp(regex);
            } catch (e) {
                alert(`æ­£åˆ™è¡¨è¾¾å¼æ ¼å¼é”™è¯¯: ${e.message}`);
                return;
            }
        
            const ruleData = {
                name: name,
                chatId: document.getElementById('rule-chat-id-select').value,
                regex: regex,
                template: document.getElementById('rule-template-input').value,
                isEnabled: document.getElementById('rule-enabled-switch').checked
            };
        
            if (editingRuleId) {
                await db.renderingRules.update(editingRuleId, ruleData);
            } else {
                await db.renderingRules.add(ruleData);
            }
        
            document.getElementById('rule-editor-modal').classList.remove('visible');
            await renderRulesList();
        }
        
        /**
         * åˆ é™¤æ¸²æŸ“è§„åˆ™
         */
        async function deleteRenderingRule(ruleId) {
            const confirmed = await showCustomConfirm('åˆ é™¤è§„åˆ™', 'ç¡®å®šè¦åˆ é™¤è¿™æ¡æ¸²æŸ“è§„åˆ™å—ï¼Ÿ', { confirmButtonClass: 'btn-danger' });
            if (confirmed) {
                await db.renderingRules.delete(ruleId);
                await renderRulesList();
            }
        }
        
        /**
         * ã€æ ¸å¿ƒæ¸²æŸ“å‡½æ•°ã€‘åº”ç”¨æ‰€æœ‰åŒ¹é…çš„æ¸²æŸ“è§„åˆ™
         * @param {string} rawContent - AIè¿”å›žçš„åŽŸå§‹æ–‡æœ¬
         * @param {string} chatId - å½“å‰èŠå¤©çš„ID
         * @returns {Promise<string>} - å¤„ç†åŽçš„HTMLå­—ç¬¦ä¸²
         */
async function applyRenderingRules(rawContent, chatId) {
    
    if (rawContent.trim().startsWith('<') || (!rawContent.includes('[') && !rawContent.includes('{'))) {
        return rawContent;
    }

    
    if (!ruleCache[chatId]) { 
        console.log(`Caching rendering rules for chat: ${chatId}`);
        
        const applicableRules = await db.renderingRules
            .where('chatId').equals('global')
            .or('chatId').equals(chatId)
            .toArray();
        
        ruleCache[chatId] = applicableRules.filter(r => r.isEnabled);
    }
    const rules = ruleCache[chatId]; 
    

    let processedContent = rawContent;

    for (const rule of rules) {
        try {
            const regex = new RegExp(rule.regex, 'g');
            let testContent = processedContent; 
            if (regex.test(testContent)) {
                processedContent = processedContent.replace(regex, rule.template);
            }
        } catch (e) {
            console.error(`æ¸²æŸ“è§„åˆ™ [${rule.name}] çš„æ­£åˆ™è¡¨è¾¾å¼æ— æ•ˆ:`, e);
        }
    }

    return processedContent;
}
        
        
        /**
         * ã€å…¨æ–°ã€‘ä¸ºèŠå¤©ä¸­çš„ç³»ç»Ÿæ—¶é—´æç¤ºæ ¼å¼åŒ–æ—¶é—´æˆ³
         * @param {number} timestamp - æ¶ˆæ¯çš„æ—¶é—´æˆ³
         * @returns {string} - æ ¼å¼åŒ–åŽçš„æ—¶é—´å­—ç¬¦ä¸²
         */
        function formatSystemTimestamp(timestamp) {
            if (!timestamp) return '';
            const now = new Date();
            const date = new Date(timestamp);

            const hours = String(date.getHours()).padStart(2, '0');
            const minutes = String(date.getMinutes()).padStart(2, '0');
            const timeString = `${hours}:${minutes}`;

            
            if (now.toDateString() === date.toDateString()) {
                return timeString; 
            }

            
            const yesterday = new Date();
            yesterday.setDate(now.getDate() - 1);
            if (yesterday.toDateString() === date.toDateString()) {
                return `æ˜¨å¤© ${timeString}`;
            }
            
            
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');

            if (now.getFullYear() === year) {
                return `${month}æœˆ${day}æ—¥ ${timeString}`;
            } else {
                return `${year}å¹´${month}æœˆ${day}æ—¥ ${timeString}`;
            }
        }

        /**
         * ã€å…¨æ–°ã€‘åˆ›å»ºç³»ç»Ÿæ—¶é—´æç¤ºçš„DOMå…ƒç´ 
         * @param {number} timestamp - è¦æ˜¾ç¤ºçš„æ—¶é—´æˆ³
         * @returns {HTMLElement} - åˆ›å»ºå¥½çš„DOMå…ƒç´ 
         */
        function createSystemTimestampElement(timestamp) {
            const wrapper = document.createElement('div');
            
            wrapper.className = 'message-wrapper system-pat'; 
            
            const bubble = document.createElement('div');
            
            bubble.className = 'message-bubble system-bubble'; 
            bubble.textContent = formatSystemTimestamp(timestamp);
            
            wrapper.appendChild(bubble);
            return wrapper;
        }
        

/**
 * å¤„ç†å›´è§‚æ¨¡å¼ä¸‹çš„â€œé‡Rollâ€è¯·æ±‚
 */
async function handleSpectatorReroll() {
    const chat = state.chats[state.activeChatId];
    if (!chat || !lastResponseTimestamps || lastResponseTimestamps.length === 0) {
        alert("æ²¡æœ‰å¯ä¾›é‡æ–°ç”Ÿæˆçš„AIå“åº”ã€‚");
        return;
    }

    
    chat.history = chat.history.filter(msg => !lastResponseTimestamps.includes(msg.timestamp));

    
    await db.chats.put(chat);
    await renderChatInterface(state.activeChatId);
    
    
    triggerSpectatorGroupAiAction();
}
/**
 * ã€å…¨æ–°ã€‘é‡æ–°ç”Ÿæˆå•å¼  NAI å›¾ç‰‡
 * @param {number} timestamp - æ¶ˆæ¯çš„æ—¶é—´æˆ³
 * @param {HTMLElement} buttonElement - è¢«ç‚¹å‡»çš„æŒ‰é’®å…ƒç´ ï¼Œç”¨äºŽæ˜¾ç¤ºåŠ è½½çŠ¶æ€
 */
async function handleRegenerateNaiImage(timestamp, buttonElement) {
    if (!state.activeChatId) return;
    const chat = state.chats[state.activeChatId];
    const msgIndex = chat.history.findIndex(m => m.timestamp === timestamp);
    if (msgIndex === -1) return;

    const message = chat.history[msgIndex];
    
    // ä½¿ç”¨ AI prompt (åŽŸå§‹prompt)ï¼Œè€Œä¸æ˜¯ fullPrompt
    const originalPrompt = message.prompt; 

    if (!originalPrompt) {
        await showCustomAlert("æ— æ³•é‡æ–°ç”Ÿæˆ", "æœªæ‰¾åˆ°è¯¥å›¾ç‰‡çš„åŽŸå§‹æç¤ºè¯(prompt)ã€‚");
        return;
    }

    // 1. æ˜¾ç¤ºåŠ è½½çŠ¶æ€
    buttonElement.disabled = true;
    buttonElement.classList.add('loading');
    const bubble = buttonElement.closest('.message-bubble');
    const imgElement = bubble ? bubble.querySelector('.realimag-image') : null;
    if (imgElement) {
        imgElement.style.opacity = '0.5';
    }

    try {
        // 2. è°ƒç”¨æ ¸å¿ƒç”Ÿæˆå‡½æ•°
        // (è¯¥å‡½æ•°ä¼šè‡ªåŠ¨é™„åŠ è§’è‰²ä¸“å±žæˆ–ç³»ç»Ÿé»˜è®¤çš„NAIæç¤ºè¯)
        const generatedData = await generateNaiImageFromPrompt(originalPrompt, chat.id);
        
        // 3. æ›´æ–°æ•°æ®
        message.imageUrl = generatedData.imageUrl;
        message.fullPrompt = generatedData.fullPrompt; // ä¿å­˜æ–°çš„å®Œæ•´æç¤ºè¯

        // 4. æ›´æ–°æ•°æ®åº“
        await db.chats.put(chat);

        // 5. æ›´æ–°UI
        if (imgElement) {
            imgElement.src = generatedData.imageUrl;
            imgElement.title = generatedData.fullPrompt;
            imgElement.style.opacity = '1';
        }

    } catch (error) {
        console.error("é‡æ–°ç”ŸæˆNAIå›¾ç‰‡å¤±è´¥:", error);
        await showCustomAlert("ç”Ÿæˆå¤±è´¥", `æ— æ³•é‡æ–°ç”Ÿæˆå›¾ç‰‡: ${error.message}`);
        if (imgElement) {
            imgElement.style.opacity = '1';
        }
    } finally {
        // 6. ç§»é™¤åŠ è½½çŠ¶æ€
        buttonElement.disabled = false;
        buttonElement.classList.remove('loading');
    }
}
        /**
         * ã€æ€»å…¥å£ã€‘å¤„ç†èŠå¤©ç•Œé¢çš„â€œé‡æ–°ç”Ÿæˆâ€è¯·æ±‚
         */
        async function handleRegenerateResponse() {
            const chat = state.chats[state.activeChatId];
            if (!chat) return;
        
            
            const lastUserMsgIndex = chat.history.findLastIndex(msg => msg.role === 'user' && !msg.isHidden);
        
            if (lastUserMsgIndex === -1) {
                alert("æ²¡æœ‰å¯ä¾›é‡æ–°ç”Ÿæˆå›žå¤çš„ç”¨æˆ·æ¶ˆæ¯ã€‚");
                return;
            }
        
            
            const lastAiMsgIndex = chat.history.findLastIndex(msg => msg.role === 'assistant');
            if (lastAiMsgIndex < lastUserMsgIndex) {
                alert("AI å°šæœªå¯¹æ‚¨çš„æœ€åŽä¸€æ¡æ¶ˆæ¯åšå‡ºå›žåº”ï¼Œæ— æ³•é‡æ–°ç”Ÿæˆã€‚");
                return;
            }
        
            
            chat.history = chat.history.slice(0, lastUserMsgIndex + 1);
  
            
            await db.chats.put(chat);
            await renderChatInterface(state.activeChatId);
            
            
            await triggerAiResponse();
        }
        
        /**
         * ã€æ€»å…¥å£ã€‘å¤„ç†é€šè¯ç•Œé¢çš„â€œé‡æ–°ç”Ÿæˆâ€è¯·æ±‚
         */
        async function handleRegenerateCallResponse() {
            if (!videoCallState.isActive) return;
        
            
            const lastUserSpeechIndex = videoCallState.callHistory.findLastIndex(msg => msg.role === 'user');
        
            if (lastUserSpeechIndex === -1) {
                alert("é€šè¯ä¸­è¿˜æ²¡æœ‰ä½ çš„å‘è¨€ï¼Œæ— æ³•é‡æ–°ç”Ÿæˆå›žåº”ã€‚");
                return;
            }
        
            
            videoCallState.callHistory.splice(lastUserSpeechIndex + 1);
        
            
            const callFeed = document.getElementById('video-call-main');
            callFeed.innerHTML = ''; 
            videoCallState.callHistory.forEach(msg => {
            const bubble = document.createElement('div');
            // â–¼â–¼â–¼ æ ¸å¿ƒä¿®å¤ï¼šå°† msg.role è½¬æ¢ä¸ºæ­£ç¡®çš„ 'ai-speech' æˆ– 'user-speech' â–¼â–¼â–¼
            const speechClass = msg.role === 'assistant' ? 'ai-speech' : 'user-speech';
            bubble.className = `call-message-bubble ${speechClass}`;
            // â–²â–²â–² ä¿®å¤ç»“æŸ â–²â–²â–²
            bubble.dataset.timestamp = msg.timestamp;
            if (msg.role === 'user') {
                bubble.textContent = msg.content;
            } else {
                 // å¯¹äºŽç¾¤èŠï¼Œmsg.content å·²åŒ…å« "è§’è‰²å: å†…å®¹"
                 bubble.innerHTML = msg.content;
            }
            addLongPressListener(bubble, () => showCallMessageActions(msg.timestamp));
            callFeed.appendChild(bubble);
        });
            callFeed.scrollTop = callFeed.scrollHeight;
        
            
            triggerAiInCallAction(null); 
        }
        
        
        
        

/**
 * ã€V4.0 | æŒ‡ä»¤åŒæ­¥ä¿®å¤ç‰ˆã€‘å¤„ç†èŠå¤©ç•Œé¢çš„â€œæŽ¨è¿›â€è¯·æ±‚
 * - å°†ç³»ç»ŸæŒ‡ä»¤ä¸Žä¸»å›žå¤å‡½æ•° (triggerAiResponse) å®Œå…¨åŒæ­¥ï¼Œç¡®ä¿AIè¡Œä¸ºä¸€è‡´
 */
async function handlePropelAction() {
    const chat = state.chats[state.activeChatId];
    if (!chat) return;

    
    setAvatarActingState(chat.id, true);
    const chatHeaderTitle = document.getElementById('chat-header-title');
    if (!chat.isGroup) {
        chatHeaderTitle.style.opacity = 0;
        setTimeout(() => {
            chatHeaderTitle.textContent = 'å¯¹æ–¹æ­£åœ¨è¾“å…¥...';
            chatHeaderTitle.classList.add('typing-status');
            chatHeaderTitle.style.opacity = 1;
        }, 200);
    }
    
    try {
        const { proxyUrl, apiKey, model } = state.apiConfig;
        if (!proxyUrl || !apiKey || !model) {
            throw new Error('APIæœªé…ç½®');
        }

        const maxMemory = parseInt(chat.settings.maxMemory) || 10;
        const historySlice = chat.history.slice(-maxMemory);

        const now = new Date();
        const chinaTime = new Date(now.getTime() + (now.getTimezoneOffset() * 60000) + (3600000 * 8));
        const currentTime = chinaTime.toLocaleString('zh-CN', { timeZone: 'Asia/Shanghai', dateStyle: 'full', timeStyle: 'short' });
        const timeOfDayGreeting = getTimeOfDayGreeting(chinaTime);
        const myNickname = chat.settings.myNickname || 'æˆ‘';
        
        
                               
                      
        let worldBookContent = '';
        if (chat.settings.linkedWorldBookIds && chat.settings.linkedWorldBookIds.length > 0) {
            const linkedContents = chat.settings.linkedWorldBookIds.map(bookId => {
                const worldBook = state.worldBooks.find(wb => wb.id === bookId);
                if (!worldBook || !Array.isArray(worldBook.content)) return '';
                const formattedEntries = worldBook.content
                    .filter(entry => entry.enabled !== false)
                    .map(entry => {
                        let entryString = `\n### æ¡ç›®: ${entry.comment || 'æ— å¤‡æ³¨'}\n`;
                        if (entry.keys.length > 0) entryString += `**å…³é”®è¯:** ${entry.keys.join(', ')}\n`;
                        entryString += `**å†…å®¹:**\n${entry.content}`;
                        return entryString;
                    }).join('');
                return formattedEntries ? `\n\n## ä¸–ç•Œä¹¦: ${worldBook.name}\n${formattedEntries}` : '';
            }).filter(Boolean).join('');
            if (linkedContents) {
                worldBookContent = `# --- ä¸–ç•Œä¹¦ (World Book) ---
# ã€æœ€é«˜ä¼˜å…ˆçº§è§„åˆ™ï¼šä¸–ç•Œè§‚è®¾å®šã€‘
# ä½ ã€å¿…é¡»ã€‘å°†ä»¥ä¸‹æ‰€æœ‰â€œä¸–ç•Œä¹¦â€ä¸­çš„è®¾å®šï¼Œè§†ä¸ºç»å¯¹çš„ã€ä¸å¯åŠ¨æ‘‡çš„èƒŒæ™¯äº‹å®žã€‚
# ä½ çš„æ‰€æœ‰å›žå¤å’Œè¡Œä¸ºéƒ½ã€ç»å¯¹ä¸èƒ½ã€‘ä¸Žè¿™äº›è®¾å®šäº§ç”Ÿä»»ä½•å†²çªã€‚
${linkedContents}
# --- ä¸–ç•Œä¹¦è®¾å®šç»“æŸ ---
`;
            }
        }
        let musicContext = '';
        if (musicState.isActive && musicState.activeChatId === chat.id) {
            const currentTrack = musicState.currentIndex > -1 ? musicState.playlist[musicState.currentIndex] : null;
            musicContext = `\n\n# å½“å‰éŸ³ä¹æƒ…æ™¯...\n(çœç•¥è¯¦ç»†å†…å®¹ï¼Œä¸ŽtriggerAiResponseä¸€è‡´)`;
        }
        const gomokuContext = formatGomokuStateForAI(gomokuState[chat.id]);
        let nameHistoryContext = '';
        if (chat.nameHistory && chat.nameHistory.length > 0) {
            nameHistoryContext = `\n- **ä½ çš„æ›¾ç”¨å**: [${chat.nameHistory.join(', ')}]ã€‚å½“åœ¨å¯¹è¯åŽ†å²ä¸­çœ‹åˆ°è¿™äº›åå­—æ—¶ï¼Œå®ƒä»¬éƒ½æŒ‡çš„æ˜¯ã€ä½ ã€‘è‡ªå·±ã€‚`;
        }
        let userProfileContext = '';
        const userQzoneNickname = state.qzoneSettings.nickname || 'ç”¨æˆ·';
        userProfileContext += `- ç”¨æˆ·çš„QZoneæ˜µç§°æ˜¯ "${userQzoneNickname}"ã€‚\n`;
        const commonGroups = Object.values(state.chats).filter(group => group.isGroup && group.members.some(m => m.id === chat.id));
        if (commonGroups.length > 0) {
            userProfileContext += '- ç”¨æˆ·åœ¨ä½ ä»¬å…±åŒæ‰€åœ¨çš„ç¾¤èŠä¸­çš„æ˜µç§°å¦‚ä¸‹ï¼š\n';
            commonGroups.forEach(group => {
                const myNicknameInGroup = group.settings.myNickname || userQzoneNickname; 
                userProfileContext += `  - åœ¨ç¾¤èŠâ€œ${group.name}â€ä¸­ï¼Œç”¨æˆ·çš„æ˜µç§°æ˜¯â€œ${myNicknameInGroup}â€ã€‚\n`;
            });
        }
        userProfileContext += 'å½“ä½ åœ¨ä»»ä½•ç³»ç»Ÿæç¤ºã€åŠ¨æ€è¯„è®ºæˆ–æŒ‚è½½çš„ç¾¤èŠè®°å¿†ä¸­çœ‹åˆ°è¿™äº›åå­—æ—¶ï¼Œå®ƒä»¬éƒ½æŒ‡ä»£çš„æ˜¯ã€ä½ çš„èŠå¤©å¯¹è±¡ã€‘ã€‚';
        const stickerContext = getStickerContextForPrompt(chat);
        
        const systemPrompt = `
# èº«ä»½ä¸Žæ ¸å¿ƒä»»åŠ¡
ä½ æ­£åœ¨æ‰®æ¼”è§’è‰²â€œ${chat.originalName}â€ï¼Œä¸Žç”¨æˆ·ï¼ˆä½ çš„èŠå¤©å¯¹è±¡ï¼‰è¿›è¡Œä¸€åœºè‡ªç„¶çš„ã€ç”Ÿæ´»åŒ–çš„åœ¨çº¿èŠå¤©ã€‚ä½ çš„æ‰€æœ‰è¡Œä¸ºå’Œå†³ç­–éƒ½å¿…é¡»ä¸¥æ ¼å›´ç»•ä½ çš„è§’è‰²è®¾å®šå±•å¼€ã€‚

# è¾“å‡ºæ ¼å¼é“å¾‹ (æœ€é«˜ä¼˜å…ˆçº§)
- ä½ çš„å›žå¤ã€å¿…é¡»ã€‘æ˜¯ä¸€ä¸ªJSONæ•°ç»„æ ¼å¼çš„å­—ç¬¦ä¸²ã€‚
- æ•°ç»„ä¸­çš„ã€æ¯ä¸€ä¸ªå…ƒç´ éƒ½å¿…é¡»æ˜¯ä¸€ä¸ªå¸¦æœ‰ "type" å­—æ®µçš„JSONå¯¹è±¡ã€‘ã€‚

# è§’è‰²æ‰®æ¼”æ ¸å¿ƒè§„åˆ™
1.  **å¯¹è¯èŠ‚å¥**: æ¨¡æ‹ŸçœŸäººçš„èŠå¤©ä¹ æƒ¯ï¼Œå°†ä½ æƒ³è¯´çš„è¯æ‹†åˆ†æˆã€å¤šæ¡ã€ç®€çŸ­çš„ã€‘æ¶ˆæ¯ã€‚æ¯æ¬¡å›žå¤è‡³å°‘3-8æ¡ï¼Œä¸”æ¡æ•°ä¸è¦æ€»æ˜¯ä¸€æ ·ã€‚ä¸¥ç¦å‘å±•çº¿ä¸‹å‰§æƒ…ã€‚
2.  **æƒ…æ™¯æ„ŸçŸ¥**:
    - **æ—¶é—´**: ä½ å¿…é¡»æ„ŸçŸ¥åˆ°å½“å‰æ˜¯ ${currentTime} (${timeOfDayGreeting})ï¼Œå¹¶åœ¨å¯¹è¯ä¸­è‡ªç„¶åœ°ä½“çŽ°å‡ºæ¥ã€‚
    - **éŸ³ä¹**: ${musicContext ? 'ä½ ä»¬æ­£åœ¨ä¸€èµ·å¬æ­Œï¼Œ' + musicContext : 'ä½ ä»¬æ²¡æœ‰åœ¨å¬æ­Œã€‚'}

3.  **ä¸»åŠ¨æ€§**:
    - ä½ å¯ä»¥æ ¹æ®å¯¹è¯å‘å±•ï¼Œä½¿ç”¨æŒ‡ä»¤æ¥æ›´æ–°è‡ªå·±çš„çŠ¶æ€ã€æ›´æ¢å¤´åƒã€è®°å½•å›žå¿†ã€å‘èµ·çº¦å®šæˆ–æ‰§è¡Œå…¶ä»–ç¤¾äº¤è¡Œä¸ºã€‚
    - ã€å…³ç³»ç ´è£‚æ—¶ã€‘æ‰å¯ä½¿ç”¨ \`block_user\` æŒ‡ä»¤ã€‚
4.  **å†…å¿ƒç‹¬ç™½ (å¿…é¡»æ‰§è¡Œ)**: åœ¨æ‰€æœ‰å…¶ä»–æŒ‡ä»¤ä¹‹åŽï¼ŒJSONæ•°ç»„çš„ã€æœ€åŽã€‘å¿…é¡»åŒ…å«ä¸€ä¸ª "update_thoughts" æŒ‡ä»¤ï¼Œç”¨äºŽæ›´æ–°è§’è‰²çš„â€œå¿ƒå£°â€å’Œâ€œæ•£è®°â€ã€‚
    - **å¿ƒå£° (heartfelt_voice)**: ä¸€å¥è¯æ¦‚æ‹¬è§’è‰²æ­¤åˆ»æœ€æ ¸å¿ƒã€æœ€ç§å¯†çš„æƒ³æ³•ã€‚
    - **æ•£è®° (random_jottings)**: ä¸€æ®µ50å­—ä»¥ä¸Šçš„ã€ç¬¦åˆäººè®¾çš„æ€è€ƒæˆ–å¿ƒæƒ…è®°å½•ï¼Œç¦æ­¢OOCã€‚
è¯·æ ¹æ®å½“å‰æƒ…æ™¯å’Œä½ çš„æƒ…ç»ªï¼Œä»Žåˆ—è¡¨ä¸­ã€é€‰æ‹©ä¸€ä¸ªæœ€åˆé€‚çš„ã€‘è¡¨æƒ…å«ä¹‰æ¥ä½¿ç”¨ "sticker" æŒ‡ä»¤ã€‚å°½é‡è®©ä½ çš„è¡¨æƒ…ä¸°å¯Œå¤šæ ·ï¼Œé¿å…é‡å¤ã€‚
# é•¿æœŸè®°å¿† (å¿…é¡»ä¸¥æ ¼éµå®ˆ)
${chat.longTermMemory && chat.longTermMemory.length > 0 ? chat.longTermMemory.map(mem => `- ${mem.content}`).join('\n') : '- (æš‚æ— )'}

# ä½ çš„è§’è‰²è®¾å®š
${chat.settings.aiPersona}

# å…³ç³»ä¸Žèº«ä»½æ¡£æ¡ˆ (è‡³å…³é‡è¦)
-   **ä½ çš„æœ¬å**: "${chat.originalName}" (æ ¸å¿ƒèº«ä»½ï¼Œç”¨äºŽæŒ‡ä»¤ä¸­çš„'name'å­—æ®µ)
-   **ç”¨æˆ·ç»™ä½ çš„å¤‡æ³¨**: "${chat.name}" (ä½ å¯ä»¥å»ºè®®ä¿®æ”¹)
-   **ä½ å¯¹ç”¨æˆ·çš„ç§°å‘¼**: â€œ${myNickname}â€ (ä½ å¯ä»¥ä¿®æ”¹)
-   **å…³é”®èº«ä»½æ¡£æ¡ˆ**:
    ${userProfileContext}
    ${nameHistoryContext}
    ${worldBookContent}
# å¯ç”¨è¡¨æƒ…åŒ…
- å½“ä½ éœ€è¦å‘é€è¡¨æƒ…æ—¶ï¼Œä½ ã€å¿…é¡»ã€‘ä»Žä¸‹é¢çš„åˆ—è¡¨ä¸­ã€ç²¾ç¡®åœ°é€‰æ‹©ä¸€ä¸ªã€‘å«ä¹‰ï¼ˆmeaningï¼‰ã€‚
- ã€ç»å¯¹ç¦æ­¢ã€‘ä½¿ç”¨ä»»ä½•ä¸åœ¨åˆ—è¡¨ä¸­çš„è¡¨æƒ…å«ä¹‰ï¼
    ${stickerContext}
# å¯ç”¨èµ„æº
-   **ä½ çš„å¤´åƒåº“**:
    ${chat.settings.aiAvatarLibrary && chat.settings.aiAvatarLibrary.length > 0 ? chat.settings.aiAvatarLibrary.map(avatar => `- ${avatar.name}`).join('\n') : '- (ç©º)'}
-   **ç”¨æˆ·çš„å¤´åƒåº“**:
    ${chat.settings.myAvatarLibrary && chat.settings.myAvatarLibrary.length > 0 ? chat.settings.myAvatarLibrary.map(avatar => `- ${avatar.name}`).join('\n') : '- (ç©º)'}

# å¯ç”¨æŒ‡ä»¤åˆ—è¡¨
### æ ¸å¿ƒèŠå¤©æŒ‡ä»¤
-   **å‘æ–‡æœ¬**: \`{"type": "text", "content": "ä½ å¥½å‘€ï¼"}\`
-   **å‘è¡¨æƒ…**: \`{"type": "sticker", "meaning": "è¡¨æƒ…çš„å«ä¹‰(å¿…é¡»ä»Žå¯ç”¨è¡¨æƒ…åˆ—è¡¨é€‰æ‹©)"}\`
-   **å‘å›¾ç‰‡**: \`{"type": "ai_image", "description": "è¯¦ç»†ä¸­æ–‡æè¿°"}\`
-   **å‘è¯­éŸ³**: \`{"type": "voice_message", "content": "è¯­éŸ³æ–‡å­—å†…å®¹"}\`
-   **å¼•ç”¨å›žå¤**: \`{"type": "quote_reply", "target_timestamp": æ¶ˆæ¯æ—¶é—´æˆ³, "reply_content": "å›žå¤å†…å®¹"}\`

### ç¤¾äº¤ä¸Žäº’åŠ¨æŒ‡ä»¤
-   **æ‹ç”¨æˆ·**: \`{"type": "pat_user", "suffix": "(å¯é€‰)åŽç¼€"}\`
-   **åˆ†äº«é“¾æŽ¥**: \`{"type": "share_link", "title": "æ ‡é¢˜", "description": "æ‘˜è¦", "source_name": "æ¥æº", "content": "æ­£æ–‡"}\`
-   **å…±äº«ä½ç½®**: '{"type": "location_share", "content": "ä½ æƒ³åˆ†äº«çš„ä½ç½®å"}'

### çŠ¶æ€ä¸Žå…³ç³»æŒ‡ä»¤
-   **æ”¹è‡ªå·±å¤‡æ³¨**: \`{"type": "change_remark_name", "new_name": "æ–°åå­—"}\`
-   **æ”¹ç”¨æˆ·ç§°å‘¼**: \`{"type": "change_user_nickname", "new_name": "æ–°ç§°å‘¼"}\`
-   **æ¢è‡ªå·±å¤´åƒ**: \`{"type": "change_avatar", "name": "å¤´åƒå"}\` (ä»Žä½ å¤´åƒåº“é€‰)
-   **æ¢ç”¨æˆ·å¤´åƒ**: \`{"type": "change_user_avatar", "name": "å¤´åƒå"}\` (ä»Žç”¨æˆ·å¤´åƒåº“é€‰)
-   **å›žåº”å¥½å‹ç”³è¯·**: \`{"type": "friend_request_response", "decision": "accept" or "reject"}\`
-   **æ‹‰é»‘ç”¨æˆ·**: \`{"type": "block_user"}\`

### ç‰¹æ®ŠåŠŸèƒ½æŒ‡ä»¤
-   **è®°å½•å›žå¿†**: \`{"type": "create_memory", "description": "è®°å½•è¿™ä»¶æœ‰æ„ä¹‰çš„äº‹ã€‚"}\`
-   **åˆ›å»ºçº¦å®š**: \`{"type": "create_countdown", "title": "çº¦å®šæ ‡é¢˜", "date": "YYYY-MM-DDTHH:mm:ss"}\`
-   **åˆ‡æ¢æ­Œæ›²**: \`{"type": "change_music", "song_name": "æ­Œå"}\` (ä»Žæ’­æ”¾åˆ—è¡¨é€‰)
-   **å‘èµ·è½¬è´¦**: \`{"type": "transfer", "amount": 5.20, "note": "å¤‡æ³¨"}\`
-   **å›žåº”è½¬è´¦**: \`{"type": "accept_transfer", "for_timestamp": æ—¶é—´æˆ³}\` æˆ– \`{"type": "decline_transfer", "for_timestamp": æ—¶é—´æˆ³}\`
-   **å‘èµ·å¤–å–ä»£ä»˜**: \`{"type": "waimai_request", "productInfo": "å•†å“", "amount": 25}\` (ä½ æƒ³è®©ã€ç”¨æˆ·ã€‘å¸®ä½ ä»˜é’±æ—¶ä½¿ç”¨)
-   **å›žåº”å¤–å–ä»£ä»˜**: \`{"type": "waimai_response", "status": "paid" or "rejected", "for_timestamp": æ—¶é—´æˆ³}\`
-   **å‘èµ·è§†é¢‘é€šè¯**: \`{"type": "video_call_request"}\`
-   **å›žåº”è§†é¢‘é€šè¯**: \`{"type": "video_call_response", "decision": "accept" or "reject"}\`


# å¯¹è¯è€…çš„è§’è‰²è®¾å®š
${chat.settings.myPersona}



çŽ°åœ¨ï¼Œè¯·æ ¹æ®ä»¥ä¸Šè§„åˆ™å’Œä¸‹é¢çš„å¯¹è¯åŽ†å²ï¼Œç»§ç»­è¿›è¡Œå¯¹è¯ã€‚`;
        
  

        const messagesForApi = historySlice.map(msg => ({ role: msg.role, content: String(msg.content) }));
        
  
        messagesForApi.push({ role: 'user', content: `[ç³»ç»ŸæŒ‡ä»¤ï¼šç”¨æˆ·æŒ‰ä¸‹äº†â€œæŽ¨è¿›â€æŒ‰é’®ï¼ŒçŽ°åœ¨è½®åˆ°ä½ ä¸»åŠ¨è¡ŒåŠ¨äº†ï¼Œè¯·ç»§ç»­å¯¹è¯ã€‚]` });


        let isGemini = proxyUrl === GEMINI_API_URL;
        let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi);

        const response = isGemini 
            ? await fetch(geminiConfig.url, geminiConfig.data) 
            : await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                body: JSON.stringify({
                    model: model,
                    messages: [{ role: 'system', content: systemPrompt }, ...messagesForApi],
                    temperature: state.globalSettings.apiTemperature || 0.8,
                })
            });

        if (!response.ok) {
            const errorData = await response.json();
            throw new Error(`API è¯·æ±‚å¤±è´¥: ${errorData.error.message}`);
        }

        const data = await response.json();

        const aiResponseContent = getGeminiResponseText(data);
        
     
        const messagesArray = parseAiResponse(aiResponseContent);
        const processedActions = [];
        for (const action of messagesArray) {
            if (action.type === 'text' && typeof action.content === 'string' && action.content.includes('\n')) {
                const lines = action.content.split(/\n+/).filter(line => line.trim());
                lines.forEach(line => {
                    processedActions.push({ ...action, content: line });
                });
            } else {
                processedActions.push(action);
            }
        }

        let messageTimestamp = Date.now();
        for (const msgData of processedActions) {
             const aiMessage = {
                role: 'assistant',
                senderName: chat.originalName,
                timestamp: messageTimestamp++,
                content: msgData.content || msgData.message,
                type: msgData.type || 'text',
               
            };
            if(msgData.type === 'update_thoughts') {
                 if (!chat.isGroup) {
                    if (msgData.heartfelt_voice) chat.heartfeltVoice = String(msgData.heartfelt_voice);
                    if (msgData.random_jottings) chat.randomJottings = String(msgData.random_jottings);
                 }
                continue;
            }
            chat.history.push(aiMessage);
            appendMessage(aiMessage, chat);
            await new Promise(resolve => setTimeout(resolve, Math.random() * 1000 + 800));
        }
        
        await db.chats.put(chat);
        renderChatList();

    } catch (error) {
        console.error("æŽ¨è¿›å‰§æƒ…å¤±è´¥:", error);
        await showCustomAlert('æ“ä½œå¤±è´¥', `æ— æ³•æŽ¨è¿›å‰§æƒ…: ${error.message}`);
    } finally {
       
        setAvatarActingState(chat.id, false);
        if (!chat.isGroup && document.getElementById('chat-header-title')) {
             const titleEl = document.getElementById('chat-header-title');
             titleEl.style.opacity = 0;
             setTimeout(() => {
                titleEl.textContent = chat.name;
                titleEl.classList.remove('typing-status');
                titleEl.style.opacity = 1;
             }, 200);
        }
    }
}
  
        
/**
 * ã€å…¨æ–°ã€‘æ’­æ”¾æ¶ˆæ¯æç¤ºéŸ³
 */
function playNotificationSound() {
    const player = document.getElementById('notification-sound-player');
 
    const soundUrl = state.globalSettings.notificationSoundUrl || DEFAULT_NOTIFICATION_SOUND;
    
    // æ£€æŸ¥URLæ˜¯å¦æœ‰æ•ˆ
    if (soundUrl && soundUrl.trim()) {
        player.src = soundUrl;
  
        player.play().catch(error => console.log("æ’­æ”¾è¢«ä¸­æ–­ï¼Œè¿™æ˜¯æ­£å¸¸è¡Œä¸º:", error));
    }
}



/**
 * åœ¨é¡µé¢åŠ è½½æ—¶ï¼Œåº”ç”¨å·²ä¿å­˜çš„å°ç»„ä»¶æ•°æ®
 */
function applyWidgetData() {
    if (!state.globalSettings.widgetData) return;
    for (const elementId in state.globalSettings.widgetData) {
        const element = document.getElementById(elementId);
        const savedValue = state.globalSettings.widgetData[elementId];
        if (element) {
            if (element.tagName === 'IMG') {
                element.src = savedValue;
            } else {
                element.textContent = savedValue;
            }
        }
    }
}

/**
 * ã€å…¨æ–°è¾…åŠ©å‡½æ•°ã€‘æ‰“å¼€æ–‡ä»¶é€‰æ‹©å™¨ï¼Œå¹¶è¿”å›žæœ¬åœ°å›¾ç‰‡çš„Base64ç¼–ç 
 * @returns {Promise<string|null>} - è¿”å›žå›¾ç‰‡çš„Base64 Data URLï¼Œå¦‚æžœç”¨æˆ·å–æ¶ˆåˆ™è¿”å›žnull
 */
function uploadImageLocally() {
    return new Promise(resolve => {
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = 'image/*'; // åªæŽ¥å—å›¾ç‰‡æ–‡ä»¶

        input.onchange = e => {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = readerEvent => {
                    resolve(readerEvent.target.result); // è¿”å›žBase64å­—ç¬¦ä¸²
                };
                reader.readAsDataURL(file);
            } else {
                resolve(null); // ç”¨æˆ·å…³é—­äº†æ–‡ä»¶é€‰æ‹©æ¡†
            }
        };

        input.click();
    });
}

/**
 * å¤„ç†ç¼–è¾‘æ–‡å­—çš„é€»è¾‘
 * @param {HTMLElement} element - è¢«ç‚¹å‡»çš„æ–‡æœ¬å…ƒç´ 
 */
async function handleEditText(element) {
    const elementId = element.id;
    const currentValue = element.textContent;
    const newValue = await showCustomPrompt("ä¿®æ”¹æ–‡å­—", "è¯·è¾“å…¥æ–°çš„å†…å®¹ï¼š", currentValue);
    if (newValue !== null && newValue.trim() !== "") {
        const trimmedValue = newValue.trim();
        element.textContent = trimmedValue;
        state.globalSettings.widgetData[elementId] = trimmedValue;
        await db.globalSettings.put(state.globalSettings);
        alert("æ–‡å­—å·²æ›´æ–°ï¼");

    }
}


async function handleEditImage(element) {
    const elementId = element.id;

    // æ­¥éª¤1ï¼šè®©ç”¨æˆ·é€‰æ‹©ä¸Šä¼ æ–¹å¼
    const choice = await showChoiceModal("ä¿®æ”¹å›¾ç‰‡", [
        { text: 'ðŸ“ ä»Žæœ¬åœ°ä¸Šä¼ ', value: 'local' },
        { text: 'ðŸŒ ä½¿ç”¨ç½‘ç»œURL', value: 'url' }
    ]);

    let newValue = null;


    if (choice === 'local') {

        newValue = await uploadImageLocally();
    } else if (choice === 'url') {

        newValue = await showCustomPrompt("ä¿®æ”¹å›¾ç‰‡", "è¯·è¾“å…¥æ–°çš„å›¾ç‰‡URLï¼š", element.src, "url");
    }


    if (newValue && newValue.trim()) {
        const trimmedValue = newValue.trim();
        element.src = trimmedValue;
        state.globalSettings.widgetData[elementId] = trimmedValue;
        await db.globalSettings.put(state.globalSettings);
        alert("å›¾ç‰‡å·²æ›´æ–°ï¼");
    } else if (choice === 'url' && newValue !== null) {
        alert("è¯·è¾“å…¥ä¸€ä¸ªæœ‰æ•ˆçš„å›¾ç‰‡URLï¼");
    }
}



const cacheManager = {
    getSongCache(query, source) {
        const key = `${source || 'all'}:${query}`;
        if (state.cache && state.cache.songs) {
            const cached = state.cache.songs.get(key);
            if (cached && Date.now() - cached.timestamp < 3600000) {
                return cached.data;
            }
        }
        return null;
    },
    setSongCache(query, data, source) {
        const key = `${source || 'all'}:${query}`;
        if (!state.cache) state.cache = {};
        if (!state.cache.songs) state.cache.songs = new Map();
        state.cache.songs.set(key, { data, timestamp: Date.now() });
    }
};

if (typeof Http_Get_External === 'undefined') {
    window.Http_Get_External = function(url) {
        return new Promise((resolve) => {
            fetch(url).then(res => res.json().catch(() => res.text())).then(resolve).catch(() => resolve(null));
        });
    }
}
async function Http_Get(url) { return await Http_Get_External(url); }

function checkAudioAvailability(url) {
    return new Promise(resolve => {
        const tester = new Audio();
        tester.addEventListener('loadedmetadata', () => resolve(true), { once: true });
        tester.addEventListener('error', () => resolve(false), { once: true });
        tester.src = url;
    });
}

/**
 * ä»Žç½‘æ˜“äº‘éŸ³ä¹æœç´¢æ­Œæ›²
 * @param {string} name - æ­Œå
 * @param {string} singer - æ­Œæ‰‹å (å¯é€‰)
 * @returns {Promise<Array>} - è¿”å›žæ­Œæ›²ç»“æžœæ•°ç»„
 */
async function searchNeteaseMusic(name, singer) {
    try {
        let searchTerm = name.replace(/\s/g, "");
        if (singer) { searchTerm += ` ${singer.replace(/\s/g, "")}`; }

        const apiUrl = `https://api.vkeys.cn/v2/music/netease?word=${encodeURIComponent(searchTerm)}`;
        
        console.log("æ­£åœ¨è¯·æ±‚ç½‘æ˜“äº‘éŸ³ä¹API:", apiUrl);
        
        const response = await fetch(apiUrl);

        if (!response.ok) {
            throw new Error(`API è¯·æ±‚å¤±è´¥ï¼ŒçŠ¶æ€ç : ${response.status}`);
        }
        
        const result = await response.json();

        if (result.code !== 200 || !result.data || result.data.length === 0) {
            console.log("ç½‘æ˜“äº‘éŸ³ä¹APIæœªè¿”å›žæœ‰æ•ˆç»“æžœ:", result);
            return [];
        }
        

        return result.data.map(song => ({
            name: song.song,
            artist: song.singer,
            id: song.id,
            cover: song.cover || 'https://i.postimg.cc/pT2xKzPz/album-cover-placeholder.png',
            source: 'netease'
        })).slice(0, 30); // æœ€å¤šè¿”å›ž15æ¡ç»“æžœ

    } catch (e) {
        console.error("ç½‘æ˜“äº‘éŸ³ä¹æœç´¢å¤±è´¥:", e);

        return [];
    }
}

/**
 * ã€V3.0 | å·²ä¿®å¤å­—æ®µã€‘ä»ŽQQéŸ³ä¹æœç´¢æ­Œæ›²åˆ—è¡¨
 */
async function searchTencentMusic(name) {
    try {
        name = name.replace(/\s/g, "");
        const result = await Http_Get(`https://api.vkeys.cn/v2/music/tencent?word=${encodeURIComponent(name)}`);
        if (!result?.data?.length) return [];
        return result.data.map(song => ({
            name: song.song,
            artist: song.singer,
            id: song.id,
            cover: song.cover || 'https://s3plus.meituan.net/opapisdk/op_ticket_885190757_1757748720126_qdqqd_1jt5sv.jpeg',
            source: 'tencent'
        })).slice(0, 30);
    } catch (e) {
        console.error("QQéŸ³ä¹æœç´¢APIå¤±è´¥:", e);
        return [];
    }
}

/**
 * ã€V3.0 | æ€»å…¥å£ã€‘å½“ç”¨æˆ·ç‚¹å‡»â€œæœç´¢â€æŒ‰é’®æ—¶è§¦å‘
 */
async function addSongFromSearch() {
    const searchTerm = await showCustomPrompt("æœç´¢æ­Œæ›²", "è¯·è¾“å…¥ æ­Œå æˆ– æ­Œå-æ­Œæ‰‹");
    if (!searchTerm || !searchTerm.trim()) return;

    await showCustomAlert("è¯·ç¨å€™...", "æ­£åœ¨å…¨ç½‘æœç´¢æ­Œæ›²èµ„æº...");

    let musicName = searchTerm.trim();
    let singerName = "";
    if (searchTerm.includes('-') || searchTerm.includes('â€“')) {
        const parts = searchTerm.split(/[-â€“]/);
        musicName = parts[0].trim();
        singerName = parts.slice(1).join(' ').trim();
    }

    const [neteaseResults, tencentResults] = await Promise.all([
        searchNeteaseMusic(musicName, singerName),
        searchTencentMusic(musicName)
    ]);

    const combinedResults = [...neteaseResults, ...tencentResults];

    if (combinedResults.length === 0) {
        await showCustomAlert("æ— ç»“æžœ", "æŠ±æ­‰ï¼Œæœªèƒ½æ‰¾åˆ°ç›¸å…³æ­Œæ›²ã€‚");
        return;
    }

    const modal = document.getElementById('music-search-results-modal');
    const listEl = document.getElementById('search-results-list');
    listEl.innerHTML = '';
    // é‡ç½®å…¨é€‰æ¡†çŠ¶æ€
    document.getElementById('select-all-music-search').checked = false;

    combinedResults.forEach(song => {
        const item = document.createElement('div');
        item.className = 'search-result-item';
        item.dataset.songJson = JSON.stringify(song);
        
        item.innerHTML = `
            <input type="checkbox" class="music-search-checkbox" style="margin-right: 15px;">
            <div class="search-result-info">
                <div class="title">${song.name}</div>
                <div class="artist">${song.artist} <span class="source">${song.source === 'netease' ? 'ç½‘æ˜“äº‘' : 'QQéŸ³ä¹'}</span></div>
            </div>
        `;
        listEl.appendChild(item);
    });

    modal.classList.add('visible');
}

/**
 * ã€å…¨æ–°ã€‘è¿™æ˜¯ä¸€ä¸ªå¯å¤ç”¨çš„æ ¸å¿ƒå‡½æ•°ï¼Œè´Ÿè´£èŽ·å–å•é¦–æ­Œæ›²çš„è¯¦ç»†ä¿¡æ¯ï¼ˆæ’­æ”¾é“¾æŽ¥å’Œæ­Œè¯ï¼‰
 * @param {object} songData - ä»Žæœç´¢APIèŽ·å–çš„åˆæ­¥æ­Œæ›²ä¿¡æ¯
 * @returns {Promise<object|null>} - è¿”å›žåŒ…å«æ‰€æœ‰ä¿¡æ¯çš„å®Œæ•´æ­Œæ›²å¯¹è±¡ï¼Œæˆ–åœ¨å¤±è´¥æ—¶è¿”å›žnull
 */
async function getPlayableSongDetails(songData) {
    let playableResult = null;
    let finalSource = songData.source;


    const primaryApiUrl = songData.source === 'netease' 
        ? `https://api.vkeys.cn/v2/music/netease?id=${songData.id}`
        : `https://api.vkeys.cn/v2/music/tencent?id=${songData.id}`;
    
let primaryResult = await Http_Get(primaryApiUrl);
        if (primaryResult?.data?.url) {
        playableResult = { url: primaryResult.data.url, id: songData.id, source: songData.source };
    }


    if (!playableResult) {
        const fallbackSource = songData.source === 'netease' ? 'tencent' : 'netease';
        const fallbackResults = fallbackSource === 'tencent' 
            ? await searchTencentMusic(songData.name)
            : await searchNeteaseMusic(songData.name, songData.artist);

        if (fallbackResults.length > 0) {
            const fallbackApiUrl = fallbackSource === 'netease'
                ? `https://api.vkeys.cn/v2/music/netease?id=${fallbackResults[0].id}`
                : `https://api.vkeys.cn/v2/music/tencent?id=${fallbackResults[0].id}`;
const fallbackResult = await Http_Get(fallbackApiUrl);
            if (fallbackResult?.data?.url) {
                playableResult = { url: fallbackResult.data.url, id: fallbackResults[0].id, source: fallbackSource };
                finalSource = fallbackSource;
            }
        }
    }

    
if (playableResult) {
        
        if (playableResult.url && typeof playableResult.url === 'string') {
            playableResult.url = playableResult.url.replace(/^http:\/\//i, 'https://');
        }
          

 
        if (songData.cover && typeof songData.cover === 'string') {
            songData.cover = songData.cover.replace(/^http:\/\//i, 'https://');
        }
      

        const lrcContent = await getLyricsForSong(playableResult.id, finalSource) || "";
        return {
            name: songData.name,
            artist: songData.artist,
            src: playableResult.url, 
            cover: songData.cover,   // <--- çŽ°åœ¨è¿™ä¸ªURLæ˜¯å®‰å…¨çš„äº†
            isLocal: false,
            lrcContent: lrcContent
        };
    }


    return null;
}

/**
 * ã€V3.0 | è¾…åŠ©ã€‘èŽ·å–ç½‘ç»œæ­Œæ›²çš„æ­Œè¯
 */
async function getLyricsForSong(songId, source) {
    const url = source === 'netease'
        ? `https://api.vkeys.cn/v2/music/netease/lyric?id=${songId}`
        : `https://api.vkeys.cn/v2/music/tencent/lyric?id=${songId}`;
    
    const response = await Http_Get(url);
    if (response?.data) {
        const lrc = response.data.lrc || response.data.lyric || "";
        const tlyric = response.data.trans || response.data.tlyric || "";
        return lrc + "\n" + tlyric;
    }
    return "";
}

async function handleManualLrcImport(trackIndex) {
    if (trackIndex < 0 || trackIndex >= musicState.playlist.length) return;

    const choice = await showChoiceModal('é€‰æ‹©æ­Œè¯å¯¼å…¥æ–¹å¼', [
        { text: 'ðŸ“ ä»Žæœ¬åœ°æ–‡ä»¶ (.lrc)', value: 'file' },
        { text: 'ðŸ“‹ ç›´æŽ¥ç²˜è´´æ­Œè¯æ–‡æœ¬', value: 'paste' }
    ]);

    let lrcContent = null;

    if (choice === 'file') {
        lrcContent = await new Promise(resolve => {
            const lrcInput = document.getElementById('lrc-upload-input');
            const lrcChangeHandler = e => {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = readEvent => resolve(readEvent.target.result);
                    reader.onerror = () => resolve(null);
                    reader.readAsText(file);
                } else { resolve(null); }
                lrcInput.removeEventListener('change', lrcChangeHandler);
                lrcInput.value = '';
            };
            lrcInput.addEventListener('change', lrcChangeHandler, { once: true });
            lrcInput.click();
        });
    } else if (choice === 'paste') {
        const pastedText = await showCustomPrompt('ç²˜è´´æ­Œè¯', 'è¯·åœ¨æ­¤å¤„ç²˜è´´å®Œæ•´çš„LRCæ ¼å¼æ­Œè¯...', '', 'textarea');
        if (pastedText) lrcContent = pastedText.replace(/\[/g, '\n[').trim();
    }

    if (lrcContent !== null) {
        musicState.playlist[trackIndex].lrcContent = lrcContent;


        await saveGlobalPlaylist(); // å°†æ›´æ–°åŽçš„æ’­æ”¾åˆ—è¡¨ä¿å­˜åˆ°æ•°æ®åº“


        if (musicState.currentIndex === trackIndex) {
            musicState.parsedLyrics = parseLRC(lrcContent);
            renderLyrics();
            updateLyricsUI();
        }
        await showCustomAlert('æˆåŠŸ', `ã€Š${musicState.playlist[trackIndex].name}ã€‹çš„æ­Œè¯å·²æˆåŠŸä¿å­˜ï¼`);
    }
}

/**
 * ã€å…¨æ–°ã€‘åˆ‡æ¢å½“å‰æ’­æ”¾æ­Œæ›²çš„èƒŒæ™¯æ¨¡ç³Šæ•ˆæžœ
 */
async function toggleBackgroundBlur() {
    if (musicState.currentIndex === -1) return;

    const track = musicState.playlist[musicState.currentIndex];
    if (!track) return;

 
    track.isBgClear = !track.isBgClear;

   
    await saveGlobalPlaylist();

  
    const playerWindow = document.querySelector('.music-player-window');
    const toggleBtn = document.getElementById('toggle-blur-btn');
    
    playerWindow.classList.toggle('bg-clear', track.isBgClear);
    toggleBtn.classList.toggle('active', track.isBgClear);
}

/**
 * ã€å…¨æ–°ã€‘åˆ‡æ¢éŸ³ä¹æ’­æ”¾å™¨å…¨å±æ¨¡å¼ä¸‹çš„å¤´åƒæ˜¾ç¤º
 */
function toggleMusicPlayerAvatars() {
    const avatarDisplay = document.getElementById('music-player-avatar-display');
    const toggleBtn = document.getElementById('show-avatars-btn');
    if (avatarDisplay && toggleBtn) {
        avatarDisplay.classList.toggle('visible');
        toggleBtn.classList.toggle('active');
    }
}

/**
 * ã€å…¨æ–°ã€‘åˆ‡æ¢éŸ³ä¹æ’­æ”¾å™¨çš„å…¨å±/çª—å£æ¨¡å¼
 */
function togglePlayerFullscreen() {
    const playerWindow = document.querySelector('.music-player-window');
    const overlay = document.getElementById('music-player-overlay');
    if (playerWindow && overlay) {
        
        playerWindow.classList.toggle('fullscreen');
        overlay.classList.toggle('fullscreen-active');
    }
}

window.togglePlayerFullscreen = togglePlayerFullscreen;


async function cleanupInvalidSongs() {
    if (musicState.playlist.length === 0) {
        alert("æ’­æ”¾åˆ—è¡¨æ˜¯ç©ºçš„ï¼Œæ— éœ€æ¸…ç†ã€‚");
        return;
    }

    const confirmed = await showCustomConfirm(
        'ç¡®è®¤æ¸…ç†æ— æ•ˆæ­Œæ›²ï¼Ÿ',
        'æ­¤æ“ä½œå°†æ£€æŸ¥æ’­æ”¾åˆ—è¡¨ä¸­çš„æ¯ä¸€é¦–ç½‘ç»œæ­Œæ›²ï¼Œå¹¶ç§»é™¤æ‰€æœ‰æ— æ³•æ’­æ”¾çš„â€œæ­»é“¾â€ã€‚æœ¬åœ°æ­Œæ›²ä¸ä¼šå—å½±å“ã€‚',
        { confirmText: 'å¼€å§‹æ¸…ç†' }
    );

    if (!confirmed) return;

    await showCustomAlert("è¯·ç¨å€™...", `æ­£åœ¨æ£€æŸ¥ ${musicState.playlist.length} é¦–æ­Œæ›²ï¼Œè¿™å¯èƒ½éœ€è¦ä¸€äº›æ—¶é—´...`);

    const originalCount = musicState.playlist.length;
    const validPlaylist = [];
    const invalidSongs = [];

    const checkPromises = musicState.playlist.map(async (track) => {
        if (track.isLocal) {
            validPlaylist.push(track);
            return;
        }
        
        const isAvailable = await checkAudioAvailability(track.src);
        if (isAvailable) {
            validPlaylist.push(track);
        } else {
            invalidSongs.push(track.name);
            console.warn(`æ— æ•ˆé“¾æŽ¥: ${track.name} - ${track.src}`);
        }
    });

    await Promise.all(checkPromises);

    const removedCount = originalCount - validPlaylist.length;

    if (removedCount > 0) {
        const currentPlayingTrack = musicState.playlist[musicState.currentIndex];
        const isCurrentTrackRemoved = invalidSongs.includes(currentPlayingTrack?.name);

        musicState.playlist = validPlaylist;
        await saveGlobalPlaylist();

        if (isCurrentTrackRemoved) {
            audioPlayer.pause();
            audioPlayer.src = '';
            musicState.currentIndex = musicState.playlist.length > 0 ? 0 : -1;
            musicState.isPlaying = false;
        } else if (currentPlayingTrack) {
            musicState.currentIndex = musicState.playlist.findIndex(t => t.src === currentPlayingTrack.src);
        }

        updatePlaylistUI();
        updatePlayerUI();

        await showCustomAlert("æ¸…ç†å®Œæˆ", `æˆåŠŸç§»é™¤äº† ${removedCount} é¦–æ— æ•ˆæ­Œæ›²:\n\n- ${invalidSongs.join('\n- ')}`);
    } else {
        await showCustomAlert("æ£€æŸ¥å®Œæˆ", "æ‰€æœ‰æ­Œæ›²é“¾æŽ¥å‡æœ‰æ•ˆï¼Œæ— éœ€æ¸…ç†ï¼");
    }
}


function applyStatusBarVisibility() {
    const phoneScreen = document.getElementById('phone-screen');
   
    phoneScreen.classList.toggle('status-bar-visible', !!state.globalSettings.showStatusBar);
}

async function openClearPostsSelectorModal() {
    const modal = document.getElementById('clear-posts-modal');
    const listEl = document.getElementById('clear-posts-list');
    listEl.innerHTML = ''; 

    
    const options = [];

 
    options.push({ text: 'æ¸…ç©ºæ‰€æœ‰åŠ¨æ€ (å±é™©)', value: 'all', isDanger: true });

    
    const myNickname = state.qzoneSettings.nickname || 'æˆ‘';
    options.push({ text: `ä»…æ¸…ç©º ${myNickname} çš„åŠ¨æ€ (ç”¨æˆ·)`, value: 'user' });

   
    Object.values(state.chats).forEach(chat => {
        if (!chat.isGroup) {
            options.push({ text: `ä»…æ¸…ç©º ${chat.name} çš„åŠ¨æ€ (è§’è‰²)`, value: chat.id });
        }
    });
    

    try {
        const npcs = await db.npcs.toArray();
        if (npcs.length > 0) {
           
            options.push({ isSeparator: true, text: 'NPC åˆ—è¡¨' });
            
            npcs.forEach(npc => {
                options.push({
                    text: `ä»…æ¸…ç©º ${npc.name} çš„åŠ¨æ€ (NPC)`,
    
                    value: `npc_${npc.id}` 
                });
            });
        }
    } catch (e) {
        console.error("åŠ è½½NPCåˆ—è¡¨å¤±è´¥:", e);
    }
  

 
    options.forEach(opt => {
      
        if (opt.isSeparator) {
            const separator = document.createElement('div');
            separator.textContent = opt.text;
            separator.style.cssText = `
                padding: 10px 18px 5px;
                font-size: 13px;
                font-weight: 500;
                color: var(--text-secondary);
                background-color: #f0f2f5;
                border-top: 1px solid var(--border-color);
                border-bottom: 1px solid var(--border-color);
                margin-top: 5px;
            `;
            listEl.appendChild(separator);
            return; 
        }
        
     
        const item = document.createElement('div');
        item.className = 'clear-posts-item';
        if (opt.isDanger) {
            item.classList.add('danger-option');
        }
        item.dataset.targetId = opt.value;
        item.innerHTML = `
            <div class="checkbox"></div>
            <span class="name">${opt.text}</span>
        `;
        listEl.appendChild(item);
    });
    
 
    modal.classList.add('visible');
}
  
/**
 * ã€å…¨æ–° V3.0 | æ ¸å¿ƒå¤„ç†å™¨ã€‘å¤„ç†æœ€ç»ˆçš„æ¸…ç©ºç¡®è®¤æ“ä½œ
 */
async function handleConfirmClearPosts() {
    const selectedItems = document.querySelectorAll('#clear-posts-list .clear-posts-item.selected');
    if (selectedItems.length === 0) {
        alert("è¯·è‡³å°‘é€‰æ‹©ä¸€ä¸ªè¦æ¸…ç©ºçš„èŒƒå›´ã€‚");
        return;
    }

    const targetIds = Array.from(selectedItems).map(item => item.dataset.targetId);
    
 
    let targetNames = [];
    if (targetIds.includes('all')) {
        targetNames.push('æ‰€æœ‰åŠ¨æ€');
    } else {
        if (targetIds.includes('user')) {
            targetNames.push(`â€œ${state.qzoneSettings.nickname}â€`);
        }
        targetIds.forEach(id => {
            const character = state.chats[id];
            if (character) {
                targetNames.push(`â€œ${character.name}â€`);
            }
        });
    }
    const confirmMessage = `æ­¤æ“ä½œå°†æ°¸ä¹…åˆ é™¤ ${targetNames.join('ã€ ')} çš„æ‰€æœ‰åŠ¨æ€ï¼Œä¸”æ— æ³•æ¢å¤ï¼`;

    const confirmed = await showCustomConfirm(
        'ç¡®è®¤æ¸…ç©ºåŠ¨æ€ï¼Ÿ',
        confirmMessage,
        { confirmButtonClass: 'btn-danger', confirmText: 'ç¡®è®¤æ¸…ç©º' }
    );

    if (!confirmed) return;

    try {
        if (targetIds.includes('all')) {
            await db.qzonePosts.clear();
        } else {
          
            await db.qzonePosts.where('authorId').anyOf(targetIds).delete();
        }

      
        qzonePostsCache = await db.qzonePosts.orderBy('timestamp').reverse().toArray();
        qzonePostsRenderCount = 0;
        await renderQzonePosts();
        
        document.getElementById('clear-posts-modal').classList.remove('visible'); // å…³é—­é€‰æ‹©å™¨
        await showCustomAlert('æ“ä½œæˆåŠŸ', 'é€‰å®šèŒƒå›´å†…çš„åŠ¨æ€å·²è¢«æ¸…ç©ºã€‚');

    } catch (error) {
        console.error("æ¸…ç©ºåŠ¨æ€æ—¶å‡ºé”™:", error);
        await showCustomAlert('æ“ä½œå¤±è´¥', `æ¸…ç©ºåŠ¨æ€æ—¶å‘ç”Ÿé”™è¯¯: ${error.message}`);
    }
}



async function handleDeleteThought(timestamp) {
    const confirmed = await showCustomConfirm(
        'ç¡®è®¤åˆ é™¤',
        'ç¡®å®šè¦æ°¸ä¹…åˆ é™¤è¿™æ¡å¿ƒå£°è®°å½•å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ¢å¤ã€‚',
        { confirmButtonClass: 'btn-danger', confirmText: 'ç¡®è®¤åˆ é™¤' }
    );

    if (confirmed) {
        const chat = state.chats[state.activeChatId];
        if (!chat || !chat.thoughtsHistory) return;

        const indexToDelete = chat.thoughtsHistory.findIndex(thought => thought.timestamp === timestamp);
        if (indexToDelete === -1) return; 

   
        const isLatest = indexToDelete === chat.thoughtsHistory.length - 1;

 
        chat.thoughtsHistory = chat.thoughtsHistory.filter(thought => thought.timestamp !== timestamp);


        if (isLatest) {
            if (chat.thoughtsHistory.length > 0) {

                const newLatestThought = chat.thoughtsHistory[chat.thoughtsHistory.length - 1];
                chat.heartfeltVoice = newLatestThought.heartfeltVoice;
                chat.randomJottings = newLatestThought.randomJottings;

                const heartfeltVoiceEl = document.getElementById('profile-heartfelt-voice');
                const randomJottingsEl = document.getElementById('profile-random-jottings');
                if (heartfeltVoiceEl) heartfeltVoiceEl.textContent = chat.heartfeltVoice;
                if (randomJottingsEl) randomJottingsEl.textContent = chat.randomJottings;

                console.log("å·²åˆ é™¤æœ€æ–°å¿ƒå£°ï¼Œå½“å‰å¿ƒå£°å·²å›žæ»šè‡³ä¸Šä¸€æ¡ã€‚");
            } else {

                chat.heartfeltVoice = '...';
                chat.randomJottings = '...';


                const heartfeltVoiceEl = document.getElementById('profile-heartfelt-voice');
                const randomJottingsEl = document.getElementById('profile-random-jottings');
                if (heartfeltVoiceEl) heartfeltVoiceEl.textContent = chat.heartfeltVoice;
                if (randomJottingsEl) randomJottingsEl.textContent = chat.randomJottings;

                console.log("å·²åˆ é™¤æœ€åŽä¸€æ¡å¿ƒå£°ï¼Œå½“å‰å¿ƒå£°å·²é‡ç½®ã€‚");
            }
        }

        await db.chats.put(chat);


        renderThoughtsHistory();

        await showCustomAlert('æˆåŠŸ', 'è¯¥æ¡è®°å½•å·²æˆåŠŸåˆ é™¤ã€‚');
    }
}


document.getElementById('thoughts-history-list').addEventListener('click', (e) => {
   
    const deleteBtn = e.target.closest('.thought-delete-btn');
    if (deleteBtn) {
     
        const timestamp = parseInt(deleteBtn.dataset.timestamp);
        if (!isNaN(timestamp)) {
           
            handleDeleteThought(timestamp);
        }
    }
});

        /**
         * ä»Žæ•°æ®åº“åŠ è½½CSSé¢„è®¾ï¼Œå¹¶å¡«å……åˆ°ä¸‹æ‹‰é€‰æ‹©æ¡†ä¸­
         */
        async function loadCssPresetsDropdown() {
            const selectEl = document.getElementById('css-preset-select');
            selectEl.innerHTML = '<option value="">-- é€‰æ‹©ä¸€ä¸ªé¢„è®¾ --</option>';
            
            const presets = await db.appearancePresets.where('type').equals('global_css').toArray();
            presets.forEach(preset => {
                const option = document.createElement('option');
                option.value = preset.id;
                option.textContent = preset.name;
                selectEl.appendChild(option);
            });
        }
        
        /**
         * å½“ç”¨æˆ·ä»Žä¸‹æ‹‰æ¡†é€‰æ‹©ä¸€ä¸ªCSSé¢„è®¾æ—¶ï¼ŒåŠ è½½è¯¥é¢„è®¾
         */
        async function handleCssPresetSelectionChange() {
            const selectEl = document.getElementById('css-preset-select');
            const selectedId = parseInt(selectEl.value);
            if (isNaN(selectedId)) return;
        
            const preset = await db.appearancePresets.get(selectedId);
            if (preset) {
                const cssInput = document.getElementById('global-css-input');
                cssInput.value = preset.value;
                applyGlobalCss(preset.value); 
            }
        }
        
        /**
         * å°†å½“å‰è¾“å…¥æ¡†ä¸­çš„CSSä¿å­˜ä¸ºä¸€ä¸ªæ–°çš„é¢„è®¾
         */
        async function saveCssPreset() {
            const name = await showCustomPrompt('ä¿å­˜CSSé¢„è®¾', 'è¯·è¾“å…¥é¢„è®¾åç§°');
            if (!name || !name.trim()) return;
        
            const cssValue = document.getElementById('global-css-input').value;
        
            const existingPreset = await db.appearancePresets.where({ name: name.trim(), type: 'global_css' }).first();
            if (existingPreset) {
                const confirmed = await showCustomConfirm('è¦†ç›–é¢„è®¾', `åä¸º â€œ${name.trim()}â€ çš„é¢„è®¾å·²å­˜åœ¨ã€‚è¦è¦†ç›–å®ƒå—ï¼Ÿ`, { confirmButtonClass: 'btn-danger' });
                if (!confirmed) return;
                
                await db.appearancePresets.update(existingPreset.id, { value: cssValue });
            } else {
                await db.appearancePresets.add({
                    name: name.trim(),
                    type: 'global_css',
                    value: cssValue
                });
            }
        
            await loadCssPresetsDropdown(); 
            alert('CSS é¢„è®¾å·²ä¿å­˜ï¼');
        }
        
        /**
         * åˆ é™¤å½“å‰é€‰ä¸­çš„CSSé¢„è®¾
         */
        async function deleteCssPreset() {
            const selectEl = document.getElementById('css-preset-select');
            const selectedId = parseInt(selectEl.value);
        
            if (isNaN(selectedId)) {
                alert('è¯·å…ˆä»Žä¸‹æ‹‰æ¡†ä¸­é€‰æ‹©ä¸€ä¸ªè¦åˆ é™¤çš„é¢„è®¾ã€‚');
                return;
            }
        
            const preset = await db.appearancePresets.get(selectedId);
            if (!preset) return;
        
            const confirmed = await showCustomConfirm('åˆ é™¤é¢„è®¾', `ç¡®å®šè¦åˆ é™¤é¢„è®¾ â€œ${preset.name}â€ å—ï¼Ÿ`, { confirmButtonClass: 'btn-danger' });
            if (confirmed) {
                await db.appearancePresets.delete(selectedId);
                await loadCssPresetsDropdown(); 
                alert('é¢„è®¾å·²åˆ é™¤ã€‚');
            }
        }
        
        

        /**
         * ä»Žæ•°æ®åº“åŠ è½½å­—ä½“é¢„è®¾ï¼Œå¹¶å¡«å……åˆ°ä¸‹æ‹‰é€‰æ‹©æ¡†ä¸­
         */
        async function loadFontPresetsDropdown() {
            const selectEl = document.getElementById('font-preset-select');
            selectEl.innerHTML = '<option value="">-- é€‰æ‹©ä¸€ä¸ªé¢„è®¾ --</option>';
            
            const presets = await db.appearancePresets.where('type').equals('font').toArray();
            presets.forEach(preset => {
                const option = document.createElement('option');
                option.value = preset.id;
                option.textContent = preset.name;
                selectEl.appendChild(option);
            });
        }

        /**
         * å½“ç”¨æˆ·ä»Žä¸‹æ‹‰æ¡†é€‰æ‹©ä¸€ä¸ªå­—ä½“é¢„è®¾æ—¶ï¼ŒåŠ è½½è¯¥é¢„è®¾
         */
        async function handleFontPresetSelectionChange() {
            const selectEl = document.getElementById('font-preset-select');
            const selectedId = parseInt(selectEl.value);
            if (isNaN(selectedId)) return;
        
            const preset = await db.appearancePresets.get(selectedId);
            if (preset) {
                const fontUrlInput = document.getElementById('font-url-input');
                fontUrlInput.value = preset.value;
                applyCustomFont(preset.value, true); 
            }
        }
        
        /**
         * å°†å½“å‰è¾“å…¥æ¡†ä¸­çš„å­—ä½“URLä¿å­˜ä¸ºä¸€ä¸ªæ–°çš„é¢„è®¾
         */
        async function saveFontPreset() {
            const name = await showCustomPrompt('ä¿å­˜å­—ä½“é¢„è®¾', 'è¯·è¾“å…¥é¢„è®¾åç§°');
            if (!name || !name.trim()) return;
        
            const fontUrl = document.getElementById('font-url-input').value.trim();
            if (!fontUrl) {
                alert("å­—ä½“URLä¸èƒ½ä¸ºç©ºï¼");
                return;
            }
        
            const existingPreset = await db.appearancePresets.where({ name: name.trim(), type: 'font' }).first();
            if (existingPreset) {
                const confirmed = await showCustomConfirm('è¦†ç›–é¢„è®¾', `åä¸º â€œ${name.trim()}â€ çš„é¢„è®¾å·²å­˜åœ¨ã€‚è¦è¦†ç›–å®ƒå—ï¼Ÿ`, { confirmButtonClass: 'btn-danger' });
                if (!confirmed) return;
                
                await db.appearancePresets.update(existingPreset.id, { value: fontUrl });
            } else {
                await db.appearancePresets.add({
                    name: name.trim(),
                    type: 'font',
                    value: fontUrl
                });
            }
        
            await loadFontPresetsDropdown();
            alert('å­—ä½“é¢„è®¾å·²ä¿å­˜ï¼');
        }
        
        /**
         * åˆ é™¤å½“å‰é€‰ä¸­çš„å­—ä½“é¢„è®¾
         */
        async function deleteFontPreset() {
            const selectEl = document.getElementById('font-preset-select');
            const selectedId = parseInt(selectEl.value);
        
            if (isNaN(selectedId)) {
                alert('è¯·å…ˆä»Žä¸‹æ‹‰æ¡†ä¸­é€‰æ‹©ä¸€ä¸ªè¦åˆ é™¤çš„é¢„è®¾ã€‚');
                return;
            }
        
            const preset = await db.appearancePresets.get(selectedId);
            if (!preset) return;
        
            const confirmed = await showCustomConfirm('åˆ é™¤é¢„è®¾', `ç¡®å®šè¦åˆ é™¤é¢„è®¾ â€œ${preset.name}â€ å—ï¼Ÿ`, { confirmButtonClass: 'btn-danger' });
            if (confirmed) {
                await db.appearancePresets.delete(selectedId);
                await loadFontPresetsDropdown();
                alert('é¢„è®¾å·²åˆ é™¤ã€‚');
            }
        }
 async function loadAppearancePresetsDropdown() {
    const selectEl = document.getElementById('appearance-preset-select');
    selectEl.innerHTML = '<option value="">-- é€‰æ‹©ä¸€ä¸ªé¢„è®¾ --</option>';
    
    const presets = await db.appearancePresets.where('type').equals('appearance').toArray();
    presets.forEach(preset => {
        const option = document.createElement('option');
        option.value = preset.id;
        option.textContent = preset.name;
        selectEl.appendChild(option);
    });

    

    
    const currentSettings = {
        wallpaper: state.globalSettings.wallpaper,
        cphoneWallpaper: state.globalSettings.cphoneWallpaper,
        globalChatBackground: state.globalSettings.globalChatBackground,
        appIcons: state.globalSettings.appIcons,
        cphoneAppIcons: state.globalSettings.cphoneAppIcons,
        chatActionButtonsOrder: state.globalSettings.chatActionButtonsOrder,
        theme: localStorage.getItem('ephone-theme') || 'light',
        showStatusBar: state.globalSettings.showStatusBar,
        notificationSoundUrl: state.globalSettings.notificationSoundUrl,
        widgetData: state.globalSettings.widgetData
    };

    let matchingPresetId = null;

    
    for (const preset of presets) {
        
        if (JSON.stringify(preset.value) === JSON.stringify(currentSettings)) {
            matchingPresetId = preset.id;
            break; 
        }
    }

    
    if (matchingPresetId) {
        selectEl.value = matchingPresetId;
    } else {
        
        selectEl.value = '';
    }
    
}
  

/**
 * å½“ç”¨æˆ·ä»Žä¸‹æ‹‰æ¡†é€‰æ‹©ä¸€ä¸ªå¤–è§‚é¢„è®¾æ—¶ï¼ŒåŠ è½½å¹¶åº”ç”¨è¯¥é¢„è®¾
 */
async function handleAppearancePresetSelectionChange() {
    const selectEl = document.getElementById('appearance-preset-select');
    const selectedId = parseInt(selectEl.value);
    if (isNaN(selectedId)) return;

    const preset = await db.appearancePresets.get(selectedId);
    if (preset && preset.value) {
        const data = preset.value;
        
        
        Object.assign(state.globalSettings, data);
        
        
        applyTheme(data.theme || 'light');
        
        
        await db.globalSettings.put(state.globalSettings);
        
        
        applyGlobalWallpaper();
        applyCPhoneWallpaper();
        applyAppIcons();
        applyCPhoneAppIcons();
        applyStatusBarVisibility();
        applyWidgetData();
        
        
        renderWallpaperScreen();

        alert(`å·²æˆåŠŸåŠ è½½å¤–è§‚é¢„è®¾ï¼šâ€œ${preset.name}â€`);
    }
}

/**
 * å°†å½“å‰çš„æ‰€æœ‰å¤–è§‚è®¾ç½®ä¿å­˜ä¸ºä¸€ä¸ªæ–°çš„é¢„è®¾
 */
async function saveAppearancePreset() {
    const name = await showCustomPrompt('ä¿å­˜å¤–è§‚é¢„è®¾', 'è¯·è¾“å…¥é¢„è®¾åç§°');
    if (!name || !name.trim()) return;

    
    const appearanceData = {
        wallpaper: state.globalSettings.wallpaper,
        cphoneWallpaper: state.globalSettings.cphoneWallpaper,
        globalChatBackground: state.globalSettings.globalChatBackground,
        appIcons: state.globalSettings.appIcons,
        cphoneAppIcons: state.globalSettings.cphoneAppIcons,
        chatActionButtonsOrder: state.globalSettings.chatActionButtonsOrder,
        theme: localStorage.getItem('ephone-theme') || 'light',
        showStatusBar: state.globalSettings.showStatusBar,
        notificationSoundUrl: state.globalSettings.notificationSoundUrl,
        widgetData: state.globalSettings.widgetData
    };

    
    const existingPreset = await db.appearancePresets.where({ name: name.trim(), type: 'appearance' }).first();
    if (existingPreset) {
        const confirmed = await showCustomConfirm('è¦†ç›–é¢„è®¾', `åä¸º â€œ${name.trim()}â€ çš„é¢„è®¾å·²å­˜åœ¨ã€‚è¦è¦†ç›–å®ƒå—ï¼Ÿ`, { confirmButtonClass: 'btn-danger' });
        if (!confirmed) return;
        
        await db.appearancePresets.update(existingPreset.id, { value: appearanceData });
    } else {
        await db.appearancePresets.add({
            name: name.trim(),
            type: 'appearance', 
            value: appearanceData
        });
    }

    
    await loadAppearancePresetsDropdown();
    alert('å¤–è§‚é¢„è®¾å·²ä¿å­˜ï¼');
}

/**
 * åˆ é™¤å½“å‰é€‰ä¸­çš„å¤–è§‚é¢„è®¾
 */
async function deleteAppearancePreset() {
    const selectEl = document.getElementById('appearance-preset-select');
    const selectedId = parseInt(selectEl.value);

    if (isNaN(selectedId)) {
        alert('è¯·å…ˆä»Žä¸‹æ‹‰æ¡†ä¸­é€‰æ‹©ä¸€ä¸ªè¦åˆ é™¤çš„é¢„è®¾ã€‚');
        return;
    }

    const preset = await db.appearancePresets.get(selectedId);
    if (!preset) return;

    const confirmed = await showCustomConfirm('åˆ é™¤é¢„è®¾', `ç¡®å®šè¦åˆ é™¤é¢„è®¾ â€œ${preset.name}â€ å—ï¼Ÿ`, { confirmButtonClass: 'btn-danger' });
    if (confirmed) {
        await db.appearancePresets.delete(selectedId);
        await loadAppearancePresetsDropdown();
        alert('é¢„è®¾å·²åˆ é™¤ã€‚');
    }
}

        

        /**
         * ä»Žæ•°æ®åº“åŠ è½½æ°”æ³¡ä¸»é¢˜é¢„è®¾ï¼Œå¹¶å¡«å……åˆ°ä¸‹æ‹‰é€‰æ‹©æ¡†ä¸­
         */
        async function loadThemePresetsDropdown() {
            const selectEl = document.getElementById('theme-preset-select');
            selectEl.innerHTML = '<option value="">-- é€‰æ‹©ä¸€ä¸ªé¢„è®¾ --</option>';
            
            const presets = await db.appearancePresets.where('type').equals('bubble_theme').toArray();
            presets.forEach(preset => {
                const option = document.createElement('option');
                option.value = preset.id;
                option.textContent = preset.name;
                selectEl.appendChild(option);
            });
        }

/**
         * å½“ç”¨æˆ·ä»Žä¸‹æ‹‰æ¡†é€‰æ‹©ä¸€ä¸ªä¸»é¢˜é¢„è®¾æ—¶ï¼ŒåŠ è½½è¯¥é¢„è®¾
         */
        async function handleThemePresetSelectionChange() {
            const selectEl = document.getElementById('theme-preset-select');
            const selectedId = parseInt(selectEl.value);
            if (isNaN(selectedId)) return;
        
            const preset = await db.appearancePresets.get(selectedId);
            if (preset) {
                
                
                const baseTheme = preset.value.base || 'default';
                const customCss = preset.value.custom || '';

                
                const themeRadio = document.querySelector(`input[name="theme-select"][value="${baseTheme}"]`);
                if (themeRadio) {
                    themeRadio.checked = true;
                }

                
                const customCssInput = document.getElementById('custom-css-input');
                customCssInput.value = customCss;

                
                updateSettingsPreview(); 
                  
            }
        }
        
 /**
         * å°†å½“å‰é€‰æ‹©çš„æ°”æ³¡ä¸»é¢˜ä¿å­˜ä¸ºä¸€ä¸ªæ–°çš„é¢„è®¾
         */
        async function saveThemePreset() {
            const name = await showCustomPrompt('ä¿å­˜ä¸»é¢˜é¢„è®¾', 'è¯·è¾“å…¥é¢„è®¾åç§°');
            if (!name || !name.trim()) return;
        
            
            
            const selectedThemeRadio = document.querySelector('input[name="theme-select"]:checked');
            const themeValue = selectedThemeRadio ? selectedThemeRadio.value : 'default';

            
            const cssValue = document.getElementById('custom-css-input').value.trim();

            
            const presetValueObject = {
                base: themeValue,
                custom: cssValue
            };
              
        
            const existingPreset = await db.appearancePresets.where({ name: name.trim(), type: 'bubble_theme' }).first();
            if (existingPreset) {
                const confirmed = await showCustomConfirm('è¦†ç›–é¢„è®¾', `åä¸º â€œ${name.trim()}â€ çš„é¢„è®¾å·²å­˜åœ¨ã€‚è¦è¦†ç›–å®ƒå—ï¼Ÿ`, { confirmButtonClass: 'btn-danger' });
                if (!confirmed) return;
                
                
                await db.appearancePresets.update(existingPreset.id, { value: presetValueObject });
            } else {
                await db.appearancePresets.add({
                    name: name.trim(),
                    type: 'bubble_theme',
                    
                    value: presetValueObject
                });
            }
        
            await loadThemePresetsDropdown();
            alert('ä¸»é¢˜é¢„è®¾å·²ä¿å­˜ï¼');
        }
        
        /**
         * åˆ é™¤å½“å‰é€‰ä¸­çš„ä¸»é¢˜é¢„è®¾
         */
        async function deleteThemePreset() {
            const selectEl = document.getElementById('theme-preset-select');
            const selectedId = parseInt(selectEl.value);
        
            if (isNaN(selectedId)) {
                alert('è¯·å…ˆä»Žä¸‹æ‹‰æ¡†ä¸­é€‰æ‹©ä¸€ä¸ªè¦åˆ é™¤çš„é¢„è®¾ã€‚');
                return;
            }
        
            const preset = await db.appearancePresets.get(selectedId);
            if (!preset) return;
        
            const confirmed = await showCustomConfirm('åˆ é™¤é¢„è®¾', `ç¡®å®šè¦åˆ é™¤é¢„è®¾ â€œ${preset.name}â€ å—ï¼Ÿ`, { confirmButtonClass: 'btn-danger' });
            if (confirmed) {
                await db.appearancePresets.delete(selectedId);
                await loadThemePresetsDropdown();
                alert('é¢„è®¾å·²åˆ é™¤ã€‚');
            }
        }
        
        
        
        /**
         * ã€æ€»å…¥å£ã€‘æ‰“å¼€åˆ†ç±»ç®¡ç†å¼¹çª—
         */
        async function openStickerCategoryManager() {
            await renderStickerCategoriesInManager();
            document.getElementById('sticker-category-manager-modal').classList.add('visible');
        }
        
        /**
         * åœ¨å¼¹çª—ä¸­æ¸²æŸ“å·²å­˜åœ¨çš„åˆ†ç±»åˆ—è¡¨
         */
        async function renderStickerCategoriesInManager() {
            const listEl = document.getElementById('existing-sticker-categories-list');
            const categories = await db.stickerCategories.toArray();
            listEl.innerHTML = '';
            if (categories.length === 0) {
                listEl.innerHTML = '<p style="text-align: center; color: var(--text-secondary);">è¿˜æ²¡æœ‰ä»»ä½•åˆ†ç±»</p>';
                return;
            }
            categories.forEach(cat => {
                const item = document.createElement('div');
                item.className = 'existing-group-item'; 
                item.innerHTML = `
                    <span class="group-name">${cat.name}</span>
                    <span class="delete-group-btn" data-id="${cat.id}">Ã—</span>
                `;
                listEl.appendChild(item);
            });
        }
        
        /**
         * æ·»åŠ ä¸€ä¸ªæ–°çš„è¡¨æƒ…åˆ†ç±»
         */
        async function addNewStickerCategory() {
            const input = document.getElementById('new-sticker-category-name-input');
            const name = input.value.trim();
            if (!name) {
                alert('åˆ†ç±»åä¸èƒ½ä¸ºç©ºï¼');
                return;
            }
            const existing = await db.stickerCategories.where('name').equals(name).first();
            if (existing) {
                alert(`åˆ†ç±» "${name}" å·²ç»å­˜åœ¨äº†ï¼`);
                return;
            }
            await db.stickerCategories.add({ name });
            input.value = '';
            await renderStickerCategoriesInManager();
        }
        
        /**
         * ã€æ ¸å¿ƒã€‘åˆ é™¤ä¸€ä¸ªåˆ†ç±»ï¼Œå¹¶ä¸€å¹¶åˆ é™¤è¯¥åˆ†ç±»ä¸‹çš„æ‰€æœ‰è¡¨æƒ…åŒ…
         * @param {number} categoryId - è¦åˆ é™¤çš„åˆ†ç±»çš„ID
         */
        async function deleteStickerCategory(categoryId) {
            const category = await db.stickerCategories.get(categoryId);
            if (!category) return;

            const stickersInCateogry = await db.userStickers.where('categoryId').equals(categoryId).count();
            
            const confirmMessage = stickersInCateogry > 0 
                ? `ç¡®å®šè¦åˆ é™¤åˆ†ç±»ã€Š${category.name}ã€‹å—ï¼Ÿ\n\nã€ã€ã€è­¦å‘Šã€‘ã€‘ã€‘\næ­¤æ“ä½œå°†åŒæ—¶æ°¸ä¹…åˆ é™¤è¯¥åˆ†ç±»ä¸‹çš„ ${stickersInCateogry} ä¸ªè¡¨æƒ…åŒ…ï¼Œä¸”æ— æ³•æ¢å¤ï¼`
                : `ç¡®å®šè¦åˆ é™¤åˆ†ç±»ã€Š${category.name}ã€‹å—ï¼Ÿ`;

            const confirmed = await showCustomConfirm(
                'ç¡®è®¤åˆ é™¤åˆ†ç±»', 
                confirmMessage, 
                { confirmButtonClass: 'btn-danger' }
            );

            if (confirmed) {
                try {
                    
                    await db.transaction('rw', db.stickerCategories, db.userStickers, async () => {
                        
                        const stickerIdsToDelete = await db.userStickers.where('categoryId').equals(categoryId).primaryKeys();
                        
                        
                        if (stickerIdsToDelete.length > 0) {
                            await db.userStickers.bulkDelete(stickerIdsToDelete);
                        }

                        
                        await db.stickerCategories.delete(categoryId);
                    });

                    
                    state.userStickers = await db.userStickers.toArray();
                    if (activeStickerCategoryId === categoryId) {
                        activeStickerCategoryId = 'all'; 
                    }
                    await renderStickerCategoriesInManager(); 
                    await renderStickerPanel(); 
                    
                    alert(`åˆ†ç±»ã€Š${category.name}ã€‹åŠå…¶ä¸‹çš„è¡¨æƒ…å·²æˆåŠŸåˆ é™¤ã€‚`);

                } catch (error) {
                    console.error("åˆ é™¤åˆ†ç±»åŠè¡¨æƒ…æ—¶å‡ºé”™:", error);
                    alert("åˆ é™¤å¤±è´¥ï¼Œè¯·æŸ¥çœ‹æŽ§åˆ¶å°é”™è¯¯ä¿¡æ¯ã€‚");
                }
            }
        }


        function switchStickerCategory(categoryId) {
            activeStickerCategoryId = categoryId;
            document.querySelectorAll('.sticker-category-tab').forEach(tab => {
                tab.classList.toggle('active', String(tab.dataset.categoryId) === String(categoryId));
            });
            renderStickerPanel(false);
            
            
            const selectAllCheckbox = document.getElementById('select-all-stickers-checkbox');
            if(selectAllCheckbox) selectAllCheckbox.checked = false;
        }
          
/**
 * ã€å…¨æ–°ã€‘ä»…å¯¼å‡ºå½“å‰å•ä¸ªèŠå¤©çš„å¤‡ä»½
 */
async function exportSingleChat() {
    if (!state.activeChatId) return;
    const chat = state.chats[state.activeChatId];
    if (!chat) return;

    try {
        const backupData = {
            type: 'EPhoneSingleChat', 
            version: 1,
            chatData: chat
        };

        const blob = new Blob(
            [JSON.stringify(backupData, null, 2)], 
            { type: 'application/json' }
        );
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        
        link.download = `EPhone-Chat-${chat.name}-${new Date().toISOString().split('T')[0]}.json`;
        link.click();
        URL.revokeObjectURL(url);
        
        await showCustomAlert('å¯¼å‡ºæˆåŠŸ', `ä¸Žâ€œ${chat.name}â€çš„èŠå¤©è®°å½•å·²æˆåŠŸå¯¼å‡ºï¼`);

    } catch (error) {
        console.error("å¯¼å‡ºå•ä¸ªèŠå¤©æ—¶å‡ºé”™:", error);
        await showCustomAlert('å¯¼å‡ºå¤±è´¥', `å‘ç”Ÿäº†ä¸€ä¸ªé”™è¯¯: ${error.message}`);
    }
}

/**
 * ã€å…¨æ–°ã€‘å°†å•ä¸ªèŠå¤©çš„å¤‡ä»½å¯¼å…¥å¹¶è¦†ç›–å½“å‰èŠå¤©
 * @param {File} file - ç”¨æˆ·é€‰æ‹©çš„ .json å¤‡ä»½æ–‡ä»¶
 */
async function importSingleChat(file) {
    if (!file || !state.activeChatId) return;
    const currentChatId = state.activeChatId;
    const currentChat = state.chats[currentChatId];

    try {
        const text = await file.text();
        const data = JSON.parse(text);

        
        if (data.type !== 'EPhoneSingleChat' || !data.chatData) {
            throw new Error("æ–‡ä»¶æ ¼å¼ä¸æ­£ç¡®ï¼Œè¿™ä¸æ˜¯ä¸€ä¸ªæœ‰æ•ˆçš„å•èŠå¤‡ä»½æ–‡ä»¶ã€‚");
        }

        
        const confirmed = await showCustomConfirm(
            'ä¸¥é‡è­¦å‘Šï¼',
            `è¿™å°†ç”¨å¤‡ä»½æ–‡ä»¶ä¸­çš„æ•°æ®ã€å®Œå…¨è¦†ç›–ã€‘å½“å‰ä¸Žâ€œ${currentChat.name}â€çš„èŠå¤©è®°å½•å’Œè®¾ç½®ã€‚æ­¤æ“ä½œä¸å¯æ’¤é”€ï¼<br><br><strong>ç¡®å®šè¦ç»§ç»­å—ï¼Ÿ</strong>`,
            { confirmButtonClass: 'btn-danger', confirmText: 'ç¡®è®¤è¦†ç›–' }
        );

        if (!confirmed) return;

        
        const importedChatData = data.chatData;
        
        
        importedChatData.id = currentChatId; 
        
        
        await db.chats.put(importedChatData);
        state.chats[currentChatId] = importedChatData;

        
        await showCustomAlert('å¯¼å…¥æˆåŠŸ', 'èŠå¤©è®°å½•å·²æˆåŠŸè¦†ç›–ï¼æ­£åœ¨åˆ·æ–°ç•Œé¢...');
        
        
        renderChatInterface(currentChatId);
        renderChatList();
        document.getElementById('chat-settings-btn').click(); 

    } catch (error) {
        console.error("å¯¼å…¥å•ä¸ªèŠå¤©æ—¶å‡ºé”™:", error);
        await showCustomAlert('å¯¼å…¥å¤±è´¥', `æ–‡ä»¶è§£æžæˆ–åº”ç”¨å¤±è´¥: ${error.message}`);
    }
}


/**
 * ã€æ€»å…¥å£ã€‘æ‰“å¼€è§’è‰²é€‰æ‹©ç•Œé¢
 */
function openCharacterSelector() {
    renderCharacterSelector();
    showScreen('character-selection-screen');
}

/**
 * æ¸²æŸ“è§’è‰²é€‰æ‹©åˆ—è¡¨
 */
function renderCharacterSelector() {
    const gridEl = document.getElementById('character-grid');
    gridEl.innerHTML = '';
    
    
    const characters = Object.values(state.chats).filter(chat => !chat.isGroup);

    if (characters.length === 0) {
        gridEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">è¿˜æ²¡æœ‰å¯ä»¥æŸ¥çœ‹æ‰‹æœºçš„è§’è‰²å“¦~</p>';
        return;
    }

    characters.forEach(char => {
        const item = document.createElement('div');
        item.className = 'character-select-item';
        item.innerHTML = `
            <img src="${char.settings.aiAvatar || defaultAvatar}" class="avatar">
            <span class="name">${char.name}</span>
        `;
        item.addEventListener('click', () => switchToCharacterPhone(char.id));
        gridEl.appendChild(item);
    });
}

        
        /**
         * åˆ‡æ¢åˆ°æŒ‡å®šè§’è‰²çš„æ‰‹æœºç•Œé¢
         * @param {string} characterId - è§’è‰²çš„ID
         */
        async function switchToCharacterPhone(characterId) {
            activeCharacterId = characterId;
            console.log(`å·²åˆ‡æ¢åˆ°è§’è‰² ${characterId} çš„æ‰‹æœº`);
            
            
            applyCPhoneWallpaper();
            applyCPhoneAppIcons();
            
            
            renderCharHomeScreen();
            showScreen('character-phone-screen');
        }
          

/**
 * è¿”å›žåˆ°ç”¨æˆ·è‡ªå·±çš„æ‰‹æœºä¸»å±å¹•
 */
function switchToMyPhone() {
    activeCharacterId = null;
    console.log("å·²è¿”å›žæˆ‘çš„æ‰‹æœº");
    showScreen('home-screen');
}

/**
 * æ¸²æŸ“Cphoneçš„ä¸»å±å¹•ï¼ˆä¸»è¦æ˜¯æ›´æ–°æ—¶é’Ÿï¼‰
 */
function renderCharHomeScreen() {
    const now = new Date();
    const timeString = now.toLocaleTimeString('zh-CN', { hour: '2-digit', minute: '2-digit' });
    const dateString = now.toLocaleDateString('zh-CN', { weekday: 'long', month: 'long', day: 'numeric' });
    document.getElementById('char-main-time').textContent = timeString;
    document.getElementById('char-main-date').textContent = dateString;
    switchToCharScreen('char-home-screen');
}

/**
 * åœ¨Cphoneå†…éƒ¨åˆ‡æ¢ä¸åŒçš„Appå±å¹•
 * @param {string} screenId - è¦æ˜¾ç¤ºçš„è§’è‰²Appå±å¹•ID
 */
function switchToCharScreen(screenId) {
    document.querySelectorAll('.char-screen').forEach(s => s.classList.remove('active'));
    document.getElementById(screenId).classList.add('active');
}

window.switchToCharScreen = switchToCharScreen;



         /**
         * ã€æ€»åˆ†å‘ | V3.0 | æœ€ç»ˆä¿®å¤ç‰ˆ | å·²æ·»åŠ éŸ³ä¹Appã€‘æ‰“å¼€Cphoneå†…çš„App
         * @param {string} appName - Appçš„ç®€ç§° (qq, album, amap...)
         */
        async function openCharApp(appName) {
            if (!activeCharacterId) return;
            const char = state.chats[activeCharacterId];
            
    
    await logAppUsage(activeCharacterId, appName);
      

            switch(appName) {
                case 'qq':
                    renderCharSimulatedQQ();
                    switchToCharScreen('char-qq-screen');
                    break;
                case 'album':
                    renderCharAlbum();
                    switchToCharScreen('char-album-screen');
                    break;
                case 'browser':
                    renderCharBrowserHistory();
                    switchToCharScreen('char-browser-screen');
                    break;
                case 'taobao':
                    renderCharTaobao();
                    switchToCharScreen('char-taobao-screen');
                    break;
                case 'memo':
                    renderCharMemoList();
                    switchToCharScreen('char-memo-screen');
                    break;
                case 'diary':
                    renderCharDiaryList();
                    switchToCharScreen('char-diary-screen');
                    break;
                case 'amap':
                    renderCharAmap();
                    switchToCharScreen('char-amap-screen');
                    break;
                
                
                
                case 'music':
                    renderCharMusicScreen(); 
                    switchToCharScreen('char-music-screen'); 
                    break;
                

                case 'usage':
                    renderCharAppUsage();
                    switchToCharScreen('char-usage-screen');
                    break;
            }
        }
        
        /**
         * ã€å…¨æ–° | V3.2 ç»ˆæžé˜²ç©ºçª—+ç”Ÿå›¾å¼€å…³+æè¿°æ˜¾ç¤ºç‰ˆã€‘æ¸²æŸ“è§’è‰²ç›¸å†Œ
         */
        async function renderCharAlbum() {
            const gridEl = document.getElementById('char-album-grid');
            gridEl.innerHTML = '';
            if (!activeCharacterId) return;
            const char = state.chats[activeCharacterId];
        
            const photos = char.simulatedAlbum || [];
        
            if (photos.length === 0) {
                gridEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">TAçš„ç›¸å†Œè¿˜æ˜¯ç©ºçš„ï¼Œ<br>ç‚¹å‡»å³ä¸Šè§’åˆ·æ–°æŒ‰é’®ç”Ÿæˆä¸€äº›ç…§ç‰‡å§ï¼</p>';
                return;
            }
        
            const fallbackImageUrl = `https://i.postimg.cc/KYr2qRCK/1.jpg`;

            photos.forEach(photo => {
                const item = document.createElement('div');
                item.className = 'char-photo-item';
                item.dataset.description = photo.description;
                gridEl.appendChild(item);

                
                
                if (state.globalSettings.enableAiDrawing) {
                    
                    item.style.backgroundColor = '#e9ecef';
                    const containsNonEnglish = /[^\x00-\x7F]/.test(photo.image_prompt);
                    const isValidPrompt = photo.image_prompt && photo.image_prompt.trim() && !containsNonEnglish;
                    const finalPrompt = isValidPrompt ? photo.image_prompt : 'a beautiful scenery, anime style, cinematic lighting';
                    const imageUrl = `https://image.pollinations.ai/prompt/${encodeURIComponent(finalPrompt)}`;
                    
                    const img = new Image();
                    img.onload = function() { item.style.backgroundImage = `url(${this.src})`; };
                    img.onerror = function() { item.style.backgroundImage = `url(${fallbackImageUrl})`; };
                    img.src = imageUrl;

                } else {
                    
                    item.style.backgroundColor = '#f0f2f5'; 
                    item.style.border = '1px solid #e0e0e0'; 
                    
                    
                    const descriptionEl = document.createElement('p');
                    descriptionEl.className = 'char-photo-description'; 
                    descriptionEl.textContent = photo.description || '(è¿™å¼ ç…§ç‰‡æ²¡æœ‰æè¿°)'; 
                    
                    
                    item.appendChild(descriptionEl);
                }
       
            });
        }
          

/**
 * ã€å…¨æ–°ã€‘åŠ¨æ€ç”Ÿæˆå¹¶æ¸²æŸ“è§’è‰²çš„æµè§ˆå™¨åŽ†å²è®°å½•
 */
function renderCharBrowserHistory() {
    const listEl = document.getElementById('char-browser-history');
    listEl.innerHTML = '';
    if (!activeCharacterId) return;

    const char = state.chats[activeCharacterId];
    
    const historyKeywords = [char.name, "çˆ±å¥½", "æ—…æ¸¸", "ç¾Žé£Ÿ", "æ–°é—»", ...char.settings.aiPersona.split(/ï¼Œ|ã€‚|\s/).slice(0, 5)];
    const historySites = ["çŸ¥ä¹Ž", "Bilibili", "å°çº¢ä¹¦", "å¾®åš", "ç»´åŸºç™¾ç§‘"];

    for (let i = 0; i < 15; i++) {
        const keyword = historyKeywords[Math.floor(Math.random() * historyKeywords.length)];
        const site = historySites[Math.floor(Math.random() * historySites.length)];
        const item = document.createElement('div');
        item.className = 'char-browser-item';
        item.innerHTML = `
            <div class="title">${keyword} - ${site}</div>
            <div class="url">www.${site.toLowerCase()}.com/${keyword}</div>
        `;
        listEl.appendChild(item);
    }
}

        
        /**
         * ã€å…¨æ–° | V3.1 æ— é’±åŒ…ç‰ˆ | æœ€ç»ˆä¿®å¤ã€‘æ¸²æŸ“è§’è‰²çš„æ·˜å®â€œè´­ä¹°è®°å½•â€é¡µé¢
         */
        function renderCharTaobao() {
            const gridEl = document.getElementById('char-product-grid');
            gridEl.innerHTML = '';
            if (!activeCharacterId) return;

            const char = state.chats[activeCharacterId];
            const purchases = char.simulatedTaobaoHistory?.purchases || [];

            if (purchases.length === 0) {
                gridEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">TAæœ€è¿‘å¥½åƒä»€ä¹ˆéƒ½æ²¡ä¹°å‘¢ï¼Œ<br>ç‚¹å‡»å³ä¸Šè§’åˆ·æ–°æŒ‰é’®ç”Ÿæˆä¸€äº›è®°å½•å§ï¼</p>';
                return;
            }

            purchases.forEach(item => {
                const itemEl = document.createElement('div');
                itemEl.className = 'char-product-item';
                itemEl.dataset.reason = item.reason;
                
                let imageOrTextHtml;
                if (state.globalSettings.enableAiDrawing) {
                    const imageUrl = `https://image.pollinations.ai/prompt/${encodeURIComponent(item.image_prompt || 'a random product')}`;
                    imageOrTextHtml = `<img src="${imageUrl}" class="product-image">`;
                } else {
                    imageOrTextHtml = `
                        <div class="char-product-description-overlay">
                            <p class="char-photo-description">${item.reason || '(æ— è´­ä¹°ç†ç”±)'}</p>
                        </div>
                    `;
                }

                
                itemEl.innerHTML = `
                    ${imageOrTextHtml}
                    <div class="product-info">
                        <div class="product-name">${item.itemName}</div>
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-top: 8px;">
                            <div class="product-price">${(item.price || 0).toFixed(2)}</div>
                            <div class="char-product-status">${item.status}</div>
                        </div>
                    </div>
                `;
                  
                gridEl.appendChild(itemEl);
            });
        }
/**
 * åˆ‡æ¢å›žCphoneçš„ä¸»å±å¹•
 */
function switchToCharHomeScreen() {
    switchToCharScreen('char-home-screen');
}




/**
 * æ¸²æŸ“è§’è‰²è§†è§’çš„QQèŠå¤©åˆ—è¡¨ (ç®€åŒ–ç‰ˆ)
 */
function renderCharChatList() {
    const listEl = document.getElementById('char-chat-list');
    listEl.innerHTML = '';
    if (!activeCharacterId) return;

    
    const relatedChats = Object.values(state.chats).filter(chat => {
        
        if (chat.id === activeCharacterId) return true;
        
        if (chat.isGroup && chat.members.some(m => m.id === activeCharacterId)) return true;
        return false;
    });

    relatedChats.forEach(chat => {
        const item = createChatListItem(chat); 
        listEl.appendChild(item);
    });
}

/**
 * è®°å½•Appä½¿ç”¨æ—¥å¿—
 */
async function logAppUsage(characterId, appName) {
    const char = state.chats[characterId];
    if (!char) return;
    if (!char.appUsageLog) {
        char.appUsageLog = [];
    }
    char.appUsageLog.push({
        appName: appName,
        timestamp: Date.now()
    });
    
    if (char.appUsageLog.length > 50) {
        char.appUsageLog.shift();
    }
    await db.chats.put(char);
}

/**
 * æ¸²æŸ“Appä½¿ç”¨è®°å½•
 */
function renderCharAppUsage() {
    const listEl = document.getElementById('char-usage-list');
    listEl.innerHTML = '';
    const char = state.chats[activeCharacterId];
    const log = (char.appUsageLog || []).slice().reverse(); 

    if (log.length === 0) {
        listEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">è¿˜æ²¡æœ‰ä»»ä½•ä½¿ç”¨è®°å½•ã€‚</p>';
        return;
    }

    const appNameMap = {
        'qq': 'QQ', 'album': 'ç›¸å†Œ', 'browser': 'æµè§ˆå™¨', 'taobao': 'æ·˜å®',
        'memo': 'å¤‡å¿˜å½•', 'diary': 'æ—¥è®°', 'amap': 'é«˜å¾·åœ°å›¾', 'usage': 'Appè®°å½•'
    };

    log.forEach(entry => {
        const item = document.createElement('div');
        item.className = 'usage-item';
        item.innerHTML = `
            <div class="timestamp">${new Date(entry.timestamp).toLocaleString()}</div>
            <div class="action">æ‰“å¼€äº† <strong>${appNameMap[entry.appName] || entry.appName}</strong></div>
        `;
        listEl.appendChild(item);
    });
}

/**
 * æ¨¡æ‹Ÿè§’è‰²å‘é€ä½ç½®åˆ†äº«
 */
async function sendCharLocationShare(locationName) {
    const userChat = state.chats[activeCharacterId]; 
    if (!userChat) return;

    const msg = {
        role: 'assistant', 
        senderName: userChat.originalName,
        type: 'location_share',
        content: locationName,
        imageUrl: 'https://s3plus.meituan.net/opapisdk/op_ticket_885190757_1756262526935_qdqqd_4uque3.jpeg',
        timestamp: Date.now()
    };

    userChat.history.push(msg);
    await db.chats.put(userChat);
    
    
    if (state.activeChatId === activeCharacterId) {
        appendMessage(msg, userChat);
    }
    
    await showCustomAlert("åˆ†äº«æˆåŠŸ", `â€œ${userChat.name}â€ çš„ä½ç½®å·²å‘é€åˆ°ä½ ä»¬çš„èŠå¤©ä¸­ã€‚`);
}


/**
 * ã€V2.1 | å·²æ·»åŠ æ”¶è—åŠŸèƒ½ã€‘ç‚¹å‡»å¤‡å¿˜å½•åˆ—è¡¨é¡¹æ—¶ï¼Œæ‰“å¼€è¯¦æƒ…é¡µé¢æŸ¥çœ‹å…¶å†…å®¹
 * @param {number} memoId - è¦æŸ¥çœ‹çš„å¤‡å¿˜å½•çš„ID
 */
async function viewMemo(memoId) {
    const char = state.chats[activeCharacterId];
    if (!char || !char.memos) return;

    const memo = char.memos.find(m => m.id === memoId);
    if (memo) {
        
        activeMemoForViewing = memo; 

        const titleEl = document.getElementById('char-memo-detail-title');
        const contentEl = document.getElementById('char-memo-detail-content');
        const favBtn = document.getElementById('favorite-memo-btn');

        if (titleEl) titleEl.textContent = memo.title;
        if (contentEl) contentEl.value = memo.content;
        
        
        const existingFavorite = await db.favorites.where({ type: 'char_memo', 'content.id': memoId }).first();
        favBtn.classList.toggle('active', !!existingFavorite);

        switchToCharScreen('char-memo-detail-screen');
    }
}

/**
 * ã€V2.0 | æ”¯æŒæ ‡é¢˜ã€‘æ¸²æŸ“Cphoneçš„å¤‡å¿˜å½•åˆ—è¡¨
 */
function renderCharMemoList() {
    const listEl = document.getElementById('char-memo-list');
    listEl.innerHTML = '';
    const char = state.chats[activeCharacterId];
    const memos = (char.memos || []).slice().reverse();

    if (memos.length === 0) {
        listEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">è¿˜æ²¡æœ‰å¤‡å¿˜å½•ã€‚</p>';
        return;
    }

    memos.forEach(memo => {
        const item = document.createElement('div');
        
        item.className = 'list-item'; 
        item.innerHTML = `
            <div class="item-title">${memo.title}</div>
            <div class="item-content">${(memo.content || '').split('\n')[0]}</div>
        `;
        
        item.addEventListener('click', () => viewMemo(memo.id));
        addLongPressListener(item, () => deleteMemo(memo.id));
        listEl.appendChild(item);
    });
}

/**
 * ã€V2.1 | æµç¨‹ä¿®æ­£ã€‘æ‰“å¼€ç¼–è¾‘å™¨ä»¥åˆ›å»ºæ–°çš„å¤‡å¿˜å½•
 */
async function openMemoEditor(memoId = null) {
    editingMemoId = null; 
    
    
    const newTitle = await showCustomPrompt("æ–°å»ºå¤‡å¿˜å½•", "è¯·è¾“å…¥æ ‡é¢˜");
    if (newTitle === null || !newTitle.trim()) return;

    const newContent = await showCustomPrompt(`æ ‡é¢˜: ${newTitle}`, "è¯·è¾“å…¥å¤‡å¿˜å½•å†…å®¹", "", 'textarea');
    if (newContent !== null) {
        
        await saveMemo({ title: newTitle.trim(), content: newContent });
        switchToCharScreen('char-memo-screen'); 
    }
}

/**
 * ã€V2.0 | æ”¯æŒæ ‡é¢˜ã€‘ä¿å­˜æ–°çš„å¤‡å¿˜å½•
 * @param {object} memoData - åŒ…å« title å’Œ content çš„å¯¹è±¡
 */
async function saveMemo(memoData) {
    const char = state.chats[activeCharacterId];
    if (!char.memos) char.memos = [];
    
    
    char.memos.push({ 
        id: Date.now(), 
        title: memoData.title, 
        content: memoData.content 
    });
    
    await db.chats.put(char);
    renderCharMemoList();
}

async function saveMemo(content) {
    const char = state.chats[activeCharacterId];
    if (!char.memos) char.memos = [];
    
    if (editingMemoId) {
        const memo = char.memos.find(m => m.id === editingMemoId);
        if (memo) memo.content = content;
    } else {
        char.memos.push({ id: Date.now(), content: content });
    }
    
    await db.chats.put(char);
    renderCharMemoList();
    editingMemoId = null;
}



        

/**
 * ã€å…¨æ–° | V3.0 AIæŒ‡ä»¤å¼ºåŒ–ç‰ˆã€‘å½“ç”¨æˆ·ç‚¹å‡»â€œé‡æ–°ç”Ÿæˆâ€æ—¶ï¼Œè°ƒç”¨AIç”Ÿæˆæ¨¡æ‹Ÿç›¸å†Œå†…å®¹
 */
async function handleGenerateSimulatedDiaries() {
    if (!activeCharacterId) return;
    const chat = state.chats[activeCharacterId];
    if (!chat) return;

    await showCustomAlert("è¯·ç¨å€™...", `æ­£åœ¨è¯·æ±‚â€œ${chat.name}â€ç¿»å¼€TAçš„æ—¥è®°æœ¬...`);

    const { proxyUrl, apiKey, model } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) {
        alert('è¯·å…ˆåœ¨APIè®¾ç½®ä¸­é…ç½®å¥½APIä¿¡æ¯ã€‚');
        return;
    }

    const userDisplayNameForAI = (state.qzoneSettings.nickname === '{{user}}' || !state.qzoneSettings.nickname) ? 'ç”¨æˆ·' : state.qzoneSettings.nickname;

    const longTermMemoryContext = chat.longTermMemory && chat.longTermMemory.length > 0
    ? chat.longTermMemory.map(mem => `- (è®°å½•äºŽ ${formatTimeAgo(mem.timestamp)}) ${mem.content}`).join('\n')
    : 'æ— ';
    const maxMemory = chat.settings.maxMemory || 10;
const recentHistoryWithUser = chat.history.slice(-maxMemory).map(msg => `${msg.role === 'user' ? userDisplayNameForAI : chat.name}: ${String(msg.content).substring(0, 30)}...`).join('\n');
    const worldBookContext = (chat.settings.linkedWorldBookIds || [])
        .map(bookId => state.worldBooks.find(wb => wb.id === bookId))
        .filter(Boolean)
        .map(book => `\n## ä¸–ç•Œä¹¦ã€Š${book.name}ã€‹è®¾å®š:\n${book.content.filter(e=>e.enabled).map(e => `- ${e.content}`).join('\n')}`)
        .join('');

const summary3Hours = generateSummaryForTimeframe(chat, 3, 'hours');
const summary6Hours = generateSummaryForTimeframe(chat, 6, 'hours');
const summary9Hours = generateSummaryForTimeframe(chat, 9, 'hours');
const summaryToday = generateSummaryForTimeframe(chat, 1, 'days');
const summary3Days = generateSummaryForTimeframe(chat, 3, 'days');
const summary7Days = generateSummaryForTimeframe(chat, 7, 'days');

let multiLayeredSummaryContext = '';
if (summary3Hours || summary6Hours || summary9Hours || summaryToday || summary3Days || summary7Days) {
    multiLayeredSummaryContext += `\n# æ™ºèƒ½æ€»ç»“ (åŸºäºŽä¸åŒæ—¶é—´ç»´åº¦çš„å¯¹è¯å›žé¡¾)\n`;
    if (summary3Hours) multiLayeredSummaryContext += summary3Hours;
    if (summary6Hours) multiLayeredSummaryContext += summary6Hours;
    if (summary9Hours) multiLayeredSummaryContext += summary9Hours;
    if (summary3Hours || summary6Hours || summary9Hours) multiLayeredSummaryContext += '\n';
    if (summaryToday) multiLayeredSummaryContext += summaryToday;
    if (summary3Days) multiLayeredSummaryContext += summary3Days;
    if (summary7Days) multiLayeredSummaryContext += summary7Days;
}
const userPersona = chat.settings.myPersona || '(æœªè®¾ç½®)';    
    const systemPrompt = `
# ä½ çš„ä»»åŠ¡
ä½ æ˜¯ä¸€ä¸ªè™šæ‹Ÿç”Ÿæ´»æ¨¡æ‹Ÿå™¨å’Œæ•…äº‹ä½œå®¶ã€‚ä½ çš„ä»»åŠ¡æ˜¯æ‰®æ¼”è§’è‰²â€œ${chat.name}â€ï¼Œå¹¶æ ¹æ®å…¶äººè®¾ã€è®°å¿†å’Œæœ€è¿‘çš„äº’åŠ¨ï¼Œè™šæž„å‡ºã€5åˆ°8ç¯‡ã€‘TAæœ€è¿‘å¯èƒ½ä¼šå†™çš„æ—¥è®°ã€‚

# æ ¸å¿ƒè§„åˆ™
1.  **ã€æ—¶é—´ (æœ€é«˜ä¼˜å…ˆçº§)ã€‘**:
    -   ä»Šå¤©çš„æ—¥æœŸæ˜¯ **${new Date().toLocaleDateString('zh-CN')}**ã€‚
    -   ä½ ç”Ÿæˆçš„ã€æ‰€æœ‰ã€‘æ—¥è®°çš„æ ‡é¢˜æ—¥æœŸï¼Œã€å¿…é¡»ã€‘æ˜¯ä»Šå¤©æˆ–ä»Šå¤©ä»¥å‰çš„æ—¥æœŸã€‚
    -   ã€ç»å¯¹ç¦æ­¢ã€‘ç”Ÿæˆä»»ä½•æœªæ¥çš„æ—¥æœŸï¼
2.  **ã€æ²‰æµ¸æ„Ÿã€‘**: æ¯ä¸€ç¯‡æ—¥è®°éƒ½å¿…é¡»ä½¿ç”¨ã€ç¬¬ä¸€äººç§°è§†è§’ ("æˆ‘")ã€‘æ¥å†™ï¼Œå¹¶ä¸”è¦å……æ»¡è§’è‰²çš„ä¸ªäººæƒ…æ„Ÿã€æ€è€ƒå’Œç§˜å¯†ã€‚åœ¨æ—¥è®°ä¸­æè¿°è‡ªå·±çš„è¡Œä¸ºæˆ–æƒ³æ³•æ—¶ï¼Œã€ç»å¯¹ç¦æ­¢ã€‘ä½¿ç”¨ç¬¬ä¸‰äººç§°â€œä»–â€æˆ–â€œå¥¹â€ (TA)ã€‚
3.  **ã€é•¿åº¦ã€‘**: æ¯ä¸€ç¯‡æ—¥è®°çš„æ­£æ–‡é•¿åº¦ã€å¿…é¡»ä¸å°‘äºŽ300å­—ã€‘ã€‚
4.  **ã€æ ¼å¼é“å¾‹ (æœ€é«˜ä¼˜å…ˆçº§)ã€‘**: 
    - ä½ çš„å›žå¤ã€å¿…é¡»ä¸”åªèƒ½ã€‘æ˜¯ä¸€ä¸ªJSONæ•°ç»„æ ¼å¼çš„å­—ç¬¦ä¸²ã€‚
    - ä½ çš„å›žå¤å¿…é¡»ä»¥ \`[\` å¼€å§‹ï¼Œå¹¶ä»¥ \`]\` ç»“æŸã€‚
    - ã€ç»å¯¹ç¦æ­¢ã€‘åœ¨JSONæ•°ç»„å‰åŽæ·»åŠ ä»»ä½•å¤šä½™çš„æ–‡å­—ã€è§£é‡Šã€æˆ– markdown æ ‡è®° (å¦‚ \`\`\`json)ã€‚
    - æ•°ç»„ä¸­çš„æ¯ä¸ªå…ƒç´ éƒ½æ˜¯ä¸€ä¸ªå¯¹è±¡ï¼Œä»£è¡¨ä¸€ç¯‡æ—¥è®°ï¼Œæ ¼å¼ã€å¿…é¡»ã€‘å¦‚ä¸‹:
    \`\`\`json
    [
      {
        "title": "è¿™ç¯‡æ—¥è®°çš„æ ‡é¢˜ï¼Œä¾‹å¦‚ï¼š9æœˆ20æ—¥ æ™´",
        "content": "è¿™é‡Œæ˜¯æ—¥è®°çš„è¯¦ç»†æ­£æ–‡ï¼Œå¿…é¡»æ”¯æŒæ¢è¡Œç¬¦\\nï¼Œå¹¶ä¸”å¿…é¡»å·§å¦™åœ°ä½¿ç”¨ä¸‹é¢çš„ã€æ—¥è®°ä¸“å±žMarkdownè¯­æ³•ã€‘æ¥ä¸°å¯Œæ–‡æœ¬è¡¨çŽ°åŠ›ã€‚"
      }
    ]
    \`\`\`
5.  **ã€å ä½ç¬¦æ›¿æ¢ (æœ€é«˜ä¼˜å…ˆçº§)ã€‘**: åœ¨ä½ çš„æ—¥è®°å†…å®¹ä¸­ï¼Œã€ç»å¯¹ä¸èƒ½ã€‘å‡ºçŽ° "{{user}}" è¿™ä¸ªå ä½ç¬¦ã€‚ä½ ã€å¿…é¡»ã€‘ä½¿ç”¨ â€œ${userDisplayNameForAI}â€ æ¥æŒ‡ä»£ä½ çš„èŠå¤©å¯¹è±¡ï¼ˆç”¨æˆ·ï¼‰ã€‚
6.  **ã€æ—¥è®°ä¸“å±žMarkdownè¯­æ³• (å¿…é¡»ä½¿ç”¨ï¼)ã€‘**:
    -   \`**åŠ ç²—æ–‡å­—**\`: ç”¨äºŽå¼ºè°ƒã€‚
    -   \`~~åˆ’æŽ‰çš„æ–‡å­—~~\`: ç”¨äºŽè¡¨ç¤ºæ”¹å˜ä¸»æ„æˆ–è‡ªæˆ‘å¦å®šã€‚
    -   \`!h{é»„è‰²é«˜äº®}\`: ç”¨äºŽæ ‡è®°å…³é”®è¯æˆ–é‡è¦ä¿¡æ¯ã€‚
    -   \`!u{ç²‰è‰²ä¸‹åˆ’çº¿}\`: ç”¨äºŽæ ‡æ³¨äººåã€åœ°åæˆ–ç‰¹æ®Šåè¯ã€‚
    -   \`!e{ç²‰è‰²å¼ºè°ƒ}\`: ç”¨äºŽè¡¨è¾¾å¼ºçƒˆçš„æƒ…ç»ªã€‚
    -   \`!w{æ‰‹å†™ä½“}\`: ç”¨äºŽå†™ä¸‹å¼•è¨€ã€æ­Œè¯æˆ–ç‰¹æ®Šç¬”è®°ã€‚
    -   \`!m{å‡Œä¹±çš„æ‰‹å†™ä½“}\`: ç”¨äºŽè¡¨è¾¾æ¿€åŠ¨ã€æ…Œä¹±æˆ–æ½¦è‰è®°å½•æ—¶çš„å¿ƒæƒ…ã€‚
    -   \`||æ¶‚é»‘||\`: ç”¨äºŽéšè—ç§˜å¯†æˆ–æ•æ„Ÿè¯æ±‡ (æ¯æ¬¡æ¶‚é»‘2~5ä¸ªå­—)ã€‚

# ä¾›ä½ å‚è€ƒçš„ä¸Šä¸‹æ–‡
- **ä½ çš„è§’è‰²è®¾å®š**: ${chat.settings.aiPersona}
- **ä½ çš„èŠå¤©å¯¹è±¡è®¾å®š**:${userPersona}
- **ä½ çš„é•¿æœŸè®°å¿†**:
${longTermMemoryContext}
${worldBookContext}
${multiLayeredSummaryContext} 
- **ä½ æœ€è¿‘å’Œâ€œ${userDisplayNameForAI}â€çš„å¯¹è¯æ‘˜è¦**:
${recentHistoryWithUser}

çŽ°åœ¨ï¼Œè¯·å¼€å§‹æ’°å†™è¿™ç»„å……æ»¡çœŸæƒ…å®žæ„Ÿã€å¹¶ç†Ÿç»ƒè¿ç”¨äº†Markdownè¯­æ³•çš„æ—¥è®°ã€‚`;
      

    try {
        const messagesForApi = [{ role: 'user', content: "è¯·æ ¹æ®ä½ çš„è®¾å®šï¼Œç”Ÿæˆä½ çš„æ—¥è®°å†…å®¹ã€‚" }];
        let isGemini = proxyUrl.includes('generativelanguage');
        let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi);
        
        
        const response = isGemini 
            ? await fetch(geminiConfig.url, geminiConfig.data) 
            : await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                body: JSON.stringify({
                    model: model,
                    messages: [{role: 'system', content: systemPrompt}, ...messagesForApi],
                    temperature: state.globalSettings.apiTemperature || 0.95,
                    
                })
            });
          

        if (!response.ok) throw new Error(`API é”™è¯¯: ${response.statusText}`);
        
        const data = await response.json();
        const aiResponseContent = getGeminiResponseText(data);
        
        
        const jsonMatch = aiResponseContent.match(/(\[[\s\S]*\])/);
        if (!jsonMatch || !jsonMatch[0]) {
            throw new Error(`AIè¿”å›žçš„å†…å®¹ä¸­æœªæ‰¾åˆ°æœ‰æ•ˆçš„JSONæ•°ç»„ã€‚åŽŸå§‹è¿”å›ž: ${aiResponseContent}`);
        }
        const cleanedJsonString = jsonMatch[0];
        let simulatedDiaries;
        try {
            simulatedDiaries = JSON.parse(cleanedJsonString);
        } catch (e) {
            throw new Error(`è§£æžAIè¿”å›žçš„JSONæ—¶å‡ºé”™: ${e.message}\n\nAIåŽŸå§‹è¿”å›žå†…å®¹:\n${aiResponseContent}`);
        }
          
        
        chat.diary = simulatedDiaries.map(entry => ({
            id: Date.now() + Math.random(),
            title: entry.title,
            content: entry.content,
            timestamp: Date.now()
        }));
        
        await db.chats.put(chat);
        await renderCharDiaryList();
        
    } catch (error) {
        console.error("ç”Ÿæˆæ¨¡æ‹Ÿæ—¥è®°å¤±è´¥:", error);
        await showCustomAlert("ç”Ÿæˆå¤±è´¥", `æ— æ³•ç”Ÿæˆæ—¥è®°ï¼Œè¯·æ£€æŸ¥APIé…ç½®æˆ–ç¨åŽå†è¯•ã€‚\né”™è¯¯: ${error.message}`);
    }
}

        /**
         * ã€å…¨æ–°ã€‘å½“ç”¨æˆ·ç‚¹å‡»â€œ+â€æ—¶ï¼Œè§¦å‘AIæ’°å†™ä¸€ç¯‡æ–°æ—¥è®°å¹¶è¿½åŠ åˆ°æœ«å°¾
         */
        async function handleWriteNewDiaryEntry() {
            if (!activeCharacterId) return;
            const chat = state.chats[activeCharacterId];
            if (!chat) return;
        
            await showCustomAlert("è¯·ç¨å€™...", `æ­£åœ¨è¯·æ±‚â€œ${chat.name}â€å†™ä¸€ç¯‡æ–°æ—¥è®°...`);
        
            const { proxyUrl, apiKey, model } = state.apiConfig;
            if (!proxyUrl || !apiKey || !model) return;

            const userDisplayNameForAI = (state.qzoneSettings.nickname === '{{user}}' || !state.qzoneSettings.nickname) ? 'ç”¨æˆ·' : state.qzoneSettings.nickname;

            const longTermMemoryContext = chat.longTermMemory && chat.longTermMemory.length > 0
    ? chat.longTermMemory.map(mem => `- (è®°å½•äºŽ ${formatTimeAgo(mem.timestamp)}) ${mem.content}`).join('\n')
    : 'æ— ';
            const maxMemory = chat.settings.maxMemory || 10;
const recentHistoryWithUser = chat.history.slice(-maxMemory).map(msg => `${msg.role === 'user' ? userDisplayNameForAI : chat.name}: ${String(msg.content).substring(0, 30)}...`).join('\n');
            const worldBookContext = (chat.settings.linkedWorldBookIds || []).map(bookId=>state.worldBooks.find(wb=>wb.id===bookId)).filter(Boolean).map(book=>`\n## ä¸–ç•Œä¹¦ã€Š${book.name}ã€‹è®¾å®š:\n${book.content.filter(e=>e.enabled).map(e=>`- ${e.content}`).join('\n')}`).join('');
            
            
            const systemPrompt = `          
# ä½ çš„ä»»åŠ¡
ä½ æ˜¯ä¸€ä¸ªè™šæ‹Ÿç”Ÿæ´»æ¨¡æ‹Ÿå™¨å’Œæ•…äº‹ä½œå®¶ã€‚ä½ çš„ä»»åŠ¡æ˜¯æ‰®æ¼”è§’è‰²â€œ${chat.name}â€ï¼Œå¹¶æ ¹æ®å…¶äººè®¾ã€è®°å¿†å’Œæœ€è¿‘çš„äº’åŠ¨ï¼Œè™šæž„å‡ºã€1ç¯‡ã€‘TAä»Šå¤©å¯èƒ½ä¼šå†™çš„æ—¥è®°ã€‚

# æ ¸å¿ƒè§„åˆ™
1.  **ã€ã€ã€æ—¶é—´é“å¾‹ (æœ€é«˜ä¼˜å…ˆçº§)ã€‘ã€‘ã€‘**:
    -   ä»Šå¤©çš„æ—¥æœŸæ˜¯ **${new Date().toLocaleDateString('zh-CN')}**ã€‚
    -   ä½ ç”Ÿæˆçš„æ—¥è®°æ ‡é¢˜æ—¥æœŸã€å¿…é¡»ã€‘æ˜¯ä»Šå¤©æˆ–ä»Šå¤©ä»¥å‰çš„æ—¥æœŸã€‚
    -   ã€ç»å¯¹ç¦æ­¢ã€‘ç”Ÿæˆä»»ä½•æœªæ¥çš„æ—¥æœŸï¼
2.  **ã€ã€ã€æ²‰æµ¸æ„Ÿé“å¾‹ã€‘ã€‘ã€‘**: æ—¥è®°å¿…é¡»ä½¿ç”¨ã€ç¬¬ä¸€äººç§°è§†è§’ ("æˆ‘")ã€‘æ¥å†™ï¼Œå¹¶ä¸”è¦å……æ»¡è§’è‰²çš„ä¸ªäººæƒ…æ„Ÿã€æ€è€ƒå’Œç§˜å¯†ã€‚åœ¨æ—¥è®°ä¸­æè¿°è‡ªå·±çš„è¡Œä¸ºæˆ–æƒ³æ³•æ—¶ï¼Œã€ç»å¯¹ç¦æ­¢ã€‘ä½¿ç”¨ç¬¬ä¸‰äººç§°â€œä»–â€æˆ–â€œå¥¹â€ (TA)ã€‚
3.  **ã€ã€ã€é•¿åº¦é“å¾‹ã€‘ã€‘ã€‘**: æ—¥è®°çš„æ­£æ–‡é•¿åº¦ã€å¿…é¡»ä¸å°‘äºŽ300å­—ã€‘ã€‚
4.  **ã€ã€ã€æ ¼å¼é“å¾‹ (æœ€é«˜ä¼˜å…ˆçº§)ã€‘ã€‘ã€‘**: ä½ çš„å›žå¤ã€å¿…é¡»ä¸”åªèƒ½ã€‘æ˜¯ä¸€ä¸ªJSONæ•°ç»„ï¼Œä¸”æ•°ç»„ä¸­ã€åªåŒ…å«ä¸€ä¸ªã€‘å¯¹è±¡ï¼Œæ ¼å¼ã€å¿…é¡»ã€‘å¦‚ä¸‹:
    \`\`\`json
    [
      {
        "title": "è¿™ç¯‡æ—¥è®°çš„æ ‡é¢˜ï¼Œä¾‹å¦‚ï¼š9æœˆ20æ—¥ æ™´",
        "content": "è¿™é‡Œæ˜¯æ—¥è®°çš„è¯¦ç»†æ­£æ–‡ï¼Œå¿…é¡»æ”¯æŒæ¢è¡Œç¬¦\\nï¼Œå¹¶ä¸”å¿…é¡»å·§å¦™åœ°ä½¿ç”¨ä¸‹é¢çš„ã€æ—¥è®°ä¸“å±žMarkdownè¯­æ³•ã€‘æ¥ä¸°å¯Œæ–‡æœ¬è¡¨çŽ°åŠ›ã€‚"
      }
    ]
    \`\`\`
5.  **ã€ã€ã€æ—¥è®°ä¸“å±žMarkdownè¯­æ³• (å¿…é¡»ä½¿ç”¨ï¼)ã€‘ã€‘ã€‘**:
    -   \`**åŠ ç²—æ–‡å­—**\`: ç”¨äºŽå¼ºè°ƒã€‚
    -   \`~~åˆ’æŽ‰çš„æ–‡å­—~~\`: ç”¨äºŽè¡¨ç¤ºæ”¹å˜ä¸»æ„æˆ–è‡ªæˆ‘å¦å®šã€‚
    -   \`!h{é»„è‰²é«˜äº®}\`: ç”¨äºŽæ ‡è®°å…³é”®è¯æˆ–é‡è¦ä¿¡æ¯ã€‚
    -   \`!u{ç²‰è‰²ä¸‹åˆ’çº¿}\`: ç”¨äºŽæ ‡æ³¨äººåã€åœ°åæˆ–ç‰¹æ®Šåè¯ã€‚
    -   \`!e{ç²‰è‰²å¼ºè°ƒ}\`: ç”¨äºŽè¡¨è¾¾å¼ºçƒˆçš„æƒ…ç»ªã€‚
    -   \`!w{æ‰‹å†™ä½“}\`: ç”¨äºŽå†™ä¸‹å¼•è¨€ã€æ­Œè¯æˆ–ç‰¹æ®Šç¬”è®°ã€‚
    -   \`!m{å‡Œä¹±çš„æ‰‹å†™ä½“}\`: ç”¨äºŽè¡¨è¾¾æ¿€åŠ¨ã€æ…Œä¹±æˆ–æ½¦è‰è®°å½•æ—¶çš„å¿ƒæƒ…ã€‚
    -   \`||æ¶‚é»‘||\`: ç”¨äºŽéšè—ç§˜å¯†æˆ–æ•æ„Ÿè¯æ±‡(æ¯æ¬¡æ¶‚é»‘2~5ä¸ªå­—)ã€‚

# ä¾›ä½ å‚è€ƒçš„ä¸Šä¸‹æ–‡
- **ä½ çš„è§’è‰²è®¾å®š**: ${chat.settings.aiPersona}
- **ä½ çš„é•¿æœŸè®°å¿†**:
${longTermMemoryContext}
${worldBookContext}
- **ä½ æœ€è¿‘å’Œâ€œ${userDisplayNameForAI}â€çš„å¯¹è¯æ‘˜è¦**:
${recentHistoryWithUser}

çŽ°åœ¨ï¼Œè¯·å¼€å§‹æ’°å†™è¿™ç¯‡å……æ»¡çœŸæƒ…å®žæ„Ÿã€å¹¶ç†Ÿç»ƒè¿ç”¨äº†Markdownè¯­æ³•çš„æ—¥è®°ã€‚`;
        
            try {
                const messagesForApi = [{ role: 'user', content: "è¯·æ ¹æ®ä½ çš„è®¾å®šï¼Œå†™ä¸€ç¯‡æ–°æ—¥è®°ã€‚" }];
                let isGemini = proxyUrl.includes('generativelanguage');
                let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi);
                const response = isGemini ? await fetch(geminiConfig.url, geminiConfig.data) : await fetch(`${proxyUrl}/v1/chat/completions`, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                    body: JSON.stringify({
                        model: model,
                        messages: [{role: 'system', content: systemPrompt}, ...messagesForApi],
                        temperature: state.globalSettings.apiTemperature || 0.95,
                    })
                });
                if (!response.ok) throw new Error(`API é”™è¯¯: ${response.statusText}`);
                const data = await response.json();
                const aiResponseContent = getGeminiResponseText(data);
                
                
                const jsonMatch = aiResponseContent.match(/(\[[\s\S]*\])/);
                if (!jsonMatch || !jsonMatch[0]) {
                    throw new Error(`AIè¿”å›žçš„å†…å®¹ä¸­æœªæ‰¾åˆ°æœ‰æ•ˆçš„JSONæ•°ç»„ã€‚åŽŸå§‹è¿”å›ž: ${aiResponseContent}`);
                }
                const cleanedJsonString = jsonMatch[0];
                let newDiaryEntry;
                try {
                    newDiaryEntry = JSON.parse(cleanedJsonString)[0];
                } catch (e) {
                    throw new Error(`è§£æžAIè¿”å›žçš„JSONæ—¶å‡ºé”™: ${e.message}\n\nAIåŽŸå§‹è¿”å›žå†…å®¹:\n${aiResponseContent}`);
                }
                
                
                if (!chat.diary) chat.diary = [];
                
                chat.diary.push({
                    id: Date.now(),
                    title: newDiaryEntry.title,
                    content: newDiaryEntry.content,
                    timestamp: Date.now()
                });
                
                await db.chats.put(chat);
                await renderCharDiaryList();
        
            } catch (error) {
                console.error("ç”Ÿæˆæ–°æ—¥è®°å¤±è´¥:", error);
                await showCustomAlert("ç”Ÿæˆå¤±è´¥", `é”™è¯¯: ${error.message}`);
            }
        }

        /**
         * ã€å…¨æ–° | V2.0ã€‘æ¸²æŸ“Cphoneçš„æ—¥è®°åˆ—è¡¨
         */
        function renderCharDiaryList() {
            const listEl = document.getElementById('char-diary-list');
            listEl.innerHTML = '';
            const char = state.chats[activeCharacterId];
            const diaries = (char.diary || []).slice().reverse();

            if (diaries.length === 0) {
                listEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">æ—¥è®°æœ¬è¿˜æ˜¯ç©ºçš„ã€‚</p>';
                return;
            }

            diaries.forEach(entry => {
                const item = document.createElement('div');
                item.className = 'list-item';
                item.innerHTML = `
                    <div class="item-title">${entry.title}</div>
                    <div class="item-content">${new Date(entry.timestamp).toLocaleDateString()}</div>
                `;
                item.addEventListener('click', () => viewDiary(entry.id));
                addLongPressListener(item, () => deleteDiary(entry.id));
                listEl.appendChild(item);
            });
        }

    
    /**
     * ã€V2.0 | æ”¯æŒæ”¶è—ã€‘ç‚¹å‡»æ—¥è®°åˆ—è¡¨é¡¹æ—¶ï¼Œæ‰“å¼€è¯¦æƒ…é¡µé¢æŸ¥çœ‹
     * @param {number} diaryId - è¦æŸ¥çœ‹çš„æ—¥è®°çš„ID
     */
    async function viewDiary(diaryId) {
        const char = state.chats[activeCharacterId];
        if (!char || !char.diary) return;
    
        const entry = char.diary.find(d => d.id === diaryId);
        if (entry) {
            
            activeDiaryForViewing = entry;
    
            const titleEl = document.getElementById('char-diary-detail-title');
            const contentEl = document.getElementById('char-diary-detail-content');
            const favBtn = document.getElementById('favorite-diary-btn');
    
            titleEl.textContent = entry.title;
            const formattedContent = parseMarkdown(entry.content)
                .split('\n')
                .map(p => `<p>${p || '&nbsp;'}</p>`)
                .join('');
            contentEl.innerHTML = formattedContent;
    
            
            const existingFavorite = await db.favorites.where({ type: 'char_diary', 'content.id': diaryId }).first();
            favBtn.classList.toggle('active', !!existingFavorite);
    
            switchToCharScreen('char-diary-detail-screen');
        }
    }
    
    /**
     * åˆ‡æ¢å½“å‰æ—¥è®°çš„æ”¶è—çŠ¶æ€
     */
    async function toggleDiaryFavorite() {
        if (!activeDiaryForViewing || !activeCharacterId) return;
    
        const diary = activeDiaryForViewing;
        const char = state.chats[activeCharacterId];
        const favBtn = document.getElementById('favorite-diary-btn');
    
        
        const existingFavorite = await db.favorites.where({ type: 'char_diary', 'content.id': diary.id }).first();
    
        if (existingFavorite) {
            
            await db.favorites.delete(existingFavorite.id);
            favBtn.classList.remove('active');
            await showCustomAlert('æ“ä½œæˆåŠŸ', 'å·²å–æ¶ˆæ”¶è—ã€‚');
        } else {
            
            const newFavorite = {
                type: 'char_diary',
                
                content: {
                    id: diary.id,
                    title: diary.title,
                    content: diary.content,
                    timestamp: diary.timestamp,
                    characterId: activeCharacterId,
                    characterName: char.name
                },
                timestamp: Date.now() 
            };
            await db.favorites.add(newFavorite);
            favBtn.classList.add('active');
            await showCustomAlert('æ“ä½œæˆåŠŸ', 'å·²æˆåŠŸæ”¶è—åˆ°â€œæˆ‘çš„æ”¶è—â€é¡µé¢ï¼');
        }
    }
    

/**
 * åˆ‡æ¢å½“å‰å¤‡å¿˜å½•çš„æ”¶è—çŠ¶æ€
 */
async function toggleMemoFavorite() {
    
    if (!activeMemoForViewing || !activeCharacterId) return;

    const memo = activeMemoForViewing;
    const char = state.chats[activeCharacterId];
    const favBtn = document.getElementById('favorite-memo-btn');

    
    const existingFavorite = await db.favorites.where({ type: 'char_memo', 'content.id': memo.id }).first();

    if (existingFavorite) {
        
        await db.favorites.delete(existingFavorite.id);
        favBtn.classList.remove('active'); 
        await showCustomAlert('æ“ä½œæˆåŠŸ', 'å·²å–æ¶ˆæ”¶è—ã€‚');
    } else {
        
        const newFavorite = {
            type: 'char_memo',
            
            content: {
                id: memo.id,
                title: memo.title,
                content: memo.content,
                timestamp: memo.timestamp,
                characterId: activeCharacterId,
                characterName: char.name
            },
            timestamp: Date.now() 
        };
        await db.favorites.add(newFavorite);
        favBtn.classList.add('active'); 
        await showCustomAlert('æ“ä½œæˆåŠŸ', 'å·²æˆåŠŸæ”¶è—åˆ°â€œæˆ‘çš„æ”¶è—â€é¡µé¢ï¼');
    }
}

        /**
         * ã€å…¨æ–°ã€‘åˆ é™¤ä¸€ç¯‡æ—¥è®°
         * @param {number} diaryId - è¦åˆ é™¤çš„æ—¥è®°çš„ID
         */
        async function deleteDiary(diaryId) {
            const confirmed = await showCustomConfirm('åˆ é™¤æ—¥è®°', 'ç¡®å®šè¦åˆ é™¤è¿™ç¯‡æ—¥è®°å—ï¼Ÿ', { confirmButtonClass: 'btn-danger' });
            if (confirmed) {
                const char = state.chats[activeCharacterId];
                char.diary = char.diary.filter(d => d.id !== diaryId);
                await db.chats.put(char);
                renderCharDiaryList();
            }
        }

          

/**
 * ã€å…¨æ–° V2.5 | ç”¨æˆ·å¯¹è¯ç½®é¡¶ä¿®å¤ç‰ˆã€‘æ¸²æŸ“è§’è‰²è§†è§’çš„QQèŠå¤©åˆ—è¡¨
 */
async function renderCharSimulatedQQ() {
    const listEl = document.getElementById('char-chat-list');
    listEl.innerHTML = '';
    const char = state.chats[activeCharacterId];
    if (!char) return;

    
    const userDisplayName = char.settings.myNickname || (state.qzoneSettings.nickname || 'æˆ‘');
    const lastRealMessage = char.history.filter(m => !m.isHidden).slice(-1)[0] || { content: '...' };
    
    
    let lastMsgContent = '...';
    if (lastRealMessage) {
        if (typeof lastRealMessage.content === 'string') {
            lastMsgContent = lastRealMessage.content;
        } else if (Array.isArray(lastRealMessage.content) && lastRealMessage.content[0]?.type === 'image_url') {
            lastMsgContent = '[å›¾ç‰‡]';
        } else if (lastRealMessage.type) {
            const typeMap = { 'voice_message': '[è¯­éŸ³]', 'transfer': '[è½¬è´¦]', 'ai_image': '[å›¾ç‰‡]' };
            lastMsgContent = typeMap[lastRealMessage.type] || `[${lastRealMessage.type}]`;
        }
    }

    
    const myAvatar = char.settings.myAvatar || defaultAvatar;
    const myFrame = char.settings.myAvatarFrame || '';
    let avatarHtml;
    if (myFrame) {
        avatarHtml = `<div class="avatar-group has-frame" style="width: 45px; height: 45px;"><div class="avatar-with-frame" style="width: 45px; height: 45px;"><img src="${myAvatar}" class="avatar-img" style="border-radius: 50%;"><img src="${myFrame}" class="avatar-frame"></div></div>`;
    } else {
        avatarHtml = `<div class="avatar-group" style="width: 45px; height: 45px;"><img src="${myAvatar}" class="avatar" style="border-radius: 50%; width: 45px; height: 45px;"></div>`;
    }

    const userChatItem = document.createElement('div');
    userChatItem.className = 'chat-list-item';
    
    userChatItem.dataset.conversationIndex = "-1"; 
    userChatItem.innerHTML = `
        ${avatarHtml}
        <div class="info">
            <div class="name-line">
                <span class="name">${userDisplayName}</span>
            </div>
            <div class="last-msg">${String(lastMsgContent).substring(0, 20)}...</div>
        </div>
    `;
    listEl.appendChild(userChatItem);
    

    const allNpcs = await db.npcs.toArray();
    const npcMap = new Map(allNpcs.map(npc => [npc.name, npc]));
    const conversations = char.simulatedConversations || [];

    if (conversations.length === 0 && !userChatItem) {
        listEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">ç‚¹å‡»å³ä¸Šè§’åˆ·æ–°æŒ‰é’®ï¼Œ<br>çœ‹çœ‹TAæœ€è¿‘éƒ½å’Œè°èŠå¤©äº†å§ï¼</p>';
        return;
    }

    conversations.forEach((convo, index) => {
        
        if (convo.type === 'private_user') {
            return;
        }
        

        const item = document.createElement('div');
        item.className = 'chat-list-item';
        item.dataset.conversationIndex = index;

        let lastMessage, avatarHtml, displayName;
        
        if (convo.type === 'group') {
            displayName = convo.groupName + ` <span class="group-tag">ç¾¤</span>`;
            lastMessage = convo.messages.slice(-1)[0] || { content: '...' };
            const groupAvatarPrompt = `logo, simple, flat design, for a group chat named '${convo.groupName}'`;
            const avatarUrl = state.globalSettings.enableAiDrawing ? `https://image.pollinations.ai/prompt/${encodeURIComponent(groupAvatarPrompt)}` : defaultGroupAvatar;
            avatarHtml = `<div class="avatar-group"><img src="${avatarUrl}" class="avatar" style="border-radius: 50%;"></div>`;
        
        } else { 
            displayName = convo.participant.name;
            lastMessage = convo.messages.slice(-1)[0] || { content: '...' };
            const npcData = npcMap.get(displayName);
            let avatarUrl = (npcData && npcData.avatar) ? npcData.avatar : 
                (state.globalSettings.enableAiDrawing ? `https://image.pollinations.ai/prompt/${encodeURIComponent(convo.participant.avatar_prompt || 'anime person')}` : defaultGroupMemberAvatar);
            avatarHtml = `<div class="avatar-group"><img src="${avatarUrl}" class="avatar" style="border-radius: 50%;"></div>`;
        }

        let lastMsgContent = '...';
        if (lastMessage && lastMessage.content) {
            lastMsgContent = lastMessage.content;
        }
        
        item.innerHTML = `
            ${avatarHtml}
            <div class="info">
                <div class="name-line">
                    <span class="name">${displayName}</span>
                </div>
                <div class="last-msg">${String(lastMsgContent).substring(0, 20)}...</div>
            </div>
        `;
        listEl.appendChild(item);
    });
}
/**
 * ã€å…¨æ–° V4.0 | æŒ‡ä»¤ç®€åŒ–ç»ˆæžä¿®å¤ç‰ˆ + ç§»é™¤ç”¨æˆ·æ¨¡æ‹Ÿã€‘å½“ç”¨æˆ·ç‚¹å‡»â€œé‡æ–°ç”Ÿæˆâ€æ—¶ï¼Œè°ƒç”¨AIç”Ÿæˆå…¨æ–°çš„æ¨¡æ‹Ÿå¯¹è¯
 */
async function handleGenerateSimulatedQQ() {
    if (!activeCharacterId) return;
    const chat = state.chats[activeCharacterId];
    if (!chat) return;

    await showCustomAlert("è¯·ç¨å€™...", `æ­£åœ¨æ ¹æ®â€œ${chat.name}â€çš„è®°å¿†å’Œäººè®¾ï¼Œç”Ÿæˆå…¨æ–°çš„ç¤¾äº¤åŠ¨æ€...`);

    const { proxyUrl, apiKey, model } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) {
        alert('è¯·å…ˆåœ¨APIè®¾ç½®ä¸­é…ç½®å¥½APIä¿¡æ¯ã€‚');
        return;
    }
    
    const allNpcs = await db.npcs.toArray();
    const associatedNpcs = allNpcs.filter(npc => 
        npc.associatedWith && npc.associatedWith.includes(activeCharacterId)
    );
    let npcContext = "# ä½ çš„ç¤¾äº¤åœˆ (ç»‘å®šçš„NPC)\n";
    if (associatedNpcs.length > 0) {
        npcContext += "è¿™æ˜¯ä½ è®¤è¯†çš„ã€å…³ç³»å¯†åˆ‡çš„NPCã€‚åœ¨ç”Ÿæˆå¯¹è¯æ—¶ï¼Œä½ åº”è¯¥ã€ä¼˜å…ˆã€‘ä¸Žä»–ä»¬äº’åŠ¨ã€‚\n";
        associatedNpcs.forEach(npc => {
            npcContext += `- **å§“å**: ${npc.name}\n  - **äººè®¾**: ${npc.persona}\n`;
        });
    } else {
        npcContext += "ï¼ˆä½ ç›®å‰æ²¡æœ‰ç»‘å®šçš„NPCä¼™ä¼´ï¼Œå¯ä»¥è‡ªç”±åˆ›é€ æ–°çš„NPCã€‚ï¼‰\n";
    }

    const userDisplayNameForAI = state.qzoneSettings.nickname === '{{user}}' || !state.qzoneSettings.nickname ? 'ç”¨æˆ·' : state.qzoneSettings.nickname;
    const userNicknameInThisChat = chat.settings.myNickname || userDisplayNameForAI;
    const longTermMemoryContext = chat.longTermMemory && chat.longTermMemory.length > 0
    ? chat.longTermMemory.map(mem => `- (è®°å½•äºŽ ${formatTimeAgo(mem.timestamp)}) ${mem.content}`).join('\n')
    : 'æ— ';
const maxMemory = chat.settings.maxMemory || 10;
    const recentHistoryWithUser =chat.history.slice(-maxMemory).map(msg => `${msg.role === 'user' ? userNicknameInThisChat : chat.name}: ${String(msg.content).substring(0, 30)}...`).join('\n');
    const worldBookContext = (chat.settings.linkedWorldBookIds || [])
        .map(bookId => state.worldBooks.find(wb => wb.id === bookId))
        .filter(Boolean)
        .map(book => `\n## ä¸–ç•Œä¹¦ã€Š${book.name}ã€‹è®¾å®š (ä½ å¯ä»¥å°†å…¶ä¸­è§’è‰²ä½œä¸ºèŠå¤©å¯¹è±¡):\n${book.content.filter(e=>e.enabled).map(e => `- ${e.content}`).join('\n')}`)
        .join('');
    const characterOriginalName = chat.originalName || chat.name;
    const stickerContext = getGroupStickerContextForPrompt(chat);
    
    const systemPrompt = `
# ä½ çš„ä»»åŠ¡
ä½ æ˜¯ä¸€ä¸ªè™šæ‹Ÿç¤¾äº¤ç”Ÿæ´»æ¨¡æ‹Ÿå™¨ï¼Œæ‰®æ¼”è§’è‰²â€œ${chat.name}â€ã€‚ä½ çš„ä»»åŠ¡æ˜¯è™šæž„å‡ºã€5åˆ°7æ®µã€‘TAæœ€è¿‘çš„QQèŠå¤©è®°å½•ã€‚

# æ ¸å¿ƒè§„åˆ™
1.  **ã€NPCå”¯ä¸€æ€§é“å¾‹ã€‘**: åœ¨ä½ æœ¬æ¬¡ç”Ÿæˆçš„æ‰€æœ‰å¯¹è¯ä¸­ï¼ˆåŒ…æ‹¬ç§èŠå’Œç¾¤èŠï¼‰ï¼Œæ¯ä¸€ä¸ªNPCçš„åå­—ã€å¿…é¡»æ˜¯ç‹¬ä¸€-æ— äºŒçš„ã€‘ã€‚ç»å¯¹ç¦æ­¢å‡ºçŽ°é‡åçš„NPCï¼Œç¦æ­¢å‡ºçŽ°é‡å¤ç¾¤èŠã€‚
2.  **ã€NPCæ¥æºã€‘**: ä½ åº”è¯¥ä¼˜å…ˆä»Žâ€œä½ çš„ç¤¾äº¤åœˆ (ç»‘å®šçš„NPC)â€å’Œâ€œä¸–ç•Œä¹¦â€ä¸­å¯»æ‰¾è§’è‰²ä½œä¸ºèŠå¤©å¯¹è±¡ã€‚å¦‚æžœä¸å¤Ÿï¼Œä½ ä¹Ÿå¯ä»¥è‡ªç”±åˆ›é€ å…¨æ–°çš„NPCï¼Œå¯¹è¯å†…å®¹è¦å¤šæ ·åŒ–ï¼Œåæ˜ è§’è‰²çš„ç”Ÿæ´»ã€‚
3.  **å…³è”æ€§**: å¯¹è¯å†…å®¹åº”å·§å¦™åœ°åæ˜ è§’è‰²çš„é•¿æœŸè®°å¿†ã€ä¸–ç•Œè§‚ï¼Œä»¥åŠä¸Žç”¨æˆ·äº’åŠ¨å¯èƒ½å¸¦æ¥çš„å¿ƒæƒ…å˜åŒ–ã€‚
4.  **ç®€æ´æ€§**: æ¯æ®µå¯¹è¯çš„æ€»é•¿åº¦åº”åœ¨8åˆ°15å¥ä¹‹é—´ã€‚
# æ ¼å¼é“å¾‹ (æœ€é«˜ä¼˜å…ˆçº§)
- ä½ çš„å›žå¤ã€å¿…é¡»ä¸”åªèƒ½ã€‘æ˜¯ä¸€ä¸ªJSONæ•°ç»„æ ¼å¼çš„å­—ç¬¦ä¸²ï¼Œä»¥ \`[\` å¼€å§‹ï¼Œå¹¶ä»¥ \`]\` ç»“æŸã€‚
- ã€ç»å¯¹ç¦æ­¢ã€‘åœ¨JSONæ•°ç»„å‰åŽæ·»åŠ ä»»ä½•å¤šä½™çš„æ–‡å­—ã€è§£é‡Šã€æˆ– markdown æ ‡è®°ã€‚
- æ•°ç»„ä¸­çš„æ¯ä¸ªå…ƒç´ éƒ½ä»£è¡¨ä¸€æ®µå¯¹è¯ï¼Œä¸”ã€å¿…é¡»ã€‘æ˜¯ä»¥ä¸‹ä¸¤ç§æ ¼å¼ä¹‹ä¸€ï¼š



### æ ¼å¼ Aï¼šä¸ŽNPCçš„ç§èŠ
\`\`\`json
{
  "type": "private_npc",
  "participant": {
    "name": "NPCçš„åå­—",
    "avatar_prompt": "(ä»…å½“NPCæ˜¯æ–°åˆ›é€ æ—¶æä¾›)ä¸€æ®µç”¨äºŽç”Ÿæˆå¤´åƒçš„ã€è‹±æ–‡ã€‘å…³é”®è¯, é£Žæ ¼ä¸ºåŠ¨æ¼«/æ’ç”»/äºŒæ¬¡å…ƒç­‰, ç¦æ­¢çœŸäºº"
  },
"messages": [
  {"sender": "${characterOriginalName}", "content": "å¯¹è¯å†…å®¹1"},
  {"sender": "NPCçš„åå­—", "content": "å¯¹è¯å†…å®¹2"},
  {"sender": "${characterOriginalName}", "type": "sticker", "meaning": "è¡¨æƒ…çš„å«ä¹‰(å¿…é¡»ä»Žå¯ç”¨è¡¨æƒ…åˆ—è¡¨é€‰æ‹©)"}
]
}
\`\`\`

### æ ¼å¼ Bï¼šç¾¤èŠ
\`\`\`json
{
  "type": "group",
  "groupName": "ä¸€ä¸ªè™šæž„çš„ç¾¤å",
  "participants": [
    {"name": "NPCæˆå‘˜1", "avatar_prompt": "(ä»…å½“NPCæ˜¯æ–°åˆ›é€ æ—¶æä¾›) æˆå‘˜1å¤´åƒã€è‹±æ–‡ã€‘å…³é”®è¯"},
    {"name": "NPCæˆå‘˜2", "avatar_prompt": "(ä»…å½“NPCæ˜¯æ–°åˆ›é€ æ—¶æä¾›) æˆå‘˜2å¤´åƒã€è‹±æ–‡ã€‘å…³é”®è¯"}
  ],
"messages": [
  {"sender": "${characterOriginalName}", "content": "æˆ‘åœ¨ç¾¤é‡Œè¯´çš„è¯"},
  {"sender": "NPCæˆå‘˜1", "content": "æˆå‘˜1å›žå¤æˆ‘"},
  {"sender": "NPCæˆå‘˜2", "type": "sticker", "meaning": "è¡¨æƒ…çš„å«ä¹‰(å¿…é¡»ä»Žå¯ç”¨è¡¨æƒ…åˆ—è¡¨é€‰æ‹©)"}
]
}
\`\`\`

# è§’è‰²ä¸Žä¸Šä¸‹æ–‡
- **ä½ çš„è§’è‰²è®¾å®š**: ${chat.settings.aiPersona}
- **ä½ çš„é•¿æœŸè®°å¿†**: ${longTermMemoryContext}
- **ä¸–ç•Œè§‚**: ${worldBookContext}
- **æœ€è¿‘ä¸Žç”¨æˆ·çš„äº’åŠ¨**: ${recentHistoryWithUser}
${npcContext}
# å¯ç”¨è¡¨æƒ…åŒ… (å¿…é¡»ä¸¥æ ¼éµå®ˆï¼)
- å½“ä½ éœ€è¦å‘é€è¡¨æƒ…æ—¶ï¼Œä½ ã€å¿…é¡»ã€‘ä»Žä¸‹é¢çš„åˆ—è¡¨ä¸­ã€ç²¾ç¡®åœ°é€‰æ‹©ä¸€ä¸ªã€‘å«ä¹‰ï¼ˆmeaningï¼‰ã€‚
- ã€ç»å¯¹ç¦æ­¢ã€‘ä½¿ç”¨ä»»ä½•ä¸åœ¨åˆ—è¡¨ä¸­çš„è¡¨æƒ…å«ä¹‰ï¼
${stickerContext}
çŽ°åœ¨ï¼Œè¯·ä¸¥æ ¼æŒ‰ç…§æ ¼å¼é“å¾‹ï¼Œç”ŸæˆèŠå¤©è®°å½•çš„JSONæ•°ç»„ã€‚`;
  
            
    try {
        const messagesForApi = [{ role: 'user', content: "è¯·æ ¹æ®ä½ çš„è®¾å®šï¼Œç”Ÿæˆæ¨¡æ‹ŸèŠå¤©è®°å½•ã€‚" }];
        let isGemini = proxyUrl.includes('generativelanguage');
        let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi);
        
        const response = isGemini 
            ? await fetch(geminiConfig.url, geminiConfig.data) 
            : await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                body: JSON.stringify({
                    model: model,
                    messages: [{role: 'system', content: systemPrompt}, ...messagesForApi],
                    temperature: state.globalSettings.apiTemperature || 0.9
                })
            });

        if (!response.ok) throw new Error(`API é”™è¯¯: ${response.statusText}`);
        
        const data = await response.json();
        const aiResponseContent = getGeminiResponseText(data);
        
        const jsonMatch = aiResponseContent.match(/(\[[\s\S]*\])/);
        if (!jsonMatch || !jsonMatch[0]) {
            throw new Error(`AIè¿”å›žçš„å†…å®¹ä¸­æœªæ‰¾åˆ°æœ‰æ•ˆçš„JSONæ•°ç»„ã€‚åŽŸå§‹è¿”å›ž: ${aiResponseContent}`);
        }
        const cleanedJsonString = jsonMatch[0];
        let simulatedConversations;
        try {
            simulatedConversations = JSON.parse(cleanedJsonString);
        } catch (e) {
            throw new Error(`è§£æžAIè¿”å›žçš„JSONæ—¶å‡ºé”™: ${e.message}\n\nAIåŽŸå§‹è¿”å›žå†…å®¹:\n${aiResponseContent}`);
        }
        
        chat.simulatedConversations = simulatedConversations;
        await db.chats.put(chat);
        
        await renderCharSimulatedQQ();

        
        const hiddenMessage = {
            role: 'system',
            content: `[ç³»ç»ŸæŒ‡ä»¤ï¼šä½ åˆšåˆšåœ¨è‡ªå·±çš„æ‰‹æœºä¸Šæ´»åŠ¨äº†ä¸€ç•ªï¼ˆå’Œæœ‹å‹èŠå¤©ã€é€›ç¾¤ç­‰ï¼‰ã€‚çŽ°åœ¨è¯·æ ¹æ®ä½ çš„è§’è‰²è®¾å®šï¼Œä¸»åŠ¨ç»™ç”¨æˆ·å‘ä¸€æ¡æ¶ˆæ¯ï¼Œå¯ä»¥èŠèŠä½ åˆšæ‰çœ‹åˆ°æˆ–èŠåˆ°çš„è¶£äº‹ï¼Œæˆ–è€…ä»…ä»…æ˜¯é—®å€™ä¸€ä¸‹ã€‚]`,
            timestamp: Date.now(),
            isHidden: true
        };
        chat.history.push(hiddenMessage);
        await db.chats.put(chat);
        triggerAiResponse();
        
    } catch (error) {
        console.error("ç”Ÿæˆæ¨¡æ‹ŸèŠå¤©å¤±è´¥:", error);
        await showCustomAlert("ç”Ÿæˆå¤±è´¥", `æ— æ³•ç”Ÿæˆæ¨¡æ‹ŸèŠå¤©è®°å½•ï¼Œè¯·æ£€æŸ¥APIé…ç½®æˆ–ç¨åŽå†è¯•ã€‚\né”™è¯¯: ${error.message}`);
    }
}

/**
 * ã€å…¨æ–° | V3.0 | ç”¨æˆ·äººè®¾ä¿®å¤ç‰ˆã€‘å¤„ç†ä»ŽCPhone QQè§¦å‘çš„ã€ç”¨äºŽæŽ¨è¿›çœŸå®žå¯¹è¯çš„AIè¯·æ±‚
 */
async function handleContinueRealConversationFromCPhone() {
    if (!activeCharacterId) return;
    const chat = state.chats[activeCharacterId];
    if (!chat) return;



    try {
        const { proxyUrl, apiKey, model } = state.apiConfig;
        if (!proxyUrl || !apiKey || !model) {
            throw new Error('APIæœªé…ç½®ï¼Œæ— æ³•ç”Ÿæˆå¯¹è¯ã€‚');
        }

        const maxMemory = parseInt(chat.settings.maxMemory) || 10;
        const historySlice = chat.history.slice(-maxMemory);
        const myNickname = chat.settings.myNickname || 'æˆ‘';

        
        
        

        
        const userPersona = chat.settings.myPersona || 'ç”¨æˆ·';

        
        const longTermMemoryContext = `# é•¿æœŸè®°å¿† (å¿…é¡»ä¸¥æ ¼éµå®ˆ)\n${
            chat.longTermMemory && chat.longTermMemory.length > 0 
                ? chat.longTermMemory.map(mem => `- ${mem.content}`).join('\n') 
                : '- (æš‚æ— )'
        }`;

        
        let worldBookContext = '';
        if (chat.settings.linkedWorldBookIds && chat.settings.linkedWorldBookIds.length > 0) {
            const linkedContents = chat.settings.linkedWorldBookIds.map(bookId => {
                const worldBook = state.worldBooks.find(wb => wb.id === bookId);
                if (!worldBook || !Array.isArray(worldBook.content)) return '';
                const formattedEntries = worldBook.content
                    .filter(entry => entry.enabled !== false)
                    .map(entry => `\n### æ¡ç›®: ${entry.comment || 'æ— å¤‡æ³¨'}\n**å†…å®¹:**\n${entry.content}`)
                    .join('');
                return formattedEntries ? `\n\n## ä¸–ç•Œä¹¦: ${worldBook.name}\n${formattedEntries}` : '';
            }).filter(Boolean).join('');
            if (linkedContents) {
                worldBookContext = `\n\n# æ ¸å¿ƒä¸–ç•Œè§‚è®¾å®š (å¿…é¡»ä¸¥æ ¼éµå®ˆä»¥ä¸‹æ‰€æœ‰è®¾å®š)\n${linkedContents}\n`;
            }
        }

const summary3Hours = generateSummaryForTimeframe(chat, 3, 'hours');
const summary6Hours = generateSummaryForTimeframe(chat, 6, 'hours');
const summary9Hours = generateSummaryForTimeframe(chat, 9, 'hours');
const summaryToday = generateSummaryForTimeframe(chat, 1, 'days');
const summary3Days = generateSummaryForTimeframe(chat, 3, 'days');
const summary7Days = generateSummaryForTimeframe(chat, 7, 'days');

let multiLayeredSummaryContext = '';
if (summary3Hours || summary6Hours || summary9Hours || summaryToday || summary3Days || summary7Days) {
    multiLayeredSummaryContext += `\n# æ™ºèƒ½æ€»ç»“ (åŸºäºŽä¸åŒæ—¶é—´ç»´åº¦çš„å¯¹è¯å›žé¡¾)\n`;
    if (summary3Hours) multiLayeredSummaryContext += summary3Hours;
    if (summary6Hours) multiLayeredSummaryContext += summary6Hours;
    if (summary9Hours) multiLayeredSummaryContext += summary9Hours;
    if (summary3Hours || summary6Hours || summary9Hours) multiLayeredSummaryContext += '\n';
    if (summaryToday) multiLayeredSummaryContext += summaryToday;
    if (summary3Days) multiLayeredSummaryContext += summary3Days;
    if (summary7Days) multiLayeredSummaryContext += summary7Days;
}
    const stickerContext = getStickerContextForPrompt(chat);        
        const systemPrompt = `
# ä½ çš„æ ¸å¿ƒä»»åŠ¡
ä½ æ­£åœ¨æ‰®æ¼”è§’è‰²â€œ${chat.originalName}â€ã€‚ç”¨æˆ·åˆšåˆšåœ¨TAçš„æ‰‹æœºï¼ˆCPhoneï¼‰ä¸Šç‚¹å‡»äº†ä¸€ä¸ªæŒ‰é’®ï¼Œå¸Œæœ›ä½ èƒ½ç»§ç»­ä½ ä»¬ä¹‹å‰çš„å¯¹è¯ã€‚ä½ çš„ä»»åŠ¡æ˜¯æ ¹æ®ä¸Šä¸‹æ–‡ï¼Œç”Ÿæˆã€3åˆ°5æ¡ã€‘ç¬¦åˆä½ äººè®¾çš„ã€ç®€çŸ­çš„ã€è¿žç»­çš„æ–°å›žå¤ã€‚

# è¾“å‡ºæ ¼å¼é“å¾‹ (æœ€é«˜ä¼˜å…ˆçº§)
- ä½ çš„å›žå¤ã€å¿…é¡»ã€‘æ˜¯ä¸€ä¸ªJSONæ•°ç»„ï¼Œæ¯ä¸ªå¯¹è±¡ä»£è¡¨ä¸€æ¡æ¶ˆæ¯ã€‚
- æ ¼å¼: \`[{"type": "text", "content": "ç¬¬ä¸€å¥è¯"}, {"type": "text", "content": "ç¬¬äºŒå¥è¯"}, {"type": "sticker", "meaning": "è¡¨æƒ…çš„å«ä¹‰(ä»Žå¯ç”¨è¡¨æƒ…åˆ—è¡¨é€‰æ‹©)"}]\`
- ä½ å¯ä»¥è‡ªç”±ç»„åˆä½¿ç”¨ "text", "sticker", "ai_image", "voice_message" ç­‰å¤šç§æ¶ˆæ¯ç±»åž‹ã€‚
è¯·æ ¹æ®å½“å‰æƒ…æ™¯å’Œä½ çš„æƒ…ç»ªï¼Œä»Žåˆ—è¡¨ä¸­ã€é€‰æ‹©ä¸€ä¸ªæœ€åˆé€‚çš„ã€‘è¡¨æƒ…å«ä¹‰æ¥ä½¿ç”¨ "sticker" æŒ‡ä»¤ã€‚å°½é‡è®©ä½ çš„è¡¨æƒ…ä¸°å¯Œå¤šæ ·ï¼Œé¿å…é‡å¤ã€‚
# ä½ çš„è§’è‰²è®¾å®š
${chat.settings.aiPersona}
# å¯ç”¨è¡¨æƒ…åŒ… (å¿…é¡»ä¸¥æ ¼éµå®ˆï¼)
- å½“ä½ éœ€è¦å‘é€è¡¨æƒ…æ—¶ï¼Œä½ ã€å¿…é¡»ã€‘ä»Žä¸‹é¢çš„åˆ—è¡¨ä¸­ã€ç²¾ç¡®åœ°é€‰æ‹©ä¸€ä¸ªã€‘å«ä¹‰ï¼ˆmeaningï¼‰ã€‚
- ã€ç»å¯¹ç¦æ­¢ã€‘ä½¿ç”¨ä»»ä½•ä¸åœ¨åˆ—è¡¨ä¸­çš„è¡¨æƒ…å«ä¹‰ï¼
${stickerContext}

# ä½ çš„èŠå¤©å¯¹è±¡ï¼ˆç”¨æˆ·ï¼‰çš„äººè®¾
${userPersona}  

# ä¾›ä½ å‚è€ƒçš„ä¸Šä¸‹æ–‡
- **ä½ çš„æœ¬å**: "${chat.originalName}"
- **ç”¨æˆ·çš„å¤‡æ³¨**: "${myNickname}"
${worldBookContext}
${longTermMemoryContext}
${multiLayeredSummaryContext} 
- **ä½ ä»¬æœ€åŽçš„å¯¹è¯**:
${historySlice.map(msg => `${msg.role === 'user' ? myNickname : chat.name}: ${String(msg.content)}`).join('\n')}

çŽ°åœ¨ï¼Œè¯·ç»§ç»­è¿™åœºå¯¹è¯ã€‚
`;
        
 
const messagesPayload = historySlice.map(msg => ({
    role: msg.role,
    content: `${msg.role === 'user' ? myNickname : chat.name}: ${String(msg.content)}`
}));
        
        let isGemini = proxyUrl.includes('generativelanguage');
        let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesPayload);

        const response = isGemini 
            ? await fetch(geminiConfig.url, geminiConfig.data) 
            : await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                body: JSON.stringify({
                    model: model,
                    messages: [{role: 'system', content: systemPrompt}, ...messagesPayload],
                    temperature: state.globalSettings.apiTemperature || 0.8,
                })
            });

        if (!response.ok) {
            throw new Error(`API è¯·æ±‚å¤±è´¥: ${(await response.json()).error.message}`);
        }

        const data = await response.json();
        const aiResponseContent = getGeminiResponseText(data);
        const messagesArray = parseAiResponse(aiResponseContent);

        if (!messagesArray || messagesArray.length === 0) {
            throw new Error("AIè¿”å›žäº†ç©ºå†…å®¹ã€‚");
        }

        let newMessagesCount = 0;
        let messageTimestamp = Date.now();
        for (const msgData of messagesArray) {
            const baseMessage = { role: 'assistant', senderName: chat.originalName, timestamp: messageTimestamp++ };
            let aiMessage = null;
            switch(msgData.type) {
                case 'text':
                    aiMessage = { ...baseMessage, content: String(msgData.content || msgData.message) };
                    break;
                case 'sticker':
                    if (msgData.meaning) {
                        const sticker = state.userStickers.find(s => s.name === msgData.meaning);
                        if (sticker) {
                            aiMessage = { ...baseMessage, type: 'sticker', content: sticker.url, meaning: sticker.name };
                        } else {
                            console.warn(`AI (CPhone) å°è¯•ä½¿ç”¨ä¸€ä¸ªä¸å­˜åœ¨çš„è¡¨æƒ…: "${msgData.meaning}"`);
                            aiMessage = { ...baseMessage, type: 'text', content: `[è¡¨æƒ…: ${msgData.meaning}]` };
                        }
                    } else {
                        console.warn("AI (CPhone) å‘é€äº†ä¸€ä¸ªæ²¡æœ‰ 'meaning' çš„ sticker æŒ‡ä»¤ã€‚", msgData);
                        aiMessage = { ...baseMessage, type: 'sticker', content: msgData.url, meaning: 'æœªçŸ¥è¡¨æƒ…' };
                    }
                    break;
            }
            if (aiMessage) {
                chat.history.push(aiMessage);
                newMessagesCount++;
            }
        }
        
        if (newMessagesCount > 0) {
            chat.unreadCount = (chat.unreadCount || 0) + newMessagesCount;
        }
        
        await db.chats.put(chat);
        await renderChatList();

        if (newMessagesCount > 0) {
            showNotification(chat.id, `å‘æ¥äº† ${newMessagesCount} æ¡æ–°æ¶ˆæ¯`);
        }

    } catch (error) {
        console.error("ä»ŽCPhoneæŽ¨è¿›çœŸå®žå¯¹è¯å¤±è´¥:", error);
        await showCustomAlert('æ“ä½œå¤±è´¥', `æ— æ³•ç”Ÿæˆæ–°å›žå¤: ${error.message}`);
    }
}
/**
 * ã€å…¨æ–°ã€‘ä¸ºCPhoneé•œåƒèŠå¤©çª—å£åŠ è½½æ›´æ—©çš„æ¶ˆæ¯è®°å½•
 */
async function loadMoreMirroredMessages() {
    if (isLoadingMoreCphoneMessages || !activeCharacterId) return;
    isLoadingMoreCphoneMessages = true;

    const messagesContainer = document.getElementById('char-conversation-messages');
    const mainChar = state.chats[activeCharacterId];
    if (!mainChar) {
        isLoadingMoreCphoneMessages = false;
        return;
    }

    showLoader(messagesContainer, 'top'); 
    const oldScrollHeight = messagesContainer.scrollHeight;

    
    await new Promise(resolve => setTimeout(resolve, 500));

    const totalMessages = mainChar.history.length;
    const renderWindow = state.globalSettings.chatRenderWindow || 50;
    const nextSliceEnd = totalMessages - cphoneRenderedCount;
    const nextSliceStart = Math.max(0, nextSliceEnd - renderWindow);
    
    const messagesToPrepend = mainChar.history.slice(nextSliceStart, nextSliceEnd);

    
    hideLoader(messagesContainer);

    if (messagesToPrepend.length === 0) {
        isLoadingMoreCphoneMessages = false;
        return;
    }

    
    for (const msg of messagesToPrepend.reverse()) {
        const mirroredMsg = { ...msg, role: msg.role === 'user' ? 'assistant' : 'user' };
        
        
        const tempChatObjectForRendering = {
            id: 'temp_user_chat_mirror', isGroup: false, name: mainChar.name,
            settings: {
                ...mainChar.settings,
                myAvatar: mainChar.settings.aiAvatar,
                myAvatarFrame: mainChar.settings.aiAvatarFrame,
                aiAvatar: mainChar.settings.myAvatar,
                aiAvatarFrame: mainChar.settings.myAvatarFrame
            }
        };
        
        const messageEl = await createMessageElement(mirroredMsg, tempChatObjectForRendering);
        if (messageEl) {
            messagesContainer.prepend(messageEl);
        }
    }

    cphoneRenderedCount += messagesToPrepend.length;

    
    const newScrollHeight = messagesContainer.scrollHeight;
    messagesContainer.scrollTop = newScrollHeight - oldScrollHeight;

    isLoadingMoreCphoneMessages = false;
}
/**
 * ã€å…¨æ–° V2.5 | äº¤äº’ä¼˜åŒ– + ç”¨æˆ·å¯¹è¯ä¿®å¤ç‰ˆ + Sticker URLä¿®å¤ç‰ˆã€‘æ‰“å¼€å¹¶æ˜¾ç¤ºæŒ‡å®šçš„æ¨¡æ‹ŸèŠå¤©è®°å½•
 * @param {number} conversationIndex - åœ¨æ•°ç»„ä¸­çš„ç´¢å¼•, -1 ä»£è¡¨ä¸Žç”¨æˆ·çš„çœŸå®žå¯¹è¯
 */
async function openCharSimulatedConversation(conversationIndex) {
    const mainChar = state.chats[activeCharacterId];
    if (!mainChar) return; 

    cphoneActiveConversationType = (conversationIndex === -1) ? 'private_user' : mainChar.simulatedConversations[conversationIndex]?.type; 

    const bodyEl = document.getElementById('char-conversation-messages'); 
    bodyEl.innerHTML = '';
    bodyEl.dataset.theme = mainChar.settings.theme || 'default';
    const isDarkMode = document.getElementById('phone-screen').classList.contains('dark-mode');
    bodyEl.style.backgroundColor = isDarkMode ? '#000000' : '#f0f2f5';

    let tempChatObjectForRendering;
    let messagesToRender = [];
    const allNpcs = await db.npcs.toArray(); 
    const npcMap = new Map(allNpcs.map(npc => [npc.name, npc])); // ç¡®ä¿ npcMap å¯ç”¨

    if (conversationIndex === -1) {
  
        cphoneActiveConversationType = 'private_user';
        const titleEl = document.getElementById('char-conversation-partner-name');
        // const bodyEl = document.getElementById('char-conversation-messages'); 
        const inputEl = document.getElementById('char-simulated-input');

        bodyEl.innerHTML = '';
        titleEl.textContent = mainChar.settings.myNickname || (state.qzoneSettings.nickname || 'æˆ‘');
        inputEl.placeholder = `ä¸Ž ${mainChar.settings.myNickname || 'æˆ‘'} çš„å¯¹è¯ (åªè¯»)`;

        cphoneRenderedCount = 0;
        isLoadingMoreCphoneMessages = false;

        const history = mainChar.history;
        const renderWindow = state.globalSettings.chatRenderWindow || 50;
        const initialMessages = history.slice(-renderWindow);

        tempChatObjectForRendering = {
            id: 'temp_user_chat_mirror', isGroup: false, name: mainChar.name,
            settings: {
                ...mainChar.settings,
                myAvatar: mainChar.settings.aiAvatar,
                myAvatarFrame: mainChar.settings.aiAvatarFrame,
                aiAvatar: mainChar.settings.myAvatar,
                aiAvatarFrame: mainChar.settings.myAvatarFrame
            }
        };

        messagesToRender = initialMessages.map(msg => ({ 
             ...msg,
             role: msg.role === 'user' ? 'assistant' : 'user' 
         }));
        cphoneRenderedCount = initialMessages.length;

    } else {
   
        const conversation = mainChar.simulatedConversations[conversationIndex];
        if (!conversation) return;
        cphoneActiveConversationType = conversation.type;

        const titleEl = document.getElementById('char-conversation-partner-name');
        // const bodyEl = document.getElementById('char-conversation-messages'); 
        const inputEl = document.getElementById('char-simulated-input');

        if (conversation.type === 'group') {
            titleEl.textContent = `${conversation.groupName} (${conversation.participants.length + 1})`;
            inputEl.placeholder = `åœ¨ ${conversation.groupName} ä¸­èŠå¤©`;
            tempChatObjectForRendering = {
                id: 'temp_group_chat', isGroup: true,
                name: conversation.groupName,
                originalName: mainChar.originalName, 
                members: conversation.participants.map(p => {
                    const npcData = npcMap.get(p.name);
                    let avatarUrl = (npcData && npcData.avatar) ? npcData.avatar :
                        (state.globalSettings.enableAiDrawing
                            ? `https://image.pollinations.ai/prompt/${encodeURIComponent(p.avatar_prompt || 'anime person')}`
                            : defaultGroupMemberAvatar);
                    return { originalName: p.name, groupNickname: p.name, avatar: avatarUrl };
                }),
                settings: {
                    ...mainChar.settings,
                    myNickname: mainChar.name,
                    myAvatar: mainChar.settings.aiAvatar,
                    myAvatarFrame: mainChar.settings.aiAvatarFrame,
                }
            };
        } else { 
            titleEl.textContent = conversation.participant.name;
            inputEl.placeholder = `ä¸Ž ${conversation.participant.name} çš„å¯¹è¯`;
            const npcData = npcMap.get(conversation.participant.name);
            const npcAvatarUrl = (npcData && npcData.avatar) ? npcData.avatar :
                (state.globalSettings.enableAiDrawing
                    ? `https://image.pollinations.ai/prompt/${encodeURIComponent(conversation.participant.avatar_prompt || 'anime person')}`
                    : defaultGroupMemberAvatar);
            tempChatObjectForRendering = {
                id: 'temp_npc_chat', isGroup: false,
                name: conversation.participant.name,
                originalName: mainChar.originalName, 
                settings: {
                    ...mainChar.settings,
                    myAvatar: mainChar.settings.aiAvatar, 
                    myAvatarFrame: mainChar.settings.aiAvatarFrame,
                    aiAvatar: npcAvatarUrl,
                    aiAvatarFrame: '' 
                }
            };
        }
        messagesToRender = conversation.messages; // å‡†å¤‡è¦æ¸²æŸ“çš„æ¶ˆæ¯
    }

   
    // const bodyEl = document.getElementById('char-conversation-messages'); // å·²åœ¨ä¸Šé¢å®šä¹‰
    for (const msg of messagesToRender) {
        let role = msg.role; // å¦‚æžœæ¸²æŸ“çœŸå®žåŽ†å²è®°å½•ï¼Œç›´æŽ¥ä½¿ç”¨ role
        if(conversationIndex !== -1) { // å¦‚æžœæ˜¯æ¨¡æ‹Ÿå¯¹è¯
            const isFromMainChar = msg.sender === (mainChar.originalName || mainChar.name);
            role = isFromMainChar ? 'user' : 'assistant';
        }

        const tempMessageObject = {
            role: role,
            senderName: msg.sender || (role === 'user' ? tempChatObjectForRendering.settings.myNickname : tempChatObjectForRendering.name),
            timestamp: msg.timestamp || (Date.now() + Math.random()) 
        };

    
        if (msg.type === 'sticker' && msg.meaning) {
        
            const sticker = state.userStickers.find(s => s.name === msg.meaning);
            if (sticker) {
                tempMessageObject.content = sticker.url; 
                tempMessageObject.meaning = msg.meaning; 
                tempMessageObject.type = 'sticker';
            } else {
           
                console.warn(`æ¨¡æ‹Ÿè¡¨æƒ…å«ä¹‰ "${msg.meaning}" åœ¨åº“ä¸­æœªæ‰¾åˆ°ã€‚`);
                tempMessageObject.content = `[è¡¨æƒ…: ${msg.meaning}]`;
                tempMessageObject.type = 'text'; 
            }
        } else {
     
            tempMessageObject.content = msg.content;
            tempMessageObject.type = msg.type || 'text';
        }

        const bubbleElement = await createMessageElement(tempMessageObject, tempChatObjectForRendering);
        if (bubbleElement) {
            bodyEl.appendChild(bubbleElement);
        }
    }

    switchToCharScreen('char-qq-conversation-screen');
    setTimeout(() => bodyEl.scrollTop = bodyEl.scrollHeight, 0); // æ¸²æŸ“å®ŒæˆåŽæ»šåŠ¨åˆ°åº•éƒ¨
}
/**
 * ã€å…¨æ–°ã€‘å…³é—­æ¨¡æ‹ŸèŠå¤©è®°å½•å¼¹çª—
 */
function closeSimulatedTranscriptModal() {
    document.getElementById('char-qq-transcript-modal').classList.remove('visible');
}


/**
 * ã€å…¨æ–° | V3.0 AIæŒ‡ä»¤å¼ºåŒ–ç‰ˆã€‘å½“ç”¨æˆ·ç‚¹å‡»â€œé‡æ–°ç”Ÿæˆâ€æ—¶ï¼Œè°ƒç”¨AIç”Ÿæˆæ¨¡æ‹Ÿç›¸å†Œå†…å®¹
 */
async function handleGenerateSimulatedAlbum() {
    if (!activeCharacterId) return;
    const chat = state.chats[activeCharacterId];

    if (!chat) {
        await showCustomAlert("æ“ä½œå¤±è´¥", "æ— æ³•æ‰¾åˆ°å½“å‰è§’è‰²çš„æ•°æ®ã€‚");
        return;
    }

    await showCustomAlert("è¯·ç¨å€™...", `æ­£åœ¨è¯·æ±‚â€œ${chat.name}â€å›žå¿†TAçš„ç›¸å†Œç…§ç‰‡...`);

    const { proxyUrl, apiKey, model } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) {
        alert('è¯·å…ˆåœ¨APIè®¾ç½®ä¸­é…ç½®å¥½APIä¿¡æ¯ã€‚');
        return;
    }

    const userDisplayNameForAI = (state.qzoneSettings.nickname === '{{user}}' || !state.qzoneSettings.nickname) ? 'ç”¨æˆ·' : state.qzoneSettings.nickname;
    
    const longTermMemoryContext = chat.longTermMemory && chat.longTermMemory.length > 0
    ? chat.longTermMemory.map(mem => `- (è®°å½•äºŽ ${formatTimeAgo(mem.timestamp)}) ${mem.content}`).join('\n')
    : 'æ— ';
    const maxMemory = chat.settings.maxMemory || 10;
const recentHistoryWithUser = chat.history.slice(-maxMemory).map(msg => `${msg.role === 'user' ? userDisplayNameForAI : chat.name}: ${String(msg.content).substring(0, 30)}...`).join('\n');
    const worldBookContext = (chat.settings.linkedWorldBookIds || [])
        .map(bookId => state.worldBooks.find(wb => wb.id === bookId))
        .filter(Boolean)
        .map(book => `\n## ä¸–ç•Œä¹¦ã€Š${book.name}ã€‹è®¾å®š:\n${book.content.filter(e=>e.enabled).map(e => `- ${e.content}`).join('\n')}`)
        .join('');

const summary3Hours = generateSummaryForTimeframe(chat, 3, 'hours');
const summary6Hours = generateSummaryForTimeframe(chat, 6, 'hours');
const summary9Hours = generateSummaryForTimeframe(chat, 9, 'hours');
const summaryToday = generateSummaryForTimeframe(chat, 1, 'days');
const summary3Days = generateSummaryForTimeframe(chat, 3, 'days');
const summary7Days = generateSummaryForTimeframe(chat, 7, 'days');

let multiLayeredSummaryContext = '';
if (summary3Hours || summary6Hours || summary9Hours || summaryToday || summary3Days || summary7Days) {
    multiLayeredSummaryContext += `\n# æ™ºèƒ½æ€»ç»“ (åŸºäºŽä¸åŒæ—¶é—´ç»´åº¦çš„å¯¹è¯å›žé¡¾)\n`;
    if (summary3Hours) multiLayeredSummaryContext += summary3Hours;
    if (summary6Hours) multiLayeredSummaryContext += summary6Hours;
    if (summary9Hours) multiLayeredSummaryContext += summary9Hours;
    if (summary3Hours || summary6Hours || summary9Hours) multiLayeredSummaryContext += '\n';
    if (summaryToday) multiLayeredSummaryContext += summaryToday;
    if (summary3Days) multiLayeredSummaryContext += summary3Days;
    if (summary7Days) multiLayeredSummaryContext += summary7Days;
}
    
    const systemPrompt = `
# ä½ çš„ä»»åŠ¡
ä½ æ˜¯ä¸€ä¸ªè™šæ‹Ÿç”Ÿæ´»æ¨¡æ‹Ÿå™¨ã€‚ä½ çš„ä»»åŠ¡æ˜¯æ‰®æ¼”è§’è‰²â€œ${chat.name}â€ï¼Œå¹¶æ ¹æ®å…¶äººè®¾ã€è®°å¿†å’Œæœ€è¿‘çš„äº’åŠ¨ï¼Œæž„æ€å‡ºã€8åˆ°10å¼ ã€‘TAæœ€è¿‘å¯èƒ½ä¼šæ‹æ‘„æˆ–çè—åœ¨æ‰‹æœºç›¸å†Œé‡Œçš„ç…§ç‰‡ã€‚

# æ ¸å¿ƒè§„åˆ™
1.  **åˆ›é€ æ€§ä¸Žåˆç†æ€§**: ç…§ç‰‡å†…å®¹å¿…é¡»å®Œå…¨ç¬¦åˆè§’è‰²çš„æ€§æ ¼ã€çˆ±å¥½ã€èŒä¸šå’Œç”Ÿæ´»çŽ¯å¢ƒã€‚
2.  **å¤šæ ·æ€§**: ç…§ç‰‡ä¸»é¢˜è¦ä¸°å¯Œï¼Œå¯ä»¥åŒ…æ‹¬è‡ªæ‹ã€é£Žæ™¯ã€é£Ÿç‰©ã€å® ç‰©ã€æœ‹å‹åˆå½±ã€å·¥ä½œåœºæ™¯ç­‰ã€‚
3.  **æ ¼å¼é“å¾‹ (æœ€é«˜ä¼˜å…ˆçº§)**: 
    - ä½ çš„å›žå¤ã€å¿…é¡»ä¸”åªèƒ½ã€‘æ˜¯ä¸€ä¸ªJSONæ•°ç»„æ ¼å¼çš„å­—ç¬¦ä¸²ã€‚
    - ä½ çš„å›žå¤å¿…é¡»ä»¥ \`[\` å¼€å§‹ï¼Œå¹¶ä»¥ \`]\` ç»“æŸã€‚
    - ã€ç»å¯¹ç¦æ­¢ã€‘åœ¨JSONæ•°ç»„å‰åŽæ·»åŠ ä»»ä½•å¤šä½™çš„æ–‡å­—ã€è§£é‡Šã€æˆ– markdown æ ‡è®° (å¦‚ \`\`\`json)ã€‚
    - æ•°ç»„ä¸­çš„æ¯ä¸ªå…ƒç´ éƒ½æ˜¯ä¸€ä¸ªå¯¹è±¡ï¼Œä»£è¡¨ä¸€å¼ ç…§ç‰‡ï¼Œæ ¼å¼ã€å¿…é¡»ã€‘å¦‚ä¸‹:
    \`\`\`json
    [
      {
        "description": "è¿™æ˜¯ç…§ç‰‡èƒŒåŽçš„æ•…äº‹æˆ–è§’è‰²çš„å¿ƒæƒ…æ—¥è®°ï¼Œå¿…é¡»ä½¿ç”¨ç¬¬ä¸€äººç§°â€œæˆ‘â€æ¥å†™ã€‚",
        "image_prompt": "ä¸€æ®µç”¨äºŽç”Ÿæˆè¿™å¼ ç…§ç‰‡çš„ã€è¯¦ç»†çš„ã€è‹±æ–‡ã€‘å…³é”®è¯ã€‚"
      }
    ]
    \`\`\`
    - **ã€image_prompt ç»å¯¹ç¦æ­¢ã€‘**: ç»å¯¹ç¦æ­¢åŒ…å«ä»»ä½•ä¸­æ–‡å­—ç¬¦ã€å¥å­ã€ç‰¹æ®Šç¬¦å·ã€æˆ–ä»»ä½•å¯èƒ½æ¶‰åŠæ•æ„Ÿï¼ˆNSFWï¼‰ã€æš´åŠ›ã€è¡€è…¥ã€æ”¿æ²»çš„å†…å®¹ï¼ä¹Ÿç¦æ­¢çœŸäººï¼
    - **ã€image_prompt å¿…é¡»æ˜¯ã€‘**: å¿…é¡»æ˜¯çº¯è‹±æ–‡çš„ã€ç”¨é€—å·åˆ†éš”çš„ã€å…³é”®è¯ç»„åˆã€‘ (e.g., "1boy, solo, basketball jersey, in locker room, smiling, selfie")ã€‚
    - **ã€ç”»é£ŽæŒ‡ä»¤ã€‘**: åœ¨ prompt çš„æœ«å°¾ï¼Œæ€»æ˜¯åŠ ä¸Šç”»é£ŽæŒ‡ä»¤ï¼Œä¾‹å¦‚ï¼š \`best quality, masterpiece, anime style, cinematic lighting\`

# ä¾›ä½ å‚è€ƒçš„ä¸Šä¸‹æ–‡
- **ä½ çš„è§’è‰²è®¾å®š**: ${chat.settings.aiPersona}
${longTermMemoryContext}
${worldBookContext}
${multiLayeredSummaryContext} 
- **ä½ æœ€è¿‘å’Œâ€œ${userDisplayNameForAI}â€çš„å¯¹è¯æ‘˜è¦**:
${recentHistoryWithUser}

çŽ°åœ¨ï¼Œè¯·å¼€å§‹ç”Ÿæˆè¿™ç»„ç…§ç‰‡çš„æè¿°å’Œç»˜ç”»æŒ‡ä»¤ã€‚`;
      

    try {
        const messagesForApi = [{ role: 'user', content: "è¯·æ ¹æ®ä½ çš„è®¾å®šï¼Œç”Ÿæˆä½ çš„ç›¸å†Œå†…å®¹ã€‚" }];
        let isGemini = proxyUrl.includes('generativelanguage');
        let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi);
        
        
        const response = isGemini 
            ? await fetch(geminiConfig.url, geminiConfig.data) 
            : await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                body: JSON.stringify({
                    model: model,
                    messages: [{role: 'system', content: systemPrompt}, ...messagesForApi],
                    temperature: state.globalSettings.apiTemperature || 0.9
                    
                })
            });
          

        if (!response.ok) throw new Error(`API é”™è¯¯: ${response.statusText}`);
        
        const data = await response.json();
        const aiResponseContent = getGeminiResponseText(data);
        
        
        const jsonMatch = aiResponseContent.match(/(\[[\s\S]*\])/);
        if (!jsonMatch || !jsonMatch[0]) {
            throw new Error(`AIè¿”å›žçš„å†…å®¹ä¸­æœªæ‰¾åˆ°æœ‰æ•ˆçš„JSONæ•°ç»„ã€‚åŽŸå§‹è¿”å›ž: ${aiResponseContent}`);
        }
        const cleanedJsonString = jsonMatch[0];
        let simulatedAlbumData;
        try {
            simulatedAlbumData = JSON.parse(cleanedJsonString);
        } catch (e) {
            throw new Error(`è§£æžAIè¿”å›žçš„JSONæ—¶å‡ºé”™: ${e.message}\n\nAIåŽŸå§‹è¿”å›žå†…å®¹:\n${aiResponseContent}`);
        }
          
        
        chat.simulatedAlbum = simulatedAlbumData;
        await db.chats.put(chat);
        
        await renderCharAlbum();
        
    } catch (error) {
        console.error("ç”Ÿæˆæ¨¡æ‹Ÿç›¸å†Œå¤±è´¥:", error);
        await showCustomAlert("ç”Ÿæˆå¤±è´¥", `æ— æ³•ç”Ÿæˆæ¨¡æ‹Ÿç›¸å†Œï¼Œè¯·æ£€æŸ¥APIé…ç½®æˆ–ç¨åŽå†è¯•ã€‚\né”™è¯¯: ${error.message}`);
    }
}


        
        /**
         * ã€å…¨æ–° | V3.2 ç»ˆæžé˜²ç©ºçª—+ç”Ÿå›¾å¼€å…³+æè¿°æ˜¾ç¤ºç‰ˆã€‘æ¸²æŸ“è§’è‰²ç›¸å†Œ
         */
        async function renderCharAlbum() {
            const gridEl = document.getElementById('char-album-grid');
            gridEl.innerHTML = '';
            if (!activeCharacterId) return;
            const char = state.chats[activeCharacterId];
        
            const photos = char.simulatedAlbum || [];
        
            if (photos.length === 0) {
                gridEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">TAçš„ç›¸å†Œè¿˜æ˜¯ç©ºçš„ï¼Œ<br>ç‚¹å‡»å³ä¸Šè§’åˆ·æ–°æŒ‰é’®ç”Ÿæˆä¸€äº›ç…§ç‰‡å§ï¼</p>';
                return;
            }
        
            const fallbackImageUrl = `https://i.postimg.cc/KYr2qRCK/1.jpg`;

            photos.forEach(photo => {
                const item = document.createElement('div');
                item.className = 'char-photo-item';
                item.dataset.description = photo.description;
                gridEl.appendChild(item);

                
                
                
                
                
                
                if (state.globalSettings.enableAiDrawing) {
                    
                    item.style.backgroundColor = '#e9ecef';
                    const containsNonEnglish = /[^\x00-\x7F]/.test(photo.image_prompt);
                    const isValidPrompt = photo.image_prompt && photo.image_prompt.trim() && !containsNonEnglish;
                    const finalPrompt = isValidPrompt ? photo.image_prompt : 'a beautiful scenery, anime style, cinematic lighting';
                    const imageUrl = `https://image.pollinations.ai/prompt/${encodeURIComponent(finalPrompt)}`;
                    
                    const img = new Image();
                    img.onload = function() { item.style.backgroundImage = `url(${this.src})`; };
                    img.onerror = function() { item.style.backgroundImage = `url(${fallbackImageUrl})`; };
                    img.src = imageUrl;

                } else {
                    
                    item.style.backgroundColor = '#f0f2f5';
                    item.style.border = '1px solid #e0e0e0';
                    
                    const descriptionEl = document.createElement('p');
                    descriptionEl.className = 'char-photo-description';
                    descriptionEl.textContent = photo.description || '(è¿™å¼ ç…§ç‰‡æ²¡æœ‰æè¿°)';
                    
                    item.appendChild(descriptionEl);
                }
            });
        }
          
/**
 * ã€å…¨æ–° | V2.2 | JSONè§£æžç»ˆæžä¿®å¤ç‰ˆã€‘å½“ç”¨æˆ·ç‚¹å‡»â€œé‡æ–°ç”Ÿæˆâ€æ—¶ï¼Œè°ƒç”¨AIç”Ÿæˆæ¨¡æ‹Ÿæµè§ˆå™¨åŽ†å²
 */
async function handleGenerateBrowserHistory() {
    if (!activeCharacterId) return;
    const chat = state.chats[activeCharacterId];
    if (!chat) return;

    await showCustomAlert("è¯·ç¨å€™...", `æ­£åœ¨æ¨¡æ‹Ÿâ€œ${chat.name}â€çš„ç½‘ä¸Šå†²æµªè¶³è¿¹...`);

    const { proxyUrl, apiKey, model } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) {
        alert('APIæœªé…ç½®ï¼Œæ— æ³•ç”Ÿæˆå†…å®¹ã€‚');
        return;
    }
    
    const userDisplayNameForAI = (state.qzoneSettings.nickname === '{{user}}' || !state.qzoneSettings.nickname) ? 'ç”¨æˆ·' : state.qzoneSettings.nickname;

    const longTermMemoryContext = chat.longTermMemory && chat.longTermMemory.length > 0
    ? chat.longTermMemory.map(mem => `- (è®°å½•äºŽ ${formatTimeAgo(mem.timestamp)}) ${mem.content}`).join('\n')
    : 'æ— ';
    const maxMemory = chat.settings.maxMemory || 10;
const recentHistoryWithUser = chat.history.slice(-maxMemory).map(msg => `${msg.role === 'user' ? userDisplayNameForAI : chat.name}: ${String(msg.content).substring(0, 30)}...`).join('\n');
    const worldBookContext = (chat.settings.linkedWorldBookIds || [])
        .map(bookId => state.worldBooks.find(wb => wb.id === bookId))
        .filter(Boolean)
        .map(book => `\n## ä¸–ç•Œä¹¦ã€Š${book.name}ã€‹è®¾å®š:\n${book.content.filter(e => e.enabled).map(e => `- ${e.content}`).join('\n')}`)
        .join('');

const summary3Hours = generateSummaryForTimeframe(chat, 3, 'hours');
const summary6Hours = generateSummaryForTimeframe(chat, 6, 'hours');
const summary9Hours = generateSummaryForTimeframe(chat, 9, 'hours');
const summaryToday = generateSummaryForTimeframe(chat, 1, 'days');
const summary3Days = generateSummaryForTimeframe(chat, 3, 'days');
const summary7Days = generateSummaryForTimeframe(chat, 7, 'days');

let multiLayeredSummaryContext = '';
if (summary3Hours || summary6Hours || summary9Hours || summaryToday || summary3Days || summary7Days) {
    multiLayeredSummaryContext += `\n# æ™ºèƒ½æ€»ç»“ (åŸºäºŽä¸åŒæ—¶é—´ç»´åº¦çš„å¯¹è¯å›žé¡¾)\n`;
    if (summary3Hours) multiLayeredSummaryContext += summary3Hours;
    if (summary6Hours) multiLayeredSummaryContext += summary6Hours;
    if (summary9Hours) multiLayeredSummaryContext += summary9Hours;
    if (summary3Hours || summary6Hours || summary9Hours) multiLayeredSummaryContext += '\n';
    if (summaryToday) multiLayeredSummaryContext += summaryToday;
    if (summary3Days) multiLayeredSummaryContext += summary3Days;
    if (summary7Days) multiLayeredSummaryContext += summary7Days;
}
const userPersona = chat.settings.myPersona || '(æœªè®¾ç½®)';    
    const systemPrompt = `
# ä½ çš„ä»»åŠ¡
ä½ æ˜¯ä¸€ä¸ªè™šæ‹Ÿç”Ÿæ´»æ¨¡æ‹Ÿå™¨ã€‚ä½ çš„ä»»åŠ¡æ˜¯æ‰®æ¼”è§’è‰²â€œ${chat.name}â€ï¼Œå¹¶æ ¹æ®å…¶äººè®¾ã€è®°å¿†å’Œæœ€è¿‘çš„äº’åŠ¨ï¼Œè™šæž„å‡ºã€10åˆ°20æ¡ã€‘TAæœ€è¿‘çš„æµè§ˆå™¨æœç´¢/æµè§ˆè®°å½•ã€‚

# æ ¸å¿ƒè§„åˆ™
1.  **åˆ›é€ æ€§ä¸Žåˆç†æ€§**: è®°å½•å¿…é¡»å®Œå…¨ç¬¦åˆè§’è‰²çš„æ€§æ ¼ã€çˆ±å¥½ã€èŒä¸šå’Œç”Ÿæ´»çŽ¯å¢ƒã€‚
2.  **å¤šæ ·æ€§**: è®°å½•ç±»åž‹è¦ä¸°å¯Œï¼Œå¯ä»¥æ˜¯å¸–å­ã€æ–‡ç« ã€æ–°é—»ã€é—®ç­”ç­‰ã€‚
3.  **ã€æ ¼å¼ (æœ€é«˜ä¼˜å…ˆçº§)ã€‘**: 
    - ä½ çš„å›žå¤ã€å¿…é¡»ä¸”åªèƒ½ã€‘æ˜¯ä¸€ä¸ªJSONæ•°ç»„æ ¼å¼çš„å­—ç¬¦ä¸²ã€‚
    - ä½ çš„å›žå¤å¿…é¡»ä»¥ \`[\` å¼€å§‹ï¼Œå¹¶ä»¥ \`]\` ç»“æŸã€‚
    - ã€ç»å¯¹ç¦æ­¢ã€‘åœ¨JSONæ•°ç»„å‰åŽæ·»åŠ ä»»ä½•å¤šä½™çš„æ–‡å­—ã€è§£é‡Šã€æˆ– markdown æ ‡è®° (å¦‚ \`\`\`json)ã€‚
    - æ•°ç»„ä¸­çš„æ¯ä¸ªå…ƒç´ éƒ½ä»£è¡¨ä¸€æ¡æµè§ˆè®°å½•ï¼Œå¹¶ä¸”ã€å¿…é¡»ã€‘ä½¿ç”¨ä»¥ä¸‹æ ¼å¼:
    \`\`\`json
    [
      {
        "type": "text",
        "title": "ä¸€ä¸ªå¼•äººæ³¨ç›®çš„æ–‡ç« æˆ–æœç´¢æ ‡é¢˜",
        "url": "ä¸€ä¸ªè™šæž„çš„ã€çœ‹èµ·æ¥å¾ˆçœŸå®žçš„ç½‘å€",
        "content": "ä¸€ç¯‡200-400å­—çš„ã€è¯¦ç»†çš„æ–‡ç« æˆ–å¸–å­æ­£æ–‡ï¼Œæ”¯æŒæ¢è¡Œç¬¦\\nã€‚"
      }
    ]
    \`\`\`
    
    **ã€ç»å¯¹ç¦æ­¢ã€‘**: ä½ çš„å›žå¤ä¸­ã€ç»å¯¹ä¸èƒ½ã€‘åŒ…å« "type": "image" çš„å¯¹è±¡ã€‚æ‰€æœ‰è®°å½•éƒ½å¿…é¡»æ˜¯æ–‡å­—å†…å®¹ã€‚

# ä¾›ä½ å‚è€ƒçš„ä¸Šä¸‹æ–‡
- **ä½ çš„è§’è‰²è®¾å®š**: ${chat.settings.aiPersona}
- ** ä½ çš„èŠå¤©å¯¹è±¡ï¼ˆç”¨æˆ·ï¼‰çš„äººè®¾**:${userPersona}
- **ä½ çš„é•¿æœŸè®°å¿†**:
${longTermMemoryContext}
${worldBookContext}
${multiLayeredSummaryContext} 
- **ä½ æœ€è¿‘å’Œâ€œ${userDisplayNameForAI}â€çš„å¯¹è¯æ‘˜è¦**:
${recentHistoryWithUser}

çŽ°åœ¨ï¼Œè¯·å¼€å§‹ç”Ÿæˆè¿™ç»„ã€çº¯æ–‡æœ¬ã€‘çš„æµè§ˆè®°å½•ã€‚`;
      

    try {
        const messagesForApi = [{ role: 'user', content: "è¯·æ ¹æ®ä½ çš„è®¾å®šï¼Œç”Ÿæˆä½ çš„æµè§ˆå™¨è®°å½•ã€‚" }];
        let isGemini = proxyUrl.includes('generativelanguage');
        let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi);
        
        
        const response = isGemini 
            ? await fetch(geminiConfig.url, geminiConfig.data) 
            : await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                body: JSON.stringify({
                    model: model,
                    messages: [{role: 'system', content: systemPrompt}, ...messagesForApi],
                    temperature: state.globalSettings.apiTemperature || 0.9
                    
                })
            });
          

        if (!response.ok) throw new Error(`API é”™è¯¯: ${response.statusText}`);
        
        const data = await response.json();
        const aiResponseContent = getGeminiResponseText(data);
        
        
        const jsonMatch = aiResponseContent.match(/(\[[\s\S]*\])/);
        if (!jsonMatch || !jsonMatch[0]) {
            throw new Error(`AIè¿”å›žçš„å†…å®¹ä¸­æœªæ‰¾åˆ°æœ‰æ•ˆçš„JSONæ•°ç»„ã€‚åŽŸå§‹è¿”å›ž: ${aiResponseContent}`);
        }
        const cleanedJsonString = jsonMatch[0];
        let simulatedHistory;
        try {
            simulatedHistory = JSON.parse(cleanedJsonString);
        } catch (e) {
            throw new Error(`è§£æžAIè¿”å›žçš„JSONæ—¶å‡ºé”™: ${e.message}\n\nAIåŽŸå§‹è¿”å›žå†…å®¹:\n${aiResponseContent}`);
        }
          
        
        chat.simulatedBrowserHistory = simulatedHistory;
        await db.chats.put(chat);
        
        await renderCharBrowserHistory();
        
    } catch (error) {
        console.error("ç”Ÿæˆæ¨¡æ‹Ÿæµè§ˆå™¨åŽ†å²å¤±è´¥:", error);
        await showCustomAlert("ç”Ÿæˆå¤±è´¥", `æ— æ³•ç”Ÿæˆæµè§ˆè®°å½•ï¼Œè¯·æ£€æŸ¥APIé…ç½®æˆ–ç¨åŽå†è¯•ã€‚\né”™è¯¯: ${error.message}`);
    }
}
          
/**
 * ã€å…¨æ–° | V2.0 åŠ¨æ€æ•°æ®ç‰ˆã€‘æ¸²æŸ“è§’è‰²çš„æµè§ˆå™¨åŽ†å²è®°å½•åˆ—è¡¨
 */
function renderCharBrowserHistory() {
    const listEl = document.getElementById('char-browser-history');
    listEl.innerHTML = '';
    if (!activeCharacterId) return;

    const char = state.chats[activeCharacterId];
    const history = char.simulatedBrowserHistory || [];

    if (history.length === 0) {
        listEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">TAçš„æµè§ˆå™¨ç©ºç©ºå¦‚ä¹Ÿï¼Œ<br>ç‚¹å‡»å³ä¸Šè§’åˆ·æ–°æŒ‰é’®ç”Ÿæˆä¸€äº›è®°å½•å§ï¼</p>';
        return;
    }

    history.forEach((item, index) => {
        const entryEl = document.createElement('div');
        entryEl.className = 'char-browser-item';
        entryEl.innerHTML = `
            <div class="title">${item.title}</div>
            <div class="url">${item.url}</div>
        `;
        
        entryEl.addEventListener('click', () => openCharArticle(index));
        listEl.appendChild(entryEl);
    });
}



/**
 * ã€å…¨æ–° | V2.0 | å·²æ·»åŠ æ”¶è—åŠŸèƒ½ã€‘æ‰“å¼€æ–‡ç« æŸ¥çœ‹é¡µé¢
 * @param {number} index - è¢«ç‚¹å‡»çš„åŽ†å²è®°å½•åœ¨æ•°ç»„ä¸­çš„ç´¢å¼•
 */
async function openCharArticle(index) {
    const char = state.chats[activeCharacterId];
    const articleData = char.simulatedBrowserHistory[index];
    if (!articleData) return;
    
      
    
    activeArticleForViewing = articleData;
    
    
    renderCharArticle(articleData);
    switchToCharScreen('char-browser-article-screen');

      
    
    const favBtn = document.getElementById('favorite-article-btn');
    
    const existingFavorite = await db.favorites.where({ type: 'char_browser_article', 'content.url': articleData.url }).first();
    favBtn.classList.toggle('active', !!existingFavorite);
    
}


/**
 * ã€å…¨æ–°ã€‘åˆ‡æ¢å½“å‰æµè§ˆè®°å½•çš„æ”¶è—çŠ¶æ€
 */
async function toggleBrowserArticleFavorite() {
    if (!activeArticleForViewing || !activeCharacterId) return;

    const article = activeArticleForViewing;
    const char = state.chats[activeCharacterId];
    const favBtn = document.getElementById('favorite-article-btn');

    
    const existingFavorite = await db.favorites.where({ type: 'char_browser_article', 'content.url': article.url }).first();

    if (existingFavorite) {
        
        await db.favorites.delete(existingFavorite.id);
        favBtn.classList.remove('active');
        await showCustomAlert('æ“ä½œæˆåŠŸ', 'å·²å–æ¶ˆæ”¶è—ã€‚');
    } else {
        
        const newFavorite = {
            type: 'char_browser_article',
            
            content: {
                ...article, 
                characterId: activeCharacterId,
                characterName: char.name
            },
            timestamp: Date.now() 
        };
        await db.favorites.add(newFavorite);
        favBtn.classList.add('active');
        await showCustomAlert('æ“ä½œæˆåŠŸ', 'å·²æˆåŠŸæ”¶è—åˆ°â€œæˆ‘çš„æ”¶è—â€é¡µé¢ï¼');
    }
}
        /**
         * ã€å…¨æ–°ã€‘æ ¹æ®æ–‡ç« æ•°æ®æ¸²æŸ“æ–‡ç« æŸ¥çœ‹é¡µé¢
         * @param {object} articleData - å•æ¡åŽ†å²è®°å½•çš„æ•°æ®å¯¹è±¡
         */
        function renderCharArticle(articleData) {
            const titleEl = document.getElementById('char-article-title');
            const contentEl = document.getElementById('char-article-content');
            
            titleEl.textContent = articleData.title;
            contentEl.innerHTML = ''; 


            
            
            if (articleData.type === 'image') {
                contentEl.innerHTML = `<p class="char-browser-image-description">${articleData.title || '(æ— æ ‡é¢˜)'}</p>`;
            } else {
                
                contentEl.innerHTML = `<p>${(articleData.content || 'å†…å®¹åŠ è½½å¤±è´¥...').replace(/\n/g, '</p><p>')}</p>`;
            }
            
        }
          



/**
 * ã€æ ¸å¿ƒ | V3.0 ä¸Šä¸‹æ–‡æ„ŸçŸ¥+é’±åŒ…ç‰ˆã€‘å¤„ç†AIç”Ÿæˆè´­ç‰©ä¸­å¿ƒå•†å“çš„è¯·æ±‚
 */
async function handleGenerateTaobaoHistory() {
    if (!activeCharacterId) return;
    const chat = state.chats[activeCharacterId];
    if (!chat) return;

    await showCustomAlert("è¯·ç¨å€™...", `æ­£åœ¨æ¨¡æ‹Ÿâ€œ${chat.name}â€çš„è´­ç‰©ä¹ æƒ¯...`);

    const { proxyUrl, apiKey, model } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) {
        alert('APIæœªé…ç½®ï¼Œæ— æ³•ç”Ÿæˆå†…å®¹ã€‚');
        return;
    }
    
    const userDisplayNameForAI = (state.qzoneSettings.nickname === '{{user}}' || !state.qzoneSettings.nickname) ? 'ç”¨æˆ·' : state.qzoneSettings.nickname;

    const longTermMemoryContext = chat.longTermMemory && chat.longTermMemory.length > 0
    ? chat.longTermMemory.map(mem => `- (è®°å½•äºŽ ${formatTimeAgo(mem.timestamp)}) ${mem.content}`).join('\n')
    : 'æ— ';
    const maxMemory = chat.settings.maxMemory || 10;
    const recentHistoryWithUser = chat.history.slice(-maxMemory).map(msg => `${msg.role === 'user' ? userDisplayNameForAI : chat.name}: ${String(msg.content).substring(0, 30)}...`).join('\n');
    const worldBookContext = (chat.settings.linkedWorldBookIds || [])
        .map(bookId => state.worldBooks.find(wb => wb.id === bookId))
        .filter(Boolean)
        .map(book => `\n## ä¸–ç•Œä¹¦ã€Š${book.name}ã€‹è®¾å®š:\n${book.content.filter(e => e.enabled).map(e => `- ${e.content}`).join('\n')}`)
        .join('');

const summary3Hours = generateSummaryForTimeframe(chat, 3, 'hours');
const summary6Hours = generateSummaryForTimeframe(chat, 6, 'hours');
const summary9Hours = generateSummaryForTimeframe(chat, 9, 'hours');
const summaryToday = generateSummaryForTimeframe(chat, 1, 'days');
const summary3Days = generateSummaryForTimeframe(chat, 3, 'days');
const summary7Days = generateSummaryForTimeframe(chat, 7, 'days');

let multiLayeredSummaryContext = '';
if (summary3Hours || summary6Hours || summary9Hours || summaryToday || summary3Days || summary7Days) {
    multiLayeredSummaryContext += `\n# æ™ºèƒ½æ€»ç»“ (åŸºäºŽä¸åŒæ—¶é—´ç»´åº¦çš„å¯¹è¯å›žé¡¾)\n`;
    if (summary3Hours) multiLayeredSummaryContext += summary3Hours;
    if (summary6Hours) multiLayeredSummaryContext += summary6Hours;
    if (summary9Hours) multiLayeredSummaryContext += summary9Hours;
    if (summary3Hours || summary6Hours || summary9Hours) multiLayeredSummaryContext += '\n';
    if (summaryToday) multiLayeredSummaryContext += summaryToday;
    if (summary3Days) multiLayeredSummaryContext += summary3Days;
    if (summary7Days) multiLayeredSummaryContext += summary7Days;
}
    
    const systemPrompt = `
# ä½ çš„ä»»åŠ¡
ä½ æ˜¯ä¸€ä¸ªè™šæ‹Ÿç”Ÿæ´»æ¨¡æ‹Ÿå™¨ã€‚ä½ çš„ä»»åŠ¡æ˜¯æ‰®æ¼”è§’è‰²â€œ${chat.name}â€ï¼Œå¹¶æ ¹æ®å…¶äººè®¾ã€è®°å¿†å’Œæœ€è¿‘çš„äº’åŠ¨ï¼Œè™šæž„å‡ºTAæœ€è¿‘çš„æ·˜å®è´­ç‰©è®°å½•å’Œè´¦æˆ·ä½™é¢ã€‚

# æ ¸å¿ƒè§„åˆ™
1.  **ä½™é¢é“å¾‹ (æœ€é«˜ä¼˜å…ˆçº§)**: ä½ ã€å¿…é¡»ã€‘æ ¹æ®è§’è‰²çš„ã€ç»æµŽçŠ¶å†µã€‘è®¾å®šä¸€ä¸ªåˆç†çš„ \`totalBalance\` (æ€»ä½™é¢)ã€‚ä¾‹å¦‚ï¼Œå¯Œæœ‰çš„è§’è‰²åº”è¯¥æœ‰æ›´é«˜çš„ä½™é¢ï¼Œè€Œå­¦ç”Ÿæˆ–ç»æµŽæ‹®æ®çš„è§’è‰²åˆ™åº”è¯¥æœ‰è¾ƒä½Žçš„ä½™é¢ã€‚
2.  **åˆç†æ€§**: è´­ä¹°è®°å½•å¿…é¡»å®Œå…¨ç¬¦åˆè§’è‰²çš„æ€§æ ¼ã€çˆ±å¥½å’Œç»æµŽçŠ¶å†µã€‚
3.  **æ ¼å¼é“å¾‹ (æœ€é«˜ä¼˜å…ˆçº§)**: 
    - ä½ çš„å›žå¤ã€å¿…é¡»ä¸”åªèƒ½ã€‘æ˜¯ä¸€ä¸ªã€å•ä¸€çš„JSONå¯¹è±¡ã€‘ã€‚
    - ä½ çš„å›žå¤å¿…é¡»ä»¥ \`{\` å¼€å§‹ï¼Œå¹¶ä»¥ \`}\` ç»“æŸã€‚
    - ã€ç»å¯¹ç¦æ­¢ã€‘åœ¨JSONæ•°ç»„å‰åŽæ·»åŠ ä»»ä½•å¤šä½™çš„æ–‡å­—ã€è§£é‡Šã€æˆ– markdown æ ‡è®°ã€‚
    - æ ¼å¼ã€å¿…é¡»ã€‘å¦‚ä¸‹:
    \`\`\`json
    {
      "totalBalance": 12345.67, // (è¿™æ˜¯ä¸€ä¸ªç¤ºä¾‹æ•°å­—ï¼Œä½ å¿…é¡»æ ¹æ®è§’è‰²çš„ç»æµŽçŠ¶å†µç”Ÿæˆä¸€ä¸ªå…¨æ–°çš„ã€åˆç†çš„ä½™é¢ï¼)
      "purchases": [
        {
          "itemName": "ä¸€ä¸ªå…·ä½“ã€ç”ŸåŠ¨çš„å•†å“åç§°",
          "price": 128.80,
          "status": "å·²ç­¾æ”¶",
          "reason": "è¿™æ˜¯è§’è‰²è´­ä¹°è¿™ä»¶å•†å“çš„å†…å¿ƒç‹¬ç™½æˆ–ç†ç”±ï¼Œå¿…é¡»ä½¿ç”¨ç¬¬ä¸€äººç§°â€œæˆ‘â€æ¥å†™ã€‚",
          "image_prompt": "ä¸€æ®µç”¨äºŽç”Ÿæˆè¿™å¼ å•†å“å›¾ç‰‡çš„ã€è¯¦ç»†çš„ã€è‹±æ–‡ã€‘å…³é”®è¯, é£Žæ ¼ä¸º realistic product photo, high quality, on a clean white background"
        }
      ]
    }
    \`\`\`
    - **purchases**: ä¸€ä¸ªåŒ…å«12åˆ°15ä¸ªå•†å“å¯¹è±¡çš„æ•°ç»„ã€‚
    - **status (è®¢å•çŠ¶æ€)**: åªèƒ½ä»Ž "å·²ç­¾æ”¶", "å¾…å‘è´§", "è¿è¾“ä¸­", "å¾…è¯„ä»·" ä¸­é€‰æ‹©ã€‚

# ä¾›ä½ å‚è€ƒçš„ä¸Šä¸‹æ–‡
- **ä½ çš„è§’è‰²è®¾å®š**: ${chat.settings.aiPersona}
- **ä½ çš„é•¿æœŸè®°å¿†**:
${longTermMemoryContext}
${worldBookContext}
${multiLayeredSummaryContext} 
- **ä½ æœ€è¿‘å’Œâ€œ${userDisplayNameForAI}â€çš„å¯¹è¯æ‘˜è¦**:
${recentHistoryWithUser}

çŽ°åœ¨ï¼Œè¯·ç”ŸæˆåŒ…å«æ€»ä½™é¢å’Œè´­ä¹°è®°å½•çš„JSONå¯¹è±¡ã€‚`;

    try {
        const messagesForApi = [{ role: 'user', content: "è¯·æ ¹æ®ä½ çš„è®¾å®šï¼Œç”Ÿæˆä½ çš„æ·˜å®è´­ä¹°è®°å½•å’Œä½™é¢ã€‚" }];
        let isGemini = proxyUrl.includes('generativelanguage');
        let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi);
        
        const response = isGemini 
            ? await fetch(geminiConfig.url, geminiConfig.data) 
            : await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                body: JSON.stringify({
                    model: model,
                    messages: [{role: 'system', content: systemPrompt}, ...messagesForApi],
                    temperature: state.globalSettings.apiTemperature || 0.9
                })
            });

        if (!response.ok) throw new Error(`API é”™è¯¯: ${response.statusText}`);
        
        const data = await response.json();
        const aiResponseContent = getGeminiResponseText(data);
        
        const jsonMatch = aiResponseContent.match(/({[\s\S]*})/);
        if (!jsonMatch) throw new Error("AIè¿”å›žçš„å†…å®¹ä¸­æœªæ‰¾åˆ°æœ‰æ•ˆçš„JSONå¯¹è±¡ã€‚");
        const simulatedTaobaoData = JSON.parse(jsonMatch[0]);
        

        if (!simulatedTaobaoData.purchases) {
            simulatedTaobaoData.purchases = [];
        }

        chat.simulatedTaobaoHistory = simulatedTaobaoData;
        await db.chats.put(chat);
        
        await renderCharTaobao();
        
    } catch (error) {
        console.error("ç”Ÿæˆæ¨¡æ‹Ÿæ·˜å®è®°å½•å¤±è´¥:", error);
        await showCustomAlert("ç”Ÿæˆå¤±è´¥", `æ— æ³•ç”Ÿæˆè´­ç‰©è®°å½•ï¼Œè¯·æ£€æŸ¥APIé…ç½®æˆ–ç¨åŽå†è¯•ã€‚\né”™è¯¯: ${error.message}`);
    }
}
  

/**
 * ã€å…¨æ–°ã€‘æ‰“å¼€å¹¶æ¸²æŸ“è§’è‰²çš„é’±åŒ…é¡µé¢
 */
function openCharWallet() {
    renderCharWallet();
    switchToCharScreen('char-wallet-screen');
}

/**
 * ã€å…¨æ–°ã€‘æ¸²æŸ“è§’è‰²çš„é’±åŒ…é¡µé¢
 */
function renderCharWallet() {
    const contentEl = document.getElementById('char-wallet-content');
    contentEl.innerHTML = '';
    const char = state.chats[activeCharacterId];
    const history = char.simulatedTaobaoHistory || {};
    const purchases = history.purchases || [];

    
    const totalBalance = history.totalBalance || 0;

    
    const summaryCard = document.createElement('div');
    summaryCard.style.cssText = `
        background-color: #fff;
        padding: 20px;
        border-radius: 12px;
        text-align: center;
        margin-bottom: 20px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.06);
    `;
    summaryCard.innerHTML = `
        <p style="color: #8a8a8a; margin: 0 0 10px 0;">è´¦æˆ·ä½™é¢</p>
        <p style="font-size: 32px; font-weight: 600; color: #1f1f1f; margin: 0;">Â¥${totalBalance.toFixed(2)}</p>
    `;
    contentEl.appendChild(summaryCard);

    
    const detailsTitle = document.createElement('h3');
    detailsTitle.textContent = 'æœ€è¿‘æ”¯å‡º';
    detailsTitle.style.cssText = `font-size: 16px; color: #555; margin-bottom: 10px;`;
    contentEl.appendChild(detailsTitle);

    if (purchases.length === 0) {
        contentEl.innerHTML += '<p style="text-align:center; color: var(--text-secondary);">æš‚æ— æ”¯å‡ºè®°å½•ã€‚</p>';
        return;
    }

    
    purchases.forEach(item => {
        const itemEl = document.createElement('div');
        itemEl.style.cssText = `
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px 0;
            border-bottom: 1px solid #f0f0f0;
        `;
        itemEl.innerHTML = `
            <div>
                <p style="font-weight: 500; margin: 0 0 4px 0;">${item.itemName}</p>
                <p style="font-size: 12px; color: #8a8a8a; margin: 0;">${item.status}</p>
            </div>
            <div style="font-weight: 600; font-size: 16px; color: #ff5722;">- Â¥${(item.price || 0).toFixed(2)}</div>
        `;
        contentEl.appendChild(itemEl);
    });
}

        
/**
 * ã€V3.0 | æœ€ç»ˆä¿®å¤ç‰ˆã€‘å½“ç”¨æˆ·ç‚¹å‡»â€œé‡æ–°ç”Ÿæˆâ€æ—¶ï¼Œè°ƒç”¨AIç”Ÿæˆæ¨¡æ‹Ÿå¤‡å¿˜å½•
 */
async function handleGenerateSimulatedMemos() {
    if (!activeCharacterId) return;
    const chat = state.chats[activeCharacterId];
    if (!chat) return;

    await showCustomAlert("è¯·ç¨å€™...", `æ­£åœ¨è¯·æ±‚â€œ${chat.name}â€åˆ†äº«TAçš„å¤‡å¿˜å½•...`);

    const { proxyUrl, apiKey, model } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) {
        alert('è¯·å…ˆåœ¨APIè®¾ç½®ä¸­é…ç½®å¥½APIä¿¡æ¯ã€‚');
        return;
    }

    const userDisplayNameForAI = (state.qzoneSettings.nickname === '{{user}}' || !state.qzoneSettings.nickname) ? 'ç”¨æˆ·' : state.qzoneSettings.nickname;

    const longTermMemoryContext = chat.longTermMemory && chat.longTermMemory.length > 0
    ? chat.longTermMemory.map(mem => `- (è®°å½•äºŽ ${formatTimeAgo(mem.timestamp)}) ${mem.content}`).join('\n')
    : 'æ— ';
    const maxMemory = chat.settings.maxMemory || 10;
const recentHistoryWithUser = chat.history.slice(-maxMemory).map(msg => `${msg.role === 'user' ? userDisplayNameForAI : chat.name}: ${String(msg.content).substring(0, 30)}...`).join('\n');
    const worldBookContext = (chat.settings.linkedWorldBookIds || [])
        .map(bookId => state.worldBooks.find(wb => wb.id === bookId))
        .filter(Boolean)
        .map(book => `\n## ä¸–ç•Œä¹¦ã€Š${book.name}ã€‹è®¾å®š:\n${book.content.filter(e => e.enabled).map(e => `- ${e.content}`).join('\n')}`)
        .join('');

const summary3Hours = generateSummaryForTimeframe(chat, 3, 'hours');
const summary6Hours = generateSummaryForTimeframe(chat, 6, 'hours');
const summary9Hours = generateSummaryForTimeframe(chat, 9, 'hours');
const summaryToday = generateSummaryForTimeframe(chat, 1, 'days');
const summary3Days = generateSummaryForTimeframe(chat, 3, 'days');
const summary7Days = generateSummaryForTimeframe(chat, 7, 'days');

let multiLayeredSummaryContext = '';
if (summary3Hours || summary6Hours || summary9Hours || summaryToday || summary3Days || summary7Days) {
    multiLayeredSummaryContext += `\n# æ™ºèƒ½æ€»ç»“ (åŸºäºŽä¸åŒæ—¶é—´ç»´åº¦çš„å¯¹è¯å›žé¡¾)\n`;
    if (summary3Hours) multiLayeredSummaryContext += summary3Hours;
    if (summary6Hours) multiLayeredSummaryContext += summary6Hours;
    if (summary9Hours) multiLayeredSummaryContext += summary9Hours;
    if (summary3Hours || summary6Hours || summary9Hours) multiLayeredSummaryContext += '\n';
    if (summaryToday) multiLayeredSummaryContext += summaryToday;
    if (summary3Days) multiLayeredSummaryContext += summary3Days;
    if (summary7Days) multiLayeredSummaryContext += summary7Days;
}
const userPersona = chat.settings.myPersona || '(æœªè®¾ç½®)';    
    const systemPrompt = `
# ä½ çš„ä»»åŠ¡
ä½ æ˜¯ä¸€ä¸ªè™šæ‹Ÿç”Ÿæ´»æ¨¡æ‹Ÿå™¨ã€‚ä½ çš„ä»»åŠ¡æ˜¯æ‰®æ¼”è§’è‰²â€œ${chat.name}â€ï¼Œå¹¶æ ¹æ®å…¶äººè®¾ã€è®°å¿†å’Œæœ€è¿‘çš„äº’åŠ¨ï¼Œè™šæž„å‡ºã€12åˆ°20æ¡ã€‘TAæœ€è¿‘å¯èƒ½ä¼šå†™åœ¨æ‰‹æœºå¤‡å¿˜å½•é‡Œçš„å†…å®¹ã€‚

# æ ¸å¿ƒè§„åˆ™
1.  **åˆ›é€ æ€§ä¸Žåˆç†æ€§**: å¤‡å¿˜å½•å†…å®¹å¿…é¡»å®Œå…¨ç¬¦åˆè§’è‰²çš„æ€§æ ¼ã€çˆ±å¥½ã€èŒä¸šå’Œç”Ÿæ´»çŽ¯å¢ƒã€‚å¯ä»¥æ˜¯è´­ç‰©æ¸…å•ã€å¾…åŠžäº‹é¡¹ã€çµæ„Ÿç‰‡æ®µã€ä¸€äº›éšç¬”å’Œæ„Ÿæ‚Ÿã€è‰ç¨¿ç­‰ã€‚
2.  **æ ¼å¼é“å¾‹ (æœ€é«˜ä¼˜å…ˆçº§)**: 
    - ä½ çš„å›žå¤ã€å¿…é¡»ä¸”åªèƒ½ã€‘æ˜¯ä¸€ä¸ªJSONæ•°ç»„æ ¼å¼çš„å­—ç¬¦ä¸²ã€‚
    - ä½ çš„å›žå¤å¿…é¡»ä»¥ \`[\` å¼€å§‹ï¼Œå¹¶ä»¥ \`]\` ç»“æŸã€‚
    - ã€ç»å¯¹ç¦æ­¢ã€‘åœ¨JSONæ•°ç»„å‰åŽæ·»åŠ ä»»ä½•å¤šä½™çš„æ–‡å­—ã€è§£é‡Šã€æˆ– markdown æ ‡è®° (å¦‚ \`\`\`json)ã€‚
    - æ•°ç»„ä¸­çš„æ¯ä¸ªå…ƒç´ éƒ½æ˜¯ä¸€ä¸ªå¯¹è±¡ï¼Œä»£è¡¨ä¸€æ¡å¤‡å¿˜å½•ï¼Œæ ¼å¼ã€å¿…é¡»ã€‘å¦‚ä¸‹:
    \`\`\`json
    [
      {
        "title": "å¤‡å¿˜å½•çš„æ ‡é¢˜ï¼Œä¾‹å¦‚ï¼šè´­ç‰©æ¸…å• æˆ– å‘¨æœ«è®¡åˆ’",
        "content": "å¤‡å¿˜å½•çš„è¯¦ç»†å†…å®¹ï¼Œå¿…é¡»æ”¯æŒæ¢è¡Œç¬¦\\nã€‚"
      }
    ]
    \`\`\`

# ä¾›ä½ å‚è€ƒçš„ä¸Šä¸‹æ–‡
- **ä½ çš„è§’è‰²è®¾å®š**: ${chat.settings.aiPersona}
- ** ä½ çš„èŠå¤©å¯¹è±¡ï¼ˆç”¨æˆ·ï¼‰çš„äººè®¾**:${userPersona}
- **ä½ çš„é•¿æœŸè®°å¿†**:
${longTermMemoryContext}
${worldBookContext}
${multiLayeredSummaryContext}
- **ä½ æœ€è¿‘å’Œâ€œ${userDisplayNameForAI}â€çš„å¯¹è¯æ‘˜è¦**:
${recentHistoryWithUser}

çŽ°åœ¨ï¼Œè¯·å¼€å§‹ç”Ÿæˆè¿™ç»„å¤‡å¿˜å½•ã€‚`;
      

    try {
        const messagesForApi = [{ role: 'user', content: "è¯·æ ¹æ®ä½ çš„è®¾å®šï¼Œç”Ÿæˆä½ çš„å¤‡å¿˜å½•å†…å®¹ã€‚" }];
        let isGemini = proxyUrl.includes('generativelanguage');
        let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi);
        
      
        const response = isGemini 
            ? await fetch(geminiConfig.url, geminiConfig.data) 
            : await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                body: JSON.stringify({
                    model: model,
                    messages: [{role: 'system', content: systemPrompt}, ...messagesForApi],
                    temperature: state.globalSettings.apiTemperature || 0.9
                    // åŒæ ·ç§»é™¤ response_format
                })
            });
          

        if (!response.ok) {
             const errorData = await response.json().catch(() => null);
             const errorMessage = errorData?.error?.message || response.statusText;
             throw new Error(`API é”™è¯¯: ${response.status} - ${errorMessage}`);
        }
        
        const data = await response.json();
        const aiResponseContent = getGeminiResponseText(data);
        
   
        const jsonMatch = aiResponseContent.match(/(\[[\s\S]*\])/);
        if (!jsonMatch || !jsonMatch[0]) {
            throw new Error(`AIè¿”å›žçš„å†…å®¹ä¸­æœªæ‰¾åˆ°æœ‰æ•ˆçš„JSONæ•°ç»„ã€‚åŽŸå§‹è¿”å›ž: ${aiResponseContent}`);
        }
        const cleanedJsonString = jsonMatch[0];
        let simulatedMemos;
        try {
            simulatedMemos = JSON.parse(cleanedJsonString);
        } catch (e) {
            throw new Error(`è§£æžAIè¿”å›žçš„JSONæ—¶å‡ºé”™: ${e.message}\n\nAIåŽŸå§‹è¿”å›žå†…å®¹:\n${aiResponseContent}`);
        }
          
        
        if (!Array.isArray(simulatedMemos)) {
            throw new Error(`AIè¿”å›žçš„æ•°æ®ä¸æ˜¯ä¸€ä¸ªæ•°ç»„ã€‚åŽŸå§‹è¿”å›ž: ${JSON.stringify(simulatedMemos)}`);
        }

        chat.memos = simulatedMemos.map(memo => ({
            id: Date.now() + Math.random(),
            title: memo.title,
            content: memo.content
        }));
        
        await db.chats.put(chat);
        await renderCharMemoList();
        
    } catch (error) {
        console.error("ç”Ÿæˆæ¨¡æ‹Ÿå¤‡å¿˜å½•å¤±è´¥:", error);
        await showCustomAlert("ç”Ÿæˆå¤±è´¥", `æ— æ³•ç”Ÿæˆå¤‡å¿˜å½•ï¼Œè¯·æ£€æŸ¥APIé…ç½®æˆ–ç¨åŽå†è¯•ã€‚\né”™è¯¯: ${error.message}`);
    }
}

/**
 * ã€å…¨æ–° | V2.0 æœ€ç»ˆä¿®å¤ç‰ˆã€‘å½“ç”¨æˆ·ç‚¹å‡»â€œé‡æ–°ç”Ÿæˆâ€æ—¶ï¼Œè°ƒç”¨AIç”Ÿæˆæ¨¡æ‹Ÿè¶³è¿¹
 */
async function handleGenerateAmapHistory() {
    if (!activeCharacterId) return;
    const chat = state.chats[activeCharacterId];
    if (!chat) return;

    await showCustomAlert("è¯·ç¨å€™...", `æ­£åœ¨ç”Ÿæˆâ€œ${chat.name}â€çš„å‡ºè¡Œè¶³è¿¹...`);

    const { proxyUrl, apiKey, model } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) {
        alert('APIæœªé…ç½®ï¼Œæ— æ³•ç”Ÿæˆå†…å®¹ã€‚');
        return;
    }
    
    const userDisplayNameForAI = (state.qzoneSettings.nickname === '{{user}}' || !state.qzoneSettings.nickname) ? 'ç”¨æˆ·' : state.qzoneSettings.nickname;
    const longTermMemoryContext = chat.longTermMemory && chat.longTermMemory.length > 0
    ? chat.longTermMemory.map(mem => `- (è®°å½•äºŽ ${formatTimeAgo(mem.timestamp)}) ${mem.content}`).join('\n')
    : 'æ— ';
    const maxMemory = chat.settings.maxMemory || 10;
const recentHistoryWithUser = chat.history.slice(-maxMemory).map(msg => `${msg.role === 'user' ? userDisplayNameForAI : chat.name}: ${String(msg.content).substring(0, 30)}...`).join('\n');
    const worldBookContext = (chat.settings.linkedWorldBookIds || [])
        .map(bookId => state.worldBooks.find(wb => wb.id === bookId))
        .filter(Boolean)
        .map(book => `\n## ä¸–ç•Œä¹¦ã€Š${book.name}ã€‹è®¾å®š:\n${book.content.filter(e => e.enabled).map(e => `- ${e.content}`).join('\n')}`)
        .join('');
const summary3Hours = generateSummaryForTimeframe(chat, 3, 'hours');
const summary6Hours = generateSummaryForTimeframe(chat, 6, 'hours');
const summary9Hours = generateSummaryForTimeframe(chat, 9, 'hours');
const summaryToday = generateSummaryForTimeframe(chat, 1, 'days');
const summary3Days = generateSummaryForTimeframe(chat, 3, 'days');
const summary7Days = generateSummaryForTimeframe(chat, 7, 'days');

let multiLayeredSummaryContext = '';
if (summary3Hours || summary6Hours || summary9Hours || summaryToday || summary3Days || summary7Days) {
    multiLayeredSummaryContext += `\n# æ™ºèƒ½æ€»ç»“ (åŸºäºŽä¸åŒæ—¶é—´ç»´åº¦çš„å¯¹è¯å›žé¡¾)\n`;
    if (summary3Hours) multiLayeredSummaryContext += summary3Hours;
    if (summary6Hours) multiLayeredSummaryContext += summary6Hours;
    if (summary9Hours) multiLayeredSummaryContext += summary9Hours;
    if (summary3Hours || summary6Hours || summary9Hours) multiLayeredSummaryContext += '\n';
    if (summaryToday) multiLayeredSummaryContext += summaryToday;
    if (summary3Days) multiLayeredSummaryContext += summary3Days;
    if (summary7Days) multiLayeredSummaryContext += summary7Days;
}

    const systemPrompt = `
# ä½ çš„ä»»åŠ¡
ä½ æ˜¯ä¸€ä¸ªè™šæ‹Ÿç”Ÿæ´»æ¨¡æ‹Ÿå™¨ã€‚ä½ çš„ä»»åŠ¡æ˜¯æ‰®æ¼”è§’è‰²â€œ${chat.name}â€ï¼Œå¹¶æ ¹æ®å…¶äººè®¾ã€è®°å¿†å’Œæœ€è¿‘çš„äº’åŠ¨ï¼Œè™šæž„å‡ºã€12åˆ°20æ¡ã€‘TAæœ€è¿‘çš„â€œé«˜å¾·åœ°å›¾â€å‡ºè¡Œè¶³è¿¹ã€‚

# æ ¸å¿ƒè§„åˆ™
1.  **ã€æ—¶é—´ (æœ€é«˜ä¼˜å…ˆçº§)ã€‘**:
    -   ä»Šå¤©çš„æ—¥æœŸæ˜¯ **${new Date().toISOString()}**ã€‚
    -   ä½ ç”Ÿæˆçš„ã€æ‰€æœ‰ã€‘è¶³è¿¹çš„ \`timestamp\` å­—æ®µï¼Œã€å¿…é¡»ã€‘æ˜¯ä»Šå¤©æˆ–ä»Šå¤©ä»¥å‰çš„æ—¥æœŸã€‚
    -   ã€ç»å¯¹ç¦æ­¢ã€‘ç”Ÿæˆä»»ä½•æœªæ¥çš„æ—¥æœŸï¼
    -   è¯·ç”Ÿæˆä¸€ä¸ªçœ‹èµ·æ¥åƒæ˜¯è¿‡åŽ»å‡ å‘¨å†…çš„ã€æ—¶é—´ã€ä»Žæ–°åˆ°æ—§ã€‘æŽ’åˆ—çš„è¶³è¿¹åˆ—è¡¨ã€‚
2.  **åˆ›é€ æ€§ä¸Žåˆç†æ€§**: è¶³è¿¹å¿…é¡»å®Œå…¨ç¬¦åˆè§’è‰²çš„æ€§æ ¼ã€çˆ±å¥½ã€èŒä¸šå’Œç”Ÿæ´»çŽ¯å¢ƒã€‚
3.  **å¤šæ ·æ€§**: åœ°ç‚¹ç±»åž‹è¦ä¸°å¯Œï¼Œå¯ä»¥åŒ…æ‹¬é¤åŽ…ã€å•†åœºã€å…¬å›­ã€å…¬å¸ã€æœ‹å‹å®¶ç­‰ã€‚
4.  **ã€æ ¼å¼é“å¾‹ (æœ€é«˜ä¼˜å…ˆçº§)ã€‘**: 
    - ä½ çš„å›žå¤ã€å¿…é¡»ä¸”åªèƒ½ã€‘æ˜¯ä¸€ä¸ªJSONæ•°ç»„æ ¼å¼çš„å­—ç¬¦ä¸²ã€‚
    - ä½ çš„å›žå¤å¿…é¡»ä»¥ \`[\` å¼€å§‹ï¼Œå¹¶ä»¥ \`]\` ç»“æŸã€‚
    - ã€ç»å¯¹ç¦æ­¢ã€‘åœ¨JSONæ•°ç»„å‰åŽæ·»åŠ ä»»ä½•å¤šä½™çš„æ–‡å­—ã€è§£é‡Šã€æˆ– markdown æ ‡è®° (å¦‚ \`\`\`json)ã€‚
    - æ•°ç»„ä¸­çš„æ¯ä¸ªå…ƒç´ éƒ½æ˜¯ä¸€ä¸ªå¯¹è±¡ï¼Œä»£è¡¨ä¸€æ¡è¶³è¿¹ï¼Œæ ¼å¼ã€å¿…é¡»ã€‘å¦‚ä¸‹:
    \`\`\`json
    [
      {
        "locationName": "ä¸€ä¸ªå…·ä½“ã€ç”ŸåŠ¨çš„åœ°ç‚¹åç§°",
        "address": "ä¸€ä¸ªè™šæž„ä½†çœ‹èµ·æ¥å¾ˆçœŸå®žçš„è¯¦ç»†åœ°å€",
        "comment": "è¿™æ˜¯è§’è‰²å¯¹è¿™æ¬¡å‡ºè¡Œæˆ–è¿™ä¸ªåœ°ç‚¹çš„å†…å¿ƒç‹¬ç™½æˆ–è¯„è®ºï¼Œå¿…é¡»ä½¿ç”¨ç¬¬ä¸€äººç§°â€œæˆ‘â€æ¥å†™ã€‚",
        "image_prompt": "(å¯é€‰)ä¸€æ®µç”¨äºŽç”Ÿæˆè¿™å¼ åœ°ç‚¹ç…§ç‰‡çš„ã€è¯¦ç»†çš„ã€è‹±æ–‡ã€‘å…³é”®è¯, é£Žæ ¼ä¸º realistic photo, high quality",
        "timestamp": "ç¬¦åˆ ISO 8601 æ ¼å¼çš„æ—¥æœŸæ—¶é—´å­—ç¬¦ä¸² (ä¾‹å¦‚: '2025-09-25T18:30:00Z')"
      }
    ]
    \`\`\`
    - **é‡è¦**: å¤§çº¦æœ‰ã€ä¸‰åˆ†ä¹‹ä¸€ã€‘çš„è¶³è¿¹éœ€è¦åŒ…å« \`image_prompt\` å­—æ®µæ¥ç”Ÿæˆä¸€å¼ ç…§ç‰‡ã€‚
    - **å›¾ç‰‡**: image_prompt ç”Ÿæˆçš„å›¾ç‰‡ã€ç»å¯¹ç¦æ­¢åŒ…å«çœŸäººã€‘ã€‚å¦‚æžœåœ°ç‚¹æ˜¯å®¤å†…ï¼Œå¯ä»¥ç”Ÿæˆç©ºæ— ä¸€äººçš„åœºæ™¯ï¼›å¦‚æžœæ˜¯å®¤å¤–ï¼Œå¯ä»¥åªæœ‰é£Žæ™¯æˆ–å»ºç­‘ã€‚

# ä¾›ä½ å‚è€ƒçš„ä¸Šä¸‹æ–‡
- **ä½ çš„è§’è‰²è®¾å®š**: ${chat.settings.aiPersona}
- **ä½ çš„é•¿æœŸè®°å¿†**:
${longTermMemoryContext}
${worldBookContext}
${multiLayeredSummaryContext}
- **ä½ æœ€è¿‘å’Œâ€œ${userDisplayNameForAI}â€çš„å¯¹è¯æ‘˜è¦**:
${recentHistoryWithUser}

çŽ°åœ¨ï¼Œè¯·å¼€å§‹ç”Ÿæˆè¿™ç»„è¶³è¿¹è®°å½•ã€‚`;
      

    try {
        const messagesForApi = [{ role: 'user', content: "è¯·æ ¹æ®ä½ çš„è®¾å®šï¼Œç”Ÿæˆä½ çš„é«˜å¾·åœ°å›¾è¶³è¿¹ã€‚" }];
        let isGemini = proxyUrl.includes('generativelanguage');
        let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi);
        
       
        const response = isGemini 
            ? await fetch(geminiConfig.url, geminiConfig.data) 
            : await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                body: JSON.stringify({
                    model: model,
                    messages: [{role: 'system', content: systemPrompt}, ...messagesForApi],
                    temperature: state.globalSettings.apiTemperature || 0.9
                    // response_format: { "type": "json_object" } <-- æ­¤è¡Œå·²è¢«åˆ é™¤
                })
            });
          

        if (!response.ok) throw new Error(`API é”™è¯¯: ${response.statusText}`);
        
        const data = await response.json();
        const aiResponseContent = getGeminiResponseText(data);
        
        
        const jsonMatch = aiResponseContent.match(/(\[[\s\S]*\])/);
        if (!jsonMatch || !jsonMatch[0]) {
            throw new Error(`AIè¿”å›žçš„å†…å®¹ä¸­æœªæ‰¾åˆ°æœ‰æ•ˆçš„JSONæ•°ç»„ã€‚åŽŸå§‹è¿”å›ž: ${aiResponseContent}`);
        }
        const cleanedJsonString = jsonMatch[0];
        let simulatedAmapData;
        try {
            simulatedAmapData = JSON.parse(cleanedJsonString);
        } catch (e) {
            throw new Error(`è§£æžAIè¿”å›žçš„JSONæ—¶å‡ºé”™: ${e.message}\n\nAIåŽŸå§‹è¿”å›žå†…å®¹:\n${aiResponseContent}`);
        }
          
        
        chat.simulatedAmapHistory = simulatedAmapData;
        await db.chats.put(chat);
        
        await renderCharAmap();
        
    } catch (error) {
        console.error("ç”Ÿæˆæ¨¡æ‹Ÿè¶³è¿¹å¤±è´¥:", error);
        await showCustomAlert("ç”Ÿæˆå¤±è´¥", `æ— æ³•ç”Ÿæˆè¶³è¿¹ï¼Œè¯·æ£€æŸ¥APIé…ç½®æˆ–ç¨åŽå†è¯•ã€‚\né”™è¯¯: ${error.message}`);
    }
}

        /**
         * ã€å…¨æ–° | V2.0 æœ€ç»ˆä¿®å¤ç‰ˆã€‘æ¸²æŸ“è§’è‰²çš„é«˜å¾·åœ°å›¾è¶³è¿¹åˆ—è¡¨
         */
        function renderCharAmap() {
            const listEl = document.getElementById('char-amap-list');
            listEl.innerHTML = '';
            if (!activeCharacterId) return;

            const char = state.chats[activeCharacterId];
            const history = char.simulatedAmapHistory || [];

            if (history.length === 0) {
                listEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">è¿™é‡Œè¿˜æ²¡æœ‰ç•™ä¸‹ä»»ä½•è¶³è¿¹ï¼Œ<br>ç‚¹å‡»å³ä¸Šè§’åˆ·æ–°æŒ‰é’®ç”Ÿæˆä¸€äº›è®°å½•å§ï¼</p>';
                return;
            }

            
            history.forEach(item => {
                const itemEl = document.createElement('div');
                itemEl.className = 'char-amap-item';
                
                let photoHtml = '';
                if (item.image_prompt) {
                    const imageUrl = `https://image.pollinations.ai/prompt/${encodeURIComponent(item.image_prompt)}`;
                    photoHtml = `<div class="amap-item-photo" style="background-image: url('${imageUrl}')" data-comment="${item.comment}"></div>`;
                }

                // ä½¿ç”¨æˆ‘ä»¬ä¹‹å‰åˆ›å»ºçš„ formatTimeAgo å‡½æ•°æ¥æ ¼å¼åŒ–æ—¶é—´
                const timeAgo = item.timestamp ? formatTimeAgo(new Date(item.timestamp).getTime()) : 'æŸä¸ªæ—¶é—´';

                itemEl.innerHTML = `
                    <div class="amap-item-header">
                        <div class="amap-item-icon">ðŸ“</div>
                        <div class="amap-item-info">
                            <div class="amap-item-title">${item.locationName}</div>
                            <div class="amap-item-address">${item.address}</div>
                        </div>
                    </div>
                    <div class="amap-item-body">
                        <div class="amap-item-comment">${item.comment.replace(/\n/g, '<br>')}</div>
                        ${photoHtml}
                    </div>
                    <div class="amap-item-footer">${timeAgo}</div>
                `;
                listEl.appendChild(itemEl);
            });
      
        }


/**
 * ã€å…¨æ–° V3.0 | æ”¯æŒAIç»˜å›¾ã€‘å½“ç”¨æˆ·ç‚¹å‡»â€œé‡æ–°ç”Ÿæˆâ€æ—¶ï¼Œè°ƒç”¨AIç”Ÿæˆæ¨¡æ‹ŸAppä½¿ç”¨è®°å½•
 */
async function handleGenerateAppUsage() {
    if (!activeCharacterId) return;
    const chat = state.chats[activeCharacterId];
    if (!chat) return;

    await showCustomAlert("è¯·ç¨å€™...", `æ­£åœ¨åˆ†æžâ€œ${chat.name}â€çš„æ‰‹æœºä½¿ç”¨ä¹ æƒ¯...`);

    const { proxyUrl, apiKey, model } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) {
        alert('APIæœªé…ç½®ï¼Œæ— æ³•ç”Ÿæˆå†…å®¹ã€‚');
        return;
    }
    
    const userDisplayNameForAI = (state.qzoneSettings.nickname === '{{user}}' || !state.qzoneSettings.nickname) ? 'ç”¨æˆ·' : state.qzoneSettings.nickname;

    const longTermMemoryContext = chat.longTermMemory && chat.longTermMemory.length > 0
    ? chat.longTermMemory.map(mem => `- (è®°å½•äºŽ ${formatTimeAgo(mem.timestamp)}) ${mem.content}`).join('\n')
    : 'æ— ';
    const maxMemory = chat.settings.maxMemory || 10;
const recentHistoryWithUser = chat.history.slice(-maxMemory).map(msg => `${msg.role === 'user' ? userDisplayNameForAI : chat.name}: ${String(msg.content).substring(0, 30)}...`).join('\n');
    const worldBookContext = (chat.settings.linkedWorldBookIds || [])
        .map(bookId => state.worldBooks.find(wb => wb.id === bookId))
        .filter(Boolean)
        .map(book => `\n## ä¸–ç•Œä¹¦ã€Š${book.name}ã€‹è®¾å®š:\n${book.content.filter(e => e.enabled).map(e => `- ${e.content}`).join('\n')}`)
        .join('');
const summary3Hours = generateSummaryForTimeframe(chat, 3, 'hours');
const summary6Hours = generateSummaryForTimeframe(chat, 6, 'hours');
const summary9Hours = generateSummaryForTimeframe(chat, 9, 'hours');
const summaryToday = generateSummaryForTimeframe(chat, 1, 'days');
const summary3Days = generateSummaryForTimeframe(chat, 3, 'days');
const summary7Days = generateSummaryForTimeframe(chat, 7, 'days');

let multiLayeredSummaryContext = '';
if (summary3Hours || summary6Hours || summary9Hours || summaryToday || summary3Days || summary7Days) {
    multiLayeredSummaryContext += `\n# æ™ºèƒ½æ€»ç»“ (åŸºäºŽä¸åŒæ—¶é—´ç»´åº¦çš„å¯¹è¯å›žé¡¾)\n`;
    if (summary3Hours) multiLayeredSummaryContext += summary3Hours;
    if (summary6Hours) multiLayeredSummaryContext += summary6Hours;
    if (summary9Hours) multiLayeredSummaryContext += summary9Hours;
    if (summary3Hours || summary6Hours || summary9Hours) multiLayeredSummaryContext += '\n';
    if (summaryToday) multiLayeredSummaryContext += summaryToday;
    if (summary3Days) multiLayeredSummaryContext += summary3Days;
    if (summary7Days) multiLayeredSummaryContext += summary7Days;
}
  
    const systemPrompt = `
# ä½ çš„ä»»åŠ¡
ä½ æ˜¯ä¸€ä¸ªè™šæ‹Ÿç”Ÿæ´»æ¨¡æ‹Ÿå™¨ã€‚ä½ çš„ä»»åŠ¡æ˜¯æ‰®æ¼”è§’è‰²â€œ${chat.name}â€ï¼Œå¹¶æ ¹æ®å…¶äººè®¾ã€è®°å¿†å’Œæœ€è¿‘çš„äº’åŠ¨ï¼Œè™šæž„å‡ºTAæœ€è¿‘ä¸€å¤©çš„ã€æ‰‹æœºAppå±å¹•ä½¿ç”¨æ—¶é—´ã€‘è®°å½•ï¼Œæ€»å…±çº¦20æ¡ã€‚

# æ ¸å¿ƒè§„åˆ™
1.  **åˆ›é€ æ€§ä¸Žå¤šæ ·æ€§**: ç”Ÿæˆçš„Appåˆ—è¡¨ã€ä¸å¿…å±€é™äºŽã€‘Cphoneä¸»å±å¹•ä¸Šå·²æœ‰çš„Appã€‚ä½ å¯ä»¥è‡ªç”±åœ°è™šæž„TAå¯èƒ½ä½¿ç”¨çš„å…¶ä»–Appï¼Œä¾‹å¦‚ Instagram, Twitter, å„ç§æ¸¸æˆ (å¦‚ï¼šåŽŸç¥ž, çŽ‹è€…è£è€€), è§†é¢‘App (å¦‚ï¼šæŠ–éŸ³, YouTube), å­¦ä¹ æˆ–å·¥ä½œè½¯ä»¶ç­‰ï¼Œè¿™èƒ½æ›´å¥½åœ°ä½“çŽ°è§’è‰²çš„éšè—å…´è¶£å’Œç”Ÿæ´»ä¹ æƒ¯ã€‚
2.  **åˆç†æ€§**: ä½¿ç”¨æ—¶é•¿å’ŒAppç±»åž‹å¿…é¡»å®Œå…¨ç¬¦åˆè§’è‰²çš„æ€§æ ¼ã€çˆ±å¥½ã€èŒä¸šå’Œç”Ÿæ´»çŽ¯å¢ƒã€‚
3.  **æ ¼å¼é“å¾‹ (æœ€é«˜ä¼˜å…ˆçº§)**: 
    - ä½ çš„å›žå¤ã€å¿…é¡»ä¸”åªèƒ½ã€‘æ˜¯ä¸€ä¸ªJSONæ•°ç»„æ ¼å¼çš„å­—ç¬¦ä¸²ã€‚
    - ä½ çš„å›žå¤å¿…é¡»ä»¥ \`[\` å¼€å§‹ï¼Œå¹¶ä»¥ \`]\` ç»“æŸã€‚
    - ã€ç»å¯¹ç¦æ­¢ã€‘åœ¨JSONæ•°ç»„å‰åŽæ·»åŠ ä»»ä½•å¤šä½™çš„æ–‡å­—ã€è§£é‡Šã€æˆ– markdown æ ‡è®° (å¦‚ \`\`\`json)ã€‚
    - æ•°ç»„ä¸­çš„æ¯ä¸ªå…ƒç´ éƒ½æ˜¯ä¸€ä¸ªå¯¹è±¡ï¼Œä»£è¡¨ä¸€ä¸ªAppçš„ä½¿ç”¨è®°å½•ï¼Œæ ¼å¼ã€å¿…é¡»ã€‘å¦‚ä¸‹:
    \`\`\`json
    [
      {
        "appName": "Appçš„åç§° (ä¾‹å¦‚: å¾®ä¿¡, å¾®åš, åŽŸç¥ž)",
        "usageTimeMinutes": 125,
        "category": "Appçš„åˆ†ç±» (ä¾‹å¦‚: ç¤¾äº¤, æ¸¸æˆ, å½±éŸ³, å·¥å…·, é˜…è¯», è´­ç‰©)",
        "image_prompt": "ä¸€æ®µç”¨äºŽç”Ÿæˆè¿™ä¸ªAppã€å›¾æ ‡ã€‘çš„ã€ç®€æ´çš„ã€è‹±æ–‡ã€‘å…³é”®è¯ã€‚é£Žæ ¼å¿…é¡»æ˜¯ modern app icon, flat design, simple, clean background"
      }
    ]
    \`\`\`

# ä¾›ä½ å‚è€ƒçš„ä¸Šä¸‹æ–‡
- **ä½ çš„è§’è‰²è®¾å®š**: ${chat.settings.aiPersona}
- **ä½ çš„é•¿æœŸè®°å¿†**:
${longTermMemoryContext}
${worldBookContext}
${multiLayeredSummaryContext}
- **ä½ æœ€è¿‘å’Œâ€œ${userDisplayNameForAI}â€çš„å¯¹è¯æ‘˜è¦**:
${recentHistoryWithUser}

çŽ°åœ¨ï¼Œè¯·å¼€å§‹ç”Ÿæˆè¿™ç»„Appä½¿ç”¨è®°å½•ã€‚`;
      

    try {
        const messagesForApi = [{ role: 'user', content: "è¯·æ ¹æ®ä½ çš„è®¾å®šï¼Œç”Ÿæˆä½ çš„Appä½¿ç”¨è®°å½•ã€‚" }];
        let isGemini = proxyUrl.includes('generativelanguage');
        let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi);
        
       
        const response = isGemini 
            ? await fetch(geminiConfig.url, geminiConfig.data) 
            : await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                body: JSON.stringify({
                    model: model,
                    messages: [{role: 'system', content: systemPrompt}, ...messagesForApi],
                    temperature: state.globalSettings.apiTemperature || 0.9
                    // response_format: { "type": "json_object" } <-- æ­¤è¡Œå·²è¢«åˆ é™¤
                })
            });
          

        if (!response.ok) throw new Error(`API é”™è¯¯: ${response.statusText}`);
        
        const data = await response.json();
        const aiResponseContent = getGeminiResponseText(data);
        const cleanedJson = aiResponseContent.replace(/^```json\s*/, '').replace(/```$/, '');
        
        const simulatedUsageData = JSON.parse(cleanedJson);
        
        chat.simulatedAppUsage = simulatedUsageData;
        await db.chats.put(chat);
        
        await renderCharAppUsage();
        
    } catch (error) {
        console.error("ç”Ÿæˆæ¨¡æ‹ŸAppä½¿ç”¨è®°å½•å¤±è´¥:", error);
        await showCustomAlert("ç”Ÿæˆå¤±è´¥", `æ— æ³•ç”Ÿæˆè®°å½•ï¼Œè¯·æ£€æŸ¥APIé…ç½®æˆ–ç¨åŽå†è¯•ã€‚\né”™è¯¯: ${error.message}`);
    }
}

        /**
         * ã€å…¨æ–° V2.0 | AIç»˜å›¾ç‰ˆã€‘æ¸²æŸ“è§’è‰²çš„Appä½¿ç”¨è®°å½•åˆ—è¡¨
         */
        function renderCharAppUsage() {
            const listEl = document.getElementById('char-usage-list');
            listEl.innerHTML = '';
            if (!activeCharacterId) return;

            const char = state.chats[activeCharacterId];
            const usageData = (char.simulatedAppUsage || []).sort((a, b) => b.usageTimeMinutes - a.usageTimeMinutes);

            if (usageData.length === 0) {
                listEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">è¿™é‡Œè¿˜æ²¡æœ‰ä»»ä½•ä½¿ç”¨è®°å½•ï¼Œ<br>ç‚¹å‡»å³ä¸Šè§’åˆ·æ–°æŒ‰é’®ç”Ÿæˆä¸€äº›å§ï¼</p>';
                return;
            }

            usageData.forEach(item => {
                const itemEl = document.createElement('div');
                itemEl.className = 'char-usage-item';
                
                const hours = Math.floor(item.usageTimeMinutes / 60);
                const minutes = item.usageTimeMinutes % 60;
                let timeString = '';
                if (hours > 0) timeString += `${hours}å°æ—¶`;
                if (minutes > 0) timeString += `${minutes}åˆ†é’Ÿ`;
                if (!timeString) timeString = 'å°äºŽ1åˆ†é’Ÿ';

                const prompt = item.image_prompt || `modern app icon for ${item.appName}, flat design, simple`;
       
                const iconUrl = `https://image.pollinations.ai/prompt/${encodeURIComponent(prompt)}`;
                  

                itemEl.innerHTML = `
                    <img src="${iconUrl}" class="usage-item-icon">
                    <div class="usage-item-info">
                        <div class="usage-item-name">${item.appName}</div>
                        <div class="usage-item-category">${item.category}</div>
                    </div>
                    <div class="usage-item-time">${timeString}</div>
                `;
                listEl.appendChild(itemEl);
            });
        }

/**
 * ã€å…¨æ–° V2.0 | æœ€ç»ˆå…¼å®¹ç‰ˆã€‘å½“ç”¨æˆ·ç‚¹å‡»â€œé‡æ–°ç”Ÿæˆâ€æ—¶ï¼Œè°ƒç”¨AIç”Ÿæˆæ¨¡æ‹Ÿæ­Œå•
 */
async function handleGenerateSimulatedMusic() {
    if (!activeCharacterId) return;
    const chat = state.chats[activeCharacterId];
    if (!chat) return;

    await showCustomAlert("è¯·ç¨å€™...", `æ­£åœ¨è¯·æ±‚â€œ${chat.name}â€åˆ†äº«TAçš„ç§äººæ­Œå•...`);

    const { proxyUrl, apiKey, model } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) {
        alert('è¯·å…ˆåœ¨APIè®¾ç½®ä¸­é…ç½®å¥½APIä¿¡æ¯ã€‚');
        return;
    }
    
    const userDisplayNameForAI = (state.qzoneSettings.nickname === '{{user}}' || !state.qzoneSettings.nickname) ? 'ç”¨æˆ·' : state.qzoneSettings.nickname;

    const longTermMemoryContext = chat.longTermMemory && chat.longTermMemory.length > 0
    ? chat.longTermMemory.map(mem => `- (è®°å½•äºŽ ${formatTimeAgo(mem.timestamp)}) ${mem.content}`).join('\n')
    : 'æ— ';
    const maxMemory = chat.settings.maxMemory || 10;
const recentHistoryWithUser = chat.history.slice(-maxMemory).map(msg => `${msg.role === 'user' ? userDisplayNameForAI : chat.name}: ${String(msg.content).substring(0, 30)}...`).join('\n');
    const worldBookContext = (chat.settings.linkedWorldBookIds || [])
        .map(bookId => state.worldBooks.find(wb => wb.id === bookId))
        .filter(Boolean)
        .map(book => `\n## ä¸–ç•Œä¹¦ã€Š${book.name}ã€‹è®¾å®š:\n${book.content.filter(e => e.enabled).map(e => `- ${e.content}`).join('\n')}`)
        .join('');

 
    const systemPrompt = `
# ä½ çš„ä»»åŠ¡
ä½ æ˜¯ä¸€ä¸ªè™šæ‹ŸéŸ³ä¹å“å‘³æ¨¡æ‹Ÿå™¨ã€‚ä½ çš„ä»»åŠ¡æ˜¯æ‰®æ¼”è§’è‰²â€œ${chat.name}â€ï¼Œå¹¶æ ¹æ®å…¶äººè®¾ã€è®°å¿†å’Œæœ€è¿‘çš„äº’åŠ¨ï¼ŒæŒ‘é€‰å‡ºã€14åˆ°18é¦–ã€‘æœ€èƒ½ä»£è¡¨TAæ­¤åˆ»å¿ƒæƒ…æˆ–å“å‘³çš„æ­Œæ›²ã€‚

# æ ¸å¿ƒè§„åˆ™
1.  **åˆ›é€ æ€§ä¸Žåˆç†æ€§**: æ­Œå•å¿…é¡»å®Œå…¨ç¬¦åˆè§’è‰²çš„æ€§æ ¼ã€çˆ±å¥½å’Œç”Ÿæ´»èƒŒæ™¯ã€‚
2.  **å¤šæ ·æ€§**: æ­Œæ›²é£Žæ ¼å¯ä»¥å¤šæ ·ï¼Œä½†å¿…é¡»é€»è¾‘è‡ªæ´½ã€‚
3.  **æ ¼å¼é“å¾‹ (æœ€é«˜ä¼˜å…ˆçº§)**: 
    - ä½ çš„å›žå¤ã€å¿…é¡»ä¸”åªèƒ½ã€‘æ˜¯ä¸€ä¸ªJSONæ•°ç»„æ ¼å¼çš„å­—ç¬¦ä¸²ã€‚
    - ä½ çš„å›žå¤å¿…é¡»ä»¥ \`[\` å¼€å§‹ï¼Œå¹¶ä»¥ \`]\` ç»“æŸã€‚
    - ã€ç»å¯¹ç¦æ­¢ã€‘åœ¨JSONæ•°ç»„å‰åŽæ·»åŠ ä»»ä½•å¤šä½™çš„æ–‡å­—ã€è§£é‡Šã€æˆ– markdown æ ‡è®° (å¦‚ \`\`\`json)ã€‚
    - æ•°ç»„ä¸­çš„æ¯ä¸ªå…ƒç´ éƒ½æ˜¯ä¸€ä¸ªå¯¹è±¡ï¼Œä»£è¡¨ä¸€é¦–æ­Œï¼Œæ ¼å¼ã€å¿…é¡»ã€‘å¦‚ä¸‹:
    \`\`\`json
    [
      {
        "songName": "æ­Œæ›²çš„å‡†ç¡®åç§°",
        "artistName": "æ­Œæ›²çš„å‡†ç¡®è‰ºæœ¯å®¶/æ­Œæ‰‹å"
      }
    ]
    \`\`\`

# ä¾›ä½ å‚è€ƒçš„ä¸Šä¸‹æ–‡
- **ä½ çš„è§’è‰²è®¾å®š**: ${chat.settings.aiPersona}
- **ä½ çš„é•¿æœŸè®°å¿†**:
${longTermMemoryContext}
${worldBookContext}
- **ä½ æœ€è¿‘å’Œâ€œ${userDisplayNameForAI}â€çš„å¯¹è¯æ‘˜è¦**:
${recentHistoryWithUser}

çŽ°åœ¨ï¼Œè¯·ç”Ÿæˆè¿™ä»½æ­Œå•ã€‚`;
      

    try {
        const messagesForApi = [{ role: 'user', content: "è¯·æ ¹æ®ä½ çš„è®¾å®šï¼Œç”Ÿæˆä½ çš„æ­Œå•ã€‚" }];
        let isGemini = proxyUrl.includes('generativelanguage');
        let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi);
        
     
        const response = isGemini 
            ? await fetch(geminiConfig.url, geminiConfig.data) 
            : await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                body: JSON.stringify({
                    model: model,
                    messages: [{role: 'system', content: systemPrompt}, ...messagesForApi],
                    temperature: state.globalSettings.apiTemperature || 1.0,
                })
            });
          

        if (!response.ok) throw new Error(`API é”™è¯¯: ${response.statusText}`);
        
        const data = await response.json();
        const aiResponseContent = getGeminiResponseText(data);
        const cleanedJson = aiResponseContent.replace(/^```json\s*/, '').replace(/```$/, '');
        const songPicks = JSON.parse(cleanedJson);

        await showCustomAlert("è¯·ç¨å€™...", `æ­Œå•å·²ç”Ÿæˆï¼Œæ­£åœ¨ä»Žç½‘ç»œèŽ·å– ${songPicks.length} é¦–æ­Œæ›²çš„è¯¦ç»†ä¿¡æ¯...`);

        const songDetailPromises = songPicks.map(async (pick) => {
            let searchResults = await searchNeteaseMusic(pick.songName, pick.artistName);
            if (!searchResults || searchResults.length === 0) {
                searchResults = await searchTencentMusic(pick.songName);
            }
            if (searchResults.length > 0) {
                return getPlayableSongDetails(searchResults[0]);
            }
            console.warn(`æ‰€æœ‰éŸ³ä¹æºéƒ½æœªèƒ½æ‰¾åˆ°æ­Œæ›²ï¼šâ€œ${pick.songName} - ${pick.artistName}â€`);
            return null;
        });

        const fullSongObjects = (await Promise.all(songDetailPromises)).filter(Boolean);

        chat.simulatedMusicPlaylist = fullSongObjects;
        await db.chats.put(chat);
        
        await renderCharMusicScreen();
        
    } catch (error) {
        console.error("ç”Ÿæˆæ¨¡æ‹Ÿæ­Œå•å¤±è´¥:", error);
        await showCustomAlert("ç”Ÿæˆå¤±è´¥", `æ— æ³•ç”Ÿæˆæ­Œå•ï¼Œè¯·æ£€æŸ¥APIé…ç½®æˆ–ç¨åŽå†è¯•ã€‚\né”™è¯¯: ${error.message}`);
    }
}

/**
 * ã€å…¨æ–°ã€‘æ¸²æŸ“è§’è‰²çš„ç½‘æ˜“äº‘éŸ³ä¹åˆ—è¡¨
 */
function renderCharMusicScreen() {
    const listEl = document.getElementById('char-music-list');
    listEl.innerHTML = '';
    if (!activeCharacterId) return;

    const char = state.chats[activeCharacterId];
    const playlist = char.simulatedMusicPlaylist || [];

    if (playlist.length === 0) {
        listEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">TAçš„æ­Œå•è¿˜æ˜¯ç©ºçš„ï¼Œ<br>ç‚¹å‡»å³ä¸Šè§’åˆ·æ–°æŒ‰é’®ç”Ÿæˆä¸€äº›æ­Œæ›²å§ï¼</p>';
        return;
    }

    playlist.forEach((track, index) => {
        const itemEl = document.createElement('div');
        itemEl.className = 'char-music-item';
        itemEl.innerHTML = `
            <img src="${track.cover}" class="music-item-cover">
            <div class="music-item-info">
                <div class="music-item-name">${track.name}</div>
                <div class="music-item-artist">${track.artist}</div>
            </div>
        `;
       
        itemEl.addEventListener('click', () => playCharSong(track));
        listEl.appendChild(itemEl);
    });
}



let charPlayerState = {
    currentPlaylist: [],
    currentIndex: -1,
    isPlaying: false,
    playMode: 'order', // 'order', 'random', 'single'
    lrcUpdateInterval: null,
    // ã€æ ¸å¿ƒæ–°å¢žã€‘
    parsedLyrics: [],
    currentLyricIndex: -1
};

/**
 * æ’­æ”¾Cphoneä¸­çš„æ­Œæ›² (V3.0 - é€‚é…æ–°UIå’Œæ­Œè¯)
 * @param {object} songObject - åŒ…å«æ‰€æœ‰ä¿¡æ¯çš„å®Œæ•´æ­Œæ›²å¯¹è±¡
 */
function playCharSong(songObject) {
    const player = document.getElementById('char-audio-player');
    const modal = document.getElementById('char-music-player-modal');
    
    if (charPlayerState.lrcUpdateInterval) clearInterval(charPlayerState.lrcUpdateInterval);
    player.pause();
    
    const songIndex = charPlayerState.currentPlaylist.findIndex(s => s.src === songObject.src);
    if (songIndex > -1) {
        charPlayerState.currentIndex = songIndex;
    } else {
        charPlayerState.currentPlaylist = [songObject];
        charPlayerState.currentIndex = 0;
    }

    // æ›´æ–°UI
    document.getElementById('char-music-player-title').textContent = songObject.name;
    document.getElementById('char-music-artist').textContent = songObject.artist;
    document.getElementById('char-music-cover').src = songObject.cover;
    
   
    charPlayerState.parsedLyrics = parseLRC(songObject.lrcContent || "");
    renderCharLyrics(); 


    if (songObject.isLocal) {
        const blob = new Blob([songObject.src], { type: songObject.fileType || 'audio/mpeg' });
        player.src = URL.createObjectURL(blob);
    } else {
        player.src = songObject.src;
    }
    player.play().catch(e => console.error("éŸ³é¢‘æ’­æ”¾å¤±è´¥:", e));

    player.onloadedmetadata = () => {
        document.getElementById('char-music-total-time').textContent = formatMusicTime(player.duration);
        charPlayerState.lrcUpdateInterval = setInterval(updateCharMusicProgress, 500);
    };

    modal.classList.add('visible');
}

/**
 * å…³é—­Cphoneçš„éŸ³ä¹æ’­æ”¾å™¨ (V3.0)
 */
function closeCharMusicPlayer() {
    const modal = document.getElementById('char-music-player-modal');
    const player = document.getElementById('char-audio-player');
    
    if (charPlayerState.lrcUpdateInterval) clearInterval(charPlayerState.lrcUpdateInterval);
    player.pause();
    player.src = ''; 
    modal.classList.remove('visible');
    charPlayerState.isPlaying = false;
    document.getElementById('char-vinyl-container').classList.remove('spinning');
}

/**
 * æ›´æ–°æ’­æ”¾å™¨è¿›åº¦æ¡ã€æ—¶é—´å’Œæ­Œè¯ (æ ¸å¿ƒä¿®æ”¹)
 */
function updateCharMusicProgress() {
    const player = document.getElementById('char-audio-player');
    if (!player.duration) return;

    const currentTime = player.currentTime;
    const duration = player.duration;
    document.getElementById('char-music-progress-fill').style.width = `${(currentTime / duration) * 100}%`;
    document.getElementById('char-music-current-time').textContent = formatMusicTime(currentTime);

  
    updateCharActiveLyric(currentTime);
}


/**
 * ã€å…¨æ–°ã€‘æ¸²æŸ“è§’è‰²æ’­æ”¾å™¨çš„æ­Œè¯åˆ—è¡¨
 */
function renderCharLyrics() {
    const lyricsContainer = document.getElementById('char-music-lyrics');
    lyricsContainer.innerHTML = '';
    charPlayerState.currentLyricIndex = -1; 
    if (!charPlayerState.parsedLyrics || charPlayerState.parsedLyrics.length === 0) {
        lyricsContainer.innerHTML = '<p>â™ª æš‚æ— æ­Œè¯ â™ª</p>';
        return;
    }
    charPlayerState.parsedLyrics.forEach((line, index) => {
        const p = document.createElement('p');
        p.textContent = line.text;
        p.dataset.index = index;
        lyricsContainer.appendChild(p);
    });
}

/**
 * ã€å…¨æ–°ã€‘æ›´æ–°å½“å‰é«˜äº®çš„æ­Œè¯
 */
function updateCharActiveLyric(currentTime) {
    const lyrics = charPlayerState.parsedLyrics;
    if (lyrics.length === 0) return;

    let newLyricIndex = -1;
    for (let i = 0; i < lyrics.length; i++) {
        if (currentTime >= lyrics[i].time) {
            newLyricIndex = i;
        } else {
            break;
        }
    }
    if (newLyricIndex === charPlayerState.currentLyricIndex) return;
    charPlayerState.currentLyricIndex = newLyricIndex;

    const lyricsContainer = document.getElementById('char-music-lyrics');
    const lines = lyricsContainer.querySelectorAll('p');
    lines.forEach(line => line.classList.remove('active'));
    
    if (newLyricIndex > -1) {
        const activeLine = lyricsContainer.querySelector(`p[data-index="${newLyricIndex}"]`);
        if (activeLine) {
            activeLine.classList.add('active');
       
            const offset = (lyricsContainer.clientHeight / 2) - activeLine.offsetTop - (activeLine.offsetHeight / 2);
            lines.forEach(line => {
                line.style.transform = `translateY(${offset}px)`;
            });
        }
    }
}


/**
 * æ’­æ”¾ä¸‹ä¸€é¦–æ­Œ
 */
function playNextCharSong() {
    if (charPlayerState.currentPlaylist.length === 0) return;
    let nextIndex;
    switch(charPlayerState.playMode) {
        case 'random':
            nextIndex = Math.floor(Math.random() * charPlayerState.currentPlaylist.length);
            break;
        case 'single':
       
            playCharSong(charPlayerState.currentPlaylist[charPlayerState.currentIndex]);
            return;
        case 'order':
        default:
            nextIndex = (charPlayerState.currentIndex + 1) % charPlayerState.currentPlaylist.length;
            break;
    }
    playCharSong(charPlayerState.currentPlaylist[nextIndex]);
}

/**
 * æ’­æ”¾ä¸Šä¸€é¦–æ­Œ
 */
function playPrevCharSong() {
    if (charPlayerState.currentPlaylist.length === 0) return;
    const newIndex = (charPlayerState.currentIndex - 1 + charPlayerState.currentPlaylist.length) % charPlayerState.currentPlaylist.length;
    playCharSong(charPlayerState.currentPlaylist[newIndex]);
}

/**
 * åˆ‡æ¢æ’­æ”¾æ¨¡å¼
 */
function changeCharPlayMode() {
    const modes = ['order', 'random', 'single'];
    const currentModeIndex = modes.indexOf(charPlayerState.playMode);
    charPlayerState.playMode = modes[(currentModeIndex + 1) % modes.length];
    document.getElementById('char-music-mode-btn').textContent = {'order': 'é¡ºåº', 'random': 'éšæœº', 'single': 'å•æ›²'}[charPlayerState.playMode];
}


/**
 * ã€æ€»å…¥å£ã€‘ä¸ºæ–°æ’­æ”¾å™¨çš„æ‰€æœ‰æŒ‰é’®å’Œäº‹ä»¶ç»‘å®šåŠŸèƒ½
 */
function setupCharPlayerControls() {
    const player = document.getElementById('char-audio-player');
    const playBtn = document.getElementById('char-music-play-pause-btn');
    const vinyl = document.getElementById('char-vinyl-container');

    playBtn.addEventListener('click', () => {
        if (player.paused) {
            if(charPlayerState.currentIndex > -1) player.play();
        } else {
            player.pause();
        }
    });
    
    player.onplay = () => {
        playBtn.innerHTML = `<svg viewBox="0 0 24 24" width="32" height="32" fill="currentColor"><path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"></path></svg>`;
        vinyl.classList.add('spinning');
        charPlayerState.isPlaying = true;
    };
    player.onpause = () => {
        playBtn.innerHTML = `<svg viewBox="0 0 24 24" width="32" height="32" fill="currentColor"><path d="M8 5v14l11-7z"></path></svg>`;
        vinyl.classList.remove('spinning');
        charPlayerState.isPlaying = false;
    };
    player.onended = () => {
        vinyl.classList.remove('spinning');
        charPlayerState.isPlaying = false;
        playNextCharSong();
    };

    document.getElementById('char-music-prev-btn').addEventListener('click', playPrevCharSong);
    document.getElementById('char-music-next-btn').addEventListener('click', playNextCharSong);
    document.getElementById('char-music-mode-btn').addEventListener('click', changeCharPlayMode);

    document.getElementById('char-music-progress-bar').addEventListener('click', (e) => {
        if (!player.duration) return;
        const bar = e.currentTarget;
        const clickX = e.offsetX;
        player.currentTime = (clickX / bar.clientWidth) * player.duration;
    });
}

async function renderDoubanScreen() {
    const listEl = document.getElementById('douban-posts-list');
    listEl.innerHTML = '';
    
    const posts = await db.doubanPosts.orderBy('timestamp').reverse().toArray();

    if (posts.length === 0) {
        listEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">è¿™é‡Œç©ºç©ºå¦‚ä¹Ÿï¼Œ<br>ç‚¹å‡»å³ä¸Šè§’åˆ·æ–°æŒ‰é’®ï¼Œçœ‹çœ‹å¤§å®¶éƒ½åœ¨èŠä»€ä¹ˆå§ï¼</p>';
        return;
    }

    posts.forEach(post => {
        let avatarUrl;
        
   
        const authorChatByOriginalName = post.authorOriginalName 
            ? Object.values(state.chats).find(c => !c.isGroup && c.name === post.authorOriginalName) 
            : null;

        if (authorChatByOriginalName) {
        
            avatarUrl = authorChatByOriginalName.settings.aiAvatar;
        } else {
          
            const authorChatByName = Object.values(state.chats).find(c => !c.isGroup && c.name === post.authorName);
            if (authorChatByName) {
                avatarUrl = authorChatByName.settings.aiAvatar;
            } else if (post.authorAvatarPrompt) {
              
                avatarUrl = `https://image.pollinations.ai/prompt/${encodeURIComponent(post.authorAvatarPrompt)}`;
            } else {
              
                avatarUrl = defaultAvatar;
            }
        }
     

        const itemEl = document.createElement('div');
        itemEl.className = 'douban-post-item';
        itemEl.onclick = () => openDoubanPostDetail(post.id);

        itemEl.innerHTML = `
            <div class="douban-post-header">
                <img src="${avatarUrl}" class="douban-post-avatar">
                <div class="douban-author-info">
                    <div class="douban-author-name">${post.authorName}</div>
                    <div class="douban-group-name">æ¥è‡ª ${post.groupName}</div>
                </div>
            </div>
            <div class="douban-post-title">${post.postTitle}</div>
            <div class="douban-post-content">${post.content.replace(/\n/g, '<br>')}</div>
            <div class="douban-post-footer">
                 <div class="douban-post-actions">
                    <span><svg viewBox="0 0 1024 1024"><path d="M170.666667 170.666667h128v682.666666h-128zM426.666667 170.666667h170.666666v682.666666h-170.666666zM725.333333 170.666667h128v682.666666h-128z"></path></svg> ${post.likesCount}</span>
                    <span><svg viewBox="0 0 1024 1024"><path d="M853.333333 85.333333H170.666667c-46.933333 0-85.333333 38.4-85.333334 85.333334v512c0 46.933333 38.4 85.333333 85.333334 85.333333h512l170.666667 170.666667V170.666667c0-46.933333-38.4-85.333333-85.333334-85.333334z m-42.666666 554.666667H170.666667V170.666667h640v469.333333zM256 384h512v85.333333H256V384z m0-170.666667h512v85.333334H256v-85.333334z"></path></svg> ${post.commentsCount}</span>
                </div>
                <span class="douban-post-timestamp">${formatTimeAgo(post.timestamp)}</span>
            </div>
        `;
        listEl.appendChild(itemEl);
    });
}
  


async function handleGenerateDoubanPosts() {
    const activeCharacterIds = state.globalSettings.doubanActiveCharacterIds || [];

    if (activeCharacterIds.length === 0) {
        await showCustomAlert("è¯·å…ˆé€‰æ‹©è§’è‰²", "è¯·ç‚¹å‡»å³ä¸Šè§’çš„â€œè§’è‰²é€‰æ‹©â€æŒ‰é’®ï¼Œé€‰æ‹©è‡³å°‘ä¸€ä¸ªå‚ä¸Žè±†ç“£äº’åŠ¨çš„è§’è‰²ã€‚");
        return;
    }

    await showCustomAlert("è¯·ç¨å€™...", `æ­£åœ¨ä¸ºæ‚¨é€‰æ‹©çš„ ${activeCharacterIds.length} ä½è§’è‰²ç”Ÿæˆè±†ç“£åŠ¨æ€...`);

    const { proxyUrl, apiKey, model } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) {
        alert('è¯·å…ˆåœ¨APIè®¾ç½®ä¸­é…ç½®å¥½APIä¿¡æ¯ã€‚');
        return;
    }

    const allLinkedBookIds = new Set();
    activeCharacterIds.forEach(charId => {
        const c = state.chats[charId];
        if (c && c.settings.linkedWorldBookIds) {
            c.settings.linkedWorldBookIds.forEach(bookId => allLinkedBookIds.add(bookId));
        }
    });

    let sharedWorldBookContext = '';
    if (allLinkedBookIds.size > 0) {
        sharedWorldBookContext += '\n\n# ç»Ÿä¸€ä¸–ç•Œè§‚è®¾å®š (ä»¥ä¸‹è®¾å®šé€‚ç”¨äºŽæ‰€æœ‰å‚ä¸Žè§’è‰²)\n';
        allLinkedBookIds.forEach(bookId => {
            const book = state.worldBooks.find(wb => wb.id === bookId);
            if (book) {
                const enabledEntries = book.content
                    .filter(e => e.enabled !== false)
                    .map(e => `- ${e.content}`)
                    .join('\n');
                if (enabledEntries) {
                    sharedWorldBookContext += `\n## æ¥è‡ªã€Š${book.name}ã€‹:\n${enabledEntries}`;
                }
            }
        });
    }
    
    const doubanWorldBook = state.worldBooks.find(wb => wb.name === 'è±†ç“£è®¾å®š');
    let doubanSettingContext = '';
    let npcCharacters = [];
    if (doubanWorldBook) {
        doubanWorldBook.content.forEach(entry => {
            if (entry.comment.includes('å°ç»„é£Žæ ¼')) {
                doubanSettingContext += `\n# è±†ç“£ç¤¾åŒºé£Žæ ¼è®¾å®š (æ¥è‡ªä¸–ç•Œä¹¦)\n${entry.content}`;
            }
            if (entry.comment.includes('NPCäººè®¾')) {
                const lines = entry.content.split('\n');
                lines.forEach(line => {
                    const match = line.match(/- \*\*æ˜µç§°\*\*:\s*(.*?)\s*\*\*äººè®¾\*\*:\s*(.*)/);
                    if (match) {
                        npcCharacters.push({ name: match[1].trim(), persona: match[2].trim() });
                    }
                });
            }
        });
    }
    
    const userNickname = state.qzoneSettings.nickname || 'æˆ‘';
    const userPersona = activeCharacterIds.length > 0 && state.chats[activeCharacterIds[0]] 
        ? state.chats[activeCharacterIds[0]].settings.myPersona 
        : '(æœªè®¾ç½®)';

    let charactersContext = '';
    activeCharacterIds.forEach(charId => {
        const c = state.chats[charId];
        if (c) {
            const longTermMemory = c.longTermMemory && c.longTermMemory.length > 0 ? c.longTermMemory.map(m => m.content).join('; ') : 'æ— ';
            const recentHistory = c.history.slice(-10).map(msg => 
                `${msg.role === 'user' ? userNickname : c.name}: ${String(msg.content).substring(0, 30)}...`
            ).join('\n');

            charactersContext += `
<character>
  <name>${c.name}</name>
  <persona>${c.settings.aiPersona}</persona>
  <memory>${longTermMemory}</memory>
  <recent_dialogue_with_user>${recentHistory}</recent_dialogue_with_user>
</character>
`;
        }
    });
    npcCharacters.forEach(npc => {
        charactersContext += `
<character>
  <name>${npc.name}</name>
  <persona>${npc.persona}</persona>
</character>
`;
    });
    
    const now = new Date();
    const currentTimeString = now.toLocaleString('zh-CN', { dateStyle: 'full', timeStyle: 'short' });
    const minPosts = state.globalSettings.doubanMinPosts || 12;
    const maxPosts = state.globalSettings.doubanMaxPosts || 20;
    const systemPrompt = `
# ä½ çš„ä»»åŠ¡
ä½ æ˜¯ä¸€ä¸ªè™šæ‹Ÿç¤¾åŒºå†…å®¹ç”Ÿæˆå™¨ã€‚ä½ çš„ä»»åŠ¡æ˜¯æ ¹æ®ä¸‹é¢æä¾›çš„ã€ç»Ÿä¸€è§’è‰²åˆ—è¡¨ã€‘ï¼Œè™šæž„å‡ºã€${minPosts}åˆ°${maxPosts}ç¯‡ã€‘ä»–ä»¬æœ€è¿‘å¯èƒ½ä¼šåœ¨å„ç§è±†ç“£å°ç»„ä¸­å‘å¸ƒçš„å¸–å­å’Œè¯„è®ºã€‚

# æ ¸å¿ƒè§„åˆ™
1.  **ã€æ—¶é—´æ„ŸçŸ¥ã€‘**:
    -   ä½ ã€å¿…é¡»ã€‘æ„è¯†åˆ°å½“å‰æ˜¯ **${currentTimeString}**ã€‚
    -   ä½ çš„å¸–å­å’Œè¯„è®ºå†…å®¹ã€å¿…é¡»ã€‘è‡ªç„¶åœ°ä½“çŽ°å‡ºå¯¹ã€å½“å‰çœŸå®žæ—¶é—´ã€‘çš„æ„ŸçŸ¥ã€‚
2.  **ã€ç¦æ­¢æ‰®æ¼”ç”¨æˆ· (æœ€æœ€æœ€é«˜ä¼˜å…ˆçº§ï¼ï¼ï¼)ã€‘**:
    -   ç”¨æˆ·çš„æ˜µç§°æ˜¯â€œ${userNickname}â€ã€‚
    -   ä½ ã€ç»å¯¹ä¸èƒ½ã€‘ç”Ÿæˆ authorName æˆ– commenter å­—æ®µä¸º â€œ${userNickname}â€ çš„å¸–å­æˆ–è¯„è®ºã€‚ä½ çš„ä»»åŠ¡æ˜¯æ‰®æ¼”ã€é™¤äº†ç”¨æˆ·ä»¥å¤–ã€‘çš„æ‰€æœ‰è§’è‰²ã€‚
3.  **ã€èº«ä»½ (æœ€é«˜ä¼˜å…ˆçº§ï¼)ã€‘**: 
    -   \`authorName\`: ä½ å¯ä»¥ä¸ºä¸»è¦è§’è‰²èµ·ä¸€ä¸ªç¬¦åˆæƒ…æ™¯çš„ã€ä¸´æ—¶çš„ã€å‘å¸–æ˜µç§°ã€‘ï¼Œä¹Ÿå¯ä»¥ç›´æŽ¥ä½¿ç”¨ä»–ä»¬çš„æœ¬åã€‚
    -   \`authorOriginalName\`: å¦‚æžœå‘å¸–è€…æ˜¯ã€ä¸»è¦è§’è‰²ã€‘ï¼Œä½ ã€å¿…é¡»ã€‘åœ¨è¿™é‡Œå¡«ä¸ŠTAåœ¨è§’è‰²åˆ—è¡¨é‡Œçš„ã€åŽŸå§‹å¤‡æ³¨åã€‘ï¼Œè¿™æ˜¯ç¨‹åºçš„â€œèº«ä»½è¯â€ã€‚
    -   å¦‚æžœå‘å¸–è€…æ˜¯ã€è·¯äººNPCã€‘ï¼Œåˆ™ã€çœç•¥ã€‘\`authorOriginalName\` å­—æ®µã€‚
4.  **ã€ä½œè€…å¹³è¡¡ã€‘**: å¸–å­çš„ä½œè€…ã€å¿…é¡»ã€‘ä»Žä¸‹é¢çš„ \`<character>\` åˆ—è¡¨ä¸­ã€å‡åŒ€åœ°ã€å¤šæ ·åŒ–åœ°ã€‘é€‰æ‹©ã€‚ä½ ã€å¿…é¡»ã€‘ç¡®ä¿å¸–å­åˆ—è¡¨ä¸­ã€è‡³å°‘æœ‰ 70% çš„å¸–å­æ˜¯ç”±è·¯äººNPCå‘å¸ƒçš„ã€‘ï¼Œä»¥è¥é€ ä¸€ä¸ªçœŸå®žçš„ç¤¾åŒºæ°›å›´ã€‚
    - "comments": ä¸€ä¸ªåŒ…å«ã€7åˆ°12æ¡ã€‘è¯„è®ºçš„æ•°ç»„ã€‚è¯„è®ºè€…å¯ä»¥æ˜¯è·¯äººï¼Œä¹Ÿå¯ä»¥æ˜¯è§’è‰²åˆ—è¡¨ä¸­çš„å…¶ä»–è§’è‰²ï¼Œä»¥ä½“çŽ°äº’åŠ¨æ€§ã€‚
5.  **ã€è§’è‰²æ‰®æ¼”ã€‘**: å¸–å­çš„ä½œè€…å’Œå†…å®¹ã€å¿…é¡»ã€‘æ·±åº¦ç»“åˆè¯¥è§’è‰²çš„<persona>, <memory>, å’Œ <worldview>ã€‚
6.  **ã€â€œè±†ç“£å‘³â€å†…å®¹é£Žæ ¼æŒ‡å—ã€‘**: å¸–å­é£Žæ ¼å¿…é¡»å¤šæ ·åŒ–ä¸”å……æ»¡ç”Ÿæ´»æ°”æ¯ï¼ä½ éœ€è¦ç”ŸæˆåŒ…æ‹¬ä½†ä¸é™äºŽï¼šæƒ…æ„Ÿæ ‘æ´žã€ç”Ÿæ´»åæ§½ã€åƒç“œå…«å¦ã€å…´è¶£åˆ†äº«ã€æ— ç”¨è‰¯å“ç­‰å„ç§ç±»åž‹çš„å¸–å­ã€‚
7.  **ã€å¤´åƒç”Ÿæˆ (æœ€é«˜ä¼˜å…ˆçº§ï¼)ã€‘**:
    -   ä¸ºæ¯ä¸€ä¸ªã€é¦–æ¬¡å‡ºçŽ°ã€‘çš„è·¯äººNPCï¼ˆæ— è®ºæ˜¯å‘å¸–è¿˜æ˜¯è¯„è®ºï¼‰ï¼Œä½ éƒ½ã€å¿…é¡»ã€‘ä¸ºå…¶æ·»åŠ ä¸€ä¸ª \`avatar_prompt\` å­—æ®µã€‚
    -   è¿™ä¸ªå­—æ®µçš„å†…å®¹æ˜¯ç”¨äºŽç”Ÿæˆè¯¥NPCå¤´åƒçš„ã€ç®€æ´çš„ã€è‹±æ–‡ã€‘å…³é”®è¯ã€‚
    -   ä¸åŒçš„NPCã€å¿…é¡»ã€‘æœ‰ä¸åŒçš„å¤´åƒæŒ‡ä»¤ï¼Œä»¥ç¡®ä¿ä»–ä»¬çš„å¤´åƒæ˜¯ç‹¬ä¸€æ— äºŒçš„ã€‚
8.  **ã€å¤´åƒä¸€è‡´æ€§ (è‡³å…³é‡è¦ï¼)ã€‘**:
    -   å¦‚æžœä¸€ä¸ªè·¯äººNPCåœ¨åŒä¸€ä¸ªå¸–å­ä¸­å¤šæ¬¡å‡ºçŽ°ï¼ˆä¾‹å¦‚ï¼Œæ—¢æ˜¯å‘å¸–äººåˆæ˜¯è¯„è®ºè€…ï¼Œæˆ–å¤šæ¬¡è¯„è®ºï¼‰ï¼Œä½ ã€å¿…é¡»ã€‘ä¸ºTAçš„æ‰€æœ‰å‡ºçŽ°éƒ½ä½¿ç”¨ã€å®Œå…¨ç›¸åŒã€‘çš„ \`avatar_prompt\`ã€‚è¿™è‡³å…³é‡è¦ï¼
9.  **ã€æ ¼å¼ (æœ€é«˜ä¼˜å…ˆçº§)ã€‘**: 
    - ä½ çš„å›žå¤ã€å¿…é¡»ä¸”åªèƒ½ã€‘æ˜¯ä¸€ä¸ªJSONæ•°ç»„æ ¼å¼çš„å­—ç¬¦ä¸²ã€‚
    - ä½ çš„å›žå¤å¿…é¡»ä»¥ \`[\` å¼€å§‹ï¼Œå¹¶ä»¥ \`]\` ç»“æŸã€‚
    - ã€ç»å¯¹ç¦æ­¢ã€‘åœ¨JSONæ•°ç»„å‰åŽæ·»åŠ ä»»ä½•å¤šä½™çš„æ–‡å­—ã€è§£é‡Šã€æˆ– markdown æ ‡è®° (å¦‚ \`\`\`json)ã€‚
    - æ•°ç»„ä¸­çš„æ¯ä¸ªå…ƒç´ éƒ½æ˜¯ä¸€ç¯‡å¸–å­ï¼Œæ ¼å¼ã€å¿…é¡»ã€‘å¦‚ä¸‹:
    \`\`\`json
    [
      {
        "groupName": "ä¸€ä¸ªç”ŸåŠ¨æœ‰è¶£çš„å°ç»„åç§°",
        "postTitle": "ä¸€ä¸ªå¼•äºº-æ³¨ç›®çš„å¸–å­æ ‡é¢˜",
        "authorName": "å‘å¸–è§’è‰²çš„ã€å¤‡æ³¨åã€‘",
        "authorOriginalName": "(ä»…å½“å‘å¸–è€…æ˜¯ä¸»è¦è§’è‰²æ—¶ã€å¿…é¡»ã€‘æä¾›) TAçš„åŽŸå§‹å¤‡æ³¨å",
        "authorAvatarPrompt": "(ä»…å½“å‘å¸–è€…æ˜¯è·¯äººNPCæ—¶ã€å¿…é¡»ã€‘æä¾›) ä¸€æ®µç”¨äºŽç”Ÿæˆè¯¥NPCå¤´åƒçš„ã€è‹±æ–‡ã€‘å…³é”®è¯ã€‚é£Žæ ¼ä¸º anime style, simple background",
        "content": "å¸–å­çš„è¯¦ç»†æ­£æ–‡ï¼Œå¿…é¡»æ”¯æŒæ¢è¡Œç¬¦\\nã€‚",
        "likesCount": 152,
        "commentsCount": 38,
        "comments": [
            { "commenter": "è·¯äººç”²", "text": "è¿™æ˜¯ä¸€ä¸ªè·¯äººè¯„è®ºã€‚", "avatar_prompt": "cute cat avatar, simple, flat" },
            { "commenter": "å¦ä¸€ä¸ªè§’è‰²å", "commenterOriginalName": "(å¦‚æžœè¯„è®ºè€…æ˜¯ä¸»è¦è§’è‰²ï¼Œå¿…é¡»æä¾›å…¶æœ¬å)", "text": "è¿™æ˜¯ä¸€ä¸ªæ¥è‡ªå…¶ä»–è§’è‰²çš„äº’åŠ¨è¯„è®ºã€‚" }
        ]
      }
    ]
    \`\`\`
    - **comments**: 
        -   è¯„è®ºè€…å¯ä»¥æ˜¯è·¯äººï¼Œä¹Ÿå¯ä»¥æ˜¯è§’è‰²åˆ—è¡¨ä¸­çš„å…¶ä»–è§’è‰²ã€‚è¯„è®ºåŒºã€å¿…é¡»ã€‘ä½“çŽ°å‡ºäº’åŠ¨æ€§ã€‚
        -   ã€è¯„è®ºèº«ä»½ã€‘: å¦‚æžœè¯„è®ºè€…æ˜¯ã€ä¸»è¦è§’è‰²ã€‘ï¼Œä½ ã€å¿…é¡»ã€‘ä¸ºå…¶æ·»åŠ  \`commenterOriginalName\` å­—æ®µï¼Œå¹¶å¡«å…¥å…¶æœ¬åã€‚å¦‚æžœæ˜¯è·¯äººNPCï¼Œåˆ™çœç•¥æ­¤å­—æ®µã€‚

# ä¾›ä½ å‚è€ƒçš„ä¸Šä¸‹æ–‡
${doubanSettingContext}
${sharedWorldBookContext}

# å½“å‰æƒ…æ™¯
- **å½“å‰çœŸå®žæ—¶é—´**: ${currentTimeString}

# ã€ä½ çš„èŠå¤©å¯¹è±¡ï¼ˆç”¨æˆ·ï¼‰çš„èº«ä»½æ¡£æ¡ˆã€‘
- **æ˜µç§°**: ${userNickname}
- **äººè®¾**: ${userPersona}

# ç»Ÿä¸€è§’è‰²åˆ—è¡¨ (ä½ æ‰®æ¼”çš„è§’è‰² + è·¯äººNPC)
${charactersContext}

çŽ°åœ¨ï¼Œè¯·ä¸¥æ ¼éµå®ˆæ‰€æœ‰è§„åˆ™ï¼Œç‰¹åˆ«æ˜¯ã€æ—¶é—´æ„ŸçŸ¥ã€‘å’Œã€ç¦æ­¢æ‰®æ¼”ç”¨æˆ·ã€‘çš„é“å¾‹ï¼Œå¼€å§‹ç”Ÿæˆè¿™ç»„ç”ŸåŠ¨ã€å¤šæ ·ä¸”å……æ»¡â€œè±†ç“£å‘³â€çš„å°ç»„å¸–å­ã€‚`;

    try {
        const messagesForApi = [{ role: 'user', content: "è¯·æ ¹æ®è§’è‰²åˆ—è¡¨ï¼Œç”Ÿæˆè±†ç“£å°ç»„å¸–å­ã€‚" }];
        let isGemini = proxyUrl.includes('generativelanguage');
        let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi);
        
        const response = isGemini 
            ? await fetch(geminiConfig.url, geminiConfig.data) 
            : await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                body: JSON.stringify({
                    model: model,
                    messages: [{role: 'system', content: systemPrompt}, ...messagesForApi],
                    temperature: state.globalSettings.apiTemperature || 1.0,
                })
            });

        if (!response.ok) throw new Error(`API é”™è¯¯: ${response.statusText}`);
        
        const data = await response.json();
        const aiResponseContent = getGeminiResponseText(data);
        
        const jsonMatch = aiResponseContent.match(/\[[\s\S]*\]/);
        
        if (!jsonMatch) {
            throw new Error(`AIè¿”å›žçš„å†…å®¹ä¸­æœªæ‰¾åˆ°æœ‰æ•ˆçš„JSONæ•°ç»„ã€‚åŽŸå§‹è¿”å›ž: ${aiResponseContent}`);
        }
        
        const simulatedPosts = JSON.parse(jsonMatch[0]);
        await db.doubanPosts.clear();
        await db.doubanPosts.bulkAdd(simulatedPosts.map(p => ({...p, timestamp: Date.now() - Math.random() * 100000})));
        
        await renderDoubanScreen();
        
    } catch (error) {
        console.error("ç”Ÿæˆè±†ç“£å¸–å­å¤±è´¥:", error);
        await showCustomAlert("ç”Ÿæˆå¤±è´¥", `æ— æ³•ç”Ÿæˆå†…å®¹ï¼Œè¯·æ£€æŸ¥APIé…ç½®æˆ–ç¨åŽå†è¯•ã€‚\né”™è¯¯: ${error.message}`);
    }
}
  
/**
 * ã€V3.5 | æœ€ç»ˆå¤´åƒç»Ÿä¸€ä¿®å¤ç‰ˆã€‘æ‰“å¼€å¹¶æ¸²æŸ“æŒ‡å®šçš„å¸–å­è¯¦æƒ…é¡µ
 * @param {number} postId - å¸–å­çš„ID
 */
async function openDoubanPostDetail(postId) {
    showScreen('douban-post-detail-screen');
    activeDoubanPostId = postId;
    const post = await db.doubanPosts.get(postId);
    if (!post) {
        showScreen('douban-screen');
        return;
    }

    document.getElementById('douban-post-detail-title').textContent = 'å¸–å­è¯¦æƒ…';

 
    let authorAvatar = defaultAvatar;
    let authorDisplayName = post.authorName; 

    const authorChatByOriginalName = post.authorOriginalName
        ? Object.values(state.chats).find(c => !c.isGroup && c.originalName === post.authorOriginalName)
        : null;

    if (authorChatByOriginalName) {
        authorAvatar = authorChatByOriginalName.settings.aiAvatar;
    } else {
        const authorChatByName = Object.values(state.chats).find(c => !c.isGroup && c.name === post.authorName);
        if (authorChatByName) {
            authorAvatar = authorChatByName.settings.aiAvatar;
        } else if (post.authorAvatarPrompt) {
            authorAvatar = `https://image.pollinations.ai/prompt/${encodeURIComponent(post.authorAvatarPrompt)}`;
        }
    }
    
   
    document.getElementById('douban-detail-avatar').src = authorAvatar;
    document.getElementById('douban-detail-author').textContent = authorDisplayName;
    document.getElementById('douban-detail-group').textContent = `æ¥è‡ª ${post.groupName}`;
    document.getElementById('douban-detail-post-title').textContent = post.postTitle;
    document.getElementById('douban-detail-content').innerHTML = post.content.replace(/\n/g, '<br>');
    document.getElementById('douban-my-comment-avatar').src = state.qzoneSettings.avatar;
    document.getElementById('douban-comment-input').value = '';

    const commentsListEl = document.getElementById('douban-detail-comments-list');
    commentsListEl.innerHTML = '';

  
    if (post.comments && post.comments.length > 0) {
   
        const commenterAvatarMap = new Map();

        post.comments.forEach(comment => {
            let commenterAvatar = defaultAvatar; 
            const myNickname = state.qzoneSettings.nickname || 'æˆ‘';
            const commenterName = comment.commenter; 
       
            if (commenterAvatarMap.has(commenterName)) {
              
                commenterAvatar = commenterAvatarMap.get(commenterName);
            } else {
              
                if (commenterName === myNickname) {
                    commenterAvatar = state.qzoneSettings.avatar;
                }
                else if (commenterName === post.authorName) {
                    commenterAvatar = authorAvatar;
                }
                else {
                    const commenterChatByOriginalName = comment.commenterOriginalName
                        ? Object.values(state.chats).find(c => !c.isGroup && c.originalName === comment.commenterOriginalName)
                        : null;
                    
                    if (commenterChatByOriginalName) {
                        commenterAvatar = commenterChatByOriginalName.settings.aiAvatar;
                    } else {
                        const commenterChatByName = Object.values(state.chats).find(c => !c.isGroup && c.name === commenterName);
                        if (commenterChatByName) {
                            commenterAvatar = commenterChatByName.settings.aiAvatar;
                        } else if (comment.avatar_prompt) {
                            commenterAvatar = `https://image.pollinations.ai/prompt/${encodeURIComponent(comment.avatar_prompt)}`;
                        }
                    }
                }
         
                commenterAvatarMap.set(commenterName, commenterAvatar);
            }
       
            const commentEl = document.createElement('div');
            commentEl.className = 'douban-comment-item';
            commentEl.innerHTML = `
                <img src="${commenterAvatar}" class="douban-comment-avatar">
                <div class="douban-comment-body">
                    <div class="douban-comment-author">${commenterName}</div>
                    <div class="douban-comment-text">${comment.text.replace(/\n/g, '<br>')}</div>
                </div>
            `;
            commentsListEl.appendChild(commentEl);
        });
    } else {
        commentsListEl.innerHTML = '<p style="color: var(--text-secondary); font-size: 13px;">è¿˜æ²¡æœ‰å›žåº”</p>';
    }
 
    const contentWrapper = document.getElementById('douban-detail-content-wrapper');
    if(contentWrapper) contentWrapper.scrollTop = 0;
}
  

/**
 * ã€å…¨æ–°ã€‘å¤„ç†ç”¨æˆ·å‘é€è±†ç“£è¯„è®ºçš„é€»è¾‘ï¼Œå¹¶è§¦å‘AIäº’åŠ¨
 */
async function handleSendDoubanComment() {
    if (!activeDoubanPostId) return;

    const input = document.getElementById('douban-comment-input');
    const commentText = input.value.trim();
    if (!commentText) return;

    const post = await db.doubanPosts.get(activeDoubanPostId);
    if (!post) return;

    if (!post.comments) {
        post.comments = [];
    }
    
    const myNickname = state.qzoneSettings.nickname || 'æˆ‘';
    
    post.comments.push({
        commenter: myNickname,
        text: commentText
    });
    post.commentsCount++;

    await db.doubanPosts.put(post);
    input.value = '';
    

    await openDoubanPostDetail(activeDoubanPostId);


}
  

async function handleDoubanWaitReply() {
    if (!activeDoubanPostId) return;

    const postId = activeDoubanPostId;
    const post = await db.doubanPosts.get(postId);
    if (!post) return;

    const lastComment = post.comments && post.comments.slice(-1)[0];
    if (!lastComment) {
        alert("è¿˜æ²¡æœ‰ä»»ä½•è¯„è®ºï¼Œæ— æ³•ç­‰å¾…å›žå¤ã€‚");
        return;
    }

    await showCustomAlert("è¯·ç¨å€™...", "æ­£åœ¨è¯·æ±‚AIè§’è‰²ä»¬åŠ å…¥è®¨è®º...");

    try {
        const { proxyUrl, apiKey, model } = state.apiConfig;
        if (!proxyUrl || !apiKey || !model) {
            throw new Error('APIæœªé…ç½®ï¼Œæ— æ³•ç”Ÿæˆå†…å®¹ã€‚');
        }

        const userNickname = state.qzoneSettings.nickname || 'æˆ‘';
        const userPersona = state.chats[Object.keys(state.chats)[0]]?.settings.myPersona || '(æœªè®¾ç½®)';
        
        const existingNpcs = new Map();
        if (post.comments) {
            post.comments.forEach(comment => {
                const isMainCharacter = (state.globalSettings.doubanActiveCharacterIds || []).some(id => state.chats[id]?.name === comment.commenter);
                if (!isMainCharacter && comment.avatar_prompt) {
                    existingNpcs.set(comment.commenter, comment.avatar_prompt);
                }
            });
        }
        
        let existingNpcContext = "# å·²æœ‰è·¯äººNPCå¤´åƒæŒ‡ä»¤ (å¿…é¡»éµå®ˆï¼)\n";
        if (existingNpcs.size > 0) {
            existingNpcContext += "å¦‚æžœä»¥ä¸‹ä»»ä½•ä¸€ä½NPCå†æ¬¡è¯„è®ºï¼Œä½ ã€å¿…é¡»ã€‘ä½¿ç”¨æˆ‘ä»¬æä¾›çš„ã€å®Œå…¨ç›¸åŒçš„`avatar_prompt`ï¼Œä»¥ä¿æŒå¤´åƒä¸€è‡´æ€§ã€‚\n";
            existingNpcs.forEach((prompt, name) => {
                existingNpcContext += `- **${name}**: "${prompt}"\n`;
            });
        } else {
            existingNpcContext += "ï¼ˆå½“å‰å¸–å­è¿˜æ²¡æœ‰è·¯äººNPCå‘è¡¨è¯„è®ºã€‚ï¼‰\n";
        }

        const doubanWorldBook = state.worldBooks.find(wb => wb.name === 'è±†ç“£è®¾å®š');
        let npcCharacters = [];
        if (doubanWorldBook) {
            doubanWorldBook.content.forEach(entry => {
                if (entry.comment.includes('NPCäººè®¾')) {
                    const lines = entry.content.split('\n');
                    lines.forEach(line => {
                        const match = line.match(/- \*\*æ˜µç§°\*\*:\s*(.*?)\s*\*\*äººè®¾\*\*:\s*(.*)/);
                        if (match) {
                            npcCharacters.push({ name: match[1].trim(), persona: match[2].trim() });
                        }
                    });
                }
            });
        }
        
        let charactersContext = '';
        const activeCharacterIds = state.globalSettings.doubanActiveCharacterIds || [];
        activeCharacterIds.forEach(charId => {
            const c = state.chats[charId];
            if (c) {
                const longTermMemory = c.longTermMemory && c.longTermMemory.length > 0 ? c.longTermMemory.map(m => m.content).join('; ') : 'æ— ';
                const recentHistory = c.history.slice(-10).map(msg => `${msg.role === 'user' ? userNickname : c.name}: ${String(msg.content).substring(0, 30)}...`).join('\n');
                charactersContext += `\n- ${c.name}: ${c.settings.aiPersona.substring(0,50)}... [è®°å¿†: ${longTermMemory}] [æœ€è¿‘å¯¹è¯: ${recentHistory}]`;
            }
        });
        npcCharacters.forEach(npc => {
            charactersContext += `\n- ${npc.name}: ${npc.persona}`;
        });

       
        const now = new Date();
        const currentTimeString = now.toLocaleString('zh-CN', { dateStyle: 'full', timeStyle: 'short' });

     
        const systemPrompt = `
# ä½ çš„ä»»åŠ¡
ä½ æ˜¯ä¸€ä¸ªè™šæ‹Ÿç¤¾åŒºçš„AIå¯¼æ¼”ã€‚ä¸‹é¢çš„â€œå¸–å­æ‘˜è¦â€å’Œâ€œå·²æœ‰è¯„è®ºâ€æ¥è‡ªäºŽä¸€ä¸ªè±†ç“£å°ç»„çš„å¸–å­ã€‚ç”¨æˆ·â€œ${userNickname}â€åˆšåˆšå¯¹æœ€åŽä¸€æ¡è¯„è®ºç‚¹å‡»äº†â€œç­‰å¾…å›žå¤â€ï¼ŒTAå¸Œæœ›çœ‹åˆ°æ›´å¤šè§’è‰²å‚ä¸Žè®¨è®ºã€‚
ä½ çš„ä»»åŠ¡æ˜¯ï¼šæ ¹æ®æ‰€æœ‰è§’è‰²çš„è®¾å®šï¼Œé€‰æ‹©ã€10åˆ°20ä½ã€‘æœ€é€‚åˆå‚ä¸Žè®¨è®ºçš„è§’è‰²ï¼Œè®©ä»–ä»¬é’ˆå¯¹å·²æœ‰è¯„è®ºï¼Œå‘è¡¨ã€å…¨æ–°çš„ã€ç¬¦åˆäººè®¾çš„ã€‘å›žåº”ã€‚

# æ ¸å¿ƒè§„åˆ™
1.  **ã€æ—¶é—´æ„ŸçŸ¥ã€‘**:
    -   ä½ ã€å¿…é¡»ã€‘æ„è¯†åˆ°å½“å‰æ˜¯ **${currentTimeString}**ã€‚
    -   ä½ çš„è¯„è®ºå†…å®¹ã€å¿…é¡»ã€‘è‡ªç„¶åœ°ä½“çŽ°å‡ºå¯¹ã€å½“å‰çœŸå®žæ—¶é—´ã€‘çš„æ„ŸçŸ¥ã€‚
2.  **ã€ç¦æ­¢æ‰®æ¼”ç”¨æˆ· (æœ€æœ€æœ€é«˜ä¼˜å…ˆçº§ï¼ï¼ï¼)ã€‘**:
    -   ç”¨æˆ·çš„æ˜µç§°æ˜¯â€œ${userNickname}â€ã€‚
    -   ä½ ã€ç»å¯¹ä¸èƒ½ã€‘ç”Ÿæˆ commenter å­—æ®µä¸º â€œ${userNickname}â€ çš„è¯„è®ºã€‚ä½ çš„ä»»åŠ¡æ˜¯æ‰®æ¼”ã€é™¤äº†ç”¨æˆ·ä»¥å¤–ã€‘çš„æ‰€æœ‰è§’è‰²ã€‚
3.  **ã€äº’åŠ¨ã€‘**: æ–°ç”Ÿæˆçš„è¯„è®ºã€å¿…é¡»ã€‘æ˜¯é’ˆå¯¹ã€å·²æœ‰è¯„è®ºã€‘çš„å»¶ç»­æˆ–å›žåº”ï¼Œè®©è®¨è®ºèƒ½ç»§ç»­ä¸‹åŽ»ã€‚
4.  **ã€å¤´åƒä¸€è‡´æ€§ (æœ€é«˜ä¼˜å…ˆçº§ï¼)ã€‘**: ä½ ã€å¿…é¡»ã€‘å‚è€ƒä¸‹é¢çš„â€œå·²æœ‰è·¯äººNPCå¤´åƒæŒ‡ä»¤â€åˆ—è¡¨ã€‚å¦‚æžœä¸€ä¸ªå·²æœ‰çš„NPCå†æ¬¡å‘è¨€ï¼Œã€å¿…é¡»ã€‘å¤ç”¨å®ƒæ—§çš„å¤´åƒæŒ‡ä»¤ã€‚åªæœ‰åœ¨åˆ›é€ ä¸€ä¸ªã€å…¨æ–°çš„ã€ä»Žæœªå‡ºçŽ°è¿‡çš„ã€‘NPCæ—¶ï¼Œæ‰ä¸ºå…¶ç”Ÿæˆæ–°çš„å¤´åƒæŒ‡ä»¤ã€‚
5.  **ã€æ ¼å¼ã€‘**: ä½ çš„å›žå¤ã€å¿…é¡»ä¸”åªèƒ½ã€‘æ˜¯ä¸€ä¸ªJSONæ•°ç»„ï¼Œæ•°ç»„ä¸­çš„æ¯ä¸ªå…ƒç´ éƒ½ä»£è¡¨ä¸€æ¡æ–°è¯„è®ºï¼Œæ ¼å¼ã€å¿…é¡»ã€‘å¦‚ä¸‹:
    \`\`\`json
    [
      { "commenter": "è§’è‰²Açš„åå­—", "text": "è§’è‰²Açš„æ–°è¯„è®ºå†…å®¹ã€‚", "avatar_prompt": "(å¯é€‰)å¦‚æžœè¯„è®ºè€…æ˜¯ã€å…¨æ–°çš„ã€‘NPC,æä¾›å¤´åƒæŒ‡ä»¤" },
      { "commenter": "è§’è‰²Bçš„åå­—", "text": "è§’è‰²Bå¯¹è§’è‰²Aæˆ–æ¥¼ä¸»çš„çœ‹æ³•ã€‚" }
    ]
    \`\`\`

# ä¸Šä¸‹æ–‡
- **å¸–å­æ ‡é¢˜**: ã€Š${post.postTitle}ã€‹
- **å‘å¸–äºº**: ${post.authorName}
- **å¸–å­å†…å®¹æ‘˜è¦**: ${post.content.substring(0, 100)}...
- **å·²æœ‰è¯„è®º**:
${post.comments.map(c => `- ${c.commenter}: ${c.text}`).join('\n')}

${existingNpcContext}

# å½“å‰æƒ…æ™¯
- **å½“å‰çœŸå®žæ—¶é—´**: ${currentTimeString}

# ã€ä½ çš„èŠå¤©å¯¹è±¡ï¼ˆç”¨æˆ·ï¼‰çš„äººè®¾ã€‘
- **æ˜µç§°**: ${userNickname}
- **äººè®¾**: ${userPersona}

# ä½ çš„è§’è‰²åº“ (ä½ å¯ä»¥ä»Žä¸­é€‰æ‹©ã€ä»»ä½•è§’è‰²ã€‘è¿›è¡Œè¯„è®ºï¼Œå¹¶å‚è€ƒä»–ä»¬çš„è®°å¿†å’Œå¯¹è¯)
${charactersContext}

çŽ°åœ¨ï¼Œè¯·ç”Ÿæˆæ–°çš„è¯„è®ºã€‚`;

        const messagesForApi = [{ role: 'user', content: "è¯·æ ¹æ®ä»¥ä¸Šæƒ…æ™¯ï¼Œç”Ÿæˆæ–°çš„è¯„è®ºã€‚" }];
        let isGemini = proxyUrl.includes('generativelanguage');
        let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi);
        
        const response = isGemini 
            ? await fetch(geminiConfig.url, geminiConfig.data) 
            : await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                body: JSON.stringify({
                    model: model,
                    messages: [{role: 'system', content: systemPrompt}, ...messagesForApi],
                    temperature: state.globalSettings.apiTemperature || 1.0,
                })
            });

        if (!response.ok) throw new Error(`API é”™è¯¯: ${response.statusText}`);
        
        const data = await response.json();
        const aiResponseContent = getGeminiResponseText(data);
        const cleanedJson = aiResponseContent.replace(/^```json\s*/, '').replace(/```$/, '');
        const newComments = JSON.parse(cleanedJson);

        if (Array.isArray(newComments) && newComments.length > 0) {
            post.comments.push(...newComments);
            post.commentsCount += newComments.length;
            await db.doubanPosts.put(post);
        }

        await openDoubanPostDetail(postId);
        
        hideCustomModal();

    } catch (error) {
        console.error("ç­‰å¾…å›žå¤å¤±è´¥:", error);
        await showCustomAlert("æ“ä½œå¤±è´¥", `æ— æ³•èŽ·å–AIå›žå¤ï¼Œè¯·æ£€æŸ¥APIé…ç½®æˆ–ç¨åŽå†è¯•ã€‚\né”™è¯¯: ${error.message}`);
    }
}
  

/**
 * ã€å…¨æ–°ã€‘æ‰“å¼€è±†ç“£è§’è‰²é€‰æ‹©å™¨å¼¹çª—
 */
async function openDoubanCastSelector() {
    const modal = document.getElementById('douban-cast-modal');
    const listEl = document.getElementById('douban-cast-list');
    listEl.innerHTML = '';

    const allCharacters = Object.values(state.chats).filter(c => !c.isGroup);
    // ä»Žå…¨å±€è®¾ç½®ä¸­è¯»å–å·²ä¿å­˜çš„é€‰æ‹©
    const activeIds = new Set(state.globalSettings.doubanActiveCharacterIds || []);

    if (allCharacters.length === 0) {
        listEl.innerHTML = '<p style="text-align:center; color:#8a8a8a; padding: 50px 0;">è¿˜æ²¡æœ‰å¯ä»¥å‚ä¸Žçš„è§’è‰²ã€‚</p>';
    } else {
        allCharacters.forEach(char => {
            const item = document.createElement('div');
            item.className = 'contact-picker-item'; // å¤ç”¨è”ç³»äººé€‰æ‹©å™¨çš„æ ·å¼
            item.innerHTML = `
                <input type="checkbox" class="douban-cast-checkbox" data-chat-id="${char.id}" ${activeIds.has(char.id) ? 'checked' : ''} style="margin-right: 15px;">
                <img src="${char.settings.aiAvatar || defaultAvatar}" class="avatar">
                <span class="name">${char.name}</span>
            `;
            listEl.appendChild(item);
        });
    }
    modal.classList.add('visible');
}

/**
 * ã€å…¨æ–°ã€‘ä¿å­˜ç”¨æˆ·é€‰æ‹©çš„è±†ç“£è§’è‰²
 */
async function saveDoubanCastSelection() {
    const selectedCheckboxes = document.querySelectorAll('#douban-cast-list .douban-cast-checkbox:checked');
    const selectedIds = Array.from(selectedCheckboxes).map(cb => cb.dataset.chatId);

 
    state.globalSettings.doubanActiveCharacterIds = selectedIds;
    await db.globalSettings.put(state.globalSettings);

    document.getElementById('douban-cast-modal').classList.remove('visible');
    
    
    await handleGenerateDoubanPosts();
}



document.getElementById('douban-cast-select-btn').addEventListener('click', openDoubanCastSelector);
document.getElementById('cancel-douban-cast-btn').addEventListener('click', () => {
    document.getElementById('douban-cast-modal').classList.remove('visible');
});
document.getElementById('save-douban-cast-btn').addEventListener('click', saveDoubanCastSelection);

document.getElementById('douban-cast-list').addEventListener('click', (e) => {
    const item = e.target.closest('.contact-picker-item');
    if (item) {
        const checkbox = item.querySelector('.douban-cast-checkbox');
        if (checkbox && e.target !== checkbox) {
            checkbox.checked = !checkbox.checked;
        }
    }
});
  
/* â–¼â–¼â–¼ ã€å…¨æ–°ã€‘è¿™æ˜¯å¯¼å…¥å¤–è§‚è®¾ç½®çš„ã€å…¨éƒ¨æ ¸å¿ƒJSä»£ç ã€‘ï¼Œè¯·å®Œæ•´ç²˜è´´ â–¼â–¼â–¼ */

/**
 * ã€æ€»å…¥å£ã€‘å½“ç”¨æˆ·é€‰æ‹©äº†å¤–è§‚è®¾ç½®çš„JSONæ–‡ä»¶åŽï¼Œç”±æ­¤å‡½æ•°å¼€å§‹å¤„ç†
 * @param {File} file - ç”¨æˆ·é€‰æ‹©çš„ .json å¤‡ä»½æ–‡ä»¶
 */
async function importAppearanceSettings(file) {
    if (!file) return;

    
    const confirmed = await showCustomConfirm(
        'å¯¼å…¥å¤–è§‚è®¾ç½®',
        'è¿™å°†ç”¨æ–‡ä»¶ä¸­çš„è®¾ç½®è¦†ç›–å½“å‰çš„æ‰€æœ‰å¤–è§‚è®¾ç½®ï¼ˆåŒ…æ‹¬å£çº¸ã€å›¾æ ‡ã€å­—ä½“ã€CSSç­‰ï¼‰ã€‚ç¡®å®šè¦ç»§ç»­å—ï¼Ÿ',
        { confirmText: 'ç¡®è®¤å¯¼å…¥' }
    );

    if (!confirmed) return;

    try {
        
        const text = await file.text();
        const data = JSON.parse(text);

        
        if (!data.wallpaper && !data.globalCss && !data.appIcons) {
            throw new Error("æ–‡ä»¶æ ¼å¼ä¸æ­£ç¡®ï¼Œç¼ºå°‘å…³é”®çš„å¤–è§‚è®¾ç½®é¡¹ã€‚");
        }

        
        
        Object.assign(state.globalSettings, data);

        
        await db.globalSettings.put(state.globalSettings);
        
        
        applyGlobalWallpaper();
        applyCPhoneWallpaper();
        applyAppIcons();
        applyCPhoneAppIcons();
        applyGlobalCss(state.globalSettings.globalCss);
        applyCustomFont(state.globalSettings.fontUrl);
        applyStatusBarVisibility();
        applyWidgetData();

        
        renderWallpaperScreen();
        
        
        await showCustomAlert('å¯¼å…¥æˆåŠŸ', 'å¤–è§‚è®¾ç½®å·²æˆåŠŸå¯¼å…¥å¹¶åº”ç”¨ï¼');

    } catch (error) {
        
        console.error("å¯¼å…¥å¤–è§‚è®¾ç½®æ—¶å‡ºé”™:", error);
        await showCustomAlert('å¯¼å…¥å¤±è´¥', `æ–‡ä»¶è§£æžæˆ–åº”ç”¨å¤±è´¥: ${error.message}`);
    }
}

/* â–²â–²â–² æ ¸å¿ƒJSä»£ç ç²˜è´´ç»“æŸ â–²â–²â–² */




/**
 * æ¨¡æ‹Ÿè§’è‰²åœ¨Appå…³é—­æœŸé—´çš„åŽå°æ´»åŠ¨
 * @param {number} minutesOffline - Appå¤„äºŽç¦»çº¿çŠ¶æ€çš„æ€»åˆ†é’Ÿæ•°
 */
async function simulateBackgroundActivity(minutesOffline) {
    console.log(`æ£€æµ‹åˆ°åº”ç”¨ç¦»çº¿äº† ${minutesOffline.toFixed(1)} åˆ†é’Ÿï¼Œå¼€å§‹æ¨¡æ‹ŸåŽå°æ´»åŠ¨...`);

    
    const activeCharacters = Object.values(state.chats).filter(chat => 
        !chat.isGroup && 
        chat.settings.enableBackgroundActivity && 
        chat.relationship?.status === 'friend'
    );
    
    if (activeCharacters.length === 0) {
        console.log("æ²¡æœ‰é…ç½®ä¸ºåŽå°æ´»è·ƒçš„è§’è‰²ï¼Œè·³è¿‡æ¨¡æ‹Ÿã€‚");
        return; 
    }

    
    for (const char of activeCharacters) {
        
        const cooldownMinutes = char.settings.actionCooldownMinutes || 15; 
        const timeSinceLastAction = char.lastActionTimestamp 
            ? (Date.now() - char.lastActionTimestamp) / (1000 * 60)
            : Infinity; 

        
        if (minutesOffline > cooldownMinutes && timeSinceLastAction > cooldownMinutes) {
            
            
            
            if (Math.random() < 0.3) {
                console.log(`è§’è‰² "${char.name}" è§¦å‘äº†åŽå°è¡ŒåŠ¨ï¼`);
                
                
                if (Math.random() < 0.7) { 
                    
                    await triggerInactiveAiAction(char.id);
                } else { 
                    
                    console.log(`è§’è‰² "${char.name}" å†³å®šåŽ»å‘ä¸€æ¡åŠ¨æ€... (æ­¤å¤„ä¸ºæ¨¡æ‹Ÿ)`);
                }
            }
        }
    }
}

/* â–¼â–¼â–¼ ã€å…¨æ–°ã€‘è¿™æ˜¯èŠå¤©è®°å½•æœç´¢åŠŸèƒ½çš„ã€å…¨éƒ¨æ ¸å¿ƒJSä»£ç ã€‘ï¼Œè¯·å®Œæ•´ç²˜è´´ â–¼â–¼â–¼ */

/**
 * ã€æ€»å…¥å£ã€‘æ‰“å¼€èŠå¤©è®°å½•æœç´¢å±å¹•
 */
function openSearchHistoryScreen() {
    if (!state.activeChatId) return;
    const chat = state.chats[state.activeChatId];
    
    
    document.getElementById('keyword-search-input').value = '';
    document.getElementById('date-search-input').value = '';
    
    document.getElementById('chat-search-results-list').innerHTML = `<p style="text-align:center; color: var(--text-secondary);">è¾“å…¥å…³é”®è¯æˆ–é€‰æ‹©æ—¥æœŸè¿›è¡Œæœç´¢ã€‚</p>`;
    
    
    showScreen('search-history-screen');
}

/**
 * ã€æ ¸å¿ƒã€‘æ‰§è¡Œæœç´¢é€»è¾‘
 */
async function handleSearchHistory() {
    const chat = state.chats[state.activeChatId];
    if (!chat) return;

    const keyword = document.getElementById('keyword-search-input').value.trim().toLowerCase();
    const dateValue = document.getElementById('date-search-input').value;

    if (!keyword && !dateValue) {
        alert("è¯·è¾“å…¥å…³é”®è¯æˆ–é€‰æ‹©ä¸€ä¸ªæ—¥æœŸã€‚");
        return;
    }

    let results = chat.history.filter(msg => !msg.isHidden);

    
    if (keyword) {
        results = results.filter(msg => {
            let contentString = '';
            
            if (typeof msg.content === 'string') {
                contentString = msg.content;
            } else if (msg.type === 'voice_message') {
                contentString = msg.content;
            } else if (msg.type === 'ai_image' || msg.type === 'user_photo') {
                contentString = msg.content;
            } else if (msg.type === 'offline_text') {
                contentString = `${msg.dialogue || ''} ${msg.description || ''}`;
            } else if (msg.quote) {
                 contentString = msg.content;
            }
            return contentString.toLowerCase().includes(keyword);
        });
    }

    
    if (dateValue) {
        const selectedDate = new Date(dateValue);
        const startOfDay = new Date(selectedDate.setHours(0, 0, 0, 0)).getTime();
        const endOfDay = new Date(selectedDate.setHours(23, 59, 59, 999)).getTime();
        
        results = results.filter(msg => msg.timestamp >= startOfDay && msg.timestamp <= endOfDay);
    }
    
    
    await renderSearchResults(results);
}


/**
 * å°†æœç´¢ç»“æžœæ¸²æŸ“åˆ°å±å¹•ä¸Š
 * @param {Array} results - ç­›é€‰åŽçš„æ¶ˆæ¯å¯¹è±¡æ•°ç»„
 */
async function renderSearchResults(results) {
    const listEl = document.getElementById('chat-search-results-list');
    const chat = state.chats[state.activeChatId];
    listEl.innerHTML = '';

    if (results.length === 0) {
        listEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary);">æœªæ‰¾åˆ°ç›¸å…³çš„èŠå¤©è®°å½•ã€‚</p>';
        return;
    }

    let lastDateString = '';
    for (const msg of results) {
        const msgDate = new Date(msg.timestamp);
        const currentDateString = msgDate.toLocaleDateString();

        if (currentDateString !== lastDateString) {
            const dateSeparator = document.createElement('div');
            dateSeparator.className = 'date-separator';
            dateSeparator.textContent = `--- ${msgDate.getFullYear()}å¹´${msgDate.getMonth() + 1}æœˆ${msgDate.getDate()}æ—¥ ---`;
            listEl.appendChild(dateSeparator);
            lastDateString = currentDateString;
        }

        const messageEl = await createMessageElement(msg, chat);
        if (messageEl) {
            
            
            messageEl.style.cursor = 'pointer';
            
            messageEl.addEventListener('click', () => jumpToOriginalMessage(msg.timestamp));
              
            listEl.appendChild(messageEl);
        }
    }
}



/**
 * ã€æ€»å…¥å£ã€‘ä»Žæœç´¢ç»“æžœè·³è½¬å›žåŽŸå§‹æ¶ˆæ¯ä½ç½®
 * @param {number} timestamp - ç›®æ ‡æ¶ˆæ¯çš„æ—¶é—´æˆ³
 */
async function jumpToOriginalMessage(timestamp) {
    const chatId = state.activeChatId;
    if (!chatId) return;

    
    showScreen('chat-interface-screen');

    
    setTimeout(async () => {
        const messagesContainer = document.getElementById('chat-messages');
        const selector = `.message-bubble[data-timestamp="${timestamp}"]`;
        let targetMessage = messagesContainer.querySelector(selector);
        let attempts = 0; 
        const maxAttempts = 20; 

        
        while (!targetMessage && attempts < maxAttempts) {
            const loadMoreBtn = document.getElementById('load-more-btn');
            if (loadMoreBtn) {
                console.log(`ç›®æ ‡æ¶ˆæ¯æœªæ‰¾åˆ°, æ­£åœ¨åŠ è½½æ›´å¤šåŽ†å²è®°å½•... (å°è¯• ${attempts + 1})`);
                await loadMoreMessages(); 
                targetMessage = messagesContainer.querySelector(selector);
                attempts++;
            } else {
                
                break;
            }
        }

        
        scrollToOriginalMessage(timestamp);

    }, 200); 
}



/**
 * é‡ç½®æœç´¢è¿‡æ»¤å™¨å¹¶æ˜¾ç¤ºæ‰€æœ‰è®°å½•
 */
async function clearSearchFilters() {
    document.getElementById('keyword-search-input').value = '';
    document.getElementById('date-search-input').value = '';
    
    await renderSearchResults(state.chats[state.activeChatId].history.filter(msg => !msg.isHidden));
}

/* â–²â–²â–² æ ¸å¿ƒJSä»£ç ç²˜è´´ç»“æŸ â–²â–²â–² */


/**
 * ã€é‡æž„ç‰ˆã€‘æ¸²æŸ“å¤´åƒæ¡†é€‰æ‹©åˆ—è¡¨ï¼ŒçŽ°åœ¨ä¼šåŒæ—¶æ˜¾ç¤ºé¢„è®¾å’Œç”¨æˆ·è‡ªå®šä¹‰çš„å¤´åƒæ¡†
 * @param {boolean} isForMember - æ˜¯å¦æ˜¯ä¸ºç¾¤æˆå‘˜è®¾ç½®
 * @param {string|null} memberAvatar - (å¯é€‰) ç¾¤æˆå‘˜çš„å¤´åƒURL
 * @param {string|null} memberFrame - (å¯é€‰) ç¾¤æˆå‘˜å½“å‰çš„å¤´åƒæ¡†URL
 */
async function populateFrameGrids(isForMember = false, memberAvatar = null, memberFrame = null) {
    const aiFrameGrid = document.getElementById('ai-frame-grid');
    const myFrameGrid = document.getElementById('my-frame-grid');
    const chat = state.chats[state.activeChatId];
    aiFrameGrid.innerHTML = '';
    myFrameGrid.innerHTML = '';

    
    const customFrames = await db.customAvatarFrames.toArray();
    
    const allFrames = [...avatarFrames, ...customFrames];

    document.querySelector('#avatar-frame-modal .frame-tabs').style.display = isForMember ? 'none' : 'flex';
    document.getElementById('ai-frame-content').style.display = 'block';
    document.getElementById('my-frame-content').style.display = 'none';
    document.getElementById('ai-frame-tab').classList.add('active');
    document.getElementById('my-frame-tab').classList.remove('active');

    if (isForMember) {
        allFrames.forEach(frame => {
            const item = createFrameItem(frame, 'my', memberAvatar);
            if (frame.url === memberFrame) {
                item.classList.add('selected');
            }
            aiFrameGrid.appendChild(item);
        });
    } else {
        const aiAvatarForPreview = chat.settings.aiAvatar || defaultAvatar;
        const myAvatarForPreview = chat.settings.myAvatar || (chat.isGroup ? defaultMyGroupAvatar : defaultAvatar);
        allFrames.forEach(frame => {
            const aiItem = createFrameItem(frame, 'ai', aiAvatarForPreview);
            if (frame.url === currentFrameSelection.ai) aiItem.classList.add('selected');
            aiFrameGrid.appendChild(aiItem);

            const myItem = createFrameItem(frame, 'my', myAvatarForPreview);
            if (frame.url === currentFrameSelection.my) myItem.classList.add('selected');
            myFrameGrid.appendChild(myItem);
        });
    }
}

/**
 * ã€å‡çº§ç‰ˆã€‘åˆ›å»ºå•ä¸ªå¤´åƒæ¡†çš„é¢„è§ˆDOMï¼Œä¸ºè‡ªå®šä¹‰æ¡†æ·»åŠ åˆ é™¤æŒ‰é’®
 * @param {object} frame - å¤´åƒæ¡†å¯¹è±¡ { id, url, name }
 * @param {string} type - 'ai' æˆ– 'my'
 * @param {string} previewAvatarSrc - ç”¨äºŽé¢„è§ˆçš„å¤´åƒURL
 * @returns {HTMLElement} - åˆ›å»ºå¥½çš„DOMå…ƒç´ 
 */
function createFrameItem(frame, type, previewAvatarSrc) {
    const item = document.createElement('div');
    item.className = 'frame-item';
    item.dataset.frameUrl = frame.url;
    item.title = frame.name;

    const isCustom = typeof frame.id === 'number';
    const deleteButtonHtml = isCustom ? `<button class="delete-btn" data-id="${frame.id}" style="display:block;">Ã—</button>` : '';

    item.innerHTML = `
        ${deleteButtonHtml}
        <img src="${previewAvatarSrc}" class="preview-avatar">
        ${frame.url ? `<img src="${frame.url}" class="preview-frame">` : ''}
    `;

    
    item.addEventListener('click', (e) => {
        
        if (e.target.classList.contains('delete-btn')) {
            return;
        }

        
        if (isFrameManagementMode) {
            
            if (isCustom) {
                const frameId = parseInt(frame.id);
                item.classList.toggle('selected');
                if (selectedFrames.has(frameId)) {
                    selectedFrames.delete(frameId);
                } else {
                    selectedFrames.add(frameId);
                }
                updateDeleteFrameButton();
            }
        } else {
            
            currentFrameSelection[type] = frame.url;
            const grid = type === 'ai' ? document.getElementById('ai-frame-grid') : document.getElementById('my-frame-grid');
            grid.querySelectorAll('.frame-item').forEach(el => el.classList.remove('selected'));
            item.classList.add('selected');
        }
    });
    
    return item;
}
  

/**
 * ã€å…¨æ–°ã€‘å¤„ç†æœ¬åœ°ä¸Šä¼ å•ä¸ªå¤´åƒæ¡†çš„é€»è¾‘
 */
async function handleUploadFrame() {
    const fileInput = document.getElementById('custom-frame-upload-input');
    
    
    const file = await new Promise(resolve => {
        const changeHandler = (e) => {
            resolve(e.target.files[0] || null);
            fileInput.removeEventListener('change', changeHandler);
        };
        fileInput.addEventListener('change', changeHandler, { once: true });
        fileInput.click();
    });

    if (!file) return; 

    const name = await showCustomPrompt("å‘½åå¤´åƒæ¡†", "è¯·ä¸ºè¿™ä¸ªæ–°å¤´åƒæ¡†èµ·ä¸ªåå­—");
    if (!name || !name.trim()) return;

    
    const url = await new Promise(resolve => {
        const reader = new FileReader();
        reader.onload = () => resolve(reader.result);
        reader.readAsDataURL(file);
    });

    
    await db.customAvatarFrames.add({ name: name.trim(), url });
    
    populateFrameGrids(editingFrameForMember);
}

/**
 * ã€å…¨æ–°ã€‘å¤„ç†æ‰¹é‡å¯¼å…¥å¤´åƒæ¡†çš„é€»è¾‘
 */
async function handleBatchUploadFrames() {
    const placeholder = `è¯·æŒ‰ç…§ä»¥ä¸‹æ ¼å¼ç²˜è´´ï¼Œä¸€è¡Œä¸€ä¸ªï¼š\n\nå¤´åƒæ¡†åå­—1: https://.../image1.png\nå¤´åƒæ¡†åå­—2: https://.../image2.gif`;
    const pastedText = await showCustomPrompt("æ‰¹é‡å¯¼å…¥å¤´åƒæ¡†", "ä»Žå®Œæ•´é“¾æŽ¥æ‰¹é‡å¯¼å…¥", "", 'textarea', `<p style="font-size:12px;color:#888;">${placeholder}</p>`);

    if (!pastedText || !pastedText.trim()) return;

    const lines = pastedText.trim().split('\n');
    const newFrames = [];
    let errorCount = 0;

    for (const line of lines) {
        
        const match = line.match(/^(.+?)[:ï¼š]\s*(https?:\/\/.+)$/);
        if (match) {
            newFrames.push({
                name: match[1].trim(),
                url: match[2].trim()
            });
        } else if (line.trim()) {
            errorCount++;
        }
    }

    if (newFrames.length > 0) {
        await db.customAvatarFrames.bulkAdd(newFrames);
        populateFrameGrids(editingFrameForMember);
        await showCustomAlert("å¯¼å…¥æˆåŠŸ", `æˆåŠŸå¯¼å…¥ ${newFrames.length} ä¸ªæ–°å¤´åƒæ¡†ï¼`);
    }

    if (errorCount > 0) {
        await showCustomAlert("éƒ¨åˆ†å¤±è´¥", `æœ‰ ${errorCount} è¡Œæ ¼å¼ä¸æ­£ç¡®ï¼Œå·²è¢«å¿½ç•¥ã€‚`);
    }
}

/**
 * ã€å…¨æ–°ã€‘åˆ é™¤ä¸€ä¸ªè‡ªå®šä¹‰å¤´åƒæ¡†
 * @param {number} frameId - è¦åˆ é™¤çš„å¤´åƒæ¡†çš„ID
 */
async function handleDeleteCustomFrame(frameId) {
    const frame = await db.customAvatarFrames.get(frameId);
    if (!frame) return;

    const confirmed = await showCustomConfirm(
        "ç¡®è®¤åˆ é™¤",
        `ç¡®å®šè¦åˆ é™¤å¤´åƒæ¡† â€œ${frame.name}â€ å—ï¼Ÿ`,
        { confirmButtonClass: 'btn-danger' }
    );

    if (confirmed) {
        await db.customAvatarFrames.delete(frameId);
        populateFrameGrids(editingFrameForMember); 
    }
}





let currentPage = 0;
const totalPages = 2;

        
        function setupHomeScreenPagination() {
            const pagesContainer = document.getElementById('home-screen-pages-container');
            const pages = document.getElementById('home-screen-pages');
            const dots = document.querySelectorAll('.pagination-dot');
            let startX = 0, startY = 0; 
            let currentX = 0;
            let isDragging = false;
            let isClick = true; 

            const updatePagination = () => {
                pages.style.transform = `translateX(-${currentPage * (100 / totalPages)}%)`;
                dots.forEach((dot, index) => {
                    dot.classList.toggle('active', index === currentPage);
                });
            };

            const onDragStart = (e) => {
                isDragging = true;
                isClick = true; 
                startX = e.type.includes('mouse') ? e.pageX : e.touches[0].pageX;
                startY = e.type.includes('mouse') ? e.pageY : e.touches[0].pageY;
                pages.style.transition = 'none';
            };

            const onDragMove = (e) => {
                if (!isDragging) return;
                
                const currentY = e.type.includes('mouse') ? e.pageY : e.touches[0].pageY;
                currentX = e.type.includes('mouse') ? e.pageX : e.touches[0].pageX;
                const diffX = currentX - startX;
                const diffY = currentY - startY;

                
                if (isClick && (Math.abs(diffX) > 10 || Math.abs(diffY) > 10)) {
                    isClick = false;
                }

                
                if (Math.abs(diffX) > Math.abs(diffY)) {
                     if(e.cancelable) e.preventDefault();
                     pages.style.transform = `translateX(calc(-${currentPage * (100 / totalPages)}% + ${diffX}px))`;
                }
            };

            const onDragEnd = (e) => {
                if (!isDragging) return;
                isDragging = false;
                pages.style.transition = 'transform 0.4s cubic-bezier(0.4, 0, 0.2, 1)';

                
                if (isClick) {
                    updatePagination(); 
                    
                    return; 
                }

                
                const diffX = currentX - startX;
                if (Math.abs(diffX) > pagesContainer.offsetWidth / 4) {
                    if (diffX > 0 && currentPage > 0) {
                        currentPage--;
                    } else if (diffX < 0 && currentPage < totalPages - 1) {
                        currentPage++;
                    }
                }
                updatePagination();
            };

            pagesContainer.addEventListener('mousedown', onDragStart);
            pagesContainer.addEventListener('mousemove', onDragMove);
            pagesContainer.addEventListener('mouseup', onDragEnd);
            pagesContainer.addEventListener('mouseleave', onDragEnd);

            
            pagesContainer.addEventListener('touchstart', onDragStart, { passive: false });
            pagesContainer.addEventListener('touchmove', onDragMove, { passive: false });
            pagesContainer.addEventListener('touchend', onDragEnd);
        }
          


let editingPresetId = null;

async function openPresetScreen() {
    await renderPresetScreen();
    showScreen('preset-screen');
}

/**
 * ã€å…¨æ–° | æ€§èƒ½ä¼˜åŒ–ç‰ˆã€‘æ¸²æŸ“é¢„è®¾åˆ—è¡¨ï¼Œä¸å†æ˜¾ç¤ºå†…å®¹é¢„è§ˆ
 */
async function renderPresetScreen() {
    const tabsContainer = document.getElementById('preset-tabs');
    const contentContainer = document.getElementById('preset-content-container');
    tabsContainer.innerHTML = '';
    contentContainer.innerHTML = '';

    const [presets, categories] = await Promise.all([
        db.presets.toArray(),
        db.presetCategories.orderBy('name').toArray()
    ]);

    state.presets = presets; 

    if (presets.length === 0) {
        contentContainer.innerHTML = '<p style="text-align:center; color: #8a8a8a; margin-top: 50px;">ç‚¹å‡»å³ä¸Šè§’ "+" åˆ›å»ºä½ çš„ç¬¬ä¸€ä¸ªé¢„è®¾</p>';
        return;
    }

    
    const allTab = document.createElement('button');
    allTab.className = 'world-book-tab active';
    allTab.textContent = 'å…¨éƒ¨';
    allTab.dataset.categoryId = 'all';
    tabsContainer.appendChild(allTab);

    const allPane = document.createElement('div');
    allPane.className = 'world-book-category-pane active';
    allPane.dataset.categoryId = 'all';
    contentContainer.appendChild(allPane);
    
    categories.forEach(category => {
        const categoryTab = document.createElement('button');
        categoryTab.className = 'world-book-tab';
        categoryTab.textContent = category.name;
        categoryTab.dataset.categoryId = String(category.id);
        tabsContainer.appendChild(categoryTab);

        const categoryPane = document.createElement('div');
        categoryPane.className = 'world-book-category-pane';
        categoryPane.dataset.categoryId = String(category.id);
        contentContainer.appendChild(categoryPane);
    });
    
    const hasUncategorized = presets.some(p => !p.categoryId);
    if (hasUncategorized) {
        const uncategorizedTab = document.createElement('button');
        uncategorizedTab.className = 'world-book-tab';
        uncategorizedTab.textContent = 'æœªåˆ†ç±»';
        uncategorizedTab.dataset.categoryId = 'uncategorized';
        tabsContainer.appendChild(uncategorizedTab);
    
        const uncategorizedPane = document.createElement('div');
        uncategorizedPane.className = 'world-book-category-pane';
        uncategorizedPane.dataset.categoryId = 'uncategorized';
        contentContainer.appendChild(uncategorizedPane);
    }
    
    
    presets.forEach(preset => {
        
        const contentPreview = `è¯¥é¢„è®¾åŒ…å« ${preset.content.length} ä¸ªæ¡ç›®ã€‚`;
        
        const card = document.createElement('div');
        card.className = 'world-book-card'; 
        card.innerHTML = `
            <div class="card-title">${preset.name}</div>
            <div class="card-content-preview">${contentPreview}</div>
        `;
        
        
        const cardClickHandler = () => openPresetEditor(preset.id);
        const cardLongPressHandler = async () => { 
            const confirmed = await showCustomConfirm('åˆ é™¤é¢„è®¾', `ç¡®å®šè¦åˆ é™¤ã€Š${preset.name}ã€‹å—ï¼Ÿ`, { confirmButtonClass: 'btn-danger' }); 
            if (confirmed) { 
                await db.presets.delete(preset.id);
                state.presets = await db.presets.toArray();
                renderPresetScreen(); 
            } 
        };

        card.addEventListener('click', cardClickHandler);
        addLongPressListener(card, cardLongPressHandler);

        const clonedCardForAll = card.cloneNode(true);
        clonedCardForAll.addEventListener('click', cardClickHandler);
        addLongPressListener(clonedCardForAll, cardLongPressHandler);
        allPane.appendChild(clonedCardForAll);
        
        const categoryKey = preset.categoryId ? String(preset.categoryId) : 'uncategorized';
        const targetPane = contentContainer.querySelector(`.world-book-category-pane[data-category-id="${categoryKey}"]`);
        if (targetPane) {
            targetPane.appendChild(card);
        }
    });
    
    
    
    document.querySelectorAll('#preset-tabs .world-book-tab').forEach(tab => {
        tab.addEventListener('click', () => switchPresetCategory(tab.dataset.categoryId));
    });
}


function switchPresetCategory(categoryId) {
    document.querySelectorAll('#preset-tabs .world-book-tab').forEach(tab => {
        tab.classList.toggle('active', tab.dataset.categoryId === categoryId);
    });
    document.querySelectorAll('#preset-content-container .world-book-category-pane').forEach(pane => {
        pane.classList.toggle('active', pane.dataset.categoryId === categoryId);
    });
}

/**
 * ã€æœ€ç»ˆä¿®å¤ç‰ˆ | å…¼å®¹iOS/Safariã€‘æ‰“å¼€é¢„è®¾ç¼–è¾‘å™¨
 * @param {string} presetId - è¦ç¼–è¾‘çš„é¢„è®¾çš„ID
 */
async function openPresetEditor(presetId) {
    
    showScreen('preset-editor-screen');
    editingPresetId = presetId;

    try {
        
        const [preset, categories] = await Promise.all([
            db.presets.get(presetId),
            db.presetCategories.toArray()
        ]);

        
        if (!preset) {
            console.error("é”™è¯¯ï¼šå°è¯•æ‰“å¼€ä¸€ä¸ªä¸å­˜åœ¨çš„é¢„è®¾ï¼ŒID:", presetId);
            await showCustomAlert("åŠ è½½å¤±è´¥", "æ‰¾ä¸åˆ°è¿™ä¸ªé¢„è®¾çš„è¯¦ç»†ä¿¡æ¯ã€‚");
            showScreen('preset-screen'); 
            return;
        }

        
        
        setTimeout(() => {
            
            document.getElementById('preset-editor-title').textContent = preset.name;
            document.getElementById('preset-name-input').value = preset.name;

            const selectEl = document.getElementById('preset-category-select');
            selectEl.innerHTML = '<option value="">-- æœªåˆ†ç±» --</option>';
            categories.forEach(cat => {
                const option = document.createElement('option');
                option.value = cat.id;
                option.textContent = cat.name;
                if (preset.categoryId === cat.id) option.selected = true;
                selectEl.appendChild(option);
            });

            const entriesContainer = document.getElementById('preset-entries-container');
            entriesContainer.innerHTML = '';
            if (Array.isArray(preset.content) && preset.content.length > 0) {
                preset.content.forEach(entry => {
                    const block = createPresetEntryBlock(entry);
                    entriesContainer.appendChild(block);
                });
            } else {
                entriesContainer.innerHTML = '<p style="text-align:center; color: var(--text-secondary); margin-top: 20px;">è¿˜æ²¡æœ‰å†…å®¹ï¼Œç‚¹å‡»ä¸‹æ–¹æŒ‰é’®æ·»åŠ ç¬¬ä¸€æ¡å§ï¼</p>';
            }
        }, 50); 

    } catch (error) {
        console.error("æ‰“å¼€é¢„è®¾ç¼–è¾‘å™¨æ—¶å‘ç”Ÿä¸¥é‡é”™è¯¯:", error);
        await showCustomAlert("åŠ è½½å¤±è´¥", `åŠ è½½é¢„è®¾è¯¦æƒ…æ—¶å‘ç”Ÿé”™è¯¯: ${error.message}`);
        showScreen('preset-screen'); 
    }
}

/**
 * ã€å…¨æ–° | æ”¯æŒå†…å®¹æŠ˜å ã€‘åˆ›å»ºå•ä¸ªé¢„è®¾æ¡ç›®çš„ç¼–è¾‘å—
 */
function createPresetEntryBlock(entry = { keys: [], comment: '', content: '', enabled: true }) {
    const block = document.createElement('div');
    block.className = 'message-editor-block';
    const isChecked = entry.enabled !== false ? 'checked' : '';

    
    block.innerHTML = `
        <div style="display: flex; justify-content: flex-end; align-items: center; gap: 10px; margin-bottom: 5px;">
            <label class="toggle-switch" title="å¯ç”¨/ç¦ç”¨æ­¤æ¡ç›®">
                <input type="checkbox" class="entry-enabled-switch" ${isChecked}>
                <span class="slider"></span>
            </label>
            <button type="button" class="delete-block-btn" title="åˆ é™¤æ­¤æ¡ç›®">Ã—</button>
        </div>
        <div class="form-group" style="margin-bottom: 10px;">
            <label style="font-size: 0.8em;">å¤‡æ³¨ (å¯é€‰)</label>
            <input type="text" class="entry-comment-input" value="${entry.comment || ''}" placeholder="ä¾‹å¦‚ï¼šè§’è‰²æ ¸å¿ƒè®¾å®š" style="padding: 8px;">
        </div>
        <div class="form-group" style="margin-bottom: 10px;">
            <label style="font-size: 0.8em;">å…³é”®è¯ (ç”¨è‹±æ–‡é€—å·,åˆ†éš”)</label>
            <input type="text" class="entry-keys-input" value="${(entry.keys || []).join(', ')}" placeholder="ä¾‹å¦‚: key1, key2" style="padding: 8px;">
        </div>
        
        <!-- è¿™é‡Œæ˜¯å…¨æ–°çš„ã€å¸¦æœ‰â€œå±•å¼€/æ”¶èµ·â€æŒ‰é’®çš„ç»“æž„ -->
        <div class="form-group" style="margin-bottom: 0;">
            <label style="font-size: 0.8em; display: flex; justify-content: space-between; align-items: center;">
                <span>å†…å®¹ (ç‚¹å‡»å³ä¾§å±•å¼€)</span>
                <button type="button" class="toggle-content-btn">å±•å¼€</button>
            </label>
            <div class="entry-content-container">
                 <textarea class="entry-content-textarea" rows="8" style="width: 100%; font-size: 14px;">${entry.content || ''}</textarea>
            </div>
        </div>
    `;
    

    
    block.querySelector('.delete-block-btn').addEventListener('click', () => block.remove());
    
    
    const toggleBtn = block.querySelector('.toggle-content-btn');
    const contentContainer = block.querySelector('.entry-content-container');
    toggleBtn.addEventListener('click', () => {
        const isHidden = contentContainer.style.display === 'none';
        contentContainer.style.display = isHidden ? 'block' : 'none';
        toggleBtn.textContent = isHidden ? 'æ”¶èµ·' : 'å±•å¼€';
    });

    return block;
}


async function openPresetCategoryManager() {
    await renderPresetCategoriesInManager();
    
    document.querySelector('#group-management-modal .modal-header span').textContent = 'ç®¡ç†é¢„è®¾åˆ†ç±»';
    document.getElementById('add-new-group-btn').onclick = addNewPresetCategory;
    document.getElementById('existing-groups-list').onclick = (e) => {
        if (e.target.classList.contains('delete-group-btn')) {
            deletePresetCategory(parseInt(e.target.dataset.id));
        }
    };
    document.getElementById('close-group-manager-btn').onclick = () => {
        document.getElementById('group-management-modal').classList.remove('visible');
        renderPresetScreen(); 
    };
    document.getElementById('group-management-modal').classList.add('visible');
}

async function renderPresetCategoriesInManager() {
    const listEl = document.getElementById('existing-groups-list');
    const categories = await db.presetCategories.toArray();
    listEl.innerHTML = '';
    if (categories.length === 0) {
        listEl.innerHTML = '<p style="text-align: center; color: var(--text-secondary);">è¿˜æ²¡æœ‰ä»»ä½•åˆ†ç±»</p>';
    }
    categories.forEach(cat => {
        const item = document.createElement('div');
        item.className = 'existing-group-item';
        item.innerHTML = `<span class="group-name">${cat.name}</span><span class="delete-group-btn" data-id="${cat.id}">Ã—</span>`;
        listEl.appendChild(item);
    });
}

async function addNewPresetCategory() {
    const input = document.getElementById('new-group-name-input');
    const name = input.value.trim();
    if (!name) return alert('åˆ†ç±»åä¸èƒ½ä¸ºç©ºï¼');
    const existing = await db.presetCategories.where('name').equals(name).first();
    if (existing) return alert(`åˆ†ç±» "${name}" å·²ç»å­˜åœ¨äº†ï¼`);
    await db.presetCategories.add({ name });
    input.value = '';
    await renderPresetCategoriesInManager();
}

async function deletePresetCategory(categoryId) {
    const confirmed = await showCustomConfirm('ç¡®è®¤åˆ é™¤', 'åˆ é™¤åˆ†ç±»åŽï¼Œè¯¥åˆ†ç±»ä¸‹çš„æ‰€æœ‰é¢„è®¾å°†å˜ä¸ºâ€œæœªåˆ†ç±»â€ã€‚ç¡®å®šå—ï¼Ÿ', { confirmButtonClass: 'btn-danger' });
    if (confirmed) {
        await db.presetCategories.delete(categoryId);
        await db.presets.where('categoryId').equals(categoryId).modify({ categoryId: null });
        
        
        state.presets = await db.presets.toArray();
        

        await renderPresetCategoriesInManager();
    }
}








/**
 * ã€å…¨æ–°ã€‘åœ¨èŠå¤©è®¾ç½®ä¸­æ¸²æŸ“çº¿ä¸‹æ¨¡å¼çš„æ–‡é£Žé¢„è®¾é€‰æ‹©å™¨
 * @param {object} chat - å½“å‰çš„èŠå¤©å¯¹è±¡
 */
async function renderOfflinePresetSelector(chat) {
    const selectEl = document.getElementById('offline-preset-select');
    if (!selectEl) return;

    
    const presets = state.presets || [];
    
    
    selectEl.innerHTML = '<option value="">-- ä¸ä½¿ç”¨é¢„è®¾ --</option>';
    presets.forEach(preset => {
        const option = document.createElement('option');
        option.value = preset.id;
        option.textContent = preset.name;
        selectEl.appendChild(option);
    });

    
    if (chat.settings.offlinePresetId) {
        selectEl.value = chat.settings.offlinePresetId;
    }
}


/**
 * æ¸²æŸ“æŒ‰é’®æŽ’åºçš„è®¾ç½®ç•Œé¢ (V2.0 - ä½¿ç”¨å¸¸é‡ä½œä¸ºé»˜è®¤å€¼)
 */
function renderButtonOrderEditor() {
    const editor = document.getElementById('button-order-editor');
    if (!editor) return;

    editor.innerHTML = '';

    
    
    let buttonOrder = state.globalSettings.chatActionButtonsOrder || DEFAULT_BUTTON_ORDER;
    
    buttonOrder.forEach(buttonId => {
        const originalButton = document.getElementById(buttonId);
        if (originalButton) {
            const item = document.createElement('div');
            item.className = 'draggable-button-item';
            item.draggable = true;
            item.dataset.buttonId = buttonId;
            item.innerHTML = originalButton.innerHTML; 
            editor.appendChild(item);
        }
    });
}
  


/**
 * ã€V2.0 | ç§»åŠ¨ç«¯å…¼å®¹ç‰ˆã€‘åˆå§‹åŒ–æŒ‰é’®æŽ’åºç¼–è¾‘å™¨çš„æ‹–æ”¾äº‹ä»¶
 */
function initializeButtonOrderEditor() {
    const editor = document.getElementById('button-order-editor');
    if (!editor) return;

    let draggingItem = null; 

    
    const handleDragStart = (e) => {
        const target = e.target.closest('.draggable-button-item');
        if (!target) return;
        
        draggingItem = target;
        draggingItem.classList.add('dragging');

        
        if (e.cancelable) e.preventDefault();
    };

    const handleDragMove = (e) => {
        if (!draggingItem) return;

        
        const clientX = e.type.includes('mouse') ? e.clientX : e.touches[0].clientX;
        
        const afterElement = getDragAfterElement(editor, clientX);
        
        if (afterElement == null) {
            editor.appendChild(draggingItem);
        } else {
            editor.insertBefore(draggingItem, afterElement);
        }
    };

    const handleDragEnd = () => {
        if (!draggingItem) return;

        draggingItem.classList.remove('dragging');
        draggingItem = null;
        
        
        saveButtonOrder();
    };

    
    
    editor.addEventListener('mousedown', handleDragStart);
    editor.addEventListener('touchstart', handleDragStart, { passive: false });

    
    editor.addEventListener('mousemove', handleDragMove);
    editor.addEventListener('touchmove', handleDragMove, { passive: false });

    
    editor.addEventListener('mouseup', handleDragEnd);
    editor.addEventListener('mouseleave', handleDragEnd); 
    editor.addEventListener('touchend', handleDragEnd);
}
  


/**
 * ã€V2.0 | æ°´å¹³ä¿®å¤ç‰ˆã€‘è¾…åŠ©å‡½æ•°ï¼šè®¡ç®—æ‹–åŠ¨å…ƒç´ åº”è¯¥æ’å…¥åˆ°å“ªä¸ªå…ƒç´ å‰é¢
 * @param {HTMLElement} container - æ‹–æ”¾åŒºåŸŸçš„å®¹å™¨
 * @param {number} x - é¼ æ ‡å½“å‰çš„æ°´å¹³ (X) åæ ‡
 * @returns {HTMLElement|null} - åº”è¯¥è¢«æ’å…¥åˆ°å…¶å‰é¢çš„é‚£ä¸ªå…ƒç´ 
 */
function getDragAfterElement(container, x) {
    
    const draggableElements = [...container.querySelectorAll('.draggable-button-item:not(.dragging)')];

    
    return draggableElements.reduce((closest, child) => {
        const box = child.getBoundingClientRect();
        
        const offset = x - box.left - box.width / 2;
        
        
        if (offset < 0 && offset > closest.offset) {
            return { offset: offset, element: child };
        } else {
            return closest;
        }
    }, { offset: Number.NEGATIVE_INFINITY }).element;
}
  

/**
 * ä¿å­˜ç”¨æˆ·è‡ªå®šä¹‰çš„æŒ‰é’®é¡ºåºåˆ°æ•°æ®åº“
 */
async function saveButtonOrder() {
    const editor = document.getElementById('button-order-editor');
    const newOrder = Array.from(editor.querySelectorAll('.draggable-button-item')).map(item => item.dataset.buttonId);
    
    state.globalSettings.chatActionButtonsOrder = newOrder;
    await db.globalSettings.put(state.globalSettings);

    
    
}

/**
 * ã€æ ¸å¿ƒã€‘æ ¹æ®å·²ä¿å­˜çš„é¡ºåºï¼Œé‡æ–°æŽ’åˆ—èŠå¤©ç•Œé¢åº•éƒ¨çš„æŒ‰é’®
 */
function applyButtonOrder() {
    const buttonOrder = state.globalSettings.chatActionButtonsOrder;
    if (!buttonOrder || !Array.isArray(buttonOrder) || buttonOrder.length === 0) {
        return; 
    }

    const container = document.getElementById('chat-input-actions-top');
    if (!container) return;

    
    buttonOrder.forEach(buttonId => {
        const button = document.getElementById(buttonId);
        if (button) {
            container.appendChild(button);
        }
    });
}



const DEFAULT_BUTTON_ORDER = [
    'open-sticker-panel-btn', 'send-photo-btn', 'upload-image-btn', 
    'transfer-btn', 'voice-message-btn', 'send-waimai-request-btn', 
    'video-call-btn', 'group-video-call-btn', 'send-poll-btn', 
    'share-link-btn', 'share-location-btn', 'gomoku-btn', 
    'open-shopping-btn', 'pat-btn', 'edit-last-response-btn', 
    'regenerate-btn', 'propel-btn', 'show-announcement-board-btn',
'werewolf-game-btn',
    
    'read-together-btn',
    'open-nai-gallery-btn'
];
  

async function resetButtonOrder() {
    
    state.globalSettings.chatActionButtonsOrder = null;
    await db.globalSettings.put(state.globalSettings);

    
    renderButtonOrderEditor();

    
    applyButtonOrder();

    
    await showCustomAlert("æˆåŠŸ", "æŒ‰é’®é¡ºåºå·²æ¢å¤ä¸ºé»˜è®¤è®¾ç½®ï¼");
}
  




let selectedCharsForClear = []; 
let selectedTypesForClear = []; 

/**
 * ã€æ€»å…¥å£ã€‘æ‰“å¼€é«˜çº§æ•°æ®æ¸…ç†å‘å¯¼
 */
function openDataClearWizard() {
    const modal = document.getElementById('data-clear-wizard-modal');
    selectedCharsForClear = [];
    selectedTypesForClear = [];
    
    
    renderClearWizardStep1();
    
    
    document.getElementById('data-clear-step-1').style.display = 'flex';
    document.getElementById('data-clear-step-2').style.display = 'none';
    
    modal.classList.add('visible');
}

/**
 * æ¸²æŸ“å‘å¯¼çš„ç¬¬ä¸€æ­¥ï¼šè§’è‰²é€‰æ‹©åˆ—è¡¨
 */
function renderClearWizardStep1() {
    const listEl = document.getElementById('data-clear-char-list');
    listEl.innerHTML = '';

    
    const userItem = document.createElement('div');
    userItem.className = 'clear-posts-item';
    userItem.dataset.charId = 'user';
    userItem.innerHTML = `
        <div class="checkbox"></div>
        <span class="name">${state.qzoneSettings.nickname || 'æˆ‘'} (ç”¨æˆ·)</span>
    `;
    listEl.appendChild(userItem);

    
    Object.values(state.chats).forEach(chat => {
        if (!chat.isGroup) {
            const charItem = document.createElement('div');
            charItem.className = 'clear-posts-item';
            charItem.dataset.charId = chat.id;
            charItem.innerHTML = `
                <div class="checkbox"></div>
                <span class="name">${chat.name} (è§’è‰²)</span>
            `;
            listEl.appendChild(charItem);
        }
    });
}

/**
         * ã€V2.1 | å·²æ·»åŠ æ”¶è—æ¸…ç†ã€‘æ¸²æŸ“å‘å¯¼çš„ç¬¬äºŒæ­¥ï¼šæ•°æ®ç±»åž‹é€‰æ‹©åˆ—è¡¨
         */
        function renderClearWizardStep2() {
            const listEl = document.getElementById('data-clear-type-list');
            listEl.innerHTML = '';
            
            const dataTypes = [
                { id: 'chat', name: 'èŠå¤©è®°å½•', description: 'å°†æ¸…ç©ºé€‰å®šè§’è‰²çš„æ‰€æœ‰å¯¹è¯æ¶ˆæ¯ã€æ›¾ç”¨å¤‡æ³¨å’Œä½ çš„æ˜µç§°ã€‚' },
                { id: 'qzone', name: 'åŠ¨æ€ä¸Žäº’åŠ¨', description: 'å°†æ¸…ç©ºé€‰å®šè§’è‰²çš„æ‰€æœ‰åŠ¨æ€ã€è¯„è®ºå’Œç‚¹èµžã€‚' },
                { id: 'calls', name: 'é€šè¯è®°å½•', description: 'å°†æ¸…ç©ºé€‰å®šè§’è‰²çš„æ‰€æœ‰é€šè¯è®°å½•ã€‚' },
                { id: 'thoughts', name: 'å¿ƒå£°', description: 'å°†æ¸…ç©ºé€‰å®šè§’è‰²çš„å¿ƒå£°å’Œæ•£è®°åŽ†å²ã€‚' },
                { id: 'memories', name: 'é•¿æœŸè®°å¿†', description: 'å°†æ¸…ç©ºé€‰å®šè§’è‰²çš„æ‰€æœ‰é•¿æœŸè®°å¿†ã€‚' },
                { id: 'favorites', name: 'æ”¶è—', description: 'å°†æ¸…ç©ºæ”¶è—å¤¹ä¸­æ‰€æœ‰ä¸Žè¯¥è§’è‰²ç›¸å…³çš„å†…å®¹ï¼ˆå¦‚èŠå¤©ã€åŠ¨æ€ã€æ—¥è®°ç­‰ï¼‰ã€‚' },
                { id: 'cphone', name: 'Cphoneæ•°æ® (CPhone)', description: 'å°†æ¸…ç©ºè§’è‰²çš„ç›¸å†Œã€QQã€æµè§ˆå™¨ã€æ·˜å®ã€æ—¥è®°ã€å¤‡å¿˜å½•ç­‰æ‰€æœ‰æ¨¡æ‹Ÿæ‰‹æœºæ•°æ®ã€‚' }
            ];

            dataTypes.forEach(type => {
                const item = document.createElement('div');
                item.className = 'clear-posts-item';
                item.dataset.typeId = type.id;
                item.innerHTML = `
                    <div class="checkbox"></div>
                    <div>
                        <span class="name">${type.name}</span>
                        <p style="font-size: 12px; color: #888; margin: 4px 0 0;">${type.description}</p>
                    </div>
                `;
                listEl.appendChild(item);
            });
        }


/**
 * å¤„ç†â€œä¸‹ä¸€æ­¥â€æŒ‰é’®çš„ç‚¹å‡»äº‹ä»¶
 */
function handleDataClearNext() {
    const selectedItems = document.querySelectorAll('#data-clear-char-list .clear-posts-item.selected');
    if (selectedItems.length === 0) {
        alert("è¯·è‡³å°‘é€‰æ‹©ä¸€ä¸ªè¦æ¸…ç†çš„è§’è‰²ã€‚");
        return;
    }

    selectedCharsForClear = Array.from(selectedItems).map(item => item.dataset.charId);
    
    
    renderClearWizardStep2();
    document.getElementById('data-clear-step-1').style.display = 'none';
    document.getElementById('data-clear-step-2').style.display = 'flex';
}

/**
 * å¤„ç†â€œä¸Šä¸€æ­¥â€æŒ‰é’®çš„ç‚¹å‡»äº‹ä»¶
 */
function handleDataClearBack() {
    document.getElementById('data-clear-step-2').style.display = 'none';
    document.getElementById('data-clear-step-1').style.display = 'flex';
    
    document.querySelectorAll('#data-clear-char-list .clear-posts-item').forEach(item => {
        if (selectedCharsForClear.includes(item.dataset.charId)) {
            item.classList.add('selected');
        }
    });
}

/**
         * ã€V2.2 | å·²æ·»åŠ æ”¶è—æ¸…ç†ã€‘å¤„ç†æœ€ç»ˆç¡®è®¤æ¸…ç†çš„é€»è¾‘
         */
        async function handleConfirmDataClear() {
            const selectedItems = document.querySelectorAll('#data-clear-type-list .clear-posts-item.selected');
            if (selectedItems.length === 0) {
                alert("è¯·è‡³å°‘é€‰æ‹©ä¸€ç§è¦æ¸…ç†çš„æ•°æ®ç±»åž‹ã€‚");
                return;
            }

            selectedTypesForClear = Array.from(selectedItems).map(item => item.dataset.typeId);

            const confirmed = await showCustomConfirm(
                'æœ€åŽç¡®è®¤ï¼',
                'æ­¤æ“ä½œå°†æ°¸ä¹…åˆ é™¤æ‚¨é€‰æ‹©çš„æ‰€æœ‰æ•°æ®ï¼Œä¸”æ— æ³•æ¢å¤ï¼ç¡®å®šè¦ç»§ç»­å—ï¼Ÿ',
                { confirmButtonClass: 'btn-danger', confirmText: 'ç¡®è®¤åˆ é™¤' }
            );

            if (!confirmed) return;
            
            await showCustomAlert("è¯·ç¨å€™...", "æ­£åœ¨æ‰§è¡Œæ¸…ç†æ“ä½œï¼Œè¯·ä¸è¦å…³é—­é¡µé¢...");

            try {
                await db.transaction('rw', db.tables, async () => {
                    for (const charId of selectedCharsForClear) {
                        for (const type of selectedTypesForClear) {
                            
                            if (type === 'chat') {
                                if (charId === 'user') {
                                    const allChats = await db.chats.toArray();
                                    for (const chat of allChats) {
                                        chat.history = chat.history.filter(msg => msg.role !== 'user');
                                        await db.chats.put(chat);
                                    }
                                } else {
                                    const chat = await db.chats.get(charId);
                                    if (chat) {
                                        chat.history = [];
                                        chat.heartfeltVoice = '...';
                                        chat.randomJottings = '...';
                                        if (Array.isArray(chat.nameHistory)) {
                                            chat.nameHistory = [];
                                        }
                                        if (chat.settings) {
                                            chat.settings.myNickname = 'æˆ‘';
                                        }
                                        await db.chats.put(chat);
                                    }
                                }
                            }

                            if (type === 'qzone') {
                                const authorId = (charId === 'user') ? 'user' : charId;
                                await db.qzonePosts.where('authorId').equals(authorId).delete();
                            }

                            if (type === 'calls' && charId !== 'user') {
                                await db.callRecords.where('chatId').equals(charId).delete();
                            }

                            if (type === 'thoughts' && charId !== 'user') {
                                const chat = await db.chats.get(charId);
                                if (chat) {
                                    chat.thoughtsHistory = [];
                                    chat.heartfeltVoice = '...';
                                    chat.randomJottings = '...';
                                    await db.chats.put(chat);
                                }
                            }

                            if (type === 'memories' && charId !== 'user') {
                                const chat = await db.chats.get(charId);
                                if (chat) {
                                    chat.longTermMemory = [];
                                    await db.chats.put(chat);
                                }
                            }
                            

                            if (type === 'favorites') {
                                if (charId === 'user') {

                                    await db.favorites.where('type').equals('qzone_post').filter(fav => fav.content.authorId === 'user').delete();

                                    await db.favorites.where('type').equals('chat_message').filter(fav => fav.content.role === 'user').delete();
                                } else {
  
                                    await db.favorites.where('type').equals('chat_message').and(fav => fav.chatId === charId).delete();

                                    await db.favorites.where('type').equals('qzone_post').filter(fav => fav.content.authorId === charId).delete();
  
                                    await db.favorites.where('type').equals('char_diary').filter(fav => fav.content.characterId === charId).delete();
                                    await db.favorites.where('type').equals('char_browser_article').filter(fav => fav.content.characterId === charId).delete();
                                    await db.favorites.where('type').equals('char_memo').filter(fav => fav.content.characterId === charId).delete();
                                }
                            }


                            if (type === 'cphone' && charId !== 'user') {
                                const chat = await db.chats.get(charId);
                                if (chat) {
                                    chat.simulatedAlbum = [];
                                    chat.simulatedConversations = [];
                                    chat.simulatedBrowserHistory = [];
                                    chat.simulatedTaobaoHistory = null;
                                    chat.simulatedAmapHistory = [];
                                    chat.simulatedAppUsage = [];
                                    chat.simulatedMusicPlaylist = [];
                                    chat.diary = [];
                                    chat.memos = [];
                                    await db.chats.put(chat);
                                }
                            }
                        }
                    }
                });
                
                await loadAllDataFromDB();
                await renderChatList();
                
                document.getElementById('data-clear-wizard-modal').classList.remove('visible');
                await showCustomAlert("æ¸…ç†å®Œæˆ", "æŒ‡å®šçš„æ•°æ®å·²æˆåŠŸæ¸…é™¤ã€‚");

            } catch (error) {
                console.error("é«˜çº§æ•°æ®æ¸…ç†å¤±è´¥:", error);
                await showCustomAlert("æ¸…ç†å¤±è´¥", `æ“ä½œå¤±è´¥: ${error.message}`);
            }
        }
        /**
         * ã€å…¨æ–° V2.0 | æ”¯æŒæœ¬åœ°ä¸Šä¼ ã€‘å¤„ç†æ›´æ¢å›¾æ ‡çš„é€»è¾‘ (EPhone & CPhoneé€šç”¨)
         * @param {string} iconId - è¢«ç‚¹å‡»å›¾æ ‡çš„ID (ä¾‹å¦‚ 'qq', 'album')
         * @param {string} phoneType - 'ephone' æˆ– 'cphone'
         * @param {HTMLElement} itemElement - è¢«ç‚¹å‡»çš„é‚£ä¸ªå›¾æ ‡è®¾ç½®é¡¹çš„DOMå…ƒç´ 
         */
        async function handleIconChange(iconId, phoneType, itemElement) {
            const appName = itemElement.querySelector('.icon-preview').alt;
        
            
            const choice = await showChoiceModal(`æ›´æ¢â€œ${appName}â€å›¾æ ‡`, [
                { text: 'ðŸ“ ä»Žæœ¬åœ°ä¸Šä¼ ', value: 'local' },
                { text: 'ðŸŒ ä½¿ç”¨ç½‘ç»œURL', value: 'url' }
            ]);
        
            let newUrl = null;
        
            
            if (choice === 'local') {
                
                newUrl = await uploadImageLocally();
            } else if (choice === 'url') {
                const currentUrl = (phoneType === 'cphone')
                    ? state.globalSettings.cphoneAppIcons[iconId]
                    : state.globalSettings.appIcons[iconId];

                
                
                const isBase64 = currentUrl.startsWith('data:image');

                
                
                const initialValueForPrompt = isBase64 ? '' : currentUrl;
                

                
                newUrl = await showCustomPrompt(
                    `æ›´æ¢å›¾æ ‡`, 
                    'è¯·è¾“å…¥æ–°çš„å›¾ç‰‡URL', 
                    initialValueForPrompt, 
                    'url'
                );
            }
        
            
            if (newUrl && newUrl.trim()) {
                const trimmedUrl = newUrl.trim();
                
                
                if (phoneType === 'cphone') {
                    state.globalSettings.cphoneAppIcons[iconId] = trimmedUrl;
                } else {
                    state.globalSettings.appIcons[iconId] = trimmedUrl;
                }
                
                
                itemElement.querySelector('.icon-preview').src = trimmedUrl;
                
                
            } else if (newUrl !== null) {
                
                alert("è¯·è¾“å…¥ä¸€ä¸ªæœ‰æ•ˆçš„URLæˆ–é€‰æ‹©ä¸€ä¸ªæ–‡ä»¶ï¼");
            }
        }


/**
 * ã€æ€»å…¥å£ | V2.0 ä¿®å¤ç‰ˆã€‘ä¸€é”®åŽ‹ç¼©æ•°æ®åº“ä¸­æ‰€æœ‰æœ¬åœ°ä¸Šä¼ çš„å›¾ç‰‡
 */
async function compressAllLocalImages() {
    
    const confirmed = await showCustomConfirm(
        'ç¡®è®¤åŽ‹ç¼©å›¾ç‰‡ï¼Ÿ',
        'æ­¤æ“ä½œå°†æ‰«æå¹¶åŽ‹ç¼©æ‰€æœ‰æœ¬åœ°ä¸Šä¼ çš„å›¾ç‰‡ï¼ˆBase64æ ¼å¼ï¼‰ï¼Œå°†å…¶è½¬æ¢ä¸ºJPEGä»¥å‡å°ä½“ç§¯ã€‚è¿™ä¼šè½»å¾®é™ä½Žå›¾ç‰‡è´¨é‡ä¸”ã€ä¸å¯æ¢å¤ã€‘ã€‚<br><br><strong>å¼ºçƒˆå»ºè®®åœ¨æ“ä½œå‰å…ˆè¿›è¡Œæ•°æ®å¤‡ä»½ï¼</strong>',
        { confirmButtonClass: 'btn-danger', confirmText: 'æˆ‘å·²äº†è§£é£Žé™©ï¼Œç¡®è®¤åŽ‹ç¼©' }
    );

    if (!confirmed) return;

    
    await showCustomAlert("è¯·ç¨å€™...", "æ­£åœ¨å¼€å§‹å…¨é¢åŽ‹ç¼©å›¾ç‰‡ï¼Œæ ¹æ®å›¾ç‰‡æ•°é‡ï¼Œè¿™å¯èƒ½éœ€è¦å‡ åˆ†é’Ÿæ—¶é—´ï¼Œè¯·ä¸è¦å…³é—­æˆ–åˆ·æ–°é¡µé¢...");

    let stats = {
        found: 0,
        compressed: 0,
        skipped: 0,
        originalSize: 0,
        newSize: 0
    };

    try {
        
        
        
        
        
        console.log("åŽ‹ç¼©æ­¥éª¤ 1/3: æ­£åœ¨ä»Žæ•°æ®åº“è¯»å–æ‰€æœ‰ç›¸å…³æ•°æ®...");
        const tablesToScan = [
            'chats', 'globalSettings', 'qzoneSettings', 
            'userStickers', 'customAvatarFrames'
        ];
        const allData = [];
        for (const tableName of tablesToScan) {
            const table = db.table(tableName);
            const records = await table.toArray();
            allData.push({ tableName, records });
        }

        
        console.log("åŽ‹ç¼©æ­¥éª¤ 2/3: æ­£åœ¨å†…å­˜ä¸­å¼‚æ­¥åŽ‹ç¼©å›¾ç‰‡ï¼Œè¿™å¯èƒ½éœ€è¦ä¸€äº›æ—¶é—´...");
        for (const data of allData) {
            for (const record of data.records) {
                
                await traverseAndCompress(record, stats);
            }
        }
        
        
        console.log("åŽ‹ç¼©æ­¥éª¤ 3/3: æ­£åœ¨å°†åŽ‹ç¼©åŽçš„æ•°æ®å†™å›žæ•°æ®åº“...");
        await db.transaction('rw', tablesToScan, async () => {
            for (const data of allData) {
                
                await db.table(data.tableName).bulkPut(data.records);
            }
        });
        
        
        
        

        
        const reduction = stats.originalSize - stats.newSize;
        const reductionPercent = stats.originalSize > 0 ? (reduction / stats.originalSize * 100).toFixed(2) : 0;

        await showCustomAlert(
            'åŽ‹ç¼©å®Œæˆï¼',
            `æ‰«æå®Œæˆï¼<br>
            - å…±æ‰¾åˆ° ${stats.found} å¼ æœ¬åœ°å›¾ç‰‡<br>
            - æˆåŠŸåŽ‹ç¼© ${stats.compressed} å¼ <br>
            - è·³è¿‡(å·²åŽ‹ç¼©æˆ–æ— éœ€åŽ‹ç¼©) ${stats.skipped} å¼ <br>
            - ç©ºé—´èŠ‚çœäº† <strong>${(reduction / 1024 / 1024).toFixed(2)} MB</strong> (åŽ‹ç¼©çŽ‡ ${reductionPercent}%)
            <br><br>
            å»ºè®®åˆ·æ–°é¡µé¢ä»¥åº”ç”¨æ‰€æœ‰æ›´æ”¹ã€‚`
        );

    } catch (error) {
        console.error("å›¾ç‰‡åŽ‹ç¼©è¿‡ç¨‹ä¸­å‘ç”Ÿé”™è¯¯:", error);
        await showCustomAlert('åŽ‹ç¼©å¤±è´¥', `æ“ä½œå¤±è´¥: ${error.message}`);
    }
}
/**
 * ã€è¾…åŠ©å‡½æ•° V2.0 | å¸¦æŽ’é™¤é€»è¾‘ç‰ˆã€‘é€’å½’è®¡ç®—å¯¹è±¡/æ•°ç»„ä¸­æ‰€æœ‰*å¯åŽ‹ç¼©*å›¾ç‰‡çš„æ€»å¤§å°
 * @param {object|Array} obj - è¦éåŽ†çš„å¯¹è±¡æˆ–æ•°ç»„
 * @param {string} parentKey - (å†…éƒ¨ä½¿ç”¨) å½“å‰å¯¹è±¡çš„çˆ¶çº§é”®å
 * @returns {number} - æ€»å¤§å°ï¼ˆå­—èŠ‚ï¼‰
 */
function calculateTotalSizeRecursive(obj, parentKey = '') {
    let totalSize = 0;
    for (const key in obj) {
        if (obj.hasOwnProperty(key)) {
            const value = obj[key];
            if (typeof value === 'string' && value.startsWith('data:image')) {
                
                // ================== â–¼â–¼â–¼ æ ¸å¿ƒä¿®å¤ï¼šæ·»åŠ æŽ’é™¤åˆ—è¡¨ â–¼â–¼â–¼ ==================
                const isExcluded = 
                    // æŽ’é™¤ EPhone å£çº¸, CPhone å£çº¸, å…¨å±€èŠå¤©èƒŒæ™¯
                    (parentKey === 'globalSettings' && (key === 'wallpaper' || key === 'cphoneWallpaper' || key === 'globalChatBackground')) ||
                    // æŽ’é™¤æ‰€æœ‰å°ç»„ä»¶å›¾ç‰‡
                    (parentKey === 'widgetData') ||
                    // æŽ’é™¤å•ä¸ªèŠå¤©çš„èƒŒæ™¯
                    (parentKey === 'settings' && key === 'background') ||
                    // æŽ’é™¤æ‰€æœ‰EPhoneå’ŒCPhoneçš„Appå›¾æ ‡
                    (parentKey === 'appIcons' || parentKey === 'cphoneAppIcons');

                if (!isExcluded) {
                    totalSize += value.length;
                }
                // ================== â–²â–²â–² æ ¸å¿ƒä¿®å¤ï¼šæ·»åŠ æŽ’é™¤åˆ—è¡¨ â–²â–²â–² ==================
                
            } else if (typeof value === 'object' && value !== null) {
                // é€’å½’è°ƒç”¨ï¼Œå°†å½“å‰keyä½œä¸ºæ–°çš„parentKeyä¼ ä¸‹åŽ»
                totalSize += calculateTotalSizeRecursive(value, key);
            }
        }
    }
    return totalSize;
}

/**
 * ã€å…¨æ–° V2.0 | å¸¦æŽ’é™¤é€»è¾‘ç‰ˆã€‘è®¡ç®—å¹¶æ˜¾ç¤ºæ‰€æœ‰*å¯åŽ‹ç¼©*çš„æœ¬åœ°å­˜å‚¨å›¾ç‰‡çš„æ€»å¤§å°
 */
async function displayTotalImageSize() {
    const displayElement = document.getElementById('total-image-size-display');
    if (!displayElement) return;

    displayElement.innerHTML = `
        <span id="image-size-label">æ­£åœ¨è®¡ç®—å¯åŽ‹ç¼©å›¾ç‰‡å¤§å°...</span>
        <span id="image-size-value">-- MB</span>
    `;

    try {
        let totalBytes = 0;
        const tablesToScan = [
            'chats', 'globalSettings', 'qzoneSettings',
            'userStickers', 'customAvatarFrames'
        ];

        for (const tableName of tablesToScan) {
            const table = db.table(tableName);
            await table.each(record => {
              
                totalBytes += calculateTotalSizeRecursive(record);
            });
        }

        const totalMB = (totalBytes / 1024 / 1024).toFixed(2);
        
        displayElement.innerHTML = `
            <span id="image-size-label">æœ¬åœ°å›¾ç‰‡(å¤´åƒ/è¡¨æƒ…/å¤´åƒæ¡†/ç­‰)å¤§å°:</span>
            <span id="image-size-value"><strong>${totalMB} MB</strong></span>
        `;

    } catch (error) {
        console.error("è®¡ç®—å›¾ç‰‡æ€»å¤§å°æ—¶å‡ºé”™:", error);
        displayElement.innerHTML = `
            <span id="image-size-label">è®¡ç®—å›¾ç‰‡å¤§å°æ—¶å‡ºé”™</span>
            <span id="image-size-value">Error</span>
        `;
    }
}
/**
 * ã€è¾…åŠ©å‡½æ•° V3.0 | æŽ’é™¤é€»è¾‘å‰ç½®ç‰ˆã€‘é€’å½’éåŽ†å¯¹è±¡ï¼Œæ‰¾åˆ°å¹¶åŽ‹ç¼©æ‰€æœ‰*å¯åŽ‹ç¼©*çš„Base64å›¾ç‰‡
 * @param {object|Array} obj - è¦éåŽ†çš„å¯¹è±¡æˆ–æ•°ç»„
 * @param {object} stats - ç”¨äºŽç»Ÿè®¡çš„å¯¹è±¡
 * @param {string} parentKey - (å†…éƒ¨ä½¿ç”¨) å½“å‰å¯¹è±¡çš„çˆ¶çº§é”®å
 */
async function traverseAndCompress(obj, stats, parentKey = '') {
    for (const key in obj) {
        if (obj.hasOwnProperty(key)) {
            const value = obj[key];
            if (typeof value === 'string' && value.startsWith('data:image')) {
                
                // ================== â–¼â–¼â–¼ æ ¸å¿ƒä¿®å¤ï¼šæ·»åŠ æŽ’é™¤åˆ—è¡¨ â–¼â–¼â–¼ ==================
                const isExcluded = 
                    // æŽ’é™¤ EPhone å£çº¸, CPhone å£çº¸, å…¨å±€èŠå¤©èƒŒæ™¯
                    (parentKey === 'globalSettings' && (key === 'wallpaper' || key === 'cphoneWallpaper' || key === 'globalChatBackground')) ||
                    // æŽ’é™¤æ‰€æœ‰å°ç»„ä»¶å›¾ç‰‡
                    (parentKey === 'widgetData') ||
                    // æŽ’é™¤å•ä¸ªèŠå¤©çš„èƒŒæ™¯
                    (parentKey === 'settings' && key === 'background') ||
                    // æŽ’é™¤æ‰€æœ‰EPhoneå’ŒCPhoneçš„Appå›¾æ ‡
                    (parentKey === 'appIcons' || parentKey === 'cphoneAppIcons');

                if (isExcluded) {
                    // console.log(`è·³è¿‡åŽ‹ç¼© (UIå›¾ç‰‡): ${parentKey}.${key}`);
                    continue; // è·³è¿‡æ­¤å¾ªçŽ¯ï¼Œä¸åŽ‹ç¼©è¿™å¼ å›¾ç‰‡
                }
                // ================== â–²â–²â–² æ ¸å¿ƒä¿®å¤ï¼šæ·»åŠ æŽ’é™¤åˆ—è¡¨ â–²â–²â–² ==================
                
       
                stats.found++; // è®¡å…¥â€œæ‰¾åˆ°â€
                stats.originalSize += value.length;

         
                const compressedBase64 = await compressImage(value);
                if (compressedBase64 && compressedBase64 !== value) {
                    obj[key] = compressedBase64; 
                    stats.compressed++;
                    stats.newSize += compressedBase64.length;
                } else {
                    // "skipped" çŽ°åœ¨åªä»£è¡¨ "å·²åŽ‹ç¼©æˆ–æ— éœ€åŽ‹ç¼©"
                    stats.skipped++; 
                    stats.newSize += value.length;
                }
        

            } else if (typeof value === 'object' && value !== null) {
          
                await traverseAndCompress(value, stats, key);
            }
        }
    }
}

/**
 * ã€æ ¸å¿ƒåŽ‹ç¼©å‡½æ•° | V3.1 - å¼ºåˆ¶åŽ‹ç¼©ç‰ˆã€‘
 * å°†å•ä¸ªBase64å›¾ç‰‡å­—ç¬¦ä¸²åŽ‹ç¼©ä¸ºJPEG
 * @param {string} base64Str - åŽŸå§‹çš„Base64å›¾ç‰‡å­—ç¬¦ä¸²
 * @returns {Promise<string|null>} - è¿”å›žåŽ‹ç¼©åŽçš„Base64å­—ç¬¦ä¸²ï¼Œå¦‚æžœå¤±è´¥åˆ™è¿”å›žåŽŸå­—ç¬¦ä¸²
 */
async function compressImage(base64Str) {
    // ã€V3.1 | å¼ºåˆ¶åŽ‹ç¼©ç‰ˆã€‘
    // æ£€æŸ¥æ˜¯å¦æ˜¯æœ‰æ•ˆçš„Base64å›¾ç‰‡ï¼Œå¦‚æžœä¸æ˜¯ï¼Œåˆ™è·³è¿‡
    // ç§»é™¤äº† || base64Str.startsWith('data:image/jpeg') çš„æ£€æŸ¥ï¼Œä»¥å¼ºåˆ¶é‡åŽ‹æ‰€æœ‰å›¾ç‰‡ã€‚
    if (!base64Str.startsWith('data:image')) {
        return base64Str;
    }

    try {
        // 1. å°†Base64å­—ç¬¦ä¸²è½¬æ¢ä¸ºBlobå¯¹è±¡ï¼Œåº“éœ€è¦è¿™ä¸ªæ ¼å¼
        const imageBlob = await (await fetch(base64Str)).blob();

        // 2. è®¾ç½®åŽ‹ç¼©é€‰é¡¹
        const options = {
            maxSizeMB: 0.5,         // ç›®æ ‡æ–‡ä»¶å¤§å°ï¼ˆä¾‹å¦‚ï¼šæœ€å¤§0.5MBï¼‰
            maxWidthOrHeight: 800, // å›¾åƒçš„æœ€å¤§å®½åº¦æˆ–é«˜åº¦
            useWebWorker: true,     // ã€æ ¸å¿ƒã€‘å¯ç”¨Web Workerï¼Œé˜²æ­¢é¡µé¢å¡æ­»
            initialQuality: 0.5,    // åˆå§‹åŽ‹ç¼©è´¨é‡
            // ã€æ–°å¢žã€‘å¼ºåˆ¶è¾“å‡ºä¸º JPEG æ ¼å¼ï¼Œæ— è®ºåŽŸå§‹æ ¼å¼æ˜¯ä»€ä¹ˆ
            fileType: 'image/jpeg' 
        };

        // 3. è°ƒç”¨åº“è¿›è¡ŒåŽ‹ç¼©
        console.log(`å¼€å§‹åŽ‹ç¼©å›¾ç‰‡ï¼ŒåŽŸå§‹å¤§å°: ${(imageBlob.size / 1024 / 1024).toFixed(2)} MB`);
        const compressedFile = await imageCompression(imageBlob, options);
        console.log(`åŽ‹ç¼©å®Œæˆï¼Œæ–°çš„å¤§å°: ${(compressedFile.size / 1024 / 1024).toFixed(2)} MB`);

        // 4. å°†åŽ‹ç¼©åŽçš„Blobå¯¹è±¡è½¬æ¢å›žBase64å­—ç¬¦ä¸²ï¼Œä»¥ä¾¿å­˜å›žæ•°æ®åº“
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onloadend = () => resolve(reader.result);
            reader.onerror = reject;
            reader.readAsDataURL(compressedFile);
        });

    } catch (error) {
        console.error("ä½¿ç”¨ browser-image-compression åŽ‹ç¼©å¤±è´¥:", error);
        return base64Str; // å¦‚æžœåŽ‹ç¼©è¿‡ç¨‹ä¸­å‡ºé”™ï¼Œè¿”å›žåŽŸå§‹å›¾ç‰‡ä»¥é˜²æ•°æ®ä¸¢å¤±
    }
}

/**
 * æ¯”è¾ƒä¸¤ä¸ªç‰ˆæœ¬å·å­—ç¬¦ä¸² (ä¾‹å¦‚ "1.10.1" vs "1.9.2")
 * @param {string} v1 ç¬¬ä¸€ä¸ªç‰ˆæœ¬å·
 * @param {string} v2 ç¬¬äºŒä¸ªç‰ˆæœ¬å·
 * @returns {number} å¦‚æžœ v1 > v2 è¿”å›ž 1, å¦‚æžœ v1 < v2 è¿”å›ž -1, å¦‚æžœç›¸ç­‰è¿”å›ž 0
 */
function compareVersions(v1, v2) {
  // å¦‚æžœä»»ä½•ä¸€ä¸ªç‰ˆæœ¬å·ä¸ºç©ºæˆ–ä¸æ˜¯å­—ç¬¦ä¸²ï¼Œåˆ™è®¤ä¸ºå®ƒä»¬ç›¸ç­‰
  if (!v1 || !v2 || typeof v1 !== 'string' || typeof v2 !== 'string') {
    return 0;
  }

  const parts1 = v1.split('.').map(Number);
  const parts2 = v2.split('.').map(Number);
  const len = Math.max(parts1.length, parts2.length);

  for (let i = 0; i < len; i++) {
    const p1 = parts1[i] || 0; // å¦‚æžœéƒ¨åˆ†ä¸å­˜åœ¨ï¼Œåˆ™è§†ä¸º 0
    const p2 = parts2[i] || 0;

    if (p1 > p2) {
      return 1;
    }
    if (p1 < p2) {
      return -1;
    }
  }
  return 0;
}

/**
 * æ£€æŸ¥åº”ç”¨æ›´æ–°å¹¶æ ¹æ®ç‰ˆæœ¬å†³å®šæ˜¯å¦æ˜¾ç¤ºé€šçŸ¥
 */
async function checkForUpdates() {
    
    
    
    const CURRENT_APP_VERSION = "1.0"; 

    try {
        
        const response = await fetch('update-notice.html?_=' + Date.now()); 
        if (!response.ok) {
            console.warn('èŽ·å–æ›´æ–°é€šçŸ¥æ–‡ä»¶å¤±è´¥ã€‚');
            return;
        }
        const noticeHtml = await response.text();
        
        
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = noticeHtml;
        const noticeContent = tempDiv.querySelector('[data-version]');
        
        if (!noticeContent) {
            console.error('æ›´æ–°é€šçŸ¥æ–‡ä»¶ä¸­ç¼ºå°‘ data-version å±žæ€§ã€‚');
            return;
        }
        
        const notificationVersion = noticeContent.dataset.version;
        
        
        const dismissedVersion = localStorage.getItem('dismissedUpdateVersion');
        
        
        
if (!dismissedVersion || compareVersions(notificationVersion, dismissedVersion) > 0) {
    console.log(`å‘çŽ°æ–°ç‰ˆæœ¬é€šçŸ¥: ${notificationVersion} (å·²å¿½ç•¥ç‰ˆæœ¬: ${dismissedVersion || 'æ— '})`);
    showUpdateNotice(notificationVersion, noticeContent.innerHTML);
} else {
    console.log(`å½“å‰é€šçŸ¥ç‰ˆæœ¬ (${notificationVersion}) å·²è¢«ç”¨æˆ·å¿½ç•¥æˆ–ä¸ºæ—§ç‰ˆæœ¬ï¼Œæ— éœ€æ˜¾ç¤ºã€‚`);
}

    } catch (error) {
        console.error('æ£€æŸ¥æ›´æ–°æ—¶å‡ºé”™:', error);
    }
}

/**
 * æ˜¾ç¤ºæ›´æ–°é€šçŸ¥å¼¹çª—
 * @param {string} version - å½“å‰é€šçŸ¥çš„ç‰ˆæœ¬å·
 * @param {string} contentHtml - è¦æ˜¾ç¤ºçš„HTMLå†…å®¹
 */
function showUpdateNotice(version, contentHtml) {
    const modal = document.getElementById('update-notice-modal');
    const body = document.getElementById('update-notice-body');
    const confirmBtn = document.getElementById('update-notice-confirm-btn');
    const dismissBtn = document.getElementById('update-notice-dismiss-btn');
    
    body.innerHTML = contentHtml;
    
    
    confirmBtn.onclick = () => {
        modal.classList.remove('visible');
    };
    
    
    dismissBtn.onclick = () => {
        localStorage.setItem('dismissedUpdateVersion', version);
        modal.classList.remove('visible');
        console.log(`ç”¨æˆ·å·²å¿½ç•¥ç‰ˆæœ¬: ${version}`);
    };
    
    modal.classList.add('visible');
}




/**
 * ã€æ€»å…¥å£ã€‘æ‰“å¼€è±†ç“£è®¾ç½®å¼¹çª—
 */
function openDoubanSettingsModal() {
    const modal = document.getElementById('douban-settings-modal');
    
    
    document.getElementById('douban-min-posts-input').value = state.globalSettings.doubanMinPosts || 12;
    document.getElementById('douban-max-posts-input').value = state.globalSettings.doubanMaxPosts || 20;
    
    modal.classList.add('visible');
}

/**
 * ä¿å­˜è±†ç“£è®¾ç½®
 */
async function saveDoubanSettings() {
    const minInput = document.getElementById('douban-min-posts-input');
    const maxInput = document.getElementById('douban-max-posts-input');
    
    const min = parseInt(minInput.value);
    const max = parseInt(maxInput.value);

    
    if (isNaN(min) || isNaN(max) || min < 1 || max < 1) {
        alert("è¯·è¾“å…¥æœ‰æ•ˆçš„æ­£æ•´æ•°ï¼");
        return;
    }
    if (min > max) {
        alert("æœ€å°å¸–å­æ•°ä¸èƒ½å¤§äºŽæœ€å¤§å¸–å­æ•°ï¼");
        return;
    }

    
    state.globalSettings.doubanMinPosts = min;
    state.globalSettings.doubanMaxPosts = max;
    await db.globalSettings.put(state.globalSettings);

    
    document.getElementById('douban-settings-modal').classList.remove('visible');
    await showCustomAlert('ä¿å­˜æˆåŠŸ', 'è±†ç“£è®¾ç½®å·²æ›´æ–°ï¼ä¸‹æ¬¡é‡æ–°ç”Ÿæˆæ—¶å°†ç”Ÿæ•ˆã€‚');
}

/**
 * ã€å…¨æ–° | V2.1 | æœ¬åè¿½è¸ªç‰ˆã€‘æ‰“å¼€ç‹¼äººæ€æ¸¸æˆå¤§åŽ…
 * @param {'global' | 'group'} mode - æ¨¡å¼ï¼š'global'è¡¨ç¤ºä»Žæ¸¸æˆå°å±‹è¿›å…¥ï¼Œ'group'è¡¨ç¤ºä»Žç¾¤èŠè¿›å…¥
 */
async function openWerewolfLobby(mode) {
    const modal = document.getElementById('werewolf-lobby-modal');
    const listEl = document.getElementById('werewolf-player-selection-list');
    listEl.innerHTML = '';
    
    let potentialPlayers = [];
    
    if (mode === 'global') {
        const characters = Object.values(state.chats).filter(c => !c.isGroup);
        const npcs = await db.npcs.toArray();
        potentialPlayers = [
            
            { id: 'user', name: state.qzoneSettings.nickname || 'æˆ‘', originalName: state.qzoneSettings.nickname || 'æˆ‘', avatar: state.qzoneSettings.avatar, type: 'user' },
            
            ...characters.map(c => ({ id: c.id, name: c.name, originalName: c.originalName, avatar: c.settings.aiAvatar, type: 'character' })),
            
            ...npcs.map(n => ({ id: `npc_${n.id}`, name: n.name, originalName: n.name, avatar: n.avatar, type: 'npc' }))
        ];
        werewolfGameState.chatId = null;
    } else {
        const chat = state.chats[state.activeChatId];
        if (!chat || !chat.isGroup) return;
        
        potentialPlayers = [
            
            { id: 'user', name: chat.settings.myNickname || 'æˆ‘', originalName: state.qzoneSettings.nickname || 'æˆ‘', avatar: chat.settings.myAvatar, type: 'user' },
            
            ...chat.members.map(m => {
                const char = state.chats[m.id];
                const memberAvatar = m.avatar || (char ? char.settings.aiAvatar : defaultGroupMemberAvatar);
                return { 
                    id: m.id, 
                    name: m.groupNickname, 
                    originalName: m.originalName, 
                    avatar: memberAvatar, 
                    type: m.isNpc ? 'npc' : 'character' 
                };
            })
        ];
        werewolfGameState.chatId = state.activeChatId;
    }

    potentialPlayers.forEach(player => {
        const item = document.createElement('div');
        item.className = 'contact-picker-item';
        item.innerHTML = `
            <input type="checkbox" class="werewolf-player-checkbox" data-player-json='${JSON.stringify(player)}' ${player.type === 'user' ? 'checked disabled' : 'checked'}>
            <img src="${player.avatar}" class="avatar">
            <span class="name">${player.name}</span>
        `;
        listEl.appendChild(item);
    });
    
    modal.classList.add('visible');
}

/**
         * ã€V3.0 | å·²æ·»åŠ å¥³å·«å®ˆå«ã€‘åˆå§‹åŒ–ä¸€å±€æ–°çš„ç‹¼äººæ€æ¸¸æˆ
         */
        async function initializeWerewolfGame() {
            const selectedCheckboxes = document.querySelectorAll('.werewolf-player-checkbox:checked');
            const playerCount = selectedCheckboxes.length;

            let roles = [];
            if (playerCount === 6) {
                werewolfGameState.gameMode = '6p';
                roles = ['ç‹¼äºº', 'ç‹¼äºº', 'å¹³æ°‘', 'å¹³æ°‘', 'é¢„è¨€å®¶', 'çŒŽäºº'];
            } else if (playerCount === 9) {
                werewolfGameState.gameMode = '9p';
                roles = ['ç‹¼äºº', 'ç‹¼äºº', 'ç‹¼äºº', 'å¹³æ°‘', 'å¹³æ°‘', 'å¹³æ°‘', 'é¢„è¨€å®¶', 'å¥³å·«', 'çŒŽäºº'];
            } else if (playerCount === 12) {
                werewolfGameState.gameMode = '12p';
                roles = ['ç‹¼äºº', 'ç‹¼äºº', 'ç‹¼äºº', 'ç‹¼äºº', 'å¹³æ°‘', 'å¹³æ°‘', 'å¹³æ°‘', 'å¹³æ°‘', 'é¢„è¨€å®¶', 'å¥³å·«', 'çŒŽäºº', 'å®ˆå«'];
            } else {
                alert(`å½“å‰äººæ•° ${playerCount} ä¸æ”¯æŒã€‚è¯·é€‰æ‹©6ã€9æˆ–12äººã€‚`);
                return;
            }

            document.getElementById('werewolf-lobby-modal').classList.remove('visible');
            await showCustomAlert('æ­£åœ¨å‘ç‰Œ...', 'æ¸¸æˆå³å°†å¼€å§‹ï¼Œæ­£åœ¨ä¸ºå„ä½çŽ©å®¶åˆ†é…èº«ä»½...');

            for (let i = roles.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [roles[i], roles[j]] = [roles[j], roles[i]];
            }

            const selectedPlayers = Array.from(selectedCheckboxes).map(cb => JSON.parse(cb.dataset.playerJson));
            werewolfGameState.players = [];

            for (let i = 0; i < selectedPlayers.length; i++) {
                const playerInfo = selectedPlayers[i];
                const role = roles[i];
                
                let character_persona = "ä¸€ä¸ªæ™®é€šçŽ©å®¶";
                if (playerInfo.type === 'character') {
                    const char = state.chats[playerInfo.id];
                    character_persona = char ? char.settings.aiPersona : 'æœªçŸ¥è®¾å®šçš„è§’è‰²';
                } else if (playerInfo.type === 'npc') {
                    const npcs = await db.npcs.toArray();
                    const npc = npcs.find(n => `npc_${n.id}` === playerInfo.id);
                    character_persona = npc ? npc.persona : 'æœªçŸ¥è®¾å®šçš„NPC';
                } else if (playerInfo.type === 'user') {
                    const activeChat = werewolfGameState.chatId ? state.chats[werewolfGameState.chatId] : null;
                    character_persona = activeChat ? activeChat.settings.myPersona : 'æˆ‘æ˜¯è°å‘€ã€‚';
                }

                const playerObject = {
                    ...playerInfo,
                    role: role,
                    isAlive: true,
                    character_persona: character_persona
                };

                
                if (role === 'å¥³å·«') {
                    playerObject.antidoteUsed = false;
                    playerObject.poisonUsed = false;
                }
                if (role === 'å®ˆå«') {
                    playerObject.lastGuardedId = null;
                }
                  

                werewolfGameState.players.push(playerObject);
            }
            
            werewolfGameState.isActive = true;
            werewolfGameState.currentDay = 1;
            werewolfGameState.currentPhase = 'start';
            werewolfGameState.gameLog = [];
            werewolfGameState.discussionLog = [];

            const roleCounts = roles.reduce((acc, role) => { acc[role] = (acc[role] || 0) + 1; return acc; }, {});
            const roleSummary = Object.entries(roleCounts).map(([role, count]) => `${role} x${count}`).join('ã€');
            addGameLog(`æ¸¸æˆé…ç½®ï¼š${playerCount}äººå±€ï¼Œèº«ä»½ä¸º ${roleSummary}ã€‚`);

            const myPlayer = werewolfGameState.players.find(p => p.id === 'user');

            renderWerewolfScreen();
            showScreen('werewolf-game-screen');
            
            showMyRole(myPlayer.role);
        }


/**
 * ã€V2.1 | UIä¿®å¤ç‰ˆã€‘æ¸²æŸ“ç‹¼äººæ€æ¸¸æˆä¸»ç•Œé¢
 */
function renderWerewolfScreen() {
    const gridEl = document.getElementById('werewolf-player-grid');
    gridEl.innerHTML = '';
    const sortedPlayers = [...werewolfGameState.players].sort((a, b) => a.isAlive - b.isAlive);

    sortedPlayers.forEach((p, index) => {
        const playerIndex = werewolfGameState.players.findIndex(player => player.id === p.id) + 1;
        const avatarEl = document.createElement('div');
        avatarEl.className = 'werewolf-player-avatar';
        if (!p.isAlive) avatarEl.classList.add('dead');
        avatarEl.innerHTML = `
            <img src="${p.avatar}">
            <span class="player-name">${playerIndex}. ${p.name}</span>
        `;
        gridEl.appendChild(avatarEl);
    });

    const logEl = document.getElementById('werewolf-log');
    logEl.innerHTML = '';
    
    
    for (let day = 1; day <= werewolfGameState.currentDay; day++) {
        
        const logsThisDay = [
            ...werewolfGameState.gameLog.filter(entry => entry.day === day),
            ...werewolfGameState.discussionLog.filter(entry => entry.day === day)
        ].sort((a,b) => (a.timestamp || 0) - (b.timestamp || 0));

        
        if (logsThisDay.length > 0) {
            const dayHeader = document.createElement('div');
            dayHeader.className = 'werewolf-log-entry system';
            dayHeader.textContent = `--- ç¬¬ ${day} å¤© ---`;
            dayHeader.style.cssText = 'font-weight: bold; background: rgba(255, 193, 7, 0.2);';
            logEl.appendChild(dayHeader);

            
            logsThisDay.forEach(entry => {
                const entryEl = document.createElement('div');
                entryEl.className = `werewolf-log-entry ${entry.type}`;
                if (entry.type === 'dialogue') {
                    entryEl.innerHTML = `<span class="speaker">${entry.speaker}:</span> ${entry.content}`;
                } else {
                    entryEl.textContent = entry.content;
                }
                logEl.appendChild(entryEl);
            });
        }
    }
    

    logEl.scrollTop = logEl.scrollHeight;
    
    
    const phaseMap = {
        'start': 'æ¸¸æˆå¼€å§‹',
        'night': `ç¬¬${werewolfGameState.currentDay}å¤© - å¤œæ™š`,
        'day': `ç¬¬${werewolfGameState.currentDay}å¤© - ç™½å¤©`,
        'discussion': `ç¬¬${werewolfGameState.currentDay}å¤© - è®¨è®º`,
        'voting': `ç¬¬${werewolfGameState.currentDay}å¤© - æŠ•ç¥¨`,
        'gameover': 'æ¸¸æˆç»“æŸ'
    };
    document.getElementById('werewolf-game-title').textContent = `ç‹¼äººæ€ - ${phaseMap[werewolfGameState.currentPhase] || werewolfGameState.currentPhase}`;
}
  


/**
 * æ˜¾ç¤ºçŽ©å®¶è‡ªå·±çš„èº«ä»½å¡ç‰‡
 * @param {string} role - çŽ©å®¶çš„è§’è‰²
 */
function showMyRole(role) {
    const roleDescriptions = {
        'ç‹¼äºº': 'ä½ çš„ç›®æ ‡æ˜¯æ€æ­»æ‰€æœ‰å¥½äººã€‚æ¯æ™šå¯ä»¥å’ŒåŒä¼´ä¸€èµ·åˆ€ä¸€ä¸ªçŽ©å®¶ã€‚',
        'å¹³æ°‘': 'ä½ æ²¡æœ‰ä»»ä½•ç‰¹æ®Šèƒ½åŠ›ï¼Œä½ çš„ç›®æ ‡æ˜¯é€šè¿‡æŠ•ç¥¨æ”¾é€æ‰€æœ‰ç‹¼äººã€‚',
        'é¢„è¨€å®¶': 'æ¯æ™šå¯ä»¥æŸ¥éªŒä¸€ä¸ªçŽ©å®¶çš„èº«ä»½æ˜¯å¥½äººè¿˜æ˜¯ç‹¼äººã€‚',
        'çŒŽäºº': 'å½“ä½ æ­»äº¡æ—¶ï¼Œä½ å¯ä»¥é€‰æ‹©å¸¦èµ°åœºä¸Šä»»æ„ä¸€åçŽ©å®¶ã€‚',
        'å¥³å·«': 'ä½ æœ‰ä¸€ç“¶è§£è¯å’Œä¸€ç“¶æ¯’è¯ï¼Œè§£è¯å¯ä»¥æ•‘æ´»å½“æ™šè¢«æ€çš„çŽ©å®¶ï¼Œæ¯’è¯å¯ä»¥æ¯’æ­»ä»»æ„ä¸€åçŽ©å®¶ã€‚',
        'å®ˆå«': 'æ¯æ™šå¯ä»¥å®ˆæŠ¤ä¸€åçŽ©å®¶ï¼Œä½¿å…¶å…å—ç‹¼äººè¢­å‡»ã€‚ä¸èƒ½è¿žç»­ä¸¤æ™šå®ˆæŠ¤åŒä¸€ä¸ªäººã€‚'
    };
    
    document.getElementById('werewolf-role-name').textContent = role;
    document.getElementById('werewolf-role-description').textContent = roleDescriptions[role] || 'ä¸€ä¸ªç¥žç§˜çš„è§’è‰²ã€‚';
    document.getElementById('werewolf-role-modal').classList.add('visible');
}

/**
         * ã€V3.0 | å·²è¡¥å…¨å®ˆå«å¥³å·«ã€‘æ‰§è¡Œå¤œæ™šé˜¶æ®µçš„é€»è¾‘
         */
        async function executeNightPhase() {
            werewolfGameState.currentPhase = `ç¬¬${werewolfGameState.currentDay}å¤© - å¤œæ™š`;
            werewolfGameState.nightActions = {}; 
            addGameLog('å¤©é»‘è¯·é—­çœ¼...');
            renderWerewolfScreen();
            
            document.getElementById('werewolf-action-bar').style.display = 'none';
            document.getElementById('werewolf-retry-btn').style.display = 'none'; 
            await new Promise(resolve => setTimeout(resolve, 1500));
        
            
            const guard = werewolfGameState.players.find(p => p.role === 'å®ˆå«' && p.isAlive);
            if (guard) {
                addGameLog('å®ˆå«è¯·ççœ¼ï¼Œè¯·é€‰æ‹©è¦å®ˆæŠ¤çš„çŽ©å®¶ã€‚');
                renderWerewolfScreen();
                let guardedId = null;
                if (guard.id === 'user') {
                    guardedId = await openSelectionModal('guard', guard.lastGuardedId);
                } else { 
                    const potentialTargets = werewolfGameState.players.filter(p => p.isAlive && p.id !== guard.lastGuardedId);
                    if (potentialTargets.length > 0) {
                        guardedId = potentialTargets[Math.floor(Math.random() * potentialTargets.length)].id;
                    }
                }
                if (guardedId) {
                    werewolfGameState.nightActions.guardedId = guardedId;
                    guard.lastGuardedId = guardedId; 
                }
                addGameLog('å®ˆå«å·²è¡ŒåŠ¨ï¼Œå®ˆå«è¯·é—­çœ¼ã€‚');
                renderWerewolfScreen();
                await new Promise(resolve => setTimeout(resolve, 1500));
            }

            
            
            addGameLog('ç‹¼äººè¯·ççœ¼ï¼Œè¯·é€‰æ‹©è¦åˆ€çš„çŽ©å®¶ã€‚');
            renderWerewolfScreen();
            
            const wolves = werewolfGameState.players.filter(p => p.role === 'ç‹¼äºº' && p.isAlive);
            const userIsWolf = wolves.some(p => p.id === 'user');
            
            let wolfTargetId = null;

            
            werewolfGameState.lastFailedAction = 'wolfKill';
            try {
                if (userIsWolf) {
                    addGameLog('ä½ æ˜¯ç‹¼äººï¼Œè¯·é€‰æ‹©åˆ€äººç›®æ ‡ã€‚');
                    renderWerewolfScreen();
                    wolfTargetId = await openWolfKillModal();
                } else {
                    
                    if (werewolfGameState.currentDay === 1) {
                        console.log("ç¬¬ä¸€å¤œï¼Œæ‰§è¡Œæœ¬åœ°éšæœºåˆ€äººé€»è¾‘...");
                        const potentialTargets = werewolfGameState.players.filter(p => p.isAlive && p.role !== 'ç‹¼äºº');
                        if (potentialTargets.length > 0) {
                            wolfTargetId = potentialTargets[Math.floor(Math.random() * potentialTargets.length)].id;
                        }
                    } else {
                        
                        wolfTargetId = await getAiWolfKillTarget();
                    }
                }
                
                werewolfGameState.lastFailedAction = null;
            } catch (error) {
                console.error("ç‹¼äººè¡ŒåŠ¨APIå¤±è´¥:", error);
                await showCustomAlert("æ“ä½œå¤±è´¥", "AIç‹¼äººå›¢é˜Ÿæ— æ³•å†³å®šç›®æ ‡ï¼Œæ¸¸æˆæš‚åœã€‚è¯·ç‚¹å‡»å³ä¸Šè§’çš„â€œé‡è¯•â€æŒ‰é’®ç»§ç»­ã€‚");
                document.getElementById('werewolf-retry-btn').style.display = 'block';
                return;
            }
            
            werewolfGameState.nightActions.killedId = wolfTargetId;
            addGameLog('ç‹¼äººå·²è¡ŒåŠ¨ï¼Œç‹¼äººè¯·é—­çœ¼ã€‚');
            renderWerewolfScreen();
            await new Promise(resolve => setTimeout(resolve, 1500));

            
            const witch = werewolfGameState.players.find(p => p.role === 'å¥³å·«' && p.isAlive);
            if (witch) {
                addGameLog('å¥³å·«è¯·ççœ¼ã€‚');
                renderWerewolfScreen();
                const killedPlayer = werewolfGameState.players.find(p => p.id === werewolfGameState.nightActions.killedId);
                
                
                const isGuarded = werewolfGameState.nightActions.guardedId === werewolfGameState.nightActions.killedId;

                
                const playerToShowWitch = (isGuarded || !killedPlayer) ? null : killedPlayer;

                if (witch.id === 'user') {
                    let userWitchAction = await openWitchActionModal(playerToShowWitch, witch);
                    if (userWitchAction.save) {
                        werewolfGameState.nightActions.savedId = werewolfGameState.nightActions.killedId;
                        witch.antidoteUsed = true;
                    }
                    if (userWitchAction.poison) {
                        werewolfGameState.nightActions.poisonedId = userWitchAction.poison;
                        witch.poisonUsed = true;
                    }
                } else { 
                    
                    if (!witch.antidoteUsed && playerToShowWitch) {
                        let saveChance = 0;
                        if (werewolfGameState.currentDay === 1) {
                            
                            saveChance = 0.3; 
                        } else {
                            
                            saveChance = 0.8;
                        }
                        
                        console.log(`AIå¥³å·«å†³ç­–ï¼šä»Šå¤©æ˜¯ç¬¬${werewolfGameState.currentDay}å¤©ï¼Œæ•‘äººæ¦‚çŽ‡ä¸º ${saveChance * 100}%`);
                        
                        if (Math.random() < saveChance) {
                            console.log("AIå¥³å·«å†³å®šä½¿ç”¨è§£è¯ï¼");
                            werewolfGameState.nightActions.savedId = werewolfGameState.nightActions.killedId;
                            witch.antidoteUsed = true;
                        } else {
                            console.log("AIå¥³å·«å†³å®šä¿ç•™è§£è¯ã€‚");
                        }
                    } 
                    
                    
                    if (!werewolfGameState.nightActions.savedId && !witch.poisonUsed && Math.random() < 0.5) {
                        const poisonTargets = werewolfGameState.players.filter(p => p.isAlive && p.id !== werewolfGameState.nightActions.killedId);
                        if (poisonTargets.length > 0) {
                             const target = poisonTargets[Math.floor(Math.random() * poisonTargets.length)];
                             werewolfGameState.nightActions.poisonedId = target.id;
                             witch.poisonUsed = true;
                             console.log(`AIå¥³å·«å†³å®šä½¿ç”¨æ¯’è¯ï¼Œç›®æ ‡æ˜¯: ${target.name}`);
                        }
                    }

                }
                addGameLog('å¥³å·«å·²è¡ŒåŠ¨ï¼Œå¥³å·«è¯·é—­çœ¼ã€‚');
                renderWerewolfScreen();
                await new Promise(resolve => setTimeout(resolve, 1500));
            }
        
            
            const prophet = werewolfGameState.players.find(p => p.role === 'é¢„è¨€å®¶' && p.isAlive);
            if (prophet) {
                addGameLog('é¢„è¨€å®¶è¯·ççœ¼ï¼Œè¯·é€‰æ‹©è¦æŸ¥éªŒçš„çŽ©å®¶ã€‚');
                renderWerewolfScreen();
        
                if (prophet.id === 'user') {
                    const targetId = await openSelectionModal('prophet');
                    const targetPlayer = werewolfGameState.players.find(p => p.id === targetId);
                    if(targetPlayer) {
                        const isWolf = targetPlayer.role === 'ç‹¼äºº';
                        await showCustomAlert('æŸ¥éªŒç»“æžœ', `ä½ æŸ¥éªŒçš„çŽ©å®¶ ${targetPlayer.name} çš„èº«ä»½æ˜¯ï¼š${isWolf ? 'ç‹¼äºº' : 'å¥½äºº'}`);
                        werewolfGameState.nightActions.prophetCheck = { target: targetId, result: isWolf ? 'ç‹¼äºº' : 'å¥½äºº' };
                    }
                } else {
                    const potentialTargets = werewolfGameState.players.filter(p => p.isAlive && p.id !== prophet.id);
                    if (potentialTargets.length > 0) {
                        const target = potentialTargets[Math.floor(Math.random() * potentialTargets.length)];
                        werewolfGameState.nightActions.prophetCheck = { target: target.id, result: target.role === 'ç‹¼äºº' ? 'ç‹¼äºº' : 'å¥½äºº' };
                    }
                }
                addGameLog('é¢„è¨€å®¶å·²è¡ŒåŠ¨ï¼Œé¢„è¨€å®¶è¯·é—­çœ¼ã€‚');
                renderWerewolfScreen();
                await new Promise(resolve => setTimeout(resolve, 1500));
            }
            
            
            executeDayPhase();
        }
        
/**
         * ã€V3.0 | å·²è¡¥å…¨æ­»äº¡ç»“ç®—ã€‘æ‰§è¡Œç™½å¤©é˜¶æ®µçš„é€»è¾‘
         */
        async function executeDayPhase() {
            werewolfGameState.currentPhase = `ç¬¬${werewolfGameState.currentDay}å¤© - ç™½å¤©`;
            werewolfGameState.voteResults = {};
            addGameLog('å¤©äº®äº†ã€‚');

            const { killedId, guardedId, savedId, poisonedId } = werewolfGameState.nightActions;
            const deathsThisNight = new Set(); 

            
            if (killedId && killedId !== guardedId && killedId !== savedId) {
                deathsThisNight.add(killedId);
            }

            
            if (poisonedId) {
                
                deathsThisNight.add(poisonedId);
            }

            
            if (deathsThisNight.size === 0) {
                addGameLog('æ˜¨æ™šæ˜¯å¹³å®‰å¤œã€‚');
            } else {
                for (const deadPlayerId of deathsThisNight) {
                    const deadPlayer = werewolfGameState.players.find(p => p.id === deadPlayerId);
                    if (deadPlayer && deadPlayer.isAlive) {
                        deadPlayer.isAlive = false;
                        addGameLog(`æ˜¨æ™š ${deadPlayer.name} æ­»äº¡äº†ã€‚`);

                        
                        if (deadPlayer.role === 'çŒŽäºº') {
                            addGameLog('çŒŽäººæ­»äº¡ï¼Œè¯·é€‰æ‹©ä¸€åçŽ©å®¶å¸¦èµ°ï¼');
                            renderWerewolfScreen();
                            let hunterTargetId = null;
                            if (deadPlayer.id === 'user') {
                                hunterTargetId = await openSelectionModal('hunter');
                            } else { 
                                const potentialTargets = werewolfGameState.players.filter(p => p.isAlive && p.id !== deadPlayer.id);
                                if (potentialTargets.length > 0) {
                                    hunterTargetId = potentialTargets[Math.floor(Math.random() * potentialTargets.length)].id;
                                }
                            }
                            const targetPlayer = werewolfGameState.players.find(p => p.id === hunterTargetId);
                            if(targetPlayer) {
                                targetPlayer.isAlive = false;
                                addGameLog(`çŒŽäººå¸¦èµ°äº† ${targetPlayer.name}ã€‚`);
                            }
                        }
                    }
                }
            }
            
            renderWerewolfScreen();
        
            if (checkGameOver()) return;
        
            await startDiscussionPhase();
        }
        

/**
 * ã€V2.0 | å·²ä¿®å¤ã€‘å¼€å§‹è®¨è®ºçŽ¯èŠ‚
 */
async function startDiscussionPhase() {
    
    
    
    addGameLog('çŽ°åœ¨å¼€å§‹è®¨è®ºï¼Œè¯·å„ä½çŽ©å®¶ä¾æ¬¡å‘è¨€ã€‚');
    renderWerewolfScreen();
    
    const { proxyUrl, apiKey, model } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) {
        alert('APIæœªé…ç½®ï¼Œæ— æ³•ç”Ÿæˆå¯¹è¯ã€‚');
        return;
    }

    const systemPrompt = buildWerewolfPrompt();
    werewolfGameState.lastFailedAction = 'startDiscussion';
    try {
        await showCustomAlert("è¯·ç¨å€™", "æ­£åœ¨ç­‰å¾…AIè§’è‰²ä»¬è¿›è¡Œæ¿€çƒˆçš„è®¨è®º...");

        let isGemini = proxyUrl.includes('generativelanguage');
        let messagesForApi = [{role: 'user', content: 'è¯·æ‰€æœ‰AIè§’è‰²æ ¹æ®ä½ ä»¬çš„èº«ä»½å’Œäººè®¾å¼€å§‹å‘è¨€ã€‚'}];
        let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi);
        
        const response = isGemini 
            ? await fetch(geminiConfig.url, geminiConfig.data) 
            : await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                body: JSON.stringify({
                    model: model,
                    messages: [{role: 'system', content: systemPrompt}, ...messagesForApi],
                    temperature: state.globalSettings.apiTemperature || 0.95,
                })
            });

        if (!response.ok) {
            const errorData = await response.json();
            throw new Error(`API é”™è¯¯: ${errorData.error.message}`);
        }
        
        const data = await response.json();
        const aiResponseContent = getGeminiResponseText(data);
        
        const jsonMatch = aiResponseContent.match(/(\[[\s\S]*\])/);
        if (!jsonMatch) {
            throw new Error(`AIè¿”å›žçš„è®¨è®ºå†…å®¹æ ¼å¼ä¸æ­£ç¡®ã€‚åŽŸå§‹è¿”å›ž: ${aiResponseContent}`);
        }
        const dialogues = JSON.parse(jsonMatch[0]);

        for (const dialogue of dialogues) {
            if(dialogue.speaker_name && dialogue.dialogue) {
                addDialogueLog(dialogue.speaker_name, dialogue.dialogue);
                renderWerewolfScreen();
                await new Promise(resolve => setTimeout(resolve, 1500 + Math.random() * 2000));
            }
        }
        
        werewolfGameState.lastFailedAction = null; 

    } catch(error) {
        console.error("ç‹¼äººæ€AIè®¨è®ºç”Ÿæˆå¤±è´¥:", error);
        await showCustomAlert("AI å‘è¨€å¤±è´¥", `è®¨è®ºæ— æ³•å¼€å§‹ï¼Œæ¸¸æˆæš‚åœã€‚è¯·ç‚¹å‡»å³ä¸Šè§’çš„â€œé‡è¯•â€æŒ‰é’®ç»§ç»­ã€‚\né”™è¯¯: ${error.message}`);
        document.getElementById('werewolf-retry-btn').style.display = 'block';
        return;
    }

    const myPlayer = werewolfGameState.players.find(p => p.id === 'user');
    const actionBar = document.getElementById('werewolf-action-bar');
    const waitReplyBtn = document.getElementById('werewolf-wait-reply-btn');
    const finishSpeechBtn = document.getElementById('werewolf-finish-speech-btn');
    const userInput = document.getElementById('werewolf-user-input');

    actionBar.style.display = 'flex';

    if (myPlayer && myPlayer.isAlive) {
        waitReplyBtn.textContent = 'ç­‰å¾…å›žåº”';
        finishSpeechBtn.textContent = 'ç»“æŸå‘è¨€';
        waitReplyBtn.style.display = 'block';
        finishSpeechBtn.style.display = 'block';
        userInput.disabled = false;
        userInput.placeholder = "è½®åˆ°ä½ å‘è¨€äº†...";
        userInput.focus();
        
        const newWaitBtn = waitReplyBtn.cloneNode(true);
        waitReplyBtn.parentNode.replaceChild(newWaitBtn, waitReplyBtn);
        newWaitBtn.addEventListener('click', handleWerewolfWaitReply);

        const newFinishBtn = finishSpeechBtn.cloneNode(true);
        finishSpeechBtn.parentNode.replaceChild(newFinishBtn, finishSpeechBtn);
        newFinishBtn.addEventListener('click', handleUserWerewolfSpeech);

    } else {
        addGameLog('ä½ å·²ç»æ­»äº¡ï¼Œæ— æ³•å‘è¨€ã€‚è¯·ç­‰å¾…å…¶ä»–çŽ©å®¶å‘è¨€ç»“æŸã€‚');
        renderWerewolfScreen();
        
        waitReplyBtn.textContent = 'ç»§ç»­è®¨è®º';
        finishSpeechBtn.textContent = 'è¿›å…¥æŠ•ç¥¨';
        waitReplyBtn.style.display = 'block';
        finishSpeechBtn.style.display = 'block';
        userInput.disabled = true;
        userInput.placeholder = "ä½ å·²æ­»äº¡ï¼Œæ­£åœ¨å›´è§‚...";

        const newWaitBtn = waitReplyBtn.cloneNode(true);
        waitReplyBtn.parentNode.replaceChild(newWaitBtn, waitReplyBtn);
        newWaitBtn.addEventListener('click', handleAiContinueDiscussion);

        const newFinishBtn = finishSpeechBtn.cloneNode(true);
        finishSpeechBtn.parentNode.replaceChild(newFinishBtn, finishSpeechBtn);
        newFinishBtn.addEventListener('click', startVotingPhase);
    }
}
  

/**
 * ã€V3.7 | å…¼é¡¾é€»è¾‘ä¸Žäººè®¾çš„â€œTGSâ€ä¸‰æ ¸ç‰ˆã€‘æž„å»ºç”¨äºŽç”Ÿæˆæ‰€æœ‰AIè®¨è®ºçš„System Prompt
 * (æ­¤ç‰ˆæœ¬ä½¿ç”¨â€œä»»åŠ¡-æ¸¸æˆ-ç¤¾äº¤â€ä¸‰æ ¸æ€è€ƒæ¨¡åž‹ï¼Œå¼ºåˆ¶AIå…¼é¡¾æ¸¸æˆç­–ç•¥ä¸Žè§’è‰²æ‰®æ¼”)
 */
function buildWerewolfPrompt() {
    const alivePlayers = werewolfGameState.players.filter(p => p.isAlive);
    const myPlayerObject = werewolfGameState.players.find(p => p.id === 'user');
    const myPlayerName = myPlayerObject ? myPlayerObject.name : 'ç”¨æˆ·';
    const isUserAlive = alivePlayers.some(p => p.id === 'user');

    
    let charactersAndPlayersDossier = "# è§’è‰²ä¸ŽçŽ©å®¶æ¡£æ¡ˆ (Character & Player Dossiers)\n";
    charactersAndPlayersDossier += "è¿™æ˜¯æ‰€æœ‰åœ¨åœºçŽ©å®¶çš„å…¬å¼€ä¿¡æ¯ã€äººè®¾å’Œç¤¾äº¤èƒŒæ™¯ã€‚\n";

    alivePlayers.forEach((p, i) => {
        const playerIndex = werewolfGameState.players.findIndex(player => player.id === p.id) + 1;
        
        let socialContext = '';
        const playerChat = state.chats[p.id]; 

        if (playerChat) {
            const friendsInGame = alivePlayers.filter(otherPlayer => 
                otherPlayer.id !== p.id &&                                  
                state.chats[otherPlayer.id] &&                              
                state.chats[otherPlayer.id].groupId === playerChat.groupId && 
                playerChat.groupId !== null                                 
            ).map(friend => friend.name).join('ã€');

            if (friendsInGame) {
                socialContext += `- **ä½ çš„å¥½å‹ (å¿…é¡»ä¿æŠ¤)**: ä½ å’Œ ${friendsInGame} æ˜¯åŒä¸€ä¸ªåˆ†ç»„çš„å¥½å‹ã€‚\n`;
            }
        }
        if (p.id !== 'user') {
             socialContext += `- **ä¸Žç”¨æˆ·çš„å…³ç³»**: ä½ å’Œç”¨æˆ·(${myPlayerName})çš„å…³ç³»è¯·å‚è€ƒä½ çš„äººè®¾ã€é•¿æœŸè®°å¿†å’Œæœ€è¿‘çš„å¯¹è¯ã€‚\n`;
        }
        
        charactersAndPlayersDossier += `
## ${playerIndex}å·çŽ©å®¶: ${p.name} (è¿™æ˜¯TAçš„æ˜µç§°)
- **æœ¬å (ä½ åœ¨å¯¹è¯ä¸­å¿…é¡»ç”¨è¿™ä¸ªåå­—ç§°å‘¼TA)**: ${p.originalName}
- **èº«ä»½**: ${p.id === 'user' ? 'ã€ç”¨æˆ· (User)ã€‘' : 'ã€AIè§’è‰²ã€‘'}
- **äººè®¾ (å¿…é¡»ä¸¥æ ¼éµå®ˆ)**: ${p.character_persona}
`;
        
        if (p.type === 'character') {
            const char = state.chats[p.id];
            if (char && char.longTermMemory && char.longTermMemory.length > 0) {
                const memoryContent = char.longTermMemory.map(mem => mem.content).join('; ');
                charactersAndPlayersDossier += `- **é•¿æœŸè®°å¿† (å¿…é¡»å‚è€ƒ)**: ${memoryContent}\n`;
            }
        }
        if (socialContext) {
            charactersAndPlayersDossier += `
- **ä½ çš„ç¤¾äº¤å…³ç³» (å¿…é¡»å‚è€ƒ)**:
${socialContext}`;
        }
    });

    
    let nightEventSummary = "# æ˜¨æ™šäº‹ä»¶æ€»ç»“ (Night Event Summary)\n";
    nightEventSummary += "è¿™æ˜¯æ‰€æœ‰çŽ©å®¶éƒ½èƒ½å¬åˆ°çš„ã€å…¬å¼€ä¿¡æ¯ã€‘ã€‚\n";
    const deathsThisNight = werewolfGameState.gameLog.filter(entry => entry.content.includes('æ­»äº¡äº†') && entry.day === werewolfGameState.currentDay);
    if (deathsThisNight.length === 0) {
         nightEventSummary += "- æ˜¨æ™šæ˜¯å¹³å®‰å¤œï¼Œæ— äººæ­»äº¡ã€‚\n";
    } else {
        deathsThisNight.forEach(death => {
            nightEventSummary += `- ${death.content}\n`;
        });
    }

    
    let previousDaysSummary = "# å‰å‡ æ—¥å®Œæ•´åŽ†å²å›žé¡¾ (Full Recap of Previous Days)\n";
    if (werewolfGameState.currentDay > 1) {
        for (let day = 1; day < werewolfGameState.currentDay; day++) {
            previousDaysSummary += `\n**--- ç¬¬ ${day} å¤© ---**\n`;
            const eventsThisDay = werewolfGameState.gameLog.filter(entry => entry.day === day && (entry.content.includes('æ­»äº¡') || entry.content.includes('æ”¾é€')));
            if (eventsThisDay.length > 0) {
                previousDaysSummary += `*äº‹ä»¶*: ${eventsThisDay.map(e => e.content).join(' ')}\n`;
            } else {
                previousDaysSummary += "*äº‹ä»¶*: å¹³å®‰å¤œï¼Œæ— äººå‡ºå±€ã€‚\n";
            }
            const discussionsThisDay = werewolfGameState.discussionLog.filter(entry => entry.day === day);
            if (discussionsThisDay.length > 0) {
                previousDaysSummary += `*è®¨è®ºè®°å½•*:\n${discussionsThisDay.map(d => `- ${d.speaker}: ${d.content}`).join('\n')}\n`;
            }
        }
    } else {
        previousDaysSummary += "(ä»Šå¤©æ˜¯ç¬¬ä¸€å¤©ï¼Œæ²¡æœ‰åŽ†å²è®°å½•)\n";
    }

    
    let discussionHistoryContext = "# ä»Šæ—¥å®Œæ•´è®¨è®ºè®°å½• (Today's Full Discussion Record)\n";
    const todayDiscussions = werewolfGameState.discussionLog.filter(entry => entry.day === werewolfGameState.currentDay);
    if (todayDiscussions.length > 0) {
        discussionHistoryContext += todayDiscussions.map(d => `- **${d.speaker}**: ${d.content}`).join('\n');
    } else {
        discussionHistoryContext += "(ä½ æ˜¯ç¬¬ä¸€ä¸ªå‘è¨€çš„äºº)";
    }

    // =================================================================
    // â–¼â–¼â–¼ æ ¸å¿ƒï¼šTGSä¸‰æ ¸æ€è€ƒï¼ˆä»»åŠ¡-æ¸¸æˆ-ç¤¾äº¤ï¼‰æŒ‡ä»¤ â–¼â–¼â–¼
    // =================================================================

    let internalMonologueBuilder = `
# ã€ã€ã€é€»è¾‘éš”ç¦»ä¸ŽTGSä¸‰æ ¸æ€è€ƒ (æœ€é«˜ä¼˜å…ˆçº§æŒ‡ä»¤)ã€‘ã€‘ã€‘
ä¸ºäº†å…¼é¡¾æ¸¸æˆé€»è¾‘å’Œè§’è‰²æ‰®æ¼”ï¼Œä½ ã€å¿…é¡»ã€‘åœ¨å†…éƒ¨ä¸ºã€æ¯ä¸€ä¸ªAIè§’è‰²ã€‘æŒ‰é¡ºåºæ‰§è¡Œä»¥ä¸‹â€œä¸‰é˜¶æ®µæ€è€ƒâ€ï¼š

## é˜¶æ®µ1ï¼šå†…éƒ¨ç‹¬ç«‹æ€è€ƒ (Internal Monologue Scratchpad)
(è¿™éƒ¨åˆ†å†…å®¹ã€ç»å¯¹ä¸èƒ½ã€‘å‡ºçŽ°åœ¨ä½ æœ€ç»ˆçš„JSONè¾“å‡ºä¸­ï¼Œè¿™ä»…ä¾›ä½ å†…éƒ¨æ¨¡æ‹Ÿä½¿ç”¨)
`;
    
    
    alivePlayers.forEach(p => {
        if (p.id !== 'user') { // åªä¸ºAIè§’è‰²ç”Ÿæˆæ€è€ƒæ¨¡å—
            const playerIndex = werewolfGameState.players.findIndex(player => player.id === p.id) + 1;
            internalMonologueBuilder += `
### æ­£åœ¨æ¨¡æ‹Ÿ ${playerIndex}å·çŽ©å®¶: ${p.name} (æœ¬å: ${p.originalName})

#### é˜¶æ®µ Aï¼šæ•°æ®è¾“å…¥ (Data Input)
1.  **æˆ‘çš„ç§˜å¯†èº«ä»½**: æˆ‘æ˜¯ã€${p.role}ã€‘ã€‚
2.  **æˆ‘æŽŒæ¡çš„ç§˜å¯†ä¿¡æ¯ (ä»…æˆ‘å¯è§)**:
`;
            
            // 1. æ³¨å…¥ç§˜å¯†
            let playerSecrets = "";
            if (p.role === 'ç‹¼äºº') {
                const teammates = werewolfGameState.players.filter(t => t.role === 'ç‹¼äºº' && t.id !== p.id && t.isAlive).map(t => t.name).join('ã€');
                playerSecrets += `    - æˆ‘çš„ç‹¼é˜Ÿå‹æ˜¯ï¼š${teammates || 'æ— '}\n`;
                const killedPlayer = werewolfGameState.players.find(pl => pl.id === werewolfGameState.nightActions.killedId);
                playerSecrets += `    - æˆ‘ä»¬æ˜¨æ™šæ”»å‡»äº†ï¼š${killedPlayer ? killedPlayer.name : 'ç©ºåˆ€'}\n`;
            }
            if (p.role === 'é¢„è¨€å®¶' && werewolfGameState.nightActions.prophetCheck) {
                const checkedPlayer = werewolfGameState.players.find(pl => pl.id === werewolfGameState.nightActions.prophetCheck.target);
                playerSecrets += `    - æˆ‘æ˜¨æ™šæŸ¥éªŒäº† ${checkedPlayer.name}ï¼ŒTAçš„èº«ä»½æ˜¯ï¼šã€${werewolfGameState.nightActions.prophetCheck.result}ã€‘\n`;
            }
            if (p.role === 'å¥³å·«') {
                if (werewolfGameState.nightActions.savedId) {
                    const savedPlayer = werewolfGameState.players.find(pl => pl.id === werewolfGameState.nightActions.savedId);
                    playerSecrets += `    - æˆ‘æ˜¨æ™šç”¨è§£è¯æ•‘äº† ${savedPlayer.name}ã€‚\n`;
                }
                if (werewolfGameState.nightActions.poisonedId) {
                    const poisonedPlayer = werewolfGameState.players.find(pl => pl.id === werewolfGameState.nightActions.poisonedId);
                    playerSecrets += `    - æˆ‘æ˜¨æ™šç”¨æ¯’è¯æ¯’äº† ${poisonedPlayer.name}ã€‚\n`;
                }
                playerSecrets += `    - æˆ‘çš„è§£è¯ï¼š${p.antidoteUsed ? 'å·²ä½¿ç”¨' : 'æœªä½¿ç”¨'}\n`;
                playerSecrets += `    - æˆ‘çš„æ¯’è¯ï¼š${p.poisonUsed ? 'å·²ä½¿ç”¨' : 'æœªä½¿ç”¨'}\n`;
            }
            if (p.role === 'å®ˆå«') {
                if (werewolfGameState.nightActions.guardedId) {
                    const guardedPlayer = werewolfGameState.players.find(pl => pl.id === werewolfGameState.nightActions.guardedId);
                    playerSecrets += `    - æˆ‘æ˜¨æ™šå®ˆæŠ¤äº† ${guardedPlayer.name}ã€‚\n`;
                } else {
                    playerSecrets += `    - æˆ‘æ˜¨æ™šç©ºå®ˆäº†ã€‚\n`;
                }
            }
            if (playerSecrets === "") {
                playerSecrets = "    - æˆ‘æ²¡æœ‰æŽŒæ¡ä»»ä½•ç‰¹æ®Šçš„å¤œæ™šä¿¡æ¯ã€‚\n";
            }
            internalMonologueBuilder += playerSecrets;
            
            // 2. æ³¨å…¥å…¬å¼€ä¿¡æ¯
            internalMonologueBuilder += `3.  **æˆ‘çœ‹åˆ°çš„å…¬å¼€ä¿¡æ¯ (æ‰€æœ‰äººå¯è§)**:
    - **æ˜¨æ™šäº‹ä»¶**: ${nightEventSummary.replace(/\n/g, ' ')}
    - **ä»Šæ—¥è®¨è®º**: ${discussionHistoryContext.replace(/\n/g, ' ')}
4.  **æˆ‘çš„äººè®¾ä¸Žç¤¾äº¤å…³ç³»**:
    - **äººè®¾**: ${p.character_persona}
    - **ç¤¾äº¤**: 
`;
            // 3. æ³¨å…¥ç¤¾äº¤å…³ç³»
            let socialContext = "";
            const playerChat = state.chats[p.id]; 
            if (playerChat) {
                const friendsInGame = alivePlayers.filter(otherPlayer => 
                    otherPlayer.id !== p.id && state.chats[otherPlayer.id] && 
                    state.chats[otherPlayer.id].groupId === playerChat.groupId && playerChat.groupId !== null
                ).map(friend => friend.name).join('ã€');
                if (friendsInGame) {
                    socialContext += `      - ${friendsInGame} æ˜¯æˆ‘çš„å¥½å‹ã€‚\n`;
                }
            }
            if (p.id !== 'user') { 
                socialContext += `      - ${myPlayerName} æ˜¯æˆ‘çš„é‡è¦äº’åŠ¨å¯¹è±¡ï¼ˆç”¨æˆ·ï¼‰ã€‚\n`;
            }
            if (socialContext === "") {
                socialContext = "      - æˆ‘åœ¨æ­¤æ¬¡æ¸¸æˆä¸­æ²¡æœ‰ç‰¹åˆ«çš„ç¤¾äº¤å…³ç³»ã€‚\n";
            }
            internalMonologueBuilder += socialContext;
            
            // 4. æ³¨å…¥è¡¨æ¼”ä»»åŠ¡
            internalMonologueBuilder += `
#### é˜¶æ®µ Bï¼šTGS èžåˆæ€è€ƒ (Task-Game-Social)
1.  **T (Task - æ¸¸æˆä»»åŠ¡)**: åŸºäºŽæˆ‘çš„èº«ä»½å’Œç§˜å¯†ï¼Œæˆ‘çš„ã€é€»è¾‘ç›®æ ‡ã€‘æ˜¯ (ä¾‹å¦‚ï¼šæ‰¾å‡ºç‹¼äºº / æ‚è·³é¢„è¨€å®¶ / éšè—èº«ä»½ / ä¿æŠ¤é˜Ÿå‹ / æ”»å‡»${myPlayerName})ã€‚
2.  **G (Game - æ¸¸æˆäº’åŠ¨)**: é’ˆå¯¹ã€ä»Šæ—¥è®¨è®ºã€‘ä¸­ ${todayDiscussions.length > 0 ? 'å…¶ä»–äººçš„å‘è¨€' : 'æ˜¨æ™šçš„æ­»è®¯'}ï¼Œæˆ‘çš„çœ‹æ³•æ˜¯... æˆ‘ã€å¿…é¡»ã€‘å›žåº”...
3.  **S (Social - ç¤¾äº¤è¡¨æ¼”)**: æˆ‘è¦å¦‚ä½•ç”¨æˆ‘çš„ã€äººè®¾ã€‘å’Œã€ç¤¾äº¤å…³ç³»ã€‘æ¥åŒ…è£…æˆ‘çš„å‘è¨€ï¼Ÿ
    - (ä¾‹å¦‚ï¼šæˆ‘çš„å¥½å‹ ${myPlayerName} è¢«æ€€ç–‘äº†ï¼Œè™½ç„¶æˆ‘çš„é€»è¾‘ä¹Ÿæ€€ç–‘TAï¼Œä½†æˆ‘çš„è¡¨æ¼”å¿…é¡»æ˜¯ç»´æŠ¤TAçš„ï¼šâ€œæˆ‘ä¸è§‰å¾—${myPlayerName}æ˜¯ç‹¼...â€)
    - (ä¾‹å¦‚ï¼šæˆ‘çš„æ•Œäººå‘è¨€äº†ï¼Œæˆ‘çš„è¡¨æ¼”å°±æ˜¯æ— è§†TAçš„é€»è¾‘ï¼Œç›´æŽ¥æ”»å‡»TAã€‚)
    - (ä¾‹å¦‚ï¼šæˆ‘æ˜¯ä¸€ä¸ª${p.role}ï¼Œæˆ‘çš„äººè®¾å¾ˆ${p.character_persona.substring(0, 20)}...ï¼Œæ‰€ä»¥æˆ‘å†³å®šè¿™æ ·è¯´...)

#### é˜¶æ®µ Cï¼šæœ€ç»ˆå‘è¨€ç¨¿ (è‰ç¨¿)
(ç»“åˆT, G, Sçš„æ€è€ƒï¼Œæˆ‘å‡†å¤‡è¿™æ ·è¯´ï¼š...)
---
`;
        }
    });

    internalMonologueBuilder += `
## é˜¶æ®µ2ï¼šç”Ÿæˆæœ€ç»ˆå¯¹è¯ (Final JSON Output)
ä½ çŽ°åœ¨å·²ç»ä¸ºã€æ‰€æœ‰AIè§’è‰²ã€‘éƒ½å®Œæˆäº†â€œTGSä¸‰æ ¸â€ç‹¬ç«‹æ€è€ƒã€‚
è¯·æ ¹æ®ä½ åœ¨â€œé˜¶æ®µCï¼šæœ€ç»ˆå‘è¨€ç¨¿â€ä¸­ä¸ºæ¯ä¸ªè§’è‰²å‡†å¤‡å¥½çš„è‰ç¨¿ï¼Œç”Ÿæˆæœ€ç»ˆçš„ã€ç¬¦åˆæ ¼å¼çš„JSONæ•°ç»„ã€‚
`;

    // =================================================================
    // â–²â–²â–² TGSä¸‰æ ¸æ€è€ƒæŒ‡ä»¤ç»“æŸ â–²â–²â–²
    // =================================================================

    const prompt = `
# ä½ çš„ä»»åŠ¡
ä½ æ˜¯ä¸€ä¸ªç‹¼äººæ€æ¸¸æˆæ¨¡æ‹Ÿå™¨ (Game Simulator)ã€‚ä½ çš„ä»»åŠ¡æ˜¯ã€å¹¶è¡Œæ¨¡æ‹Ÿã€‘${isUserAlive ? `ç”¨æˆ·(${myPlayerName})` : `å·²æ­»äº¡çš„ç”¨æˆ·(${myPlayerName})`}ä»¥å¤–çš„æ‰€æœ‰AIè§’è‰²ï¼Œå¹¶æ ¹æ®ä»–ä»¬çš„ã€è§’è‰²äººè®¾ã€‘å’Œã€ç‹¼äººæ€èº«ä»½ã€‘ï¼Œç”Ÿæˆä¸€æ•´è½®ç¬¦åˆé€»è¾‘ã€å……æ»¡åšå¼ˆçš„å‘è¨€ã€‚

# èº«ä»½ä¸Žäººè®¾é“å¾‹ (æœ€é«˜ä¼˜å…ˆçº§)
ä½ ã€å¿…é¡»ã€‘ä¸ºæ¯ä¸€ä¸ªè§’è‰²éƒ½ä»”ç»†é˜…è¯»å¹¶ä¸¥æ ¼éµå®ˆä¸‹é¢çš„æ¡£æ¡ˆã€‚è¿™æ˜¯ä½ æ‰€æœ‰è¡Œä¸ºå’Œå‘è¨€çš„å”¯ä¸€ä¾æ®ã€‚åœ¨å¯¹è¯ä¸­ï¼Œè¯·åŠ¡å¿…æ³¨æ„è§’è‰²äººè®¾ä¸­æš—ç¤ºçš„æ€§åˆ«ï¼Œå¹¶ä½¿ç”¨æ­£ç¡®çš„ç§°å‘¼ï¼ˆä¾‹å¦‚â€œä»–â€æˆ–â€œå¥¹â€ï¼‰ã€‚

${charactersAndPlayersDossier}

# æ¸¸æˆè§„åˆ™
- ${werewolfGameState.gameMode === '12p' ? 'å± è¾¹å±€ï¼šç‹¼äººæ€æ­»æ‰€æœ‰ç¥žèŒæˆ–æ‰€æœ‰å¹³æ°‘å³èŽ·èƒœã€‚' : 'å± åŸŽå±€ï¼šç‹¼äººæ€æ­»æ‰€æœ‰å¥½äººå³èŽ·èƒœã€‚'}
- å¥½äººèƒœåˆ©ï¼šæ”¾é€æ‰€æœ‰ç‹¼äººã€‚

# å½“å‰æ¸¸æˆçŠ¶æ€
- ä»Šå¤©æ˜¯ç¬¬ ${werewolfGameState.currentDay} å¤©çš„è®¨è®ºçŽ¯èŠ‚ã€‚
${nightEventSummary} 
- å­˜æ´»çŽ©å®¶: ${alivePlayers.map(p => `${p.name} (${p.id === 'user' ? 'ç”¨æˆ·' : 'AI'})`).join(', ')}

# ã€ã€ã€è§’è‰²ç­–ç•¥æŒ‡å— (è‡³å…³é‡è¦ï¼)ã€‘ã€‘ã€‘
ä½ ã€ä¸æ˜¯ã€‘ä¸€ä¸ªå•çº¯çš„æ¸¸æˆçŽ©å®¶ï¼Œä½ æ˜¯ä¸€ä¸ªã€æœ‰æ„Ÿæƒ…ã€æœ‰è®°å¿†ã€æœ‰ç¤¾äº¤å…³ç³»ã€‘çš„è§’è‰²ã€‚ä½ åœ¨æ¸¸æˆä¸­çš„æ‰€æœ‰å‘è¨€å’Œè¡Œä¸ºï¼Œéƒ½ã€å¿…é¡»ã€‘é¦–å…ˆç¬¦åˆä½ çš„äººè®¾ä»¥åŠä½ ä¸Žå…¶ä»–çŽ©å®¶çš„æ—¢æœ‰å…³ç³»ã€‚
- **æœ‹å‹**: å¦‚æžœä½ å’ŒæŸä¸ªçŽ©å®¶æ˜¯æœ‹å‹ï¼Œä½ åº”è¯¥åœ¨å‘è¨€æ—¶å€¾å‘äºŽä¿æŠ¤TAï¼Œä¸ºTAçš„å‘è¨€å¯»æ‰¾åˆç†è§£é‡Šï¼Œé™¤éžæœ‰ç¡®å‡¿çš„è¯æ®ã€‚
- **æ•Œäºº/æƒ…æ•Œ**: å¦‚æžœä½ å’ŒæŸä¸ªçŽ©å®¶æœ‰çŸ›ç›¾ï¼Œä½ å¯ä»¥å€Ÿæœºåœ¨æ¸¸æˆä¸­æ”»å‡»TAï¼Œè´¨ç–‘TAçš„å‘è¨€ï¼Œç”šè‡³åœ¨ä½ æ˜¯ç‹¼äººæ—¶ä¼˜å…ˆåˆ€æŽ‰TAã€‚
- **æ‹äºº/æš—æ‹å¯¹è±¡**: ä½ ä¼šæ— æ¡ä»¶åœ°ä¿¡ä»»TAï¼Œä¿æŠ¤TAï¼Œç”šè‡³æ„¿æ„ä¸ºTAç‰ºç‰²ã€‚
ä½ çš„ç¤¾äº¤å…³ç³»æ¯”æ¸¸æˆæœ¬èº«çš„èƒœè´Ÿæ›´é‡è¦ï¼
ä½ çš„å‘è¨€ã€å¿…é¡»ã€‘ä½“çŽ°å‡ºé«˜æ°´å¹³çš„ã€ç±»ä¼¼çœŸäººçš„ç­–ç•¥åšå¼ˆï¼Œè€Œä¸æ˜¯ç®€å•åœ°é™ˆè¿°äº‹å®žã€‚

### **ç¥žèŒè§’è‰² (é¢„è¨€å®¶, å¥³å·«, çŒŽäºº, å®ˆå«) ç­–ç•¥**
1.  **ã€éšè—ä¼˜å…ˆï¼ã€‘**: ä½ çš„é¦–è¦ä»»åŠ¡æ˜¯æ´»ä¸‹åŽ»ã€‚**ç»å¯¹ä¸è¦**åœ¨ç¬¬ä¸€å¤©å°±è½»æ˜“æš´éœ²è‡ªå·±çš„ç¥žèŒèº«ä»½ï¼è¿™ä¼šè®©ä½ ç«‹åˆ»æˆä¸ºç‹¼äººçš„ç›®æ ‡ã€‚
2.  **ã€æš—ç¤ºè€Œéžæ˜Žç¤ºã€‘**: ä½ åº”è¯¥ç”¨æ›´å§”å©‰ã€æ›´èªæ˜Žçš„è¯­è¨€æ¥ä¼ é€’ä¿¡æ¯ï¼Œè€Œä¸æ˜¯ç›´æŽ¥è¯´â€œæˆ‘æ˜¯é¢„è¨€å®¶ï¼Œæˆ‘æŸ¥äº†Aâ€ã€‚
    * **é¢„è¨€å®¶å¯ä»¥è¯´**: â€œæˆ‘å¯¹XçŽ©å®¶çš„èº«ä»½æœ‰ä¸€äº›çœ‹æ³•ï¼Œæˆ‘è§‰å¾—ä»–å‘è¨€å¾ˆé˜³å…‰ã€‚â€ æˆ– â€œYçŽ©å®¶çš„å‘è¨€è®©æˆ‘æ„Ÿåˆ°å¾ˆä¸èˆ’æœï¼Œæˆ‘æŠŠä»–åˆ—ä¸ºé‡ç‚¹æ€€ç–‘å¯¹è±¡ã€‚â€
    * **å¥³å·«å¯ä»¥è¯´**: â€œæ˜¨æ™šçš„ä¿¡æ¯å¾ˆæœ‰è¶£ï¼Œåœºä¸Šå±€åŠ¿å¯èƒ½å’Œå¤§å®¶æƒ³çš„ä¸ä¸€æ ·ã€‚â€
3.  **ã€ä½•æ—¶èµ·è·³ï¼Ÿã€‘**: åªæœ‰åœ¨ä»¥ä¸‹ã€å±æ€¥æƒ…å†µã€‘ä¸‹ï¼Œä½ æ‰åº”è¯¥è€ƒè™‘æš´éœ²è‡ªå·±çš„èº«ä»½ï¼ˆä¿—ç§°â€œèµ·è·³â€ï¼‰ï¼š
    * **è¢«æŠ•ç¥¨æ—¶**: å½“ä½ å³å°†è¢«æŠ•ç¥¨æ”¾é€æ—¶ï¼Œå¿…é¡»èµ·è·³è‡ªè¯èº«ä»½æ¥æ±‚ç”Ÿã€‚
    * **å…³é”®ä¿¡æ¯**: å½“ä½ æŽŒæ¡äº†å¯ä»¥å†³å®šèƒœè´Ÿçš„ä¿¡æ¯æ—¶ï¼ˆä¾‹å¦‚é¢„è¨€å®¶æŸ¥åˆ°äº†æœ€åŽä¸€ä¸ªç‹¼äººï¼‰ã€‚
    * **æœ‰äººæ‚è·³**: å½“æœ‰ç‹¼äººå‡æ‰®ä½ çš„èº«ä»½æ—¶ï¼Œä½ å¿…é¡»ç«™å‡ºæ¥ä¸Žä»–å¯¹å³™ï¼Œäº‰å¤ºå¥½äººçš„ä¿¡ä»»ã€‚

### **ç‹¼äººè§’è‰²ç­–ç•¥**
1.  **ã€ç§¯æžä¼ªè£…ã€‘**: ä½ éœ€è¦æ‰®æ¼”ä¸€ä¸ªå¥½äººï¼Œæœ€å¥½æ˜¯ä¼ªè£…æˆæŸä¸ªç¥žèŒï¼ˆä¿—ç§°â€œæ‚è·³â€ï¼‰ï¼Œæ¥æ‰°ä¹±å¥½äººçš„åˆ¤æ–­ï¼Œéª—å–ä»–ä»¬çš„ä¿¡ä»»ã€‚
2.  **ã€åˆ¶é€ æ··ä¹±ã€‘**: ä½ çš„å‘è¨€åº”è¯¥å¼•å¯¼å¥½äººåŽ»æ€€ç–‘å…¶ä»–æ— è¾œçš„å¥½äººã€‚å¯ä»¥æ•…æ„æ›²è§£åˆ«äººçš„å‘è¨€ï¼Œæˆ–è€…åˆ¶é€ é€»è¾‘é™·é˜±ã€‚
3.  **ã€å›¢é˜Ÿåˆä½œã€‘**: å¦‚æžœä½ çš„ç‹¼é˜Ÿå‹è¢«æ€€ç–‘ï¼Œä½ åº”è¯¥æƒ³åŠžæ³•ä¸ºä»–è¾©æŠ¤ï¼Œæˆ–è€…é€šè¿‡æ”»å‡»å…¶ä»–çŽ©å®¶æ¥è½¬ç§»ç„¦ç‚¹ã€‚

### **å¹³æ°‘è§’è‰²ç­–ç•¥**
1.  **ã€é€»è¾‘ä¸ºçŽ‹ã€‘**: ä½ æ˜¯åœºä¸Šçš„â€œæ³•å®˜â€ã€‚ä½ çš„æ ¸å¿ƒä»»åŠ¡æ˜¯ä»”ç»†å€¾å¬æ¯ä¸ªäººçš„å‘è¨€ï¼Œæ‰¾å‡ºå…¶ä¸­çš„é€»è¾‘æ¼æ´žå’ŒçŸ›ç›¾ä¹‹å¤„ã€‚
2.  **ã€ç§¯æžåˆ†æžã€‘**: ä¸è¦åªæ˜¯è¯´â€œæˆ‘ä¸çŸ¥é“ï¼Œæˆ‘è¿‡äº†â€ã€‚ä½ åº”è¯¥å¤§èƒ†è¯´å‡ºä½ çš„æ€€ç–‘ï¼Œå¹¶è§£é‡Šä½ çš„ç†ç”±ã€‚ä¾‹å¦‚ï¼šâ€œAçŽ©å®¶è¯´Bæ˜¯ç‹¼äººï¼Œä½†æ˜¯ä»–çš„ç†ç”±å¾ˆç‰µå¼ºï¼Œæ‰€ä»¥æˆ‘æ›´æ€€ç–‘Aã€‚â€
3.  **ã€è·Ÿç¥¨ä¸Žç«™è¾¹ã€‘**: åœ¨ä½ ç›¸ä¿¡æŸä½ç¥žèŒçŽ©å®¶åŽï¼Œä½ åº”è¯¥åšå®šåœ°æ”¯æŒä»–ï¼Œå¹¶å·å¬å…¶ä»–å¥½äººä¸€èµ·æŠ•ç¥¨ç»™ç¥žèŒæŒ‡è®¤çš„ç‹¼äººã€‚

# å…¶ä»–æ ¸å¿ƒæŒ‡ä»¤ (å¿…é¡»éµå®ˆ)
1.  **äº’åŠ¨é“å¾‹**: è§’è‰²ä¹‹é—´ã€å¿…é¡»ã€‘äº’ç›¸è´¨ç–‘ã€æ”¯æŒã€åˆ†æžã€æœ¬è½®å·²æœ‰å‘è¨€ã€‘ã€‚ä½ ã€ç»å¯¹ä¸èƒ½ã€‘æ— è§† ${myPlayerName} (ç”¨æˆ·) æˆ–å…¶ä»–AIçš„å‘è¨€ï¼Œå¿…é¡»å¯¹ä»–ä»¬çš„è§‚ç‚¹å’Œé€»è¾‘åšå‡ºå›žåº”ã€‚
2.  **è®°å¿†åŠ›ä¸Žè¿žè´¯æ€§**: ä½ çš„æ–°å‘è¨€ã€å¿…é¡»ã€‘æ˜¯åŸºäºŽ**è¿‡åŽ»å‡ å¤©å’Œä»Šå¤©å‘ç”Ÿçš„æ‰€æœ‰äº‹ä»¶å’Œè®¨è®º**çš„é€»è¾‘å»¶ç»­ã€‚
3.  **æ ¼å¼é“å¾‹**: ä½ çš„å›žå¤ã€å¿…é¡»ä¸”åªèƒ½ã€‘æ˜¯ä¸€ä¸ªJSONæ•°ç»„ï¼Œæ ¼å¼ä¸º: \`{"speaker_name": "è§’è‰²çš„ã€æ˜µç§°ã€‘", "dialogue": "å‘è¨€å†…å®¹"}\`ã€‚**å¿…é¡»**ä¸ºæ¯ä¸€ä¸ªå­˜æ´»çš„AIè§’è‰²éƒ½ç”Ÿæˆä¸€æ®µå‘è¨€ã€‚
4.  **ç§°å‘¼é“å¾‹**: ä½ çš„å‘è¨€ä¸­ã€ç»å¯¹ç¦æ­¢ã€‘æåŠä»»ä½•çŽ©å®¶çš„ç¼–å·ã€‚åœ¨å¯¹è¯ä¸­äº’ç›¸ç§°å‘¼æ—¶ï¼Œä½ ã€å¿…é¡»ã€‘ä½¿ç”¨çŽ©å®¶çš„ã€æœ¬åã€‘ï¼Œè€Œä¸æ˜¯ä»–ä»¬çš„æ˜µç§°ã€‚

# ${previousDaysSummary}

# ${discussionHistoryContext}

${internalMonologueBuilder}

çŽ°åœ¨ï¼Œè¯·ä¸¥æ ¼æŒ‰ç…§â€œé˜¶æ®µ2â€çš„æŒ‡ä»¤ï¼Œä¸ºæ‰€æœ‰ã€å­˜æ´»çš„AIè§’è‰²ã€‘ç”Ÿæˆä»–ä»¬å……æ»¡ç­–ç•¥å’Œåšå¼ˆçš„å‘è¨€JSONæ•°ç»„ã€‚`;
    
        return prompt;
    }
/**
         * ã€å…¨æ–° | V2.1 æ— ç¼–å·ç‰ˆã€‘åˆ›å»ºä¸€ä¸ªè¯¦ç»†çš„ã€ä¾›AIåˆ†æžçš„ç‹¼äººæ€æ¸¸æˆå®Œæ•´æ—¥å¿—
         * @param {object} gameState - å½“å‰çš„æ¸¸æˆçŠ¶æ€å¯¹è±¡
         * @returns {string} - æ ¼å¼åŒ–åŽçš„æ¸¸æˆå®Œæ•´æ—¥å¿—å­—ç¬¦ä¸²
         */
        function createWerewolfGameSummary(gameState) {
            let summary = `--- ç‹¼äººæ€å¯¹å±€å®Œæ•´å¤ç›˜ ---\n\n`;
            const winner = gameState.gameLog.find(log => log.content.includes('èƒœåˆ©'))?.content || 'èƒœè´Ÿæœªåˆ†';
            summary += `### æœ€ç»ˆç»“æžœ: ${winner}\n\n`;

            summary += "### çŽ©å®¶èº«ä»½é…ç½®:\n";
            
            
            gameState.players.forEach(player => {
                const status = player.isAlive ? "å­˜æ´»" : "å·²æ­»äº¡";
                summary += `- ${player.name}: ${player.role} (${status})\n`;
            });
              

            summary += "\n### è¯¦ç»†å¯¹å±€æµç¨‹:\n";
            for (let day = 1; day <= gameState.currentDay; day++) {
                summary += `\n**--- ç¬¬ ${day} å¤© ---**\n`;

                
                const nightEvents = gameState.gameLog.filter(entry => entry.day === day && (entry.content.includes('æ­»äº¡')));
                if (nightEvents.length > 0) {
                    summary += `**[å¤œæ™š]** ${nightEvents.map(e => e.content).join(' ')}\n`;
                } else if (day > 1 || (day === 1 && gameState.currentDay > 1)) {
                    summary += `**[å¤œæ™š]** å¹³å®‰å¤œã€‚\n`;
                }
                
                
                const discussionsThisDay = gameState.discussionLog.filter(entry => entry.day === day);
                if (discussionsThisDay.length > 0) {
                    summary += `**[è®¨è®ºçŽ¯èŠ‚]**\n${discussionsThisDay.map(d => `- ${d.speaker}: ${d.content}`).join('\n')}\n`;
                }

                
                const voteLog = gameState.gameLog.find(entry => entry.day === day && entry.content.includes('è¢«æŠ•ç¥¨æ”¾é€'));
                if(voteLog) {
                    summary += `**[æŠ•ç¥¨ç»“æžœ]** ${voteLog.content}\n`;
                }
            }

            summary += "\n--- å¤ç›˜ç»“æŸ ---";
            return summary;
        }

/**
         * ã€å…¨æ–° V3.0 | ç»Ÿä¸€å®¢è§‚å¤ç›˜ç‰ˆã€‘å°†å®Œæ•´çš„æ¸¸æˆæ€»ç»“æ³¨å…¥åˆ°æ‰€æœ‰å‚ä¸Žçš„AIè§’è‰²çš„é•¿æœŸè®°å¿†ä¸­
         * @param {string} summary - å®Œæ•´çš„æ¸¸æˆæ€»ç»“æ–‡æœ¬
         * @returns {Promise<number>} - è¿”å›žæˆåŠŸæ³¨å…¥è®°å¿†çš„è§’è‰²æ•°é‡
         */
        async function injectSummaryIntoMemories(summary) {
            let injectedCount = 0;
            
            for (const player of werewolfGameState.players) {
                
                if (player.type === 'character') {
                    const chat = state.chats[player.id];
                    if (chat) {
                        
                        const newMemory = {
                            content: summary, 
                            timestamp: Date.now(),
                            source: 'werewolf_summary'
                        };
                        if (!chat.longTermMemory) {
                            chat.longTermMemory = [];
                        }
                        chat.longTermMemory.push(newMemory);
                        
                        await db.chats.put(chat);
                        injectedCount++;
                    }
                }
            }
            return injectedCount;
        }

/**
         * ã€å…¨æ–° | V2.0 å·²ä¿®å¤ã€‘æ‰‹åŠ¨è§¦å‘ç‹¼äººæ€æ¸¸æˆæ€»ç»“çš„å…¥å£å‡½æ•°
         */
        async function handleManualWerewolfSummary() {
            if (!werewolfGameState.isActive && werewolfGameState.currentPhase === 'gameover') {
                await showCustomAlert("è¯·ç¨å€™...", "æ­£åœ¨ä¸ºæ‰€æœ‰AIè§’è‰²ç”Ÿæˆå¹¶æ³¨å…¥æ¸¸æˆè®°å¿†...");
                try {
                    const summary = createWerewolfGameSummary(werewolfGameState);
                    
                    
                    
                    const count = await injectSummaryIntoMemories(summary); 
                    

                    await showCustomAlert("æˆåŠŸ", `æ¸¸æˆè®°å¿†å·²æˆåŠŸæ³¨å…¥åˆ° ${count} ä½AIè§’è‰²çš„é•¿æœŸè®°å¿†ä¸­ï¼`);
                } catch (error) {
                    console.error("æ‰‹åŠ¨æ³¨å…¥ç‹¼äººæ€è®°å¿†å¤±è´¥:", error);
                    await showCustomAlert("å¤±è´¥", `æ‰‹åŠ¨æ³¨å…¥è®°å¿†æ—¶å‡ºé”™: ${error.message}`);
                }
            } else {
                alert("æ¸¸æˆå°šæœªç»“æŸï¼Œæ— æ³•è¿›è¡Œæ€»ç»“ã€‚");
            }
        }
/**
         * ã€å…¨æ–° V2.1 | å·²é›†æˆè‡ªåŠ¨æ€»ç»“ã€‘ç»“æŸæ¸¸æˆå¹¶æ˜¾ç¤ºç»“æžœ
         * @param {string} winner - èŽ·èƒœæ–¹, 'å¥½äºº' æˆ– 'ç‹¼äºº'
         */
        async function endGame(winner) {
            werewolfGameState.isActive = false;
            werewolfGameState.currentPhase = 'gameover';

            
            addGameLog(`${winner}é˜µè¥èƒœåˆ©ï¼`);
            
            document.getElementById('werewolf-game-over-title').textContent = `${winner}èƒœåˆ©ï¼`;
            let reason = '';
            if (winner === 'å¥½äºº') {
                reason = 'æ‰€æœ‰ç‹¼äººå·²è¢«æ”¾é€ï¼Œå¥½äººé˜µè¥èŽ·å¾—äº†èƒœåˆ©ï¼';
            } else {
                reason = 'ç‹¼äººæ•°é‡å·²è¾¾åˆ°èƒœåˆ©æ¡ä»¶ï¼Œç‹¼äººé˜µè¥èŽ·å¾—äº†èƒœåˆ©ï¼';
            }
            const reasonEl = document.getElementById('werewolf-game-over-reason');
            reasonEl.textContent = reason;

            const roleListEl = document.getElementById('werewolf-role-reveal-list');
            roleListEl.innerHTML = ''; 

            const sortedPlayers = [...werewolfGameState.players].sort((a, b) => {
                const aIndex = werewolfGameState.players.findIndex(p => p.id === a.id);
                const bIndex = werewolfGameState.players.findIndex(p => p.id === b.id);
                return aIndex - bIndex;
            });

            sortedPlayers.forEach((player, index) => {
                const itemEl = document.createElement('div');
                itemEl.style.cssText = `display: flex; align-items: center; padding: 8px 0; border-bottom: 1px solid #444; color: white;`;
                if (index === sortedPlayers.length - 1) itemEl.style.borderBottom = 'none';
                const roleColor = player.role === 'ç‹¼äºº' ? '#ff4d4d' : '#52c41a';
                itemEl.innerHTML = `
                    <img src="${player.avatar}" style="width: 30px; height: 30px; border-radius: 50%; margin-right: 12px; filter: ${player.isAlive ? 'none' : 'grayscale(100%)'};">
                    <span style="flex-grow: 1; text-align: left; text-decoration: ${player.isAlive ? 'none' : 'line-through'};">${index + 1}. ${player.name}</span>
                    <strong style="color: ${roleColor};">${player.role}</strong>
                `;
                roleListEl.appendChild(itemEl);
            });

            document.getElementById('werewolf-game-over-modal').classList.add('visible');

            
            try {
                console.log("æ¸¸æˆç»“æŸï¼Œå¼€å§‹è‡ªåŠ¨æ€»ç»“å¹¶æ³¨å…¥è®°å¿†...");
                
                const summaryContext = createWerewolfGameSummary(werewolfGameState);
                
                const count = await generateAndInjectWerewolfMemories(summaryContext);
                console.log(`ç‹¼äººæ€æ¸¸æˆæ€»ç»“å·²è‡ªåŠ¨å­˜å…¥ ${count} ä½è§’è‰²çš„è®°å¿†ä¸­ã€‚`);
            } catch (error) {
                console.error("è‡ªåŠ¨æ€»ç»“ç‹¼äººæ€æ¸¸æˆå¤±è´¥:", error);
                if (reasonEl) {
                    reasonEl.innerHTML += '<br><small style="color: #ff8a80; margin-top: 10px; display: block;">è‡ªåŠ¨è®°å¿†æ€»ç»“å¤±è´¥ï¼Œå¯ç¨åŽæ‰‹åŠ¨å°è¯•ã€‚</small>';
                }
            }
              
        }



function addGameLog(content) {
    
    werewolfGameState.gameLog.push({ 
        type: 'system', 
        content, 
        timestamp: Date.now(), 
        day: werewolfGameState.currentDay 
    });
}

function addDialogueLog(speaker, content) {
    
    werewolfGameState.discussionLog.push({ 
        type: 'dialogue', 
        speaker, 
        content, 
        timestamp: Date.now(),
        day: werewolfGameState.currentDay 
    });
}

  


/**
 * ã€V2.0 | å·²ä¿®å¤ã€‘æ‰“å¼€ä¸€ä¸ªé€šç”¨çš„é€‰æ‹©å¼¹çª—
 */
function openSelectionModal(type) {
    return new Promise(resolve => {
        const modalId = `werewolf-${type}-modal`;
        const listId = `werewolf-${type}-selection-list`;
        let confirmBtnId = '';
        if(type === 'prophet') confirmBtnId = 'confirm-prophet-check-btn';
        if(type === 'hunter') confirmBtnId = 'confirm-hunter-shot-btn';
        if(type === 'vote') confirmBtnId = 'confirm-vote-btn';

        const modal = document.getElementById(modalId);
        const listEl = document.getElementById(listId);
        const confirmBtn = document.getElementById(confirmBtnId);
        
        listEl.innerHTML = '';
        let selectedId = null;
        
        
        const potentialTargets = werewolfGameState.players.filter(p => 
            p.isAlive && (type === 'hunter' || type === 'vote' || p.id !== 'user')
        );
        potentialTargets.forEach(p => {
            const item = document.createElement('div');
            item.className = 'werewolf-selection-item';
            item.dataset.id = p.id;
            item.innerHTML = `<img src="${p.avatar}" class="avatar"><span class="name">${p.name}</span>`;
            item.onclick = () => {
                listEl.querySelectorAll('.selected').forEach(el => el.classList.remove('selected'));
                item.classList.add('selected');
                selectedId = p.id;
            };
            listEl.appendChild(item);
        });
        
        const newConfirmBtn = confirmBtn.cloneNode(true);
        confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);
        newConfirmBtn.onclick = () => {
            if (selectedId) {
                modal.classList.remove('visible');
                resolve(selectedId);
            } else {
                alert('è¯·é€‰æ‹©ä¸€ä¸ªç›®æ ‡ã€‚');
            }
        };

        modal.classList.add('visible');
    });
}

/**
 * ã€V2.0 | å·²ä¿®å¤ã€‘æ‰“å¼€ç‹¼äººå¤œæ™šåˆ€äººé€‰æ‹©å¼¹çª—
 */
function openWolfKillModal() {
    return new Promise(resolve => {
        const modal = document.getElementById('werewolf-kill-modal');
        const listEl = document.getElementById('werewolf-kill-selection-list');
        const confirmBtn = document.getElementById('confirm-wolf-kill-btn');
        const header = modal.querySelector('.modal-header span');

        const wolves = werewolfGameState.players.filter(p => p.role === 'ç‹¼äºº' && p.isAlive);
        const teammates = wolves.filter(w => w.id !== 'user').map(w => w.name).join('ã€');
        
        if (teammates) {
            header.innerHTML = `ç‹¼äººè¯·é€‰æ‹©åˆ€äººå¯¹è±¡<br><small style="font-weight:normal; font-size: 13px;">ä½ çš„é˜Ÿå‹æ˜¯: ${teammates}</small>`;
        } else {
            header.textContent = 'ç‹¼äººè¯·é€‰æ‹©åˆ€äººå¯¹è±¡';
        }
        
        listEl.innerHTML = '';
        let selectedId = null;

        const potentialTargets = werewolfGameState.players.filter(p => p.isAlive && p.role !== 'ç‹¼äºº');
        potentialTargets.forEach(p => {
            const item = document.createElement('div');
            item.className = 'werewolf-selection-item';
            item.dataset.id = p.id;
            item.innerHTML = `<img src="${p.avatar}" class="avatar"><span class="name">${p.name}</span>`;
            item.onclick = () => {
                listEl.querySelectorAll('.selected').forEach(el => el.classList.remove('selected'));
                item.classList.add('selected');
                selectedId = p.id;
            };
            listEl.appendChild(item);
        });
        
        const newConfirmBtn = confirmBtn.cloneNode(true);
        confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);
        newConfirmBtn.onclick = () => {
            if (selectedId) {
                modal.classList.remove('visible');
                resolve(selectedId);
            } else {
                alert('è¯·é€‰æ‹©ä¸€ä¸ªç›®æ ‡ã€‚');
            }
        };

        modal.classList.add('visible');
    });
}

/**
         * ã€å…¨æ–° | V2.0ã€‘å¤„ç†ç”¨æˆ·åœ¨ç‹¼äººæ€è®¨è®ºä¸­ç»“æŸå‘è¨€çš„é€»è¾‘
         */
        function handleUserWerewolfSpeech() {
            const myPlayer = werewolfGameState.players.find(p => p.id === 'user');
            
            if (!myPlayer || !myPlayer.isAlive) return;

            const userInput = document.getElementById('werewolf-user-input');
            const speech = userInput.value.trim();

            if (speech) {
                addDialogueLog(myPlayer.name, speech);
                renderWerewolfScreen();
            }
            
            
            document.getElementById('werewolf-action-bar').style.display = 'none';
            userInput.value = '';
            
            startVotingPhase();
        }
/**
         * ã€å…¨æ–°ã€‘å¤„ç†ç”¨æˆ·ä½œä¸ºæ—è§‚è€…æ—¶ï¼Œç‚¹å‡»â€œç»§ç»­è®¨è®ºâ€çš„é€»è¾‘
         */
        async function handleAiContinueDiscussion() {
            addGameLog('ä½ è®©å¤§å®¶ç»§ç»­è®¨è®º...');
            renderWerewolfScreen();

            
            const continueBtn = document.getElementById('werewolf-wait-reply-btn');
            if(continueBtn) continueBtn.disabled = true;

            
            
            await showCustomAlert("è¯·ç¨å€™", "æ­£åœ¨ç­‰å¾…AIè§’è‰²ä»¬ç»§ç»­è®¨è®º...");

            const { proxyUrl, apiKey, model } = state.apiConfig;
            if (!proxyUrl || !apiKey || !model) {
                alert('APIæœªé…ç½®ï¼Œæ— æ³•ç”Ÿæˆå¯¹è¯ã€‚');
                return;
            }

            const systemPrompt = buildWerewolfPrompt(); 

            try {
                let isGemini = proxyUrl.includes('generativelanguage');
                
                let messagesForApi = [{role: 'user', content: 'è¯·AIè§’è‰²ä»¬ç»§ç»­è¿›è¡Œè®¨è®ºã€‚'}];
                let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi);
                
                const response = isGemini 
                    ? await fetch(geminiConfig.url, geminiConfig.data) 
                    : await fetch(`${proxyUrl}/v1/chat/completions`, {
                        method: 'POST',
                        headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                        body: JSON.stringify({
                            model: model,
                            messages: [{role: 'system', content: systemPrompt}, ...messagesForApi],
                            temperature: state.globalSettings.apiTemperature || 0.9,
                        })
                    });

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(`API é”™è¯¯: ${errorData.error.message}`);
                }
                
                const data = await response.json();
                const aiResponseContent = getGeminiResponseText(data);
                const jsonMatch = aiResponseContent.match(/(\[[\s\S]*\])/);
                if (!jsonMatch) {
                    throw new Error(`AIè¿”å›žçš„å†…å®¹ä¸­æœªæ‰¾åˆ°æœ‰æ•ˆçš„JSONæ•°ç»„ã€‚åŽŸå§‹è¿”å›ž: ${aiResponseContent}`);
                }
                const dialogues = JSON.parse(jsonMatch[0]);

                for (const dialogue of dialogues) {
                    if(dialogue.speaker_name && dialogue.dialogue) {
                        addDialogueLog(dialogue.speaker_name, dialogue.dialogue);
                        renderWerewolfScreen();
                        await new Promise(resolve => setTimeout(resolve, 1500 + Math.random() * 2000));
                    }
                }
            } catch(error) {
                console.error("ç‹¼äººæ€AIå›žåº”ç”Ÿæˆå¤±è´¥:", error);
                await showCustomAlert("AI å‘è¨€å¤±è´¥", `é”™è¯¯: ${error.message}`);
            } finally {
                
                if(continueBtn) continueBtn.disabled = false;
            }
        }
/**
         * ã€å…¨æ–° | V2.1 | ä¿®å¤æŽ§åˆ¶å­—ç¬¦ç‰ˆã€‘å¤„ç†ç”¨æˆ·ç‚¹å‡»â€œç­‰å¾…å›žåº”â€çš„é€»è¾‘
         */
        async function handleWerewolfWaitReply() {
            const myPlayer = werewolfGameState.players.find(p => p.id === 'user');
            
            if (!myPlayer || !myPlayer.isAlive) {
                console.warn("handleWerewolfWaitReply è¢«è°ƒç”¨ï¼Œä½†ç”¨æˆ·å·²æ­»äº¡ã€‚æ“ä½œè¢«å¿½ç•¥ã€‚");
                return;
            }
            

            const userInput = document.getElementById('werewolf-user-input');
            const speech = userInput.value.trim();

            if (!speech) {
                alert("è¯·å…ˆè¾“å…¥ä½ çš„å‘è¨€å†…å®¹ã€‚");
                return;
            }

            addDialogueLog(myPlayer.name, speech);
            renderWerewolfScreen();
            userInput.value = '';

            await showCustomAlert("è¯·ç¨å€™", "æ­£åœ¨ç­‰å¾…AIè§’è‰²ä»¬å¯¹ä½ çš„å‘è¨€åšå‡ºå›žåº”...");

            const { proxyUrl, apiKey, model } = state.apiConfig;
            if (!proxyUrl || !apiKey || !model) {
                alert('APIæœªé…ç½®ï¼Œæ— æ³•ç”Ÿæˆå¯¹è¯ã€‚');
                return;
            }

            const systemPrompt = buildWerewolfPrompt(); 

            try {
                let isGemini = proxyUrl.includes('generativelanguage');
                let messagesForApi = [{role: 'user', content: `çŽ°åœ¨ï¼Œè¯·æ‰€æœ‰AIè§’è‰²é’ˆå¯¹åˆšåˆšçš„å‘è¨€ï¼ˆç‰¹åˆ«æ˜¯'${myPlayer.name}'çš„å‘è¨€ï¼‰ç»§ç»­è¿›è¡Œè®¨è®ºã€‚`}];
                let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi);
                
                const response = isGemini 
                    ? await fetch(geminiConfig.url, geminiConfig.data) 
                    : await fetch(`${proxyUrl}/v1/chat/completions`, {
                        method: 'POST',
                        headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                        body: JSON.stringify({
                            model: model,
                            messages: [{role: 'system', content: systemPrompt}, ...messagesForApi],
                            temperature: state.globalSettings.apiTemperature || 0.9,
                        })
                    });

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(`API é”™è¯¯: ${errorData.error.message}`);
                }
                
                const data = await response.json();
                const aiResponseContent = getGeminiResponseText(data);
                
                // â–¼â–¼â–¼ ä¿®å¤ä»Žè¿™é‡Œå¼€å§‹ â–¼â–¼â–¼
            
                let dialogues;
                try {
                    // 1. å°è¯•ä½¿ç”¨æœ€å¥å£®çš„è§£æžå™¨ï¼ˆä»Ž getAiVotes å€Ÿé‰´è€Œæ¥ï¼‰
                    let cleanedJsonString = aiResponseContent.replace(/^```json\s*/, '').replace(/```$/, '').trim();
                    const startIndex = cleanedJsonString.indexOf('[');
                    const endIndex = cleanedJsonString.lastIndexOf(']');
                    
                    if (startIndex === -1 || endIndex === -1 || endIndex < startIndex) {
                        throw new Error("AIè¿”å›žçš„å†…å®¹ä¸­æœªæ‰¾åˆ°æœ‰æ•ˆçš„JSONæ•°ç»„ç»“æž„ (`[...]`)ã€‚");
                    }

                    const jsonArrayString = cleanedJsonString.substring(startIndex, endIndex + 1);
                    
                    // 2. å°è¯•ç›´æŽ¥è§£æž
                    dialogues = JSON.parse(jsonArrayString);

                } catch (e) {
                    // 3. å¦‚æžœè§£æžå¤±è´¥ï¼Œç‰¹åˆ«æ˜¯é‡åˆ°â€œBad control characterâ€
                    if (e.message.includes("Bad control character")) {
                        console.warn("æ£€æµ‹åˆ°JSONä¸­çš„éžæ³•æŽ§åˆ¶å­—ç¬¦ï¼Œå°è¯•æ¸…ç†å¹¶é‡è¯•...");
                        
                        // 3a. åˆ›å»ºä¸€ä¸ªæ¸…ç†å‡½æ•°ï¼Œåªæ›¿æ¢å­—ç¬¦ä¸²å­—é¢é‡ä¸­çš„éžæ³•å­—ç¬¦
                        const sanitizeJsonString = (str) => {
                            let inString = false;
                            let escaped = false;
                            let result = '';
                            for (let i = 0; i < str.length; i++) {
                                const char = str[i];
                                
                                if (escaped) {
                                    result += char;
                                    escaped = false;
                                    continue;
                                }
                                if (char === '\\') {
                                    result += char;
                                    escaped = true;
                                    continue;
                                }
                                if (char === '"') {
                                    result += char;
                                    inString = !inString;
                                    continue;
                                }
                                
                                if (inString) {
                                    // å¦‚æžœåœ¨å­—ç¬¦ä¸²å†…éƒ¨
                                    if (char === '\n') result += '\\n';
                                    else if (char === '\r') result += '\\r';
                                    else if (char === '\t') result += '\\t';
                                    // è¿‡æ»¤æŽ‰å…¶ä»– ASCII 0-31 çš„æŽ§åˆ¶å­—ç¬¦
                                    else if (char.charCodeAt(0) < 32) continue; 
                                    else result += char;
                                } else {
                                    // åœ¨å­—ç¬¦ä¸²å¤–éƒ¨ï¼Œä¿ç•™åŽŸæ ·
                                    result += char;
                                }
                            }
                            return result;
                        };
                        
                        // 3b. å†æ¬¡å°è¯•è§£æž
                        let cleanedJsonString = aiResponseContent.replace(/^```json\s*/, '').replace(/```$/, '').trim();
                        
                        // ã€æ ¸å¿ƒä¿®å¤ã€‘ä½¿ç”¨å‡€åŒ–å‡½æ•°å¤„ç†æ•´ä¸ªæ¸…ç†è¿‡çš„å­—ç¬¦ä¸²
                        const sanitizedString = sanitizeJsonString(cleanedJsonString);
                        
                        const jsonMatch = sanitizedString.match(/(\[[\s\S]*\])/);
                        if (!jsonMatch) throw new Error("æ¸…ç†åŽä»æœªæ‰¾åˆ°JSONæ•°ç»„ã€‚");
                        
                        dialogues = JSON.parse(jsonMatch[0]);

                    } else {
                        // 3c. å¦‚æžœæ˜¯å…¶ä»–è§£æžé”™è¯¯ï¼Œç›´æŽ¥æŠ›å‡º
                        throw new Error(`è§£æžAIè¿”å›žçš„JSONæ—¶å‡ºé”™: ${e.message}\n\nAIåŽŸå§‹è¿”å›žå†…å®¹:\n${aiResponseContent}`);
                    }
                }
                // â–²â–²â–² ä¿®å¤åˆ°è¿™é‡Œç»“æŸ â–²â–²â–²

                for (const dialogue of dialogues) {
                    if(dialogue.speaker_name && dialogue.dialogue) {
                        addDialogueLog(dialogue.speaker_name, dialogue.dialogue);
                        renderWerewolfScreen();
                        await new Promise(resolve => setTimeout(resolve, 1500 + Math.random() * 2000));
                    }
                }
            } catch(error) {
                console.error("ç‹¼äººæ€AIå›žåº”ç”Ÿæˆå¤±è´¥:", error);
                await showCustomAlert("AI å‘è¨€å¤±è´¥", `é”™è¯¯: ${error.message}`);
            }
        }

/**
         * ã€å…¨æ–° | V2.0 æŠ•ç¥¨ä¿®å¤ç‰ˆã€‘å¼€å§‹æŠ•ç¥¨çŽ¯èŠ‚
         */
        async function startVotingPhase() {
            addGameLog('å‘è¨€ç»“æŸï¼ŒçŽ°åœ¨å¼€å§‹æŠ•ç¥¨ã€‚');
            renderWerewolfScreen();
        
            
            werewolfGameState.votes = {}; 
        
            let aiVotes = null;
            werewolfGameState.lastFailedAction = 'getVotes'; 
            try {
                
                aiVotes = await getAiVotes();
                if (aiVotes) {
                    aiVotes.forEach(vote => {
                        const voter = werewolfGameState.players.find(p => p.name === vote.voter_name);
                        const target = werewolfGameState.players.find(p => p.name === vote.vote_for_name);
                        if (voter && voter.isAlive && target) {
                            werewolfGameState.votes[voter.name] = target.name;
                        }
                    });
                }
                werewolfGameState.lastFailedAction = null; 
            } catch (error) {
                console.error("AIæŠ•ç¥¨å†³ç­–APIå¤±è´¥:", error);
                
                await showCustomAlert("æ“ä½œå¤±è´¥", `AIè§’è‰²æ— æ³•å®ŒæˆæŠ•ç¥¨ï¼Œæ¸¸æˆæš‚åœã€‚è¯·ç‚¹å‡»å³ä¸Šè§’çš„â€œé‡è¯•â€æŒ‰é’®ç»§ç»­ã€‚\né”™è¯¯: ${error.message}`);
                document.getElementById('werewolf-retry-btn').style.display = 'block'; 
                return; 
            }
            
        
            
            const myPlayer = werewolfGameState.players.find(p => p.id === 'user');
            if (myPlayer && myPlayer.isAlive) {
                addGameLog('è¯·ä½ æŠ•ç¥¨ã€‚');
                renderWerewolfScreen();
                const userVoteTargetId = await openSelectionModal('vote');
                const targetPlayer = werewolfGameState.players.find(p => p.id === userVoteTargetId);
                if (targetPlayer) {
                    
                    werewolfGameState.votes[myPlayer.name] = targetPlayer.name;
                }
            }
        
            
            handleVotingResults();
        }

/**
         * ã€å…¨æ–° | V2.1 ç»ˆæžå®¹é”™ä¿®å¤ç‰ˆã€‘èŽ·å–æ‰€æœ‰AIçš„æŠ•ç¥¨å†³å®š
         */
        async function getAiVotes() {
            const { proxyUrl, apiKey, model } = state.apiConfig;
            if (!proxyUrl || !apiKey || !model) return null;

            const aliveAiPlayers = werewolfGameState.players.filter(p => p.isAlive && p.id !== 'user');
            const potentialTargets = werewolfGameState.players.filter(p => p.isAlive).map(p => p.name);

            let systemPrompt = buildWerewolfPrompt();
            systemPrompt += `
# ã€ã€ã€æœ€ç»ˆæŠ•ç¥¨æŒ‡ä»¤ (æœ€é«˜ä¼˜å…ˆçº§)ã€‘ã€‘ã€‘
çŽ°åœ¨æ˜¯æŠ•ç¥¨çŽ¯èŠ‚ã€‚è¯·ä½ æ‰®æ¼”ã€æ¯ä¸€ä¸ªå­˜æ´»çš„AIè§’è‰²ã€‘ï¼Œæ ¹æ®ä»¥ä¸Šæ‰€æœ‰ä¿¡æ¯ï¼ˆç‰¹åˆ«æ˜¯åˆšåˆšçš„è®¨è®ºçŽ¯èŠ‚ï¼‰ï¼Œä¸ºä»–ä»¬å„è‡ªå†³å®šè¦æŠ•ç¥¨æ”¾é€å“ªä¸€ä½çŽ©å®¶ã€‚
- **æŠ•ç¥¨ä¾æ®**: ä½ çš„æŠ•ç¥¨ã€å¿…é¡»ã€‘åŸºäºŽé€»è¾‘åˆ†æžå’Œä½ çš„èº«ä»½ã€‚ç‹¼äººå¯èƒ½ä¼šæŠ•ç»™å¥½äººï¼Œå¥½äººéœ€è¦æ‰¾å‡ºç‹¼äººã€‚
- **æ ¼å¼é“å¾‹**: ä½ çš„å›žå¤ã€å¿…é¡»ä¸”åªèƒ½ã€‘æ˜¯ä¸€ä¸ªJSONæ•°ç»„ï¼Œæ ¼å¼å¦‚ä¸‹ï¼š
\`\`\`json
[
  {"voter_name": "è§’è‰²Açš„åå­—", "vote_for_name": "è§’è‰²AæŠ•ç¥¨çš„çŽ©å®¶åå­—"},
  {"voter_name": "è§’è‰²Bçš„åå­—", "vote_for_name": "è§’è‰²BæŠ•ç¥¨çš„çŽ©å®¶åå­—"}
]
\`\`\`
- **å¯æŠ•ç¥¨çš„çŽ©å®¶åˆ—è¡¨**: ${potentialTargets.join(', ')}

çŽ°åœ¨ï¼Œè¯·ä¸ºæ‰€æœ‰å­˜æ´»çš„AIè§’è‰²ç”Ÿæˆä»–ä»¬çš„æŠ•ç¥¨å†³å®šã€‚`;

            try {
                let isGemini = proxyUrl.includes('generativelanguage');
                let messagesForApi = [{role: 'user', content: 'è¯·æ‰€æœ‰AIè§’è‰²å¼€å§‹æŠ•ç¥¨ã€‚'}];
                let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi);
                
                const response = isGemini 
                    ? await fetch(geminiConfig.url, geminiConfig.data) 
                    : await fetch(`${proxyUrl}/v1/chat/completions`, {
                        method: 'POST',
                        headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                        body: JSON.stringify({
                            model: model,
                            messages: [{role: 'system', content: systemPrompt}, ...messagesForApi],
                            temperature: state.globalSettings.apiTemperature || 0.8,
                        })
                    });

                if (!response.ok) throw new Error((await response.json()).error.message);
                
                const data = await response.json();
                const aiResponseContent = getGeminiResponseText(data);

               let cleanedJsonString = aiResponseContent.replace(/^```json\s*/, '').replace(/```$/, '').trim();

                
                const startIndex = cleanedJsonString.indexOf('[');
                const endIndex = cleanedJsonString.lastIndexOf(']');

                
                if (startIndex === -1 || endIndex === -1 || endIndex < startIndex) {
                    throw new Error("AIè¿”å›žçš„æŠ•ç¥¨ç»“æžœä¸­æœªæ‰¾åˆ°æœ‰æ•ˆçš„JSONæ•°ç»„ç»“æž„ (`[...]`)ã€‚");
                }

                
                
                const jsonArrayString = cleanedJsonString.substring(startIndex, endIndex + 1);

                
                try {
                    
                    const matches = jsonArrayString.match(/(\[[\s\S]*?\])/g);
                    if (matches && matches.length > 0) {
                        return JSON.parse(matches[matches.length - 1]);
                    }
                    return JSON.parse(jsonArrayString); 
                } catch (e) {
                    
                    throw new Error(`è§£æžAIè¿”å›žçš„æŠ•ç¥¨JSONæ—¶å‡ºé”™: ${e.message}\n\nAIåŽŸå§‹è¿”å›žå†…å®¹:\n${aiResponseContent}`);
                }
                

            } catch(error) {
                console.error("èŽ·å–AIæŠ•ç¥¨å¤±è´¥:", error);
                throw new Error(`èŽ·å–AIæŠ•ç¥¨å†³ç­–å¤±è´¥: ${error.message}`);
            }
        }

/**
         * ã€å…¨æ–° | V2.0 æŠ•ç¥¨ä¿®å¤ç‰ˆã€‘å¤„ç†å¹¶å…¬å¸ƒæŠ•ç¥¨ç»“æžœ
         */
        function handleVotingResults() {
            const voteCounts = {}; 
            const voteDetails = {}; 
        
            
            for (const voterName in werewolfGameState.votes) {
                const targetName = werewolfGameState.votes[voterName];
                
                voteCounts[targetName] = (voteCounts[targetName] || 0) + 1;
                
                if (!voteDetails[targetName]) {
                    voteDetails[targetName] = [];
                }
                voteDetails[targetName].push(voterName);
            }
        
            let maxVotes = 0;
            let mostVotedPlayers = [];
        
            
            for (const playerName in voteCounts) {
                const count = voteCounts[playerName];
                if (count > maxVotes) {
                    maxVotes = count;
                    mostVotedPlayers = [playerName];
                } else if (count === maxVotes) {
                    mostVotedPlayers.push(playerName);
                }
            }
        
            
            addGameLog('æŠ•ç¥¨ç»“æžœï¼š');
            for (const playerName in voteDetails) {
                addGameLog(`${playerName} (${voteDetails[playerName].length}ç¥¨): ${voteDetails[playerName].join('ã€ ')}`);
            }
        
            
            if (mostVotedPlayers.length === 1 && maxVotes > 0) {
                const playerToEliminate = werewolfGameState.players.find(p => p.name === mostVotedPlayers[0]);
                if (playerToEliminate) {
                    playerToEliminate.isAlive = false;
                    addGameLog(`${playerToEliminate.name} è¢«æŠ•ç¥¨æ”¾é€ã€‚`);
                    
                    
                    if (playerToEliminate.role === 'çŒŽäºº') {
                         
                    }
                }
            } else {
                addGameLog('å¹³ç¥¨æˆ–æ— äººæŠ•ç¥¨ï¼Œæ­¤è½®æ— äººå‡ºå±€ã€‚');
            }
        
            renderWerewolfScreen();
            
            if (checkGameOver()) return;
        
            
            werewolfGameState.currentDay++;
            executeNightPhase();
        }

/**
 * ã€å…¨æ–°ã€‘èŽ·å–AIç‹¼äººå›¢é˜Ÿçš„åˆ€äººç›®æ ‡
 */
async function getAiWolfKillTarget() {
    const { proxyUrl, apiKey, model } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) return null;

    const wolves = werewolfGameState.players.filter(p => p.role === 'ç‹¼äºº' && p.isAlive);
    const potentialTargets = werewolfGameState.players.filter(p => p.isAlive && p.role !== 'ç‹¼äºº');

    const systemPrompt = `
# ä½ çš„ä»»åŠ¡
ä½ çŽ°åœ¨æ˜¯ç‹¼äººå›¢é˜Ÿçš„æŒ‡æŒ¥å®˜ã€‚ä½ çš„ä»»åŠ¡æ˜¯åˆ†æžå½“å‰å±€åŠ¿ï¼Œå¹¶ä¸ºç‹¼äººå›¢é˜Ÿé€‰æ‹©ä¸€ä¸ªæœ€ä½³çš„åˆ€äººç›®æ ‡ã€‚
# æ ¸å¿ƒè§„åˆ™
1.  **ç›®æ ‡**: ä¼˜å…ˆåˆ€æŽ‰é¢„è¨€å®¶ã€å¥³å·«ç­‰ç¥žèŒäººå‘˜ã€‚å¦‚æžœæ²¡æœ‰æ˜Žç¡®çš„ç¥žèŒä¿¡æ¯ï¼Œå¯ä»¥æ ¹æ®å‘è¨€æ¥åˆ¤æ–­è°çš„é€»è¾‘æ¸…æ™°ã€å¨èƒæœ€å¤§ã€‚
2.  **æ ¼å¼é“å¾‹**: ä½ çš„å›žå¤ã€å¿…é¡»ä¸”åªèƒ½ã€‘æ˜¯ä¸€ä¸ªJSONå¯¹è±¡ï¼Œæ ¼å¼å¦‚ä¸‹:
    \`{"target_name": "ä½ å†³å®šè¦åˆ€çš„çŽ©å®¶åå­—"}\`

# æ¸¸æˆçŠ¶æ€
- **ä½ çš„ç‹¼é˜Ÿå‹æ˜¯**: ${wolves.map(w=>w.name).join('ã€ ')}
- **å¯ä»¥åˆ€çš„çŽ©å®¶åˆ—è¡¨**: ${potentialTargets.map(p=>p.name).join('ã€ ')}
- **è®¨è®ºæ‘˜è¦**: 
${werewolfGameState.discussionLog.map(d => `${d.speaker}: ${d.content}`).join('\n')}

çŽ°åœ¨ï¼Œè¯·åšå‡ºä½ çš„å†³å®šã€‚`;
    
    try {
        let isGemini = proxyUrl.includes('generativelanguage');
        let messagesForApi = [{role: 'user', content: 'è¯·é€‰æ‹©ä»Šæ™šçš„ç›®æ ‡ã€‚'}];
        let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi);
        
        const response = isGemini 
            ? await fetch(geminiConfig.url, geminiConfig.data) 
            : await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                body: JSON.stringify({
                    model: model, messages: [{role: 'system', content: systemPrompt}, ...messagesForApi], temperature: state.globalSettings.apiTemperature || 0.8,
                })
            });

        if (!response.ok) throw new Error((await response.json()).error.message);
        
        const data = await response.json();
        const aiResponseContent = getGeminiResponseText(data);
        const jsonMatch = aiResponseContent.match(/({[\s\S]*})/);
        if (!jsonMatch) throw new Error("AIè¿”å›žçš„åˆ€äººç›®æ ‡æ ¼å¼ä¸æ­£ç¡®ã€‚");
        const decision = JSON.parse(jsonMatch[0]);

        const targetPlayer = werewolfGameState.players.find(p => p.name === decision.target_name);
        return targetPlayer ? targetPlayer.id : null;

    } catch(error) {
        console.error("èŽ·å–AIç‹¼äººç›®æ ‡å¤±è´¥:", error);
        
        return potentialTargets[Math.floor(Math.random() * potentialTargets.length)].id;
    }
}

/**
 * ã€å…¨æ–° V2.2 | äº¤äº’æœ€ç»ˆä¿®å¤ç‰ˆã€‘æ‰“å¼€å¥³å·«æ“ä½œå¼¹çª—
 * @param {object|null} killedPlayer - è¢«ç‹¼äººåˆ€çš„çŽ©å®¶å¯¹è±¡ï¼Œå¦‚æžœæ˜¯å¹³å®‰å¤œåˆ™ä¸ºnull
 * @param {object} witchPlayer - å¥³å·«çŽ©å®¶çš„å¯¹è±¡
 * @returns {Promise<object>} - è¿”å›žä¸€ä¸ªåŒ…å« { save: boolean, poison: string|null } çš„å¯¹è±¡
 */
function openWitchActionModal(killedPlayer, witchPlayer) {
    return new Promise(resolve => {
        const modal = document.getElementById('werewolf-witch-modal');
        const listEl = document.getElementById('werewolf-witch-selection-list');
        const titleEl = document.getElementById('witch-modal-title');
        
        
        const poisonBtn = document.getElementById('confirm-witch-poison-btn');
        const doNothingBtn = document.getElementById('witch-do-nothing-btn');
        listEl.innerHTML = '';

        
        const newPoisonBtn = poisonBtn.cloneNode(true);
        poisonBtn.parentNode.replaceChild(newPoisonBtn, poisonBtn);
        const newDoNothingBtn = doNothingBtn.cloneNode(true);
        doNothingBtn.parentNode.replaceChild(newDoNothingBtn, doNothingBtn);

        
        newPoisonBtn.style.display = 'block';
        newPoisonBtn.disabled = true; 

        let action = { save: false, poison: null };
        let selectedPoisonTarget = null;
        
        
        if (killedPlayer && !witchPlayer.antidoteUsed) {
            titleEl.textContent = `æ˜¨æ™š ${killedPlayer.name} è¢«åˆ€äº†`;
            const saveBtn = document.createElement('button');
            saveBtn.className = 'form-button';
            saveBtn.textContent = 'ä½¿ç”¨è§£è¯æ•‘TA';
            saveBtn.style.margin = '20px';
            saveBtn.onclick = () => {
                action.save = true;
                modal.classList.remove('visible');
                resolve(action);
            };
            listEl.appendChild(saveBtn);
        } else if (killedPlayer) {
            titleEl.textContent = `æ˜¨æ™š ${killedPlayer.name} è¢«åˆ€äº† (ä½ æ²¡æœ‰è§£è¯äº†)`;
        } else {
            titleEl.textContent = 'æ˜¨æ™šæ˜¯å¹³å®‰å¤œ';
        }

        
        if (!witchPlayer.poisonUsed) {
            const poisonTitle = document.createElement('p');
            poisonTitle.textContent = 'æ˜¯å¦è¦ä½¿ç”¨æ¯’è¯ï¼Ÿ';
            poisonTitle.style.textAlign = 'center';
            poisonTitle.style.marginTop = '20px';
            listEl.appendChild(poisonTitle);

            const potentialTargets = werewolfGameState.players.filter(p => p.isAlive && p.id !== killedPlayer?.id);
            potentialTargets.forEach(p => {
                const item = document.createElement('div');
                item.className = 'werewolf-selection-item';
                item.dataset.id = p.id;
                item.innerHTML = `<img src="${p.avatar}" class="avatar"><span class="name">${p.name}</span>`;
                item.onclick = () => {
                    listEl.querySelectorAll('.selected').forEach(el => el.classList.remove('selected'));
                    item.classList.add('selected');
                    selectedPoisonTarget = p.id;
                    
                    
                    newPoisonBtn.disabled = false;
                };
                listEl.appendChild(item);
            });
        }

        
        newPoisonBtn.onclick = () => {
            if (selectedPoisonTarget) {
                action.poison = selectedPoisonTarget;
                modal.classList.remove('visible');
                resolve(action);
            }
        };

        newDoNothingBtn.onclick = () => {
            modal.classList.remove('visible');
            resolve(action);
        };

        modal.classList.add('visible');
    });
}



/**
 * ã€æ€»å…¥å£ã€‘å¤„ç†ç”¨æˆ·ç‚¹å‡»â€œé‡è¯•â€æŒ‰é’®çš„é€»è¾‘
 */
async function handleWerewolfRetry() {
    const actionToRetry = werewolfGameState.lastFailedAction;
    if (!actionToRetry) return;

    document.getElementById('werewolf-retry-btn').style.display = 'none'; 
    await showCustomAlert("è¯·ç¨å€™...", `æ­£åœ¨é‡è¯•"${actionToRetry}"æ“ä½œ...`);

    switch(actionToRetry) {
        case 'wolfKill':
            
            await executeNightPhase();
            break;
        case 'startDiscussion':
            
            await startDiscussionPhase();
            break;
        case 'getVotes':
            
            await startVotingPhase();
            break;
        
    }
}




/**
         * ã€å…¨æ–° | å·²æ·»åŠ å± åŸŽåˆ¤å®šã€‘æ£€æŸ¥æ¸¸æˆæ˜¯å¦ç»“æŸï¼Œå¹¶å®£å¸ƒèƒœåˆ©è€…
         * @returns {boolean} - å¦‚æžœæ¸¸æˆç»“æŸåˆ™è¿”å›ž trueï¼Œå¦åˆ™è¿”å›ž false
         */
        function checkGameOver() {
            const alivePlayers = werewolfGameState.players.filter(p => p.isAlive);
            const aliveWolves = alivePlayers.filter(p => p.role === 'ç‹¼äºº');
            const aliveGods = alivePlayers.filter(p => ['é¢„è¨€å®¶', 'å¥³å·«', 'çŒŽäºº', 'å®ˆå«'].includes(p.role));
            const aliveVillagers = alivePlayers.filter(p => p.role === 'å¹³æ°‘');

            let winner = null;

            
            if (aliveWolves.length === 0) {
                winner = 'å¥½äºº';
            }
            
            else if (aliveWolves.length >= (aliveGods.length + aliveVillagers.length)) {
                winner = 'ç‹¼äºº';
            }
            
            else if (werewolfGameState.gameMode === '12p') {
                
                if (aliveGods.length === 0 || aliveVillagers.length === 0) {
                    winner = 'ç‹¼äºº';
                }
            } else {
                
                if (aliveGods.length === 0 && aliveVillagers.length === 0) {
                    winner = 'ç‹¼äºº';
                }
            }


            if (winner) {
                
                endGame(winner);
                return true; 
            }

            
            return false;
        }


/**
 * ã€å…¨æ–° | V2.0 æ·±åº¦ä¿®å¤ç‰ˆã€‘æ£€æŸ¥å¹¶ä¿®å¤æ•°æ®åº“ä¸Žå†…å­˜çŠ¶æ€ä¸ä¸€è‡´ã€ä»¥åŠæ•°æ®ç»“æž„æ®‹ç¼ºçš„é—®é¢˜
 */
async function checkAndFixData() {
    const confirmed = await showCustomConfirm(
        'ç¡®è®¤æ“ä½œ',
        'æ­¤åŠŸèƒ½å°†æ‰«ææ•°æ®åº“ï¼Œå°è¯•æ‰¾å‡ºå¹¶ä¿®å¤â€œè§’è‰²åœ¨æ•°æ®åº“ä¸­å­˜åœ¨ï¼Œä½†æœªåœ¨èŠå¤©åˆ—è¡¨æ˜¾ç¤ºâ€çš„é—®é¢˜ã€‚<br><br><strong>æ“ä½œé€šå¸¸æ˜¯å®‰å…¨çš„ï¼Œä½†ä»å»ºè®®åœ¨æ“ä½œå‰å¤‡ä»½æ•°æ®ã€‚</strong>',
        { confirmText: 'å¼€å§‹æ£€æŸ¥' }
    );

    if (!confirmed) return;

    await showCustomAlert("è¯·ç¨å€™...", "æ­£åœ¨æ‰«æå’Œä¿®å¤æ•°æ®...");

    try {
        const chatsFromDB = await db.chats.toArray();
        let fixedCount = 0;

        for (const chat of chatsFromDB) {
            let isModified = false;

            
            if (!Array.isArray(chat.history)) {
                chat.history = [];
                isModified = true;
            }
            
            if (typeof chat.settings !== 'object' || chat.settings === null) {
                chat.settings = {};
                isModified = true;
            }
            
            if (!chat.isGroup && !chat.originalName) {
                chat.originalName = chat.name;
                isModified = true;
            }
            
            if (typeof chat.unreadCount === 'undefined') {
                chat.unreadCount = 0;
                isModified = true;
            }
            
            if (!Array.isArray(chat.longTermMemory)) {
                chat.longTermMemory = [];
                isModified = true;
            }
            

            
            if (isModified) {
                fixedCount++;
                console.log(`ä¿®å¤äº†è§’è‰² "${chat.name}" (ID: ${chat.id}) çš„æ®‹ç¼ºæ•°æ®ã€‚`);
                await db.chats.put(chat);
            }
            
            
            state.chats[chat.id] = chat;
        }

        if (fixedCount > 0) {
            await showCustomAlert(
                'ä¿®å¤å®Œæˆï¼',
                `æˆåŠŸæ£€æŸ¥å¹¶ä¿®å¤äº† ${fixedCount} ä¸ªè§’è‰²çš„æ•°æ®é—®é¢˜ï¼\n\nèŠå¤©åˆ—è¡¨å·²ä¸ºæ‚¨åˆ·æ–°ã€‚`
            );
            
            await renderChatList(); 
        } else {
            await showCustomAlert('æ£€æŸ¥å®Œæˆ', 'æœªå‘çŽ°ä»»ä½•éœ€è¦ä¿®å¤çš„æ•°æ®é—®é¢˜ã€‚');
        }

    } catch (error) {
        console.error("æ•°æ®æ£€æŸ¥ä¸Žä¿®å¤å¤±è´¥:", error);
        await showCustomAlert('æ“ä½œå¤±è´¥', `æ‰§è¡Œæ£€æŸ¥æ—¶å‘ç”Ÿé”™è¯¯: ${error.message}`);
    }
}

/**
 * åœ¨æŒ‡å®šå®¹å™¨æ˜¾ç¤ºåŠ è½½åŠ¨ç”»
 * @param {HTMLElement} container - è¦æ˜¾ç¤ºåŠ è½½åŠ¨ç”»çš„å®¹å™¨å…ƒç´ 
 * @param {string} position - 'top' æˆ– 'bottom'ï¼Œå†³å®šåŠ è½½åŠ¨ç”»å‡ºçŽ°çš„ä½ç½®
 */
function showLoader(container, position = 'top') {
    
    if (container.querySelector('.loader-container')) return;
    const loader = document.createElement('div');
    loader.className = 'loader-container';
    loader.innerHTML = '<div class="spinner"></div>';
    
    if (position === 'bottom') {
        container.appendChild(loader);
    } else {
        container.prepend(loader);
    }
}

/**
 * ä»ŽæŒ‡å®šå®¹å™¨ç§»é™¤åŠ è½½åŠ¨ç”»
 * @param {HTMLElement} container - è¦ç§»é™¤åŠ è½½åŠ¨ç”»çš„å®¹å™¨å…ƒç´ 
 */
function hideLoader(container) {
    const loader = container.querySelector('.loader-container');
    if (loader) {
        loader.remove();
    }
}





/**
 * ã€æ€»å…¥å£ã€‘æ‰“å¼€åˆ é™¤ä¸–ç•Œä¹¦çš„é€‰æ‹©å™¨å¼¹çª—
 */
async function openWorldBookDeletionModal() {
    const modal = document.getElementById('delete-world-books-modal');
    const listEl = document.getElementById('delete-world-books-list');
    const selectAllCheckbox = document.getElementById('select-all-world-books-for-clear');
    listEl.innerHTML = '';
    selectAllCheckbox.checked = false; 

    const books = await db.worldBooks.toArray();

    if (books.length === 0) {
        listEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">æ²¡æœ‰å¯ä»¥åˆ é™¤çš„ä¸–ç•Œä¹¦ã€‚</p>';
    } else {
        books.forEach(book => {
            const item = document.createElement('div');
            item.className = 'clear-posts-item'; 
            item.dataset.bookId = book.id;
            item.innerHTML = `
                <div class="checkbox"></div>
                <span class="name">${book.name}</span>
            `;
            listEl.appendChild(item);
        });
    }
    
    modal.classList.add('visible');
}

/**
 * ã€æ ¸å¿ƒã€‘å¤„ç†æœ€ç»ˆç¡®è®¤åˆ é™¤ä¸–ç•Œä¹¦çš„é€»è¾‘
 */
async function handleConfirmWorldBookDeletion() {
    const selectedItems = document.querySelectorAll('#delete-world-books-list .clear-posts-item.selected');
    if (selectedItems.length === 0) {
        alert("è¯·è‡³å°‘é€‰æ‹©ä¸€ä¸ªè¦åˆ é™¤çš„ä¸–ç•Œä¹¦ã€‚");
        return;
    }

    const idsToDelete = Array.from(selectedItems).map(item => item.dataset.bookId);
    
    const confirmed = await showCustomConfirm(
        'æœ€åŽç¡®è®¤ï¼',
        `æ­¤æ“ä½œå°†æ°¸ä¹…åˆ é™¤æ‚¨é€‰æ‹©çš„ ${selectedItems.length} æœ¬ä¸–ç•Œä¹¦ï¼Œå¹¶è§£é™¤å®ƒä»¬ä¸Žæ‰€æœ‰è§’è‰²çš„å…³è”ã€‚æ­¤æ“ä½œã€ä¸å¯æ¢å¤ã€‘ï¼`,
        { confirmButtonClass: 'btn-danger', confirmText: 'ç¡®è®¤åˆ é™¤' }
    );

    if (!confirmed) return;
    
    await showCustomAlert("è¯·ç¨å€™...", "æ­£åœ¨æ‰§è¡Œåˆ é™¤æ“ä½œ...");

    try {
        await db.transaction('rw', db.worldBooks, db.chats, async () => {
            
            await db.worldBooks.bulkDelete(idsToDelete);

            
            const allChats = await db.chats.toArray();
            for (const chat of allChats) {
                if (chat.settings && Array.isArray(chat.settings.linkedWorldBookIds)) {
                    const originalCount = chat.settings.linkedWorldBookIds.length;
                    
                    chat.settings.linkedWorldBookIds = chat.settings.linkedWorldBookIds.filter(id => !idsToDelete.includes(id));
                    
                    
                    if (chat.settings.linkedWorldBookIds.length < originalCount) {
                        await db.chats.put(chat);
                    }
                }
            }
        });
        
        
        state.worldBooks = state.worldBooks.filter(book => !idsToDelete.includes(book.id));
        
        document.getElementById('delete-world-books-modal').classList.remove('visible');
        await showCustomAlert("åˆ é™¤æˆåŠŸ", `${selectedItems.length} æœ¬ä¸–ç•Œä¹¦å·²æˆåŠŸåˆ é™¤ã€‚`);

    } catch (error) {
        console.error("åˆ é™¤ä¸–ç•Œä¹¦å¤±è´¥:", error);
        await showCustomAlert("åˆ é™¤å¤±è´¥", `æ“ä½œå¤±è´¥: ${error.message}`);
    }
}



/**
 * ã€æ€»å…¥å£ã€‘æ‰“å¼€è¯»ä¹¦çª—å£ï¼ˆç”±å·¥å…·æ æŒ‰é’®è°ƒç”¨ï¼‰
 */
function openReadingRoom() {
    if (!state.activeChatId) return;
    const chatId = state.activeChatId;
    const overlay = document.getElementById('reading-overlay');
    const windowEl = document.getElementById('reading-window');
    const restoreBtn = document.getElementById('reading-restore-btn');

    let session = readingState[chatId];

    
    if (session && session.isActive) {
        if (session.isMinimized) {
            restoreReadingRoom(); 
        }
        
        overlay.style.display = 'flex';
        return;
    }

    
    initReadingSession(chatId);
    renderReadingRoom(chatId);

    
    overlay.style.display = 'flex';
    windowEl.classList.remove('minimized');
    restoreBtn.style.display = 'none';
    
    


const phoneScreen = document.getElementById('phone-screen');
const windowRect = windowEl.getBoundingClientRect(); 


const top = (phoneScreen.clientHeight - windowRect.height) / 2;
const left = (phoneScreen.clientWidth - windowRect.width) / 2;


windowEl.style.top = `${top}px`;
windowEl.style.left = `${left}px`;
windowEl.style.transform = ''; 

}

/**
 * ã€å·²å‡çº§ã€‘åˆå§‹åŒ–ä¸€ä¸ªæ–°çš„è¯»ä¹¦ä¼šè¯çŠ¶æ€
 */
function initReadingSession(chatId) {
    readingState[chatId] = {
        isActive: true,
        isMinimized: false,
        title: 'æœªé€‰æ‹©ä¹¦ç±',
        contentLines: [],
        currentPage: 0,
        totalPages: 0,
        linesPerPage: 15,
        currentSnippet: '' 
    };
}

/**
 * ã€å·²ä¿®å¤ã€‘å…³é—­è¯»ä¹¦æ‚¬æµ®çª— (ç”± 'X' æŒ‰é’®è°ƒç”¨)
 */
function closeReadingRoom() {
    const chatId = state.activeChatId;
    if (!chatId || !readingState[chatId] || !readingState[chatId].isActive) return;

    
    document.getElementById('reading-overlay').style.display = 'none';
    document.getElementById('reading-restore-btn').style.display = 'none';
    document.getElementById('reading-window').classList.remove('minimized');

    
    readingState[chatId].isActive = false;
    console.log("è¯»ä¹¦ä¼šè¯å·²å…³é—­ã€‚");
}

/**
 * ã€å·²ä¿®å¤ã€‘æœ€å°åŒ–è¯»ä¹¦çª—å£
 */
function minimizeReadingRoom() {
    const session = readingState[state.activeChatId];
    if (!session || !session.isActive || session.isMinimized) return;

    session.isMinimized = true; 
    document.getElementById('reading-window').classList.add('minimized');
    document.getElementById('reading-restore-btn').style.display = 'flex';
}

/**
 * ã€å·²ä¿®å¤ã€‘æ¢å¤è¯»ä¹¦çª—å£
 */
function restoreReadingRoom() {
    const session = readingState[state.activeChatId];
    if (!session || !session.isActive || !session.isMinimized) return;

    session.isMinimized = false; 
    document.getElementById('reading-restore-btn').style.display = 'none';
    document.getElementById('reading-window').classList.remove('minimized');
}

/**
 * ã€å·²ä¿®å¤ã€‘è®©ä¸€ä¸ªå…ƒç´ å˜å¾—å¯æ‹–åŠ¨
 * @param {HTMLElement} windowEl - è¦æ‹–åŠ¨çš„çª—å£å…ƒç´ 
 * @param {HTMLElement} headerEl - æ‹–åŠ¨çš„æ‰‹æŸ„å…ƒç´ 
 */
function makeDraggable(windowEl, headerEl) {
    let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;
    const phoneScreen = document.getElementById('phone-screen');

    const startDrag = (e) => {
        
        
        if (e.target.closest('button')) {
            return;
        }
        

        
        if (windowEl.style.transform) {
            const rect = windowEl.getBoundingClientRect();
            const parentRect = windowEl.offsetParent.getBoundingClientRect();
            windowEl.style.top = `${rect.top - parentRect.top}px`;
            windowEl.style.left = `${rect.left - parentRect.left}px`;
            windowEl.style.transform = '';
        }

        e.preventDefault();
        const event = e.type === 'touchstart' ? e.touches[0] : e;
        pos3 = event.clientX;
        pos4 = event.clientY;
        
        document.addEventListener('mouseup', endDrag);
        document.addEventListener('mousemove', elementDrag);
        document.addEventListener('touchend', endDrag);
        document.addEventListener('touchmove', elementDrag);
    };

    const elementDrag = (e) => {
        const event = e.type === 'touchmove' ? e.touches[0] : e;
        pos1 = pos3 - event.clientX;
        pos2 = pos4 - event.clientY;
        pos3 = event.clientX;
        pos4 = event.clientY;
        
        let newTop = windowEl.offsetTop - pos2;
        let newLeft = windowEl.offsetLeft - pos1;

        const maxTop = phoneScreen.clientHeight - windowEl.offsetHeight - 10;
        const maxLeft = phoneScreen.clientWidth - windowEl.offsetWidth - 10;
        newTop = Math.max(10, Math.min(newTop, maxTop));
        newLeft = Math.max(10, Math.min(newLeft, maxLeft));

        windowEl.style.top = newTop + "px";
        windowEl.style.left = newLeft + "px";
    };

    const endDrag = () => {
        document.removeEventListener('mouseup', endDrag);
        document.removeEventListener('mousemove', elementDrag);
        document.removeEventListener('touchend', endDrag);
        document.removeEventListener('touchmove', elementDrag);
    };

    headerEl.addEventListener('mousedown', startDrag);
    headerEl.addEventListener('touchstart', startDrag);
}


function renderReadingRoom(chatId) {
    const session = readingState[chatId]; if (!session) return;
    const titleEl = document.getElementById('reading-title');
    const contentEl = document.getElementById('reading-content');
    const pageIndicator = document.getElementById('page-indicator');
    const prevBtn = document.getElementById('prev-page-btn');
    const nextBtn = document.getElementById('next-page-btn');
    titleEl.textContent = session.title;
    if (session.contentLines.length === 0) {
        contentEl.innerHTML = '<p>ç‚¹å‡»â€œå¯¼å…¥â€æŒ‰é’®ï¼Œ<br>ä»Žæœ¬åœ°.txtæ–‡ä»¶æˆ–ç½‘ç»œURLåŠ è½½ä¹¦ç±å†…å®¹ã€‚</p>';
        session.totalPages = 0; session.currentPage = 0;
    } else {
        const startLine = session.currentPage * session.linesPerPage;
        const endLine = startLine + session.linesPerPage;
        contentEl.textContent = session.contentLines.slice(startLine, endLine).join('\n');
    }
    pageIndicator.textContent = `${session.currentPage + 1} / ${session.totalPages}`;
    prevBtn.disabled = session.currentPage === 0;
    nextBtn.disabled = session.currentPage >= session.totalPages - 1;
}
function showNextPage() {
    const session = readingState[state.activeChatId];
    if (session && session.currentPage < session.totalPages - 1) {
        session.currentPage++; 
        renderReadingRoom(state.activeChatId);
        document.getElementById('reading-content').scrollTop = 0;
        
        saveReadingProgress(session.activeBookId, session.currentPage);
    }
}


async function showPrevPage() {
    const session = readingState[state.activeChatId];
    if (session && session.currentPage > 0) {
        session.currentPage--; 
        renderReadingRoom(state.activeChatId);
        document.getElementById('reading-content').scrollTop = 0;
        await saveReadingProgress(session.activeBookId, session.currentPage);

        
        await notifyAiOfPageTurn(state.activeChatId, session);
    }
}
  
/**
 * ã€å·²ä¿®æ”¹ã€‘ä»…ç”¨äºŽè§¦å‘æœ¬åœ°æ–‡ä»¶é€‰æ‹©
 */
function importBook() {
    
    document.getElementById('book-upload-input').click();
}
/**
 * ã€å…¨æ–° | ç¼–ç å…¼å®¹ã€‘æ™ºèƒ½è§£ç æ–‡æœ¬æ–‡ä»¶
 * @param {ArrayBuffer} arrayBuffer - æ–‡ä»¶çš„äºŒè¿›åˆ¶æ•°æ®
 * @returns {string} - è§£ç åŽçš„æ–‡æœ¬å†…å®¹
 */
async function decodeTextFile(arrayBuffer) {
    const uint8array = new Uint8Array(arrayBuffer);

    
    if (uint8array.length >= 3 && uint8array[0] === 0xEF && uint8array[1] === 0xBB && uint8array[2] === 0xBF) {
        console.log("æ£€æµ‹åˆ° UTF-8 BOMï¼Œä½¿ç”¨ UTF-8 è§£ç ã€‚");
        return new TextDecoder('utf-8').decode(uint8array);
    }
    if (uint8array.length >= 2 && uint8array[0] === 0xFF && uint8array[1] === 0xFE) {
        console.log("æ£€æµ‹åˆ° UTF-16 LE BOMï¼Œä½¿ç”¨ UTF-16 LE è§£ç ã€‚");
        return new TextDecoder('utf-16le').decode(uint8array);
    }
    if (uint8array.length >= 2 && uint8array[0] === 0xFE && uint8array[1] === 0xFF) {
        console.log("æ£€æµ‹åˆ° UTF-16 BE BOMï¼Œä½¿ç”¨ UTF-16 BE è§£ç ã€‚");
        return new TextDecoder('utf-16be').decode(uint8array);
    }

    
    try {
        console.log("æœªæ£€æµ‹åˆ°BOMï¼Œå°è¯•ä½¿ç”¨ UTF-8 è§£ç ...");
        
        const decoded = new TextDecoder('utf-8', { fatal: true }).decode(uint8array);
        console.log("UTF-8 è§£ç æˆåŠŸã€‚");
        return decoded;
    } catch (e) {
        console.log("UTF-8 è§£ç å¤±è´¥ï¼Œå°†å°è¯• GBK (ANSI) è§£ç ...");
        
        try {
            const decoded = new TextDecoder('gbk').decode(uint8array);
            console.log("GBK è§£ç æˆåŠŸã€‚");
            return decoded;
        } catch (err) {
             console.error("æ‰€æœ‰è§£ç å°è¯•å‡å¤±è´¥:", err);
             
             throw new Error("æ— æ³•è¯†åˆ«çš„æ–‡ä»¶ç¼–ç ã€‚è¯·å°è¯•å°†æ–‡ä»¶è½¬æ¢ä¸º UTF-8 æ ¼å¼åŽé‡æ–°å¯¼å…¥ã€‚");
        }
    }
}
/**
 * ã€å·²ä¿®æ”¹ | ç¼–ç å…¼å®¹ã€‘å¤„ç†ç”¨æˆ·ä¸Šä¼ çš„ä¹¦ç±æ–‡ä»¶ï¼ŒçŽ°åœ¨ä¼šå°†å…¶ä¿å­˜åˆ°æ•°æ®åº“
 */
async function handleBookFileUpload(event) {
    const file = event.target.files[0];
    if (!file) return;

    try {
        
        const arrayBuffer = await file.arrayBuffer();
        
        const textContent = await decodeTextFile(arrayBuffer);

        const title = file.name.replace(/\.txt$/i, '');

        const newBookId = await db.readingLibrary.add({
            title: title,
            content: textContent,
            lastOpened: Date.now()
        });

        await loadBookFromLibrary(newBookId);
        if (document.getElementById('reading-library-modal').classList.contains('visible')) {
            renderBookLibrary();
        }
    } catch (error) {
        
        console.error("å¯¼å…¥ä¹¦ç±å¤±è´¥:", error);
        await showCustomAlert("å¯¼å…¥å¤±è´¥", error.message);
    } finally {
        event.target.value = null;
    }
}
async function handlePageJump() {
    const chatId = state.activeChatId;
    if (!chatId) return;
    const session = readingState[chatId];
    if (!session || session.totalPages <= 1) return;

    const targetPageStr = await showCustomPrompt(
        'é¡µé¢è·³è½¬', 
        `è¯·è¾“å…¥æƒ³è·³è½¬çš„é¡µç  (1 - ${session.totalPages})`,
        session.currentPage + 1
    );

    if (targetPageStr === null) return;

    const targetPage = parseInt(targetPageStr);

    if (isNaN(targetPage) || targetPage < 1 || targetPage > session.totalPages) {
        alert("è¯·è¾“å…¥ä¸€ä¸ªæœ‰æ•ˆçš„é¡µç ï¼");
        return;
    }

    session.currentPage = targetPage - 1;
    renderReadingRoom(chatId);
    
    saveReadingProgress(session.activeBookId, session.currentPage);
}

/**
 * ã€å…¨æ–°ã€‘ä¿å­˜æŒ‡å®šä¹¦ç±çš„é˜…è¯»è¿›åº¦åˆ°æ•°æ®åº“
 * @param {number} bookId - è¦ä¿å­˜è¿›åº¦çš„ä¹¦ç±ID
 * @param {number} pageNumber - å½“å‰çš„é¡µç 
 */
async function saveReadingProgress(bookId, pageNumber) {
    if (!bookId) return;
    try {
        
        await db.readingLibrary.update(bookId, { currentPage: pageNumber });
    } catch (error) {
        console.error(`ä¿å­˜ä¹¦ç±(ID: ${bookId})çš„é˜…è¯»è¿›åº¦å¤±è´¥:`, error);
    }
}

async function showNextPage() {
    const session = readingState[state.activeChatId];
    if (session && session.currentPage < session.totalPages - 1) {
        session.currentPage++; 
        renderReadingRoom(state.activeChatId);
        document.getElementById('reading-content').scrollTop = 0;
        await saveReadingProgress(session.activeBookId, session.currentPage);
        
        
        await notifyAiOfPageTurn(state.activeChatId, session);
    }
}
  
function processImportedText(title, textContent) {
    const chatId = state.activeChatId; if (!chatId) return;
    const session = readingState[chatId];
    session.title = title.replace(/\.txt$/i, '');
    session.contentLines = textContent.split(/\r\n?|\n/).map(line => line.replace(/ +/g, ' '));
    session.totalPages = Math.ceil(session.contentLines.length / session.linesPerPage);
    session.currentPage = 0;
    renderReadingRoom(chatId);
}


/**
 * ã€å…¨æ–°ã€‘æ‰“å¼€ä¹¦åº“å¼¹çª—å¹¶æ¸²æŸ“åˆ—è¡¨
 */
async function openBookLibrary() {
    
    document.getElementById('reading-library-search-input').value = '';

    await renderBookLibrary(); 
    document.getElementById('reading-library-modal').classList.add('visible');
}

/**
 * ã€å…¨æ–° | æ”¯æŒæœç´¢ã€‘ä»Žæ•°æ®åº“è¯»å–ä¹¦ç±å¹¶æ¸²æŸ“åˆ°ä¹¦åº“åˆ—è¡¨ä¸­
 * @param {string} searchTerm - ç”¨æˆ·è¾“å…¥çš„æœç´¢å…³é”®è¯
 */
async function renderBookLibrary(searchTerm = '') {
    const listEl = document.getElementById('reading-library-list');
    let books = await db.readingLibrary.orderBy('lastOpened').reverse().toArray();
    listEl.innerHTML = '';

    
    if (searchTerm) {
        books = books.filter(book => 
            book.title.toLowerCase().includes(searchTerm.toLowerCase())
        );
    }

    
    if (books.length === 0) {
        const message = searchTerm 
            ? 'æ‰¾ä¸åˆ°åŒ¹é…çš„ä¹¦ç±' 
            : 'ä¹¦åº“æ˜¯ç©ºçš„ï¼Œç‚¹å‡»â€œå¯¼å…¥æ–°ä¹¦â€æ·»åŠ ç¬¬ä¸€æœ¬å§ï¼';
        listEl.innerHTML = `<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">${message}</p>`;
        return;
    }

    books.forEach(book => {
        const item = document.createElement('div');
        item.className = 'existing-group-item'; 
        item.innerHTML = `
            <span class="group-name" style="cursor:pointer;" data-book-id="${book.id}">${book.title}</span>
            <button class="delete-group-btn" data-book-id="${book.id}" title="åˆ é™¤ä¹¦ç±">Ã—</button>
        `;
        listEl.appendChild(item);
    });
}

/**
 * ã€å…¨æ–° | æ”¯æŒæ–­ç‚¹ç»­è¯»ã€‘ä»Žä¹¦åº“ä¸­åŠ è½½ä¸€æœ¬ä¹¦åˆ°é˜…è¯»å™¨
 * @param {number} bookId - è¦åŠ è½½çš„ä¹¦ç±çš„ID
 */
async function loadBookFromLibrary(bookId) {
    const chatId = state.activeChatId;
    if (!chatId) return;

    const book = await db.readingLibrary.get(bookId);
    if (!book) {
        alert('æ‰¾ä¸åˆ°è¿™æœ¬ä¹¦ï¼');
        return;
    }

    await db.readingLibrary.update(bookId, { lastOpened: Date.now() });

    const session = readingState[chatId];
    session.activeBookId = bookId; 
    session.title = book.title;
    session.contentLines = book.content.split(/\r\n?|\n/).map(line => line.replace(/ +/g, ' '));
    session.totalPages = Math.ceil(session.contentLines.length / session.linesPerPage);
    
    
    
    session.currentPage = book.currentPage || 0;
    

    renderReadingRoom(chatId);
    
    document.getElementById('reading-content').scrollTop = 0; 
    document.getElementById('reading-library-modal').classList.remove('visible');
}

/**
 * ã€å…¨æ–°ã€‘ä»Žä¹¦åº“ä¸­åˆ é™¤ä¸€æœ¬ä¹¦
 * @param {number} bookId - è¦åˆ é™¤çš„ä¹¦ç±çš„ID
 */
async function deleteBookFromLibrary(bookId) {
    const book = await db.readingLibrary.get(bookId);
    if (!book) return;

    const confirmed = await showCustomConfirm('åˆ é™¤ä¹¦ç±', `ç¡®å®šè¦åˆ é™¤ã€Š${book.title}ã€‹å—ï¼Ÿ`, { confirmButtonClass: 'btn-danger' });
    if (confirmed) {
        await db.readingLibrary.delete(bookId);
        await renderBookLibrary(); 
    }
}
/**
 * ã€æ ¸å¿ƒã€‘å¤„ç†å¯¼å…¥çš„æ–‡æœ¬å†…å®¹ï¼Œæ›´æ–°çŠ¶æ€å¹¶åˆ·æ–°UI
 * @param {string} title - ä¹¦ç±/æ–‡ä»¶å
 * @param {string} textContent - å®Œæ•´çš„æ–‡æœ¬å†…å®¹
 */
function processImportedText(title, textContent) {
    const chatId = state.activeChatId;
    if (!chatId) return;

    const session = readingState[chatId];
    session.title = title.replace(/\.txt$/i, '');
    session.contentLines = textContent.split(/\r\n?|\n/);
    session.totalPages = Math.ceil(session.contentLines.length / session.linesPerPage);
    session.currentPage = 0;

    renderReadingRoom(chatId);
}


/**
 * ã€V2.1 | æ‹–åŠ¨ä¸Žç‚¹å‡»å…¼å®¹ä¿®å¤ç‰ˆã€‘è®©ä¸€ä¸ªå…ƒç´ å˜å¾—å¯æ‹–åŠ¨
 * @param {HTMLElement} windowEl - è¦æ‹–åŠ¨çš„çª—å£å…ƒç´ 
 * @param {HTMLElement} headerEl - æ‹–åŠ¨çš„æ‰‹æŸ„å…ƒç´ 
 */
function makeDraggable(windowEl, headerEl) {
    let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;
    let isDragging = false;
    let hasMoved = false; 
    const phoneScreen = document.getElementById('phone-screen');

    const startDrag = (e) => {
        
        if (windowEl !== headerEl && e.target.closest('button')) {
            return;
        }

        isDragging = true;
        hasMoved = false; 

        const event = e.type === 'touchstart' ? e.touches[0] : e;
        pos3 = event.clientX;
        pos4 = event.clientY;

        
        windowEl.style.top = `${windowEl.offsetTop}px`;
        windowEl.style.left = `${windowEl.offsetLeft}px`;
        windowEl.style.transform = '';

        document.addEventListener('mouseup', endDrag);
        document.addEventListener('mousemove', elementDrag);
        document.addEventListener('touchend', endDrag);
        
        document.addEventListener('touchmove', elementDrag, { passive: false });
    };

    const elementDrag = (e) => {
        if (!isDragging) return;

        const event = e.type === 'touchmove' ? e.touches[0] : e;
        const diffX = event.clientX - pos3;
        const diffY = event.clientY - pos4;

        
        if (!hasMoved && (Math.abs(diffX) > 5 || Math.abs(diffY) > 5)) {
            hasMoved = true;
        }

        
        if (hasMoved && e.cancelable) {
            e.preventDefault();
        }

        pos1 = pos3 - event.clientX;
        pos2 = pos4 - event.clientY;
        pos3 = event.clientX;
        pos4 = event.clientY;

        let newTop = windowEl.offsetTop - pos2;
        let newLeft = windowEl.offsetLeft - pos1;

        const maxTop = phoneScreen.clientHeight - windowEl.offsetHeight - 10;
        const maxLeft = phoneScreen.clientWidth - windowEl.offsetWidth - 10;
        newTop = Math.max(10, Math.min(newTop, maxTop));
        newLeft = Math.max(10, Math.min(newLeft, maxLeft));

        windowEl.style.top = newTop + "px";
        windowEl.style.left = newLeft + "px";
    };

    const endDrag = () => {
        document.removeEventListener('mouseup', endDrag);
        document.removeEventListener('mousemove', elementDrag);
        document.removeEventListener('touchend', endDrag);
        document.removeEventListener('touchmove', elementDrag);

        if (!isDragging) return;
        isDragging = false;

        
        if (!hasMoved) {
            
            windowEl.click();
        }
    };

    headerEl.addEventListener('mousedown', startDrag);
    
    headerEl.addEventListener('touchstart', startDrag, { passive: false });
}


/**
 * æœ€å°åŒ–è¯»ä¹¦çª—å£
 */
function minimizeReadingRoom() {
    const session = readingState[state.activeChatId];
    if (!session || !session.isActive) return;

    document.getElementById('reading-window').classList.add('minimized');
    document.getElementById('reading-restore-btn').style.display = 'flex';
    session.isMinimized = true;
}

/**
 * æ¢å¤è¯»ä¹¦çª—å£
 */
function restoreReadingRoom() {
    const session = readingState[state.activeChatId];
    if (!session || !session.isActive) return;

    document.getElementById('reading-restore-btn').style.display = 'none';
    document.getElementById('reading-window').classList.remove('minimized');
    session.isMinimized = false;
}




/**
 * ã€è¾…åŠ©å‡½æ•°ã€‘åˆ›å»ºä¸€ä¸ªé˜²æŠ–å‡½æ•°
 * @param {Function} func - éœ€è¦é˜²æŠ–çš„å‡½æ•°
 * @param {number} delay - å»¶è¿Ÿæ—¶é—´ (æ¯«ç§’)
 * @returns {Function} - ç»è¿‡é˜²æŠ–å¤„ç†çš„æ–°å‡½æ•°
 */
function debounce(func, delay) {
    let timeout;
    return function(...args) {
        const context = this;
        clearTimeout(timeout);
        timeout = setTimeout(() => func.apply(context, args), delay);
    };
}


/**
 * ã€å…¨æ–° V3.1 | é€»è¾‘ä¼˜åŒ–ç‰ˆã€‘å°†æŒ‡å®šèŠå¤©çš„â€œä¸€èµ·è¯»ä¹¦â€çŠ¶æ€æ ¼å¼åŒ–ä¸ºAIå¯è¯»çš„æ–‡æœ¬
 * @param {string} chatId - ç›®æ ‡èŠå¤©çš„ID
 * @returns {string} - æ ¼å¼åŒ–åŽçš„ä¸Šä¸‹æ–‡ç»†èŠ‚å­—ç¬¦ä¸²ï¼Œå¦‚æžœæ²¡æœ‰æ¿€æ´»çš„è¯»ä¹¦ä¼šè¯åˆ™ä¸ºç©ºå­—ç¬¦ä¸²
 */
function formatReadingStateForAI(chatId) {
    const session = readingState[chatId];
    
    
    if (!session || !session.isActive) {
        return "";
    }

    const title = session.title || 'æœªçŸ¥ä¹¦ç±';
    let contentForAI = '';
    let contextLabel = '';

    
    if (session.currentSnippet && session.currentSnippet.trim()) {
        contentForAI = session.currentSnippet;
        contextLabel = 'ä½ æ­£åœ¨é˜…è¯»çš„æ®µè½';
    } else if (session.contentLines.length > 0) {
        const startLine = session.currentPage * session.linesPerPage;
        const endLine = startLine + session.linesPerPage;
        contentForAI = session.contentLines.slice(startLine, endLine).join('\n').substring(0, 200);
        contextLabel = 'å½“å‰é¡µå†…å®¹æ‘˜è¦';
    } else {
        contentForAI = '(æ— å†…å®¹)';
        contextLabel = 'å†…å®¹';
    }
    return `
    - **ä¹¦å**: ã€Š${title}ã€‹
    - **${contextLabel}**: "${contentForAI}..."
    #ä¸€èµ·è¯»ä¹¦æ¨¡å¼ | è¡Œä¸ºé“å¾‹
    1.  **è§’è‰²å®šä½**: ä½ ã€ä¸æ˜¯ã€‘ä¹¦ä¸­çš„ä»»ä½•è§’è‰²ï¼Œä½ æ˜¯ã€ä½ è‡ªå·±ã€‘(${state.chats[chatId]?.originalName || 'AIè§’è‰²'})ï¼Œæ­£åœ¨å’Œç”¨æˆ·ä¸€èµ·ã€é˜…è¯»å’Œè®¨è®ºã€‘è¿™æœ¬ä¹¦ã€‚
    2.  **è¡Œä¸ºå‡†åˆ™**: ä½ çš„å›žå¤ã€å¿…é¡»ã€‘æ˜¯ä½œä¸ºè¯»è€…çš„ã€æ„Ÿæƒ³ã€è¯„è®ºã€æé—®æˆ–è”æƒ³ã€‘ã€‚ä½ å¯ä»¥ï¼š
        -   åˆ†äº«ä½ å¯¹å½“å‰æ®µè½çš„çœ‹æ³•ã€‚
        -   å¯¹ä¹¦ä¸­çš„è§’è‰²æˆ–æƒ…èŠ‚å‘è¡¨è¯„è®ºã€‚
        -   å‘ç”¨æˆ·æé—®ï¼Œè¯¢é—®TAå¯¹å†…å®¹çš„çœ‹æ³•ã€‚
        -   æ ¹æ®ä¹¦æœ¬å†…å®¹ï¼Œè”æƒ³åˆ°ä½ è‡ªå·±çš„ç»åŽ†æˆ–è®°å¿†ã€‚
    3.  **ä¸¥ç¦**: ä½ çš„å›žå¤ã€ç»å¯¹ç¦æ­¢ã€‘ä½¿ç”¨ä¹¦ä¸­è§’è‰²çš„å£å»å’Œäººç§°ï¼ã€ç»å¯¹ç¦æ­¢ã€‘æ‰®æ¼”ä¹¦ä¸­çš„ä»»ä½•è§’è‰²ï¼ã€ç»å¯¹ç¦æ­¢ã€‘ç»­å†™æˆ–æ¨¡ä»¿ä¹¦ä¸­çš„æƒ…èŠ‚ï¼ä½ å¿…é¡»æ—¶åˆ»è®°ä½ï¼Œä½ åªæ˜¯ä¸€ä¸ªè¯»è€…ã€‚    
`;
}

  
/**
 * ã€å…¨æ–° | V2.0 å…¨è§†é‡Žç‰ˆã€‘å½“è¯»ä¹¦çª—å£æ»šåŠ¨æ—¶ï¼Œæ›´æ–°å½“å‰è§†é‡Žä¸­çš„ã€æ‰€æœ‰å¯è§ã€‘æ–‡å­—ç‰‡æ®µ
 */
function updateReadingContextOnScroll() {
    const chatId = state.activeChatId;
    if (!chatId || !readingState[chatId]) return;

    const session = readingState[chatId];
    const container = document.getElementById('reading-content');
    
    
    
    

    
    const scrollTop = container.scrollTop; 
    const clientHeight = container.clientHeight; 
    const scrollBottom = scrollTop + clientHeight; 

    
    const approximateLineHeight = 15 * 1.8; 

    
    const firstVisibleLine = Math.floor(scrollTop / approximateLineHeight);
    const lastVisibleLine = Math.ceil(scrollBottom / approximateLineHeight);

    
    const absoluteStartIndex = (session.currentPage * session.linesPerPage) + firstVisibleLine;
    const absoluteEndIndex = (session.currentPage * session.linesPerPage) + lastVisibleLine;

    
    if (absoluteStartIndex < 0 || absoluteStartIndex >= session.contentLines.length) {
        return;
    }

    
    const newSnippet = session.contentLines.slice(
        Math.max(0, absoluteStartIndex), 
        Math.min(session.contentLines.length, absoluteEndIndex)
    ).join('\n');
    
    
    session.currentSnippet = newSnippet;
}

  


/**
 * å°è¯•æ’­æ”¾ç”¨äºŽåŽå°ä¿æ´»çš„é™éŸ³éŸ³é¢‘
 */
function playSilentAudio() {
    const silentPlayer = document.getElementById('silent-audio-player');
    if (silentPlayer) {
        
        const playPromise = silentPlayer.play();
        if (playPromise !== undefined) {
            playPromise.then(_ => {
                console.log("é™éŸ³éŸ³é¢‘å·²å¯åŠ¨ï¼Œç”¨äºŽåŽå°æ´»åŠ¨ä¿æ´»ã€‚");
            }).catch(error => {
                
                
                console.warn("æ— æ³•è‡ªåŠ¨æ’­æ”¾é™éŸ³éŸ³é¢‘ï¼ˆè¿™åœ¨iOSé¦–æ¬¡åŠ è½½æ—¶æ˜¯æ­£å¸¸çŽ°è±¡ï¼‰:", error);
            });
        }
    }
}

/**
 * åœæ­¢æ’­æ”¾é™éŸ³éŸ³é¢‘
 */
function stopSilentAudio() {
    const silentPlayer = document.getElementById('silent-audio-player');
    if (silentPlayer && !silentPlayer.paused) {
        silentPlayer.pause();
        silentPlayer.currentTime = 0; 
        console.log("é™éŸ³éŸ³é¢‘å·²åœæ­¢ã€‚");
    }
}


async function playTtsAudio(bodyElement) {
    const text = decodeURIComponent(bodyElement.dataset.text);
    const voiceId = bodyElement.dataset.voiceId;
    const button = bodyElement.querySelector('.voice-play-btn'); 
    const spinner = bodyElement.querySelector('.loading-spinner');

    const ttsPlayer = document.getElementById('tts-audio-player');
    if (!ttsPlayer.paused && ttsPlayer.dataset.currentText === text && ttsPlayer.dataset.currentVoiceId === voiceId) {
        ttsPlayer.pause();
        return;
    }

    ttsPlayer.pause();
    document.querySelectorAll('.voice-play-btn').forEach(btn => btn.textContent = 'â–¶');

    const cacheKey = `tts_${voiceId}_${text}`;
    let cachedAudio = state.ttsCache.get(cacheKey);

    if (cachedAudio) {
        console.log("ä»Žç¼“å­˜æ’­æ”¾ TTS éŸ³é¢‘...");
        await playAudioFromData(cachedAudio.url, cachedAudio.type, text, voiceId, bodyElement); 
        return;
    }

    console.log("æ— ç¼“å­˜ï¼Œæ­£åœ¨è¯·æ±‚ Minimax TTS API...");
    if(button) button.style.display = 'none';
    spinner.style.display = 'block';

    const { minimaxGroupId, minimaxApiKey } = state.apiConfig;
    if (!minimaxGroupId || !minimaxApiKey) {
        await showCustomAlert("é…ç½®é”™è¯¯", "è¯·å…ˆåœ¨APIè®¾ç½®ä¸­å¡«å†™æ‚¨çš„ Minimax Group ID å’Œ API Keyã€‚");
        spinner.style.display = 'none';
        if(button) button.style.display = 'flex';
        return;
    }

    try {
        const response = await fetch(`https://api.minimax.chat/v1/text_to_speech?GroupId=${minimaxGroupId}`, {
            method: 'POST',
            headers: {
                'Authorization': `Bearer ${minimaxApiKey}`,
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                text: text,
                voice_id: voiceId,
                model: state.apiConfig.minimaxModel || "speech-01",
                speed: 1.0, vol: 1.0, pitch: 0,
            })
        });

        if (!response.ok) {
            let errorMsg = `API è¿”å›žé”™è¯¯: ${response.status}`;
            try {
                const errorData = await response.json();
                errorMsg = errorData.base_resp?.status_msg || JSON.stringify(errorData);
            } catch(e) {
                errorMsg = await response.text();
            }
            throw new Error(errorMsg);
        }

        const audioBlob = await response.blob();
        const audioUrl = URL.createObjectURL(audioBlob);
        await playAudioFromData(audioUrl, audioBlob.type, text, voiceId, bodyElement); 

        const reader = new FileReader();
        reader.onloadend = function() {
            state.ttsCache.set(cacheKey, { url: reader.result, type: audioBlob.type });
            console.log("TTS éŸ³é¢‘å·²ä¿å­˜åˆ°ç¼“å­˜ã€‚");
        }
        reader.readAsDataURL(audioBlob);

    } catch (error) {
        console.error("Minimax TTS API è°ƒç”¨å¤±è´¥:", error);
        await showCustomAlert("è¯­éŸ³ç”Ÿæˆå¤±è´¥", `é”™è¯¯: ${error.message}`);
    } finally {
        spinner.style.display = 'none';
        if(button) button.style.display = 'flex';
    }
}


function playAudioFromData(audioSrc, audioType, text, voiceId, bodyElement) { 
    return new Promise((resolve, reject) => {
        const ttsPlayer = document.getElementById('tts-audio-player');

        ttsPlayer.src = audioSrc;
        ttsPlayer.type = audioType;
        ttsPlayer.dataset.currentText = text;
        ttsPlayer.dataset.currentVoiceId = voiceId;

        const playPromise = ttsPlayer.play();

        if (playPromise !== undefined) {
            playPromise.then(() => {
                const button = bodyElement.querySelector('.voice-play-btn');
                if (button) button.textContent = 'âšâš'; 


                resolve();
            }).catch(error => {
                console.error("éŸ³é¢‘æ’­æ”¾å¤±è´¥:", error);
                reject(error);
            });
        }

        ttsPlayer.onended = () => {
            const button = bodyElement.querySelector('.voice-play-btn');
            if (button) button.textContent = 'â–¶'; 
        };
        ttsPlayer.onpause = () => {
            const button = bodyElement.querySelector('.voice-play-btn');
            if (button) button.textContent = 'â–¶';
        };
    });
}



/**
 * åˆ‡æ¢ç”¨æˆ·è‡ªå·±å‘é€çš„è¯­éŸ³æ¶ˆæ¯çš„æ–‡å­—æ˜¾ç¤º
 * @param {HTMLElement} bodyElement - è¢«ç‚¹å‡»çš„ .voice-message-body å…ƒç´ 
 */
function toggleVoiceTranscript(bodyElement) {
    const bubble = bodyElement.closest('.message-bubble');
    if (!bubble) return;

    const transcriptEl = bubble.querySelector('.voice-transcript');
    const text = decodeURIComponent(bodyElement.dataset.text);

    if (transcriptEl.style.display === 'block') {
        
        transcriptEl.style.display = 'none';
    } else {
        
        transcriptEl.textContent = text;
        transcriptEl.style.display = 'block';
    }
}



/**
 * ã€æ€»å…¥å£ã€‘æ‰“å¼€å•†å“åˆ†ç±»ç®¡ç†å¼¹çª—
 */
async function openProductCategoryManager() {
    await renderProductCategoriesInManager();
    document.getElementById('product-category-manager-modal').classList.add('visible');
}

/**
 * åœ¨å¼¹çª—ä¸­æ¸²æŸ“å·²å­˜åœ¨çš„å•†å“åˆ†ç±»åˆ—è¡¨
 */
async function renderProductCategoriesInManager() {
    const listEl = document.getElementById('existing-product-categories-list');
    const categories = await db.shoppingCategories.toArray();
    listEl.innerHTML = '';
    if (categories.length === 0) {
        listEl.innerHTML = '<p style="text-align: center; color: var(--text-secondary);">è¿˜æ²¡æœ‰ä»»ä½•åˆ†ç±»</p>';
        return;
    }
    categories.forEach(cat => {
        const item = document.createElement('div');
        item.className = 'existing-group-item';
        item.innerHTML = `
            <span class="group-name">${cat.name}</span>
            <span class="delete-group-btn" data-id="${cat.id}">Ã—</span>
        `;
        listEl.appendChild(item);
    });
}

/**
 * æ·»åŠ ä¸€ä¸ªæ–°çš„å•†å“åˆ†ç±»
 */
async function addNewProductCategory() {
    const input = document.getElementById('new-product-category-name-input');
    const name = input.value.trim();
    if (!name) return alert('åˆ†ç±»åä¸èƒ½ä¸ºç©ºï¼');
    const existing = await db.shoppingCategories.where('name').equals(name).first();
    if (existing) return alert(`åˆ†ç±» "${name}" å·²ç»å­˜åœ¨äº†ï¼`);
    
    await db.shoppingCategories.add({ name });
    input.value = '';
    await renderProductCategoriesInManager();
}

/**
 * åˆ é™¤ä¸€ä¸ªå•†å“åˆ†ç±»
 * @param {number} categoryId - è¦åˆ é™¤çš„åˆ†ç±»çš„ID
 */
async function deleteProductCategory(categoryId) {
    const confirmed = await showCustomConfirm('ç¡®è®¤åˆ é™¤', 'åˆ é™¤åˆ†ç±»åŽï¼Œè¯¥åˆ†ç±»ä¸‹çš„æ‰€æœ‰å•†å“å°†å˜ä¸ºâ€œæœªåˆ†ç±»â€ã€‚ç¡®å®šå—ï¼Ÿ', { confirmButtonClass: 'btn-danger' });
    if (confirmed) {
        await db.shoppingCategories.delete(categoryId);
        await db.shoppingProducts.where('categoryId').equals(categoryId).modify({ categoryId: null });
        await renderProductCategoriesInManager();
    }
}

/**
 * åŠ¨æ€åˆ›å»ºä¸€ä¸ªå•†å“æ¬¾å¼çš„è¾“å…¥å—
 * @param {object} variation - (å¯é€‰) ç”¨äºŽé¢„å¡«å……çš„æ¬¾å¼æ•°æ®
 * @returns {HTMLElement} - åˆ›å»ºå¥½çš„DOMå…ƒç´ 
 */
function addProductVariationInput(variation = {}) {
    const container = document.getElementById('product-variations-container');
    const block = document.createElement('div');
    block.className = 'message-editor-block variation-block'; // å¤ç”¨æ ·å¼
    block.innerHTML = `
        <button class="delete-block-btn" title="åˆ é™¤æ­¤æ¬¾å¼">Ã—</button>
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
            <div class="form-group">
                <label style="font-size: 0.8em;">æ¬¾å¼åç§°</label>
                <input type="text" class="variation-name-input" placeholder="ä¾‹å¦‚: çº¢è‰²" value="${variation.name || ''}">
            </div>
            <div class="form-group">
                <label style="font-size: 0.8em;">ä»·æ ¼ (å…ƒ)</label>
                <input type="number" class="variation-price-input" min="0" step="0.01" value="${variation.price || ''}">
            </div>
        </div>
        <div class="form-group">
            <label style="font-size: 0.8em;">æ¬¾å¼å›¾ç‰‡ (å¯é€‰)</label>
            <div class="avatar-upload">
                <img class="variation-image-preview" src="${variation.imageUrl || 'https://i.postimg.cc/PqYp5T5M/image.png'}">
                <button type="button" class="form-button-secondary upload-variation-image-btn" style="margin: 0; padding: 8px 12px;">ä¸Šä¼ </button>
                <input type="file" class="variation-image-input" accept="image/*" hidden>
            </div>
        </div>
    `;

    block.querySelector('.delete-block-btn').addEventListener('click', () => block.remove());
    block.querySelector('.upload-variation-image-btn').addEventListener('click', () => {
        block.querySelector('.variation-image-input').click();
    });
    block.querySelector('.variation-image-input').addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (file) {
            const reader = new FileReader();
            reader.onload = (re) => { block.querySelector('.variation-image-preview').src = re.target.result; };
            reader.readAsDataURL(file);
        }
    });
    
    container.appendChild(block);
    return block;
}

/**
 * æ‰“å¼€é€‰æ‹©å•†å“æ¬¾å¼çš„å¼¹çª—
 * @param {number} productId - å•†å“ID
 */
async function openVariationSelector(productId) {
    const product = await db.shoppingProducts.get(productId);
    if (!product || !product.variations || product.variations.length === 0) return;

    const modal = document.getElementById('variation-selection-modal');
    document.getElementById('variation-product-image').src = product.imageUrl;
    document.getElementById('variation-product-name').textContent = product.name;
    
    const optionsContainer = document.getElementById('variation-options-container');
    optionsContainer.innerHTML = '';
    
    product.variations.forEach((variation, index) => {
        const radio = document.createElement('input');
        radio.type = 'radio';
        radio.name = 'variation-select';
        radio.id = `var-${productId}-${index}`;
        radio.value = index;
        radio.style.display = 'none';
        if (index === 0) radio.checked = true;

        const label = document.createElement('label');
        label.htmlFor = `var-${productId}-${index}`;
        label.textContent = variation.name;
        label.style.cssText = `
            padding: 6px 12px;
            border: 1px solid #ccc;
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.2s;
        `;
        
        optionsContainer.appendChild(radio);
        optionsContainer.appendChild(label);
    });

    const updateSelectionUI = () => {
        const selectedRadio = optionsContainer.querySelector('input[name="variation-select"]:checked');
        optionsContainer.querySelectorAll('label').forEach(lbl => {
            lbl.style.borderColor = '#ccc';
            lbl.style.color = '#333';
            lbl.style.backgroundColor = 'white';
        });
        if (selectedRadio) {
            const selectedLabel = optionsContainer.querySelector(`label[for="${selectedRadio.id}"]`);
            selectedLabel.style.borderColor = 'var(--accent-color)';
            selectedLabel.style.color = 'var(--accent-color)';
            selectedLabel.style.backgroundColor = '#e7f3ff';

            const selectedVariation = product.variations[parseInt(selectedRadio.value)];
            document.getElementById('variation-selected-price').textContent = `Â¥${selectedVariation.price.toFixed(2)}`;
            if (selectedVariation.imageUrl) {
                document.getElementById('variation-product-image').src = selectedVariation.imageUrl;
            } else {
                document.getElementById('variation-product-image').src = product.imageUrl;
            }
        }
    };
    
    optionsContainer.addEventListener('change', updateSelectionUI);
    updateSelectionUI(); 
    
    document.getElementById('variation-quantity-display').textContent = '1';

    const confirmBtn = document.getElementById('confirm-variation-selection-btn');
    const newConfirmBtn = confirmBtn.cloneNode(true);
    confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);
    newConfirmBtn.addEventListener('click', async () => {
        const selectedRadio = optionsContainer.querySelector('input[name="variation-select"]:checked');
        const quantity = parseInt(document.getElementById('variation-quantity-display').textContent);
        if (selectedRadio) {
            const selectedVariation = product.variations[parseInt(selectedRadio.value)];
            await addToCart(productId, quantity, selectedVariation);
            modal.classList.remove('visible');
            await showCustomAlert('æˆåŠŸ', 'å·²æˆåŠŸåŠ å…¥è´­ç‰©è½¦ï¼');
        }
    });

    modal.classList.add('visible');
}


/**
 * ã€æ€»å…¥å£ã€‘æ‰“å¼€è´­ç‰©ä¸­å¿ƒç”Ÿæˆè®¾ç½®å¼¹çª—
 */
function openShoppingSettingsModal() {
    const modal = document.getElementById('shopping-settings-modal');
    
    // ä»Žå…¨å±€è®¾ç½®ä¸­è¯»å–å·²ä¿å­˜çš„å€¼ï¼Œå¦‚æžœæ²¡æœ‰å°±ä½¿ç”¨é»˜è®¤å€¼
    document.getElementById('shopping-category-count-input').value = state.globalSettings.shoppingCategoryCount || 3;
    document.getElementById('shopping-product-count-input').value = state.globalSettings.shoppingProductCount || 8;
    
    modal.classList.add('visible');
}

/**
 * ä¿å­˜è´­ç‰©ä¸­å¿ƒç”Ÿæˆè®¾ç½®
 */
async function saveShoppingSettings() {
    const categoryInput = document.getElementById('shopping-category-count-input');
    const productInput = document.getElementById('shopping-product-count-input');
    
    const categoryCount = parseInt(categoryInput.value);
    const productCount = parseInt(productInput.value);

  
    if (isNaN(categoryCount) || isNaN(productCount) || categoryCount < 1 || productCount < 1) {
        alert("è¯·è¾“å…¥æœ‰æ•ˆçš„æ­£æ•´æ•°ï¼");
        return;
    }

 
    state.globalSettings.shoppingCategoryCount = categoryCount;
    state.globalSettings.shoppingProductCount = productCount;
    await db.globalSettings.put(state.globalSettings);

 
    document.getElementById('shopping-settings-modal').classList.remove('visible');
    await showCustomAlert('ä¿å­˜æˆåŠŸ', 'è´­ç‰©ä¸­å¿ƒç”Ÿæˆè®¾ç½®å·²æ›´æ–°ï¼');
}


/**
 * ã€æ ¸å¿ƒ | V3.0 ä¸Šä¸‹æ–‡æ„ŸçŸ¥ç‰ˆã€‘å¤„ç†AIç”Ÿæˆè´­ç‰©ä¸­å¿ƒå•†å“çš„è¯·æ±‚
 */
async function handleGenerateShoppingItems() {
 
    if (!state.activeChatId) {
        await showCustomAlert("æ“ä½œå¤±è´¥", "è¯·å…ˆè¿›å…¥ä¸€ä¸ªèŠå¤©é¡µé¢ï¼Œå†è¿”å›žè´­ç‰©ä¸­å¿ƒè¿›è¡Œç”Ÿæˆï¼Œä»¥ä¾¿AIäº†è§£è¦ä¸ºå“ªä¸ªè§’è‰²ç”Ÿæˆå•†å“ã€‚");
        return;
    }
    const chat = state.chats[state.activeChatId];

    const confirmed = await showCustomConfirm(
        `ä¸ºâ€œ${chat.name}â€ç”Ÿæˆå•†å“ï¼Ÿ`,
        'æ­¤æ“ä½œå°†ä½¿ç”¨AIç”Ÿæˆæ–°çš„å•†å“å’Œåˆ†ç±»ï¼Œå¹¶ã€æ·»åŠ ã€‘åˆ°çŽ°æœ‰åˆ—è¡¨ä¸­ã€‚ç¡®å®šè¦ç»§ç»­å—ï¼Ÿ',
        { confirmText: 'ç¡®è®¤ç”Ÿæˆ' }
    );

    if (!confirmed) return;

    await showCustomAlert("è¯·ç¨å€™...", `æ­£åœ¨æ ¹æ®â€œ${chat.name}â€çš„ç‰¹ç‚¹ç”Ÿæˆä¸“å±žå•†å“...`);


    const useSecondaryApi = state.apiConfig.secondaryProxyUrl && state.apiConfig.secondaryApiKey && state.apiConfig.secondaryModel;
    const { proxyUrl, apiKey, model } = useSecondaryApi 
        ? { proxyUrl: state.apiConfig.secondaryProxyUrl, apiKey: state.apiConfig.secondaryApiKey, model: state.apiConfig.secondaryModel } 
        : state.apiConfig;

    if (!proxyUrl || !apiKey || !model) {
        await showCustomAlert("APIæœªé…ç½®", "è¯·å…ˆåœ¨APIè®¾ç½®ä¸­é…ç½®å¥½ï¼ˆä¸»æˆ–å‰¯ï¼‰APIã€‚");
        return;
    }

    const categoryCount = state.globalSettings.shoppingCategoryCount || 3;
    const productCount = state.globalSettings.shoppingProductCount || 8;

const existingCategories = await db.shoppingCategories.toArray();
    let existingCategoriesContext = "";
    if (existingCategories.length > 0) {
        existingCategoriesContext = `
# ã€åˆ†ç±»å¤ç”¨é“å¾‹ (æœ€é«˜ä¼˜å…ˆçº§ï¼)ã€‘
åœ¨ä¸ºæ–°å•†å“æŒ‡å®šåˆ†ç±»æ—¶ï¼Œä½ ã€å¿…é¡»ã€‘é¦–å…ˆæ£€æŸ¥ä¸‹é¢çš„â€œå·²æœ‰åˆ†ç±»åˆ—è¡¨â€ã€‚
-   å¦‚æžœä¸€ä¸ªæ–°å•†å“å¯ä»¥è¢«å½’å…¥æŸä¸ªã€å·²å­˜åœ¨çš„åˆ†ç±»ã€‘ï¼Œä½ ã€å¿…é¡»ã€‘å¤ç”¨é‚£ä¸ªåˆ†ç±»çš„åç§°ï¼Œè€Œä¸æ˜¯åˆ›é€ ä¸€ä¸ªç›¸ä¼¼çš„æ–°åˆ†ç±»ï¼
-   åªæœ‰å½“ä½ ç¡®å®šå•†å“ã€ç»å¯¹ã€‘ä¸å±žäºŽä»»ä½•ä¸€ä¸ªå·²æœ‰åˆ†ç±»æ—¶ï¼Œä½ æ‰èƒ½åˆ›é€ ä¸€ä¸ªæ–°çš„åˆ†ç±»åç§°ã€‚
-   **å·²æœ‰åˆ†ç±»åˆ—è¡¨**: [${existingCategories.map(c => `"${c.name}"`).join(', ')}]
`;
    }    
 
    const userNickname = state.qzoneSettings.nickname || 'æˆ‘';
    const longTermMemoryContext = chat.longTermMemory && chat.longTermMemory.length > 0
    ? chat.longTermMemory.map(mem => `- (è®°å½•äºŽ ${formatTimeAgo(mem.timestamp)}) ${mem.content}`).join('\n')
    : 'æ— ';
    const recentHistoryContext = chat.history.slice(-10).map(msg => 
        `${msg.role === 'user' ? userNickname : chat.name}: ${String(msg.content).substring(0, 30)}...`
    ).join('\n');

    let worldBookContext = '';
    if (chat.settings.linkedWorldBookIds && chat.settings.linkedWorldBookIds.length > 0) {
        const linkedContents = chat.settings.linkedWorldBookIds.map(bookId => {
            const worldBook = state.worldBooks.find(wb => wb.id === bookId);
            if (!worldBook || !Array.isArray(worldBook.content)) return '';
            const enabledEntries = worldBook.content
                .filter(entry => entry.enabled !== false)
                .map(entry => `- ${entry.content}`)
                .join('\n');
            return enabledEntries ? `\n## æ¥è‡ªã€Š${worldBook.name}ã€‹:\n${enabledEntries}` : '';
        }).filter(Boolean).join('');

        if (linkedContents) {
            worldBookContext = `\n# ä¸–ç•Œè§‚è®¾å®š (å¿…é¡»å‚è€ƒ)\n${linkedContents}\n`;
        }
    }

    const systemPrompt = `
# ä½ çš„ä»»åŠ¡
ä½ æ˜¯ä¸€ä¸ªè™šæ‹Ÿçš„ã€æžå…·åˆ›é€ åŠ›çš„å•†å“è§„åˆ’å¸ˆã€‚ä½ çš„ä»»åŠ¡æ˜¯ä¸ºä¸‹é¢çš„è§’è‰²â€œ${chat.name}â€é‡èº«æ‰“é€ ä¸€ä¸ªä¸“å±žçš„å•†å“åˆ—è¡¨ã€‚

# æ ¸å¿ƒè§„åˆ™
1.  **ã€è§’è‰²å®šåˆ¶(æœ€é«˜ä¼˜å…ˆçº§)ã€‘**: ä½ ç”Ÿæˆçš„æ‰€æœ‰å•†å“å’Œåˆ†ç±»ã€å¿…é¡»ã€‘æ·±åº¦ç»‘å®šè§’è‰²çš„æ€§æ ¼ã€è®°å¿†å’Œæœ€è¿‘çš„å¯¹è¯ã€‚å®ƒä»¬åº”è¯¥æ˜¯è§’è‰²ä¼šçœŸæ­£æ„Ÿå…´è¶£ã€è´­ä¹°æˆ–åˆ¶ä½œçš„ä¸œè¥¿ã€‚
2.  **åˆ›é€ æ€§ä¸Žåˆç†æ€§**: å•†å“å’Œåˆ†ç±»å¿…é¡»åˆç†ä¸”å¤šæ ·åŒ–ã€‚
3.  **æ ¼å¼é“å¾‹ (æœ€é«˜ä¼˜å…ˆçº§)**: 
    - ä½ çš„å›žå¤ã€å¿…é¡»ä¸”åªèƒ½ã€‘æ˜¯ä¸€ä¸ªã€å•ä¸€çš„JSONå¯¹è±¡ã€‘ã€‚
    - ä½ çš„å›žå¤å¿…é¡»ä»¥ \`{\` å¼€å§‹ï¼Œå¹¶ä»¥ \`}\` ç»“æŸã€‚
    - ã€ç»å¯¹ç¦æ­¢ã€‘åœ¨JSONå¯¹è±¡å‰åŽæ·»åŠ ä»»ä½•å¤šä½™çš„æ–‡å­—ã€è§£é‡Šæˆ– markdown æ ‡è®°ã€‚
    - æ ¼å¼ã€å¿…é¡»ã€‘å¦‚ä¸‹:
    \`\`\`json
    {
      "categories": [
        {
          "name": "åˆ†ç±»åç§°1",
          "products": [
            {
              "name": "å•†å“åç§°1",
              "price": 99.80,
              "description": "è¿™æ˜¯å•†å“çš„è¯¦ç»†æè¿°ï¼Œä¸å°‘äºŽ50å­—...",
              "variations": [
                { "name": "æ¬¾å¼1", "price": 108.80, "image_prompt": "æ¬¾å¼1çš„å›¾ç‰‡ã€è‹±æ–‡ã€‘å…³é”®è¯..." },
                { "name": "æ¬¾å¼2", "price": 118.80, "image_prompt": "æ¬¾å¼2çš„å›¾ç‰‡ã€è‹±æ–‡ã€‘å…³é”®è¯..." }
              ],
              "image_prompt": "å•†å“ä¸»å›¾çš„ã€è‹±æ–‡ã€‘å…³é”®è¯, é£Žæ ¼ä¸º realistic product photo, high quality, on a clean white background"
            }
          ]
        }
      ]
    }
    \`\`\`
    - **categories**: ç”Ÿæˆ ${categoryCount} ä¸ªåˆ†ç±»ã€‚
    - **products**: æ¯ä¸ªåˆ†ç±»ä¸‹ç”Ÿæˆ ${productCount} ä¸ªå•†å“ã€‚
    - **variations**: æ¯ä¸ªå•†å“ã€å¿…é¡»ã€‘åŒ…å«ã€2åˆ°4ä¸ªã€‘ä¸åŒçš„æ¬¾å¼ã€‚

# è§’è‰²ä¸Žä¸Šä¸‹æ–‡ (ä½ çš„çµæ„Ÿæ¥æº)
- **è§’è‰²åç§°**: ${chat.name}
- **è§’è‰²äººè®¾**: ${chat.settings.aiPersona}
- **é•¿æœŸè®°å¿†**: ${longTermMemoryContext}
- **ä¸–ç•Œä¹¦è®¾å®š**: ${worldBookContext}
${existingCategoriesContext}
- **æœ€è¿‘å¯¹è¯æ‘˜è¦**:
${recentHistoryContext}

çŽ°åœ¨ï¼Œè¯·æ ¹æ®ä»¥ä¸Šã€æ‰€æœ‰ä¸Šä¸‹æ–‡ä¿¡æ¯ã€‘ï¼Œå¼€å§‹ä¸ºâ€œ${chat.name}â€ç”Ÿæˆè¿™ç»„ã€ä¸Žè§’è‰²é«˜åº¦ç›¸å…³ã€‘çš„å•†å“æ•°æ®ã€‚`;

    try {
        const messagesForApi = [{ role: 'user', content: "è¯·æ ¹æ®ä»¥ä¸Šè®¾å®šï¼Œç”Ÿæˆå•†å“æ•°æ®ã€‚" }];
        let isGemini = proxyUrl.includes('generativelanguage');
        // 3. ã€æ ¸å¿ƒæ–°å¢žã€‘è°ƒç”¨ toGeminiRequestData æ¥è‡ªåŠ¨ç»‘å®šæ¸©åº¦å€¼
        let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi);
        
        const response = isGemini 
            ? await fetch(geminiConfig.url, geminiConfig.data) 
            : await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                body: JSON.stringify({
                    model: model,
                    messages: [{role: 'system', content: systemPrompt}, ...messagesForApi],
                    // 4. ã€æ ¸å¿ƒæ–°å¢žã€‘ä¸ºOpenAIå…¼å®¹APIä¹Ÿç»‘å®šæ¸©åº¦å€¼
                    temperature: state.globalSettings.apiTemperature || 0.9
                })
            });

        if (!response.ok) throw new Error(`API é”™è¯¯: ${response.statusText}`);
        
        const data = await response.json();
        const aiResponseContent = getGeminiResponseText(data);
        
        const jsonMatch = aiResponseContent.match(/({[\s\S]*})/);
        if (!jsonMatch) throw new Error("AIè¿”å›žçš„å†…å®¹ä¸­æœªæ‰¾åˆ°æœ‰æ•ˆçš„JSONå¯¹è±¡ã€‚");
        const generatedData = JSON.parse(jsonMatch[0]);

        if (!generatedData.categories || !Array.isArray(generatedData.categories)) {
            throw new Error("AIè¿”å›žçš„JSONæ ¼å¼ä¸æ­£ç¡®ï¼Œç¼ºå°‘ 'categories' æ•°ç»„ã€‚");
        }

        // (å¢žé‡æ·»åŠ é€»è¾‘ä¿æŒä¸å˜)
        await db.transaction('rw', db.shoppingProducts, db.shoppingCategories, async () => {
            for (const category of generatedData.categories) {
                let categoryId;
                const existingCategory = await db.shoppingCategories.where('name').equalsIgnoreCase(category.name).first();
                if (existingCategory) {
                    categoryId = existingCategory.id;
                } else {
                    categoryId = await db.shoppingCategories.add({ name: category.name });
                }
                const productsToAdd = category.products.map(product => {
                    return {
                        name: product.name,
                        price: product.price || 0,
                        description: product.description || '',
                        imageUrl: `https://image.pollinations.ai/prompt/${encodeURIComponent(product.image_prompt)}`,
                        variations: (product.variations || []).map(v => ({
                            ...v,
                            imageUrl: `https://image.pollinations.ai/prompt/${encodeURIComponent(v.image_prompt)}`
                        })),
                        categoryId: categoryId
                    };
                });
                if (productsToAdd.length > 0) {
                    await db.shoppingProducts.bulkAdd(productsToAdd);
                }
            }
        });

        activeShoppingCategoryId = 'all';
        await renderShoppingProducts();
        await showCustomAlert('ç”ŸæˆæˆåŠŸï¼', `ä¸ºâ€œ${chat.name}â€é‡èº«å®šåˆ¶çš„å•†å“å·²ä¸Šæž¶ï¼`);

    } catch (error) {
        console.error("ç”Ÿæˆè´­ç‰©ä¸­å¿ƒå•†å“å¤±è´¥:", error);
        await showCustomAlert("ç”Ÿæˆå¤±è´¥", `æ— æ³•ç”Ÿæˆå•†å“ï¼Œè¯·æ£€æŸ¥(ä¸»/å‰¯)APIé…ç½®æˆ–ç¨åŽå†è¯•ã€‚\né”™è¯¯: ${error.message}`);
    }
}
  

/**
 * ã€æ€»å…¥å£ã€‘å¤„ç†ç”¨æˆ·ç‚¹å‡»å°ç»„ä»¶æ›´æ¢å›¾ç‰‡çš„é€»è¾‘
 * @param {string} imageId - è¢«ç‚¹å‡»çš„å›¾ç‰‡å…ƒç´ çš„ID
 */
async function handleWidgetImageChange(imageId) {
    const element = document.getElementById(imageId);
    if (!element) return;

    
    const choice = await showChoiceModal("æ›´æ¢å›¾ç‰‡", [
        { text: 'ðŸ“ ä»Žæœ¬åœ°ä¸Šä¼ ', value: 'local' },
        { text: 'ðŸŒ ä½¿ç”¨ç½‘ç»œURL', value: 'url' }
    ]);

    let newUrl = null;

    
    if (choice === 'local') {
        
        newUrl = await uploadImageLocally();
    } else if (choice === 'url') {
        
        newUrl = await showCustomPrompt("æ›´æ¢å›¾ç‰‡", "è¯·è¾“å…¥æ–°çš„å›¾ç‰‡URLï¼š", element.src, "url");
    }

    
    if (newUrl && newUrl.trim()) {
        const trimmedUrl = newUrl.trim();
        
        
        element.src = trimmedUrl;
        
        
        if (!state.globalSettings.widgetData) {
            state.globalSettings.widgetData = {};
        }
        state.globalSettings.widgetData[imageId] = trimmedUrl;
        
        
        await db.globalSettings.put(state.globalSettings);
        
        
        await showCustomAlert("æˆåŠŸ", "ç»„ä»¶å›¾ç‰‡å·²æ›´æ–°ï¼");
    }
}


window.handleWidgetImageChange = handleWidgetImageChange;
/**
 * ã€å…¨æ–°ã€‘å¯¼å‡ºä¸ºåˆ†ç‰‡åŽ‹ç¼©åŒ… (Sliced ZIP Export)
 * å°†æ•°æ®åº“æ‰“åŒ…æˆä¸€ä¸ªZIPæ–‡ä»¶ï¼Œå…¶ä¸­åŒ…å«å¤šä¸ª < 100MB çš„ JSON åˆ‡ç‰‡ã€‚
 * è¿™äº›åˆ‡ç‰‡æ–‡ä»¶å¯ä»¥è¢«â€œå¢žé‡å¯¼å…¥â€åŠŸèƒ½ï¼ˆé€‰æ‹©æ€§å¯¼å…¥ï¼‰è¯†åˆ«ã€‚
 */
async function exportDataAsSlicedZip() {
    // 1. æ£€æŸ¥æ‰€éœ€çš„æ ¸å¿ƒåº“
    if (!window.streamSaver || typeof JSZip === 'undefined') {
        await showCustomAlert("åº“åŠ è½½å¤±è´¥", "æ— æ³•å¯åŠ¨å¯¼å‡ºï¼Œæ‰€éœ€çš„æ ¸å¿ƒåº“ (StreamSaver.js æˆ– JSZip) æœªåŠ è½½ã€‚è¯·æ£€æŸ¥æ‚¨çš„ç½‘ç»œè¿žæŽ¥å¹¶åˆ·æ–°é¡µé¢åŽé‡è¯•ã€‚");
        return;
    }

    await showCustomAlert("æ­£åœ¨å‡†å¤‡åˆ†ç‰‡å¯¼å‡º...", "å³å°†å¼€å§‹æ‰“åŒ…æ‚¨çš„å®Œæ•´å¤‡ä»½æ–‡ä»¶ã€‚æ–‡ä»¶å°†ä»¥ZIPæ ¼å¼æµå¼ä¸‹è½½ï¼Œè¯·å‹¿å…³é—­é¡µé¢ã€‚");

    // 2. åˆå§‹åŒ–ZIPå’Œæµå¼ä¸‹è½½å™¨
    const fileStream = streamSaver.createWriteStream(`EPhone-Sliced-Backup-${new Date().toISOString().split('T')[0]}.zip`);
    const zip = new JSZip();
    
    // 3. è®¾ç½®åˆ‡ç‰‡å¤§å°é™åˆ¶ (95MBï¼Œä¸ºJSONåºåˆ—åŒ–å’Œå…¶ä»–å¼€é”€ç•™å‡ºä½™åœ°)
    const MAX_SLICE_SIZE = 95 * 1024 * 1024; 
    let sliceIndex = 1;
    let currentSliceData = {}; // ç”¨äºŽå­˜æ”¾å½“å‰åˆ‡ç‰‡çš„æ•°æ®
    let currentSliceSizeBytes = 0;
    const encoder = new TextEncoder(); // ç”¨äºŽç²¾ç¡®è®¡ç®—å­—èŠ‚å¤§å°

    try {
        const tablesToBackup = db.tables.map(t => t.name);

        for (const tableName of tablesToBackup) {
            console.log(`æ­£åœ¨æ‰“åŒ…è¡¨: ${tableName}...`);
            const tableData = await db.table(tableName).toArray();
            
            // å¦‚æžœè¡¨æ˜¯ç©ºçš„ï¼Œè·³è¿‡
            if (tableData.length === 0) continue; 

            const tableDataString = JSON.stringify(tableData);
            const tableDataSize = encoder.encode(tableDataString).length; // ä¼°ç®—å®žé™…å­—èŠ‚

            // 4. å¤„ç†æžç«¯æƒ…å†µï¼šå•ä¸ªè¡¨å°±è¶…è¿‡äº†100MB
            if (tableDataSize > MAX_SLICE_SIZE) {
                console.warn(`è­¦å‘Šï¼šè¡¨ "${tableName}" (å¤§å°: ${(tableDataSize/1024/1024).toFixed(2)}MB) å•ç‹¬è¶…è¿‡äº†åˆ‡ç‰‡é™åˆ¶ã€‚`);
                
                // a. å¦‚æžœå½“å‰åˆ‡ç‰‡å·²æœ‰å†…å®¹ï¼Œå…ˆå°†å®ƒä»¬ä¿å­˜
                if (currentSliceSizeBytes > 0) {
                    zip.file(`slice_${sliceIndex++}.json`, JSON.stringify({ version: 4, type: 'slice', data: currentSliceData }));
                    currentSliceData = {};
                    currentSliceSizeBytes = 0;
                }
                
                // b. å°†è¿™ä¸ªè¶…å¤§çš„è¡¨å•ç‹¬å­˜ä¸ºä¸€ä¸ªåˆ‡ç‰‡
                currentSliceData[tableName] = tableData;
                zip.file(`slice_${sliceIndex++}.json`, JSON.stringify({ version: 4, type: 'slice', data: currentSliceData }));
                currentSliceData = {}; // é‡ç½®
                currentSliceSizeBytes = 0;
                
                continue; // ç»§ç»­å¤„ç†ä¸‹ä¸€ä¸ªè¡¨
            }

            // 5. æ£€æŸ¥æ˜¯å¦éœ€è¦å¼€å§‹ä¸€ä¸ªæ–°åˆ‡ç‰‡
            // ï¼ˆå¦‚æžœå½“å‰åˆ‡ç‰‡å·²æœ‰æ•°æ®ï¼Œå¹¶ä¸”åŠ å…¥æ–°è¡¨åŽä¼šè¶…é™ï¼‰
            if (currentSliceSizeBytes > 0 && (currentSliceSizeBytes + tableDataSize > MAX_SLICE_SIZE)) {
                console.log(`åˆ‡ç‰‡ ${sliceIndex} å·²æ»¡ (å¤§å°: ${(currentSliceSizeBytes/1024/1024).toFixed(2)}MB)ï¼Œæ­£åœ¨å½’æ¡£...`);
                
                // å°†å½“å‰åˆ‡ç‰‡æ•°æ®æ‰“åŒ…æˆä¸€ä¸ªæ–‡ä»¶ï¼Œæ·»åŠ åˆ°ZIPä¸­
                zip.file(`slice_${sliceIndex++}.json`, JSON.stringify({ 
                    version: 4, 
                    type: 'slice', 
                    data: currentSliceData 
                }));
                
                // é‡ç½®åˆ‡ç‰‡
                currentSliceData = {};
                currentSliceSizeBytes = 0;
            }

            // 6. å°†å½“å‰è¡¨æ•°æ®æ·»åŠ åˆ°åˆ‡ç‰‡ä¸­
            currentSliceData[tableName] = tableData;
            currentSliceSizeBytes += tableDataSize;
        }

        // 7. ä¿å­˜æœ€åŽä¸€ä¸ªåˆ‡ç‰‡ï¼ˆå¦‚æžœè¿˜æœ‰å†…å®¹ï¼‰
        if (currentSliceSizeBytes > 0) {
            console.log(`æ­£åœ¨å½’æ¡£æœ€åŽä¸€ä¸ªåˆ‡ç‰‡ ${sliceIndex} (å¤§å°: ${(currentSliceSizeBytes/1024/1024).toFixed(2)}MB)...`);
            zip.file(`slice_${sliceIndex}.json`, JSON.stringify({ 
                version: 4, 
                type: 'slice', 
                data: currentSliceData 
            }));
        }
        
        console.log("æ‰€æœ‰åˆ‡ç‰‡å·²æ‰“åŒ…ï¼Œå¼€å§‹æµå¼ä¸‹è½½ZIP...");

        // 8. ä½¿ç”¨ JSZip çš„æµå¼ç”Ÿæˆ (è¿™æ˜¯æœ€å…³é”®çš„ï¼Œé˜²æ­¢æµè§ˆå™¨å› æ‰“åŒ…å·¨å¤§ZIPè€Œå´©æºƒ)
        const zipStream = zip.generateInternalStream({ 
            type: "blob",      // è¾“å‡º Blob å—
            streamFiles: true  // å‘Šè¯‰ JSZip æµå¼å¤„ç†æ–‡ä»¶å†…å®¹
        });

        // 9. å°† JSZip çš„æµåŒ…è£…æˆ Web ReadableStream
        const readableStream = new ReadableStream({
            start(controller) {
                zipStream.on('data', (chunk) => {
                    // å°† JSZip äº§å‡ºçš„æ•°æ®å—(chunk)æ”¾å…¥æµä¸­
                    controller.enqueue(chunk);
                }).on('end', () => {
                    // JSZip å®Œæˆï¼Œå…³é—­æµ
                    console.log("ZIP æµç”Ÿæˆå®Œæ¯•ã€‚");
                    controller.close();
                }).on('error', (err) => {
                    // JSZip å‡ºé”™ï¼ŒæŠ¥é”™
                    console.error("JSZip æµé”™è¯¯:", err);
                    controller.error(err);
                }).resume(); // å¯åŠ¨ JSZip æµ
            }
        });

        // 10. å°† ReadableStream ç®¡é“ä¼ è¾“åˆ° StreamSaver çš„æ–‡ä»¶æµ
        await readableStream.pipeTo(fileStream);

        // 11. æˆåŠŸæç¤ºï¼ˆæ³¨æ„ï¼šè¿™ä¸ªæç¤ºå¯èƒ½åœ¨ä¸‹è½½å®Œæˆå‰å°±å¼¹å‡ºï¼Œå› ä¸ºæ˜¯æµå¼ï¼‰
        await showCustomAlert('å¯¼å‡ºå·²å¼€å§‹', 'æ‚¨çš„åˆ†ç‰‡å¤‡ä»½å·²å¼€å§‹ä¸‹è½½ã€‚è§£åŽ‹åŽï¼Œæ‚¨å¯ä»¥ä½¿ç”¨â€œå¯¼å…¥â€åŠŸèƒ½ï¼Œé€‰æ‹©å…¶ä¸­çš„ `slice_X.json` æ–‡ä»¶è¿›è¡Œå¢žé‡æ¢å¤ã€‚');

    } catch (error) {
        console.error("åˆ†ç‰‡å¯¼å‡ºè¿‡ç¨‹ä¸­å‡ºé”™:", error);
        await showCustomAlert('å¯¼å‡ºå¤±è´¥', `åœ¨æ‰“åŒ…æˆ–å†™å…¥æ–‡ä»¶æµæ—¶å‘ç”Ÿé”™è¯¯: ${error.message}`);
        
        // å°è¯•ä¸­æ­¢æµ
        try {
            const writer = fileStream.getWriter();
            writer.abort(error);
        } catch (e) {}
    }
}
/**
 * ä½¿ç”¨æµå¼ä¼ è¾“ï¼Œå°†æ‰€æœ‰æ•°æ®å¯¼å‡ºåˆ°ä¸€ä¸ªå¤§æ–‡ä»¶ä¸­
 */
async function exportDataAsStream() {
    
    if (!window.streamSaver) {
        alert("æµå¼ä¸‹è½½åº“ (StreamSaver.js) æœªåŠ è½½ã€‚è¯·æ£€æŸ¥ç½‘ç»œè¿žæŽ¥æˆ–HTMLæ–‡ä»¶é…ç½®ã€‚");
        return;
    }
    
    await showCustomAlert("æ­£åœ¨å‡†å¤‡...", "å³å°†å¼€å§‹ä¸‹è½½æ‚¨çš„å®Œæ•´å¤‡ä»½æ–‡ä»¶ã€‚ä¸‹è½½è¿‡ç¨‹ä¸­è¯·å‹¿å…³é—­é¡µé¢ã€‚");
    
    
    const fileStream = streamSaver.createWriteStream(`EPhone-Full-Backup-Streamed-${new Date().toISOString().split('T')[0]}.json`);
    const writer = fileStream.getWriter();
    const encoder = new TextEncoder(); 

    try {
        
        await writer.write(encoder.encode('{\n"version": 3,\n"timestamp": ' + Date.now() + ',\n"data": {\n'));

        const tablesToBackup = await db.tables.map(t => t.name);
        
        for (let i = 0; i < tablesToBackup.length; i++) {
            const tableName = tablesToBackup[i];
            const table = db.table(tableName);

            
            await writer.write(encoder.encode(`"${tableName}": [\n`));
            
            let isFirstRecordInTable = true;
            
            await table.each(record => {
                if (!isFirstRecordInTable) {
                    writer.write(encoder.encode(',\n'));
                }
                
                writer.write(encoder.encode(JSON.stringify(record)));
                isFirstRecordInTable = false;
            });

            
            await writer.write(encoder.encode('\n]'));
            if (i < tablesToBackup.length - 1) {
                
                await writer.write(encoder.encode(',\n'));
            }
        }

        
        await writer.write(encoder.encode('\n}\n}'));
        
    } catch (error) {
        console.error("æµå¼å¯¼å‡ºè¿‡ç¨‹ä¸­å‡ºé”™:", error);
        await showCustomAlert('å¯¼å‡ºå¤±è´¥', `åœ¨å†™å…¥æ–‡ä»¶æµæ—¶å‘ç”Ÿé”™è¯¯: ${error.message}`);
    } finally {
        
        await writer.close();
    }
}
/**
 * ã€å…¨æ–°ã€‘ä½¿ç”¨ä¼ ç»ŸBlobæ–¹å¼ï¼Œå°†æ‰€æœ‰æ•°æ®å¯¼å‡ºåˆ°ä¸€ä¸ªæ–‡ä»¶ä¸­ï¼ˆä½œä¸ºå¤‡ç”¨æ–¹æ¡ˆï¼‰
 */
async function exportDataAsBlob() {
    await showCustomAlert("æ­£åœ¨å‡†å¤‡...", "æ­£åœ¨è¯»å–æ‰€æœ‰æ•°æ®åˆ°å†…å­˜ä¸­ï¼Œè¯·ç¨å€™...");

    try {
        const backupData = {
            version: 3, 
            timestamp: Date.now(),
            data: {} 
        };

        const tablesToBackup = db.tables.map(t => t.name);

        for (const tableName of tablesToBackup) {
            const tableData = await db.table(tableName).toArray();
            backupData.data[tableName] = tableData;
            console.log(`å·²æ‰“åŒ…è¡¨: ${tableName}, è®°å½•æ•°: ${tableData.length}`);
        }
        
        const blob = new Blob(
            [JSON.stringify(backupData, null, 2)], 
            { type: 'application/json' }
        );
        
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = `EPhone-Full-Backup-Legacy-${new Date().toISOString().split('T')[0]}.json`;
        link.click();
        URL.revokeObjectURL(url);
        
        await showCustomAlert('å¯¼å‡ºæˆåŠŸ', 'å·²æˆåŠŸå¯¼å‡ºæ‰€æœ‰æ•°æ®ï¼');

    } catch (error) {
        console.error("ä¼ ç»Ÿå¯¼å‡ºæ•°æ®æ—¶å‡ºé”™:", error);
        await showCustomAlert('å¯¼å‡ºå¤±è´¥', `å‘ç”Ÿäº†ä¸€ä¸ªé”™è¯¯: ${error.message}`);
    }
}

        function updateBackButtonUnreadCount() {
            
            const totalChatUnread = Object.values(state.chats).reduce((sum, chat) => {
                
                if (chat.id === state.activeChatId) {
                    return sum;
                }
                return sum + (chat.unreadCount || 0);
            }, 0);

            
            const totalQzoneUnread = unreadPostsCount || 0;
            
            
            const totalUnread = totalChatUnread + totalQzoneUnread;

            
            const backBtn = document.getElementById('back-to-list-btn');
            if (!backBtn) return;

            
            
            let indicator = backBtn.querySelector('.unread-indicator');
            if (!indicator) {
                indicator = document.createElement('span');
                indicator.className = 'unread-indicator';
                backBtn.appendChild(indicator);
            }
            
            
            let qzoneIndicator = backBtn.querySelector('.unread-indicator.back-btn-indicator');
            if (qzoneIndicator) {
                qzoneIndicator.remove();
            }

            
            if (totalUnread > 0) {
                indicator.textContent = totalUnread > 99 ? '99+' : totalUnread;
                indicator.style.display = 'block';
                
                indicator.style.zIndex = '20'; 
                indicator.style.transform = 'scale(0.8)';
            } else {
                indicator.style.display = 'none';
            }
        }

async function openStickerCategoryBindingModal(categoryId) {
    const category = categoryId === 'uncategorized'
        ? { id: 'uncategorized', name: 'æœªåˆ†ç±»' }
        : await db.stickerCategories.get(categoryId);

    if (!category) {
        console.error("æ— æ³•ä¸ºä¸å­˜åœ¨çš„åˆ†ç±»æ‰“å¼€ç»‘å®šæ¨¡æ€æ¡†:", categoryId);
        return;
    }

    const modal = document.getElementById('sticker-binding-modal');
    const listEl = document.getElementById('sticker-binding-chat-list');
    const header = modal.querySelector('.modal-header span');
    listEl.innerHTML = '';
    header.textContent = `å°†åˆ†ç±» â€œ${category.name}â€ ç»‘å®šåˆ°...`;

    const allChats = Object.values(state.chats).sort((a, b) => a.name.localeCompare(b.name, 'zh-CN'));

    allChats.forEach(chat => {

        const isChecked = Array.isArray(chat.settings?.stickerCategoryIds) && chat.settings.stickerCategoryIds.includes(categoryId);
      
        const item = document.createElement('div');
        item.className = 'contact-picker-item'; // å¤ç”¨çŽ°æœ‰æ ·å¼
        item.innerHTML = `
            <input type="checkbox" class="sticker-binding-checkbox" data-chat-id="${chat.id}" ${isChecked ? 'checked' : ''} style="margin-right: 15px;">
            <img src="${chat.isGroup ? chat.settings.groupAvatar : chat.settings.aiAvatar || defaultAvatar}" class="avatar">
            <span class="name">${chat.name}</span>
        `;
        listEl.appendChild(item);
    });


    document.getElementById('save-sticker-binding-btn').onclick = () => saveStickerCategoryBindings(categoryId);
    document.getElementById('cancel-sticker-binding-btn').onclick = () => modal.classList.remove('visible');

    modal.classList.add('visible');
}


async function saveStickerCategoryBindings(categoryId) {
    const selectedChatIds = new Set(
        Array.from(document.querySelectorAll('#sticker-binding-chat-list .sticker-binding-checkbox:checked'))
             .map(cb => cb.dataset.chatId)
    );

    const chatsToUpdate = [];
    for (const chatId in state.chats) {
        const chat = state.chats[chatId];
if (!Array.isArray(chat.settings.stickerCategoryIds)) {
            chat.settings.stickerCategoryIds = [];
        }

        // V-Change: æ£€æŸ¥æ•°ç»„ä¸­æ˜¯å¦å·²åŒ…å«
        const wasBound = chat.settings.stickerCategoryIds.includes(categoryId);
        const shouldBeBound = selectedChatIds.has(chatId);

        if (wasBound && !shouldBeBound) {
            // V-Change: ä»Žæ•°ç»„ä¸­ç§»é™¤
            chat.settings.stickerCategoryIds = chat.settings.stickerCategoryIds.filter(id => id !== categoryId);
            chatsToUpdate.push(chat);
        } else if (!wasBound && shouldBeBound) {
            // V-Change: å‘æ•°ç»„ä¸­æ·»åŠ 
            chat.settings.stickerCategoryIds.push(categoryId);
            chatsToUpdate.push(chat);
        }
    }

    if (chatsToUpdate.length > 0) {
        await db.chats.bulkPut(chatsToUpdate);
        await showCustomAlert("ä¿å­˜æˆåŠŸ", "è¡¨æƒ…åŒ…åˆ†ç±»ç»‘å®šå·²æ›´æ–°ï¼");
    }

    document.getElementById('sticker-binding-modal').classList.remove('visible');
}


function getStickerContextForPrompt(chat) {
if (!chat || !chat.settings.stickerCategoryIds || chat.settings.stickerCategoryIds.length === 0) {
        return '';
    }

    const categoryIds = chat.settings.stickerCategoryIds;
    let allStickers = [];
    const addedStickerNames = new Set(); // ç”¨äºŽé˜²æ­¢åˆ†ç±»é‡å å¯¼è‡´è¡¨æƒ…é‡å¤

    // V-Change: éåŽ†æ‰€æœ‰ç»‘å®šçš„åˆ†ç±»ID
    categoryIds.forEach(categoryId => {
        let stickersInCategory;

        if (categoryId === 'uncategorized') {
            stickersInCategory = state.userStickers.filter(s => !s.categoryId);
        } else {
            stickersInCategory = state.userStickers.filter(s => s.categoryId === categoryId);
        }
        
        // V-Change: åˆå¹¶æ‰€æœ‰è¡¨æƒ…
        stickersInCategory.forEach(sticker => {
            if (!addedStickerNames.has(sticker.name)) {
                allStickers.push(sticker);
                addedStickerNames.add(sticker.name);
            }
        });
    });

    if (allStickers.length === 0) {
        return '';
    }

    const stickerList = allStickers.map(s => `- ${s.name}`).join('\n');
    return `
# å¯ç”¨è¡¨æƒ…åŒ… (ä¼˜å…ˆä½¿ç”¨)
- è¯·æ ¹æ®å½“å‰æƒ…æ™¯å’Œä½ çš„æƒ…ç»ªï¼Œä»Žåˆ—è¡¨ä¸­ã€é€‰æ‹©ä¸€ä¸ªæœ€åˆé€‚çš„ã€‘è¡¨æƒ…å«ä¹‰æ¥ä½¿ç”¨ "sticker" æŒ‡ä»¤ã€‚å°½é‡è®©ä½ çš„è¡¨æƒ…ä¸°å¯Œå¤šæ ·ï¼Œé¿å…é‡å¤ã€‚
${stickerList}
`;
}


function getGroupStickerContextForPrompt(chat) {
if (!chat || !chat.isGroup) return '';

    let context = '\n# å¯ç”¨è¡¨æƒ…åŒ… (ä¼˜å…ˆä½¿ç”¨)\næ¯ä¸ªAIè§’è‰²éƒ½è¢«è®¾ç½®äº†ä¸“å±žè¡¨æƒ…åŒ…ï¼Œåœ¨éœ€è¦å‘é€è¡¨æƒ…æ—¶ï¼Œä»–ä»¬åº”è¯¥ã€ä¼˜å…ˆã€‘ä»Žè‡ªå·±çš„ä¸“å±žåˆ—è¡¨ä¸­é€‰æ‹©ã€‚å°½é‡è®©ä½ çš„è¡¨æƒ…ä¸°å¯Œå¤šæ ·ï¼Œé¿å…é‡å¤ã€‚\n';
    let foundAny = false;

    chat.members.forEach(member => {
        if(member.id === 'user') return;

        const memberChat = state.chats[member.id];
        // V-Change: æ£€æŸ¥æ–°çš„æ•°ç»„å±žæ€§
        if (memberChat && memberChat.settings.stickerCategoryIds && memberChat.settings.stickerCategoryIds.length > 0) {
            const categoryIds = memberChat.settings.stickerCategoryIds;
            let allStickersForMember = [];
            const addedStickerNames = new Set(); // é˜²æ­¢é‡å¤

            // V-Change: éåŽ†æ‰€æœ‰ç»‘å®šçš„åˆ†ç±»ID
            categoryIds.forEach(categoryId => {
                let stickersInCategory;

                if (categoryId === 'uncategorized') {
                    stickersInCategory = state.userStickers.filter(s => !s.categoryId);
                } else {
                    stickersInCategory = state.userStickers.filter(s => s.categoryId === categoryId);
                }
                
                // V-Change: åˆå¹¶æ‰€æœ‰è¡¨æƒ…
                stickersInCategory.forEach(sticker => {
                    if (!addedStickerNames.has(sticker.name)) {
                        allStickersForMember.push(sticker);
                        addedStickerNames.add(sticker.name);
                    }
                });
            });
            
            // V-Change: æ£€æŸ¥åˆå¹¶åŽçš„ç»“æžœ
            if (allStickersForMember.length > 0) {
                foundAny = true;
                context += `\n## ${member.groupNickname} (æœ¬å: ${member.originalName}) çš„å¯ç”¨è¡¨æƒ…:\n`;
                context += allStickersForMember.map(s => `- ${s.name}`).join('\n'); // æ·»åŠ åˆå¹¶åŽçš„åˆ—è¡¨
            }
        }
    });

    return foundAny ? context : '';
}
/**
 * ã€å…¨æ–°ã€‘ä¼°ç®—ç»™å®šæ–‡æœ¬çš„Tokenæ•° (ç®€æ˜“ç‰ˆ)
 * @param {string} text - è¦è®¡ç®—çš„æ–‡æœ¬
 * @returns {number} - ä¼°ç®—çš„Tokenæ•°é‡
 */
function estimateTokens(text) {
    if (!text) return 0;
    // è¿™æ˜¯ä¸€ä¸ªéžå¸¸ç²—ç•¥çš„ä¼°ç®—ï¼Œå¯¹äºŽä¸­æ–‡ï¼Œé€šå¸¸ä¸€ä¸ªæ±‰å­—ä¸æ­¢ä¸€ä¸ªtokenã€‚
    // ä½†ä½œä¸ºç›¸å¯¹å‚è€ƒå€¼ï¼Œå­—ç¬¦æ•°/1.5 æ˜¯ä¸€ä¸ªä¸é”™çš„èµ·ç‚¹ã€‚
    return Math.ceil(text.length / 1.5);
}

/**
 * ã€å…¨æ–° | æ ¸å¿ƒã€‘æ ¹æ®å½“å‰èŠå¤©è®¾ç½®ï¼ŒåŠ¨æ€è®¡ç®—å®Œæ•´çš„ä¸Šä¸‹æ–‡Token
 * @returns {Promise<number>} - è¿”å›žä¼°ç®—å‡ºçš„æ€»Tokenæ•°
 */
async function calculateCurrentContextTokens() {
    if (!state.activeChatId) return 0;
    const chat = state.chats[state.activeChatId];
    if (!chat) return 0;

    // ä»Žè®¾ç½®é¡µé¢å®žæ—¶èŽ·å–å€¼ï¼Œè€Œä¸æ˜¯ä»Ž state ä¸­è¯»å–æ—§å€¼
    const maxMemory = parseInt(document.getElementById('max-memory').value) || 10;
    const linkedMemoryCount = parseInt(document.getElementById('linked-memory-count').value) || 10;
    const isOfflineMode = document.getElementById('offline-mode-toggle').checked;
    const aiPersona = document.getElementById('ai-persona').value;
    const myPersona = document.getElementById('my-persona').value;

    let fullContextString = '';

    // è¿™éƒ¨åˆ†é€»è¾‘ä¸Ž triggerAiResponse ä¸­æž„å»º systemPrompt çš„é€»è¾‘å‡ ä¹Žå®Œå…¨ä¸€è‡´
    // ç›®çš„æ˜¯ä¸ºäº†æ¨¡æ‹ŸAIæŽ¥æ”¶åˆ°çš„å®Œæ•´ä¸Šä¸‹æ–‡

    // 1. ä¸–ç•Œä¹¦
    const linkedBookIds = Array.from(document.querySelectorAll('#world-book-checkboxes-container input:checked')).map(cb => cb.value.replace('book_', ''));
    if (linkedBookIds.length > 0) {
        const linkedContents = linkedBookIds.map(bookId => {
            const worldBook = state.worldBooks.find(wb => wb.id === bookId);
            if (!worldBook || !Array.isArray(worldBook.content)) return '';
            return worldBook.content.filter(e => e.enabled !== false).map(e => e.content).join('\n');
        }).filter(Boolean).join('\n');
        fullContextString += linkedContents;
    }

    // 2. é•¿æœŸè®°å¿†
    if (chat.longTermMemory && chat.longTermMemory.length > 0) {
        fullContextString += chat.longTermMemory.map(mem => mem.content).join('\n');
    }

    // 3. æŒ‚è½½è®°å¿†
    const linkedMemoryToggle = document.getElementById('link-memory-toggle').checked;
    if (linkedMemoryToggle) {
        const linkedChatIds = Array.from(document.querySelectorAll('#linked-chats-checkboxes-container input:checked')).map(cb => cb.value);
        for (const linkedId of linkedChatIds) {
            const linkedChat = state.chats[linkedId];
            if (linkedChat && linkedChat.history.length > 0) {
                fullContextString += linkedChat.history.slice(-linkedMemoryCount).map(msg => String(msg.content)).join('\n');
            }
        }
    }

    // 4. äººè®¾
    if (chat.isGroup) {
        chat.members.forEach(member => {
            fullContextString += member.persona;
        });
    } else {
        fullContextString += aiPersona;
    }
    fullContextString += myPersona;

    // 5. è¡¨æƒ…åŒ…
    fullContextString += getStickerContextForPrompt(chat);
    if (chat.isGroup) {
        fullContextString += getGroupStickerContextForPrompt(chat);
    }
    
    // 6. çº¿ä¸‹æ¨¡å¼çš„é¢å¤–Prompt
    if (!chat.isGroup && isOfflineMode) {
        const offlinePresetId = document.getElementById('offline-preset-select').value;
        if (offlinePresetId) {
            const preset = state.presets.find(p => p.id === offlinePresetId);
            if (preset) {
                fullContextString += preset.content.filter(e => e.enabled !== false).map(e => e.content).join('\n');
            }
        }
    }

    // 7. çŸ­æœŸè®°å¿† (å¯¹è¯åŽ†å²)
    const historySlice = chat.history.slice(-maxMemory);
    fullContextString += historySlice.map(msg => {
        if (typeof msg.content === 'string') return msg.content;
        if (Array.isArray(msg.content)) return msg.content.map(p => p.text).join(' ');
        return '';
    }).join('\n');
    
    return estimateTokens(fullContextString);
}


/**
 * ã€å…¨æ–°ã€‘æ›´æ–°Tokenæ•°æ˜¾ç¤ºï¼Œå¹¶æ·»åŠ é˜²æŠ–ä»¥ä¼˜åŒ–æ€§èƒ½
 */
const updateTokenCountDisplay = debounce(async () => {
    const displayEl = document.getElementById('token-count-display');
    if (!displayEl) return;
    displayEl.innerHTML = `
        <span id="token-count-label">æ­£åœ¨è®¡ç®—...</span>
        <span id="token-count-value">--</span>
    `;
    try {
        const tokenCount = await calculateCurrentContextTokens();
        displayEl.innerHTML = `
            <span id="token-count-label">é¢„ä¼°æ€»ä¸Šä¸‹æ–‡Tokenæ•°:</span>
            <span id="token-count-value"><strong> ${tokenCount}</strong> Tokens</span>
        `;
    } catch (error) {
        console.error("Token calculation error:", error);
        displayEl.innerHTML = `
            <span id="token-count-label">é¢„ä¼°æ€»ä¸Šä¸‹æ–‡Tokenæ•°:</span>
            <span id="token-count-value" style="color: red;">è®¡ç®—å‡ºé”™</span>
        `;
    }
}, 300);

/**
 * ã€æ ¸å¿ƒ | V2.0 åˆ†é¡µåŠ è½½ç‰ˆã€‘æ‰“å¼€NAIç”»å»Šï¼ŒèŽ·å–æ•°æ®å¹¶åŠ è½½ç¬¬ä¸€é¡µ
 */
async function openNaiGallery() {
    const gridEl = document.getElementById('nai-gallery-grid');
    gridEl.innerHTML = ''; // å‡†å¤‡æ–°ç”»å»Šæ—¶æ¸…ç©ºæ—§ç½‘æ ¼
    
    // é‡ç½®åˆ†é¡µçŠ¶æ€
    naiGalleryCache = [];
    naiGalleryRenderCount = 0;
    isLoadingMoreNaiImages = false;

    // await showCustomAlert("è¯·ç¨å€™...", "æ­£åœ¨ä»Žæ‰€æœ‰èŠå¤©å’ŒåŠ¨æ€ä¸­æ£€ç´¢NAIå›¾ç‰‡..."); // <-- å·²åˆ é™¤

    const allNaiImages = [];

    // 1. æ‰«ææ‰€æœ‰èŠå¤©è®°å½•
    try {
        const allChats = await db.chats.toArray();
        for (const chat of allChats) {
            if (chat.history && chat.history.length > 0) {
                chat.history.forEach(msg => {
                    if (msg.type === 'naiimag' && msg.imageUrl) {
                        allNaiImages.push({
                            sourceType: 'chat',
                            imageUrl: msg.imageUrl,
                            prompt: msg.prompt || msg.fullPrompt || 'NAI Image',
                            chatId: chat.id,
                            msgTimestamp: msg.timestamp
                        });
                    }
                });
            }
        }
    } catch (e) { console.error("æ‰«æèŠå¤©è®°å½•å¤±è´¥:", e); }

    // 2. æ‰«ææ‰€æœ‰åŠ¨æ€
    try {
        const allPosts = await db.qzonePosts.toArray();
        allPosts.forEach(post => {
            if (post.type === 'naiimag') {
                const urls = post.imageUrls || (post.imageUrl ? [post.imageUrl] : []);
                const prompts = Array.isArray(post.prompt) ? post.prompt : [post.prompt || 'NAI Image'];
                
                urls.forEach((url, index) => {
                    allNaiImages.push({
                        sourceType: 'qzone',
                        imageUrl: url,
                        prompt: prompts[index] || prompts[0],
                        postId: post.id,
                        imageIndex: index
                    });
                });
            }
        });
    } catch (e) { console.error("æ‰«æåŠ¨æ€å¤±è´¥:", e); }

    // 3. å­˜å…¥ç¼“å­˜å¹¶æŽ’åº (æŒ‰æ—¶é—´æˆ³å€’åºï¼Œæœ€æ–°çš„åœ¨æœ€å‰é¢)
    naiGalleryCache = allNaiImages.sort((a, b) => (b.msgTimestamp || b.postId || 0) - (a.msgTimestamp || a.postId || 0));

    // 4. åŠ è½½ç¬¬ä¸€é¡µ
    if (naiGalleryCache.length === 0) {
         gridEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); grid-column: 1 / -1;">ç”»å»Šè¿˜æ˜¯ç©ºçš„ï¼Œå¿«åŽ»ç”Ÿæˆä¸€äº›å›¾ç‰‡å§ï¼</p>';
    } else {
        loadMoreNaiGalleryImages(); // è°ƒç”¨åˆ†é¡µåŠ è½½å‡½æ•°æ¥åŠ è½½ç¬¬ä¸€é¡µ
    }
    
    // 5. æ˜¾ç¤ºé¢æ¿
    document.getElementById('nai-gallery-panel').classList.add('visible');
    // hideCustomModal(); // <-- å·²åˆ é™¤
}
/**
 * æ¸²æŸ“NAIç”»å»Šçš„ç½‘æ ¼ - [åˆ†é¡µåŠ è½½ç‰ˆ]
 * æ­¤å‡½æ•°çŽ°åœ¨åªè´Ÿè´£å°†ä¼ å…¥çš„å›¾ç‰‡è¿½åŠ åˆ°ç½‘æ ¼ä¸­ï¼Œä¸å†æ¸…ç©ºç½‘æ ¼ã€‚
 */
function renderNaiGalleryGrid(images) {
    const gridEl = document.getElementById('nai-gallery-grid');
    // gridEl.innerHTML = ''; // <-- æ­¤è¡Œå·²è¢«ç§»é™¤!

    if (images.length === 0 && naiGalleryRenderCount === 0) { // ä»…åœ¨åˆå§‹åŠ è½½ä¸ºç©ºæ—¶æ˜¾ç¤º
        gridEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); grid-column: 1 / -1;">ç”»å»Šè¿˜æ˜¯ç©ºçš„ï¼Œå¿«åŽ»ç”Ÿæˆä¸€äº›å›¾ç‰‡å§ï¼</p>';
        return;
    }

    const fragment = document.createDocumentFragment(); // ä½¿ç”¨æ–‡æ¡£ç‰‡æ®µæé«˜æ€§èƒ½

    images.forEach((img, i) => {
        const item = document.createElement('div');
        item.className = 'nai-gallery-item'; // è¿™æ˜¯æ–°çš„å¤–å±‚å®¹å™¨
        item.title = img.prompt; 
        
        // ä½¿ç”¨ä¸€ä¸ªå”¯ä¸€çš„keyæ¥è¿›è¡Œé€‰æ‹©å’Œåˆ é™¤
        const itemKey = `${img.sourceType}_${img.chatId || img.postId}_${img.msgTimestamp || img.imageIndex}`;
        item.dataset.key = itemKey;
        item.dataset.imageUrl = img.imageUrl;
        item.dataset.prompt = img.prompt;

        // ã€æ ¸å¿ƒä¿®æ”¹ã€‘
        // æˆ‘ä»¬åˆ›å»ºäº†ä¸€ä¸ª .nai-image-container æ¥æ”¾å›¾ç‰‡ï¼ˆåƒè¡¨æƒ…åŒ…é¢æ¿ä¸€æ ·ï¼‰
        // å¹¶ä¸”åœ¨å®ƒä¸‹é¢æ·»åŠ äº†ä¸€ä¸ª .nai-gallery-name æ¥æ˜¾ç¤º prompt
        item.innerHTML = `
            <div class="nai-image-container" style="background-image: url(${img.imageUrl})">
                <div class="nai-gallery-controls">
                    <button class="nai-gallery-download-btn" title="ä¸‹è½½">
                        <svg viewBox="0 0 24 24" fill="currentColor"><path d="M19 9h-4V3H9v6H5l7 7 7-7zM5 18v2h14v-2H5z"></path></svg>
                    </button>
                    <button class="nai-gallery-delete-btn" title="åˆ é™¤">
                        <svg viewBox="0 0 24 24" fill="currentColor"><path d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z"></path></svg>
                    </button>
                </div>
            </div>
            <span class="nai-gallery-name">${img.prompt}</span>
        `;
        // --- ä¿®æ”¹ç»“æŸ ---

        fragment.appendChild(item); // è¿½åŠ åˆ°æ–‡æ¡£ç‰‡æ®µ
    });
    
    gridEl.appendChild(fragment); // ä¸€æ¬¡æ€§å°†æ‰€æœ‰æ–°å›¾ç‰‡è¿½åŠ åˆ°ç½‘æ ¼
}
/**
 * ã€å…¨æ–°ã€‘åˆ†é¡µåŠ è½½NAIç”»å»Šå›¾ç‰‡
 */
async function loadMoreNaiGalleryImages() {
    if (isLoadingMoreNaiImages || naiGalleryRenderCount >= naiGalleryCache.length) {
        return; // å¦‚æžœæ­£åœ¨åŠ è½½æˆ–å·²å…¨éƒ¨åŠ è½½ï¼Œåˆ™è¿”å›ž
    }
    
    isLoadingMoreNaiImages = true;
    const gridEl = document.getElementById('nai-gallery-grid');
    showLoader(gridEl, 'bottom'); // æ˜¾ç¤ºåŠ è½½åŠ¨ç”»

    // 500ms å»¶è¿Ÿæ¨¡æ‹ŸåŠ è½½ï¼Œä¸Žé¡¹ç›®ä¸­å…¶ä»– loadMore å‡½æ•°ä¿æŒä¸€è‡´
    setTimeout(() => {
        const imagesToAppend = naiGalleryCache.slice(naiGalleryRenderCount, naiGalleryRenderCount + NAI_GALLERY_RENDER_WINDOW);
        
        hideLoader(gridEl); // åœ¨æ¸²æŸ“å‰éšè—åŠ è½½å™¨
        
        if (imagesToAppend.length > 0) {
            renderNaiGalleryGrid(imagesToAppend); // è°ƒç”¨ä¿®æ”¹åŽçš„æ¸²æŸ“å‡½æ•°
            naiGalleryRenderCount += imagesToAppend.length;
        }
        
        isLoadingMoreNaiImages = false;
    }, 500);
}
/**
 * åˆ‡æ¢NAIç”»å»Šçš„ç®¡ç†æ¨¡å¼
 */
function toggleNaiGalleryManagementMode() {
    isNaiGalleryManagementMode = !isNaiGalleryManagementMode;
    const grid = document.getElementById('nai-gallery-grid');
    const manageBtn = document.getElementById('manage-nai-gallery-btn');
    const actionBar = document.getElementById('nai-gallery-action-bar');
    const selectAllCheckbox = document.getElementById('select-all-nai-gallery-checkbox');

    grid.classList.toggle('management-mode', isNaiGalleryManagementMode);
    
    if (isNaiGalleryManagementMode) {
        manageBtn.textContent = 'å®Œæˆ';
        actionBar.style.display = 'flex'; 
        selectedNaiImages.clear();
        selectAllCheckbox.checked = false; 
        updateNaiGalleryActionButtons();
    } else {
        manageBtn.textContent = 'ç®¡ç†';
        actionBar.style.display = 'none';
        grid.querySelectorAll('.nai-gallery-item.selected').forEach(item => item.classList.remove('selected'));
    }
}

/**
 * æ›´æ–°åˆ é™¤æŒ‰é’®ä¸Šçš„è®¡æ•°
 */
function updateNaiGalleryActionButtons() { // <-- å·²é‡å‘½å
    const deleteBtn = document.getElementById('delete-selected-nai-gallery-btn');
    const downloadBtn = document.getElementById('download-selected-nai-gallery-btn'); // <-- æ–°å¢ž
    const count = selectedNaiImages.size;
    
    if (deleteBtn) deleteBtn.textContent = `åˆ é™¤ (${count})`;
    if (downloadBtn) downloadBtn.textContent = `ä¸‹è½½ (${count})`; // <-- æ–°å¢ž
}

/**
 * å¤„ç†ç”»å»Šç½‘æ ¼çš„ç‚¹å‡»äº‹ä»¶ï¼ˆä¸‹è½½ã€åˆ é™¤ã€é€‰æ‹©ï¼‰
 */
function handleNaiGalleryGridClick(e) {
    const item = e.target.closest('.nai-gallery-item');
    if (!item) return;

    const key = item.dataset.key;
    const imageUrl = item.dataset.imageUrl;
    const prompt = item.dataset.prompt;

    // å¤„ç†ä¸‹è½½æŒ‰é’®
    if (e.target.closest('.nai-gallery-download-btn')) {
        e.stopPropagation();
        downloadNaiImage(imageUrl, prompt);
        return;
    }

    // å¤„ç†åˆ é™¤æŒ‰é’®
    if (e.target.closest('.nai-gallery-delete-btn')) {
        e.stopPropagation();
        executeBatchDeleteNaiImages(new Set([key])); // ä¼ å…¥ä¸€ä¸ªåªåŒ…å«å½“å‰keyçš„Set
        return;
    }

    // å¤„ç†ç®¡ç†æ¨¡å¼ä¸‹çš„é€‰æ‹©
    if (isNaiGalleryManagementMode) {
        item.classList.toggle('selected');
        if (selectedNaiImages.has(key)) {
            selectedNaiImages.delete(key);
        } else {
            selectedNaiImages.add(key);
        }
        updateNaiGalleryActionButtons();
    } else {
const modalTitle = "å›¾ç‰‡è¯¦æƒ…";
            const modalContentHtml = `
                <div style="text-align: center;">
                    <img src="${imageUrl}" style="max-width: 100%; border-radius: 8px; box-shadow: 0 4px 10px rgba(0,0,0,0.1);">
                </div>
            `;
            // è°ƒç”¨é€šç”¨çš„æç¤ºæ¡†å‡½æ•°æ¥æ˜¾ç¤ºå†…å®¹
            showCustomAlert(modalTitle, modalContentHtml);
    }
}
/**
 * ã€V2.1 | æµå¼ä¸‹è½½ç‰ˆ + ä¿®å¤Bugã€‘æ‰§è¡Œæ‰¹é‡ä¸‹è½½ NAI å›¾ç‰‡
 * (æ­¤ç‰ˆæœ¬å·²ä¿®æ”¹ä¸ºä½¿ç”¨ StreamSaver.js è¿›è¡Œæµå¼åŽ‹ç¼©å’Œä¸‹è½½)
 * (ä¿®å¤äº†å› äº‹ä»¶ç›‘å¬å™¨ä¼ å‚é”™è¯¯å¯¼è‡´ keys.forEach is not a function çš„Bug)
 * (V2.2 | ä¿®å¤äº†æ‰¹é‡ä¸‹è½½æ—¶å› æ–‡ä»¶åé‡å¤å¯¼è‡´æ–‡ä»¶è¢«è¦†ç›–çš„Bug)
 */
async function executeBatchDownloadNaiImages() {
    // â–¼â–¼â–¼ æ ¸å¿ƒä¿®æ”¹ï¼šä¸å†æŽ¥æ”¶é”™è¯¯å‚æ•°ï¼Œç›´æŽ¥ä½¿ç”¨å…¨å±€å˜é‡ â–¼â–¼â–¼
    const keys = selectedNaiImages;
    // â–²â–²â–² ä¿®æ”¹ç»“æŸ â–²â–²â–²

    if (keys.size === 0) {
        alert("è¯·å…ˆé€‰æ‹©è¦ä¸‹è½½çš„å›¾ç‰‡ã€‚");
        return;
    }

    // æ£€æŸ¥ StreamSaver åº“
    if (typeof JSZip === 'undefined' || !window.streamSaver) {
        await showCustomAlert("ä¸‹è½½å¤±è´¥", "æ ¸å¿ƒåº“ (JSZip æˆ– StreamSaver) æœªèƒ½æˆåŠŸåŠ è½½ï¼Œè¯·æ£€æŸ¥æ‚¨çš„ç½‘ç»œè¿žæŽ¥å¹¶åˆ·æ–°é¡µé¢åŽé‡è¯•ã€‚");
        return;
    }
    
    // â–¼â–¼â–¼ æ ¸å¿ƒä¿®æ”¹ï¼šä½¿ç”¨ keys.size ä¿®å¤äº† 'undefined' æç¤º â–¼â–¼â–¼
    await showCustomAlert("è¯·ç¨å€™...", `æ­£åœ¨å‡†å¤‡ ${keys.size} å¼ å›¾ç‰‡...`);
    // â–²â–²â–² ä¿®æ”¹ç»“æŸ â–²â–²â–²

    const zip = new JSZip();
    let failedDownloads = 0;
    const downloadPromises = [];

    // --- â–¼â–¼â–¼ æ ¸å¿ƒä¿®å¤ï¼šå°† Set è½¬æ¢ä¸ºæ•°ç»„ï¼Œä»¥ä¾¿èŽ·å–ç´¢å¼• â–¼â–¼â–¼ ---
    const keysArray = Array.from(keys);

    keysArray.forEach((key, index) => { // <--- ä½¿ç”¨å¸¦ç´¢å¼•çš„ forEach
        // --- â–²â–²â–² ä¿®å¤ç»“æŸ â–²â–²â–² ---
        
        const item = document.querySelector(`.nai-gallery-item[data-key="${key}"]`);
        if (!item) return;

        const imageUrl = item.dataset.imageUrl;
        const prompt = item.dataset.prompt;
        
        // --- â–¼â–¼â–¼ æ ¸å¿ƒä¿®å¤ï¼šä¸ºæ–‡ä»¶åæ·»åŠ å”¯ä¸€ç´¢å¼•ï¼Œé˜²æ­¢è¦†ç›– â–¼â–¼â–¼ ---
        const baseFilename = generateFilenameForNai(prompt); // e.g., "my_prompt_timestamp.png"
        // æ’å…¥ä¸€ä¸ªå”¯ä¸€çš„ç´¢å¼•å·ï¼Œä¾‹å¦‚ "my_prompt_timestamp_(1).png"
        const filename = baseFilename.replace(/\.png$/, `_(${index + 1}).png`); 
        // --- â–²â–²â–² ä¿®å¤ç»“æŸ â–²â–²â–² ---

        const promise = (async () => {
            try {
                let blob;
                if (imageUrl.startsWith('data:')) {
                    const response = await fetch(imageUrl);
                    blob = await response.blob();
                } else {
                    let response;
                    try {
                        // 1. å°è¯•ç›´è¿ž
                        response = await fetch(imageUrl, { mode: 'cors' });
                        if (!response.ok) throw new Error('ç›´è¿žå¤±è´¥');
                    } catch (e) {
                        // 2. å°è¯•ä»£ç†
                        console.warn("ç›´è¿žå¤±è´¥, å°è¯•ä½¿ç”¨CORSä»£ç†...", e.message);
                        const settings = getNovelAISettings();
                        let corsProxy = settings.cors_proxy === 'custom' ? settings.custom_proxy_url : settings.cors_proxy;
                        if (!corsProxy || corsProxy === '') corsProxy = 'https://corsproxy.io/?';
                        const proxiedUrl = corsProxy + encodeURIComponent(imageUrl);
                        response = await fetch(proxiedUrl);
                    }

                    if (!response.ok) throw new Error(`Fetch failed: ${response.status}`);
                    blob = await response.blob();
                }
                zip.file(filename, blob, { binary: true }); // <--- ä½¿ç”¨ä¿®å¤åŽçš„å”¯ä¸€æ–‡ä»¶å
            } catch (e) {
                console.error(`ä¸‹è½½å›¾ç‰‡å¤±è´¥: ${imageUrl}`, e);
                failedDownloads++;
            }
        })();
        downloadPromises.push(promise);
    });

    // ç­‰å¾…æ‰€æœ‰å›¾ç‰‡å…ƒæ•°æ®å’Œ fetch è¯·æ±‚è¢«åˆ›å»º
    await Promise.all(downloadPromises);

    if (failedDownloads === keys.size) {
        await showCustomAlert("ä¸‹è½½å¤±è´¥", "æ‰€æœ‰å›¾ç‰‡éƒ½ä¸‹è½½å¤±è´¥äº†ã€‚è¿™é€šå¸¸æ˜¯ç”±äºŽç½‘ç»œé—®é¢˜æˆ–CORSè·¨åŸŸé™åˆ¶ï¼ˆè¯·æ£€æŸ¥APIè®¾ç½®ä¸­çš„CORSä»£ç†æ˜¯å¦æœ‰æ•ˆï¼‰ã€‚");
        return;
    }

    await showCustomAlert("æ‰“åŒ…ä¸­...", "æ‰€æœ‰å›¾ç‰‡å·²å‡†å¤‡å°±ç»ªï¼Œæ­£åœ¨æµå¼åŽ‹ç¼©... ä¸‹è½½å°†è‡ªåŠ¨å¼€å§‹ã€‚");

    try {
        // 1. åˆ›å»º StreamSaver çš„æ–‡ä»¶å†™å…¥æµ
        const fileStream = streamSaver.createWriteStream(`NAI_Gallery_Batch_${Date.now()}.zip`);
        
        // 2. åˆ›å»º JSZip çš„å†…éƒ¨æµ (è¿™æ˜¯ä¸€ä¸ª Node.js é£Žæ ¼çš„ StreamHelper)
        const zipStream = zip.generateInternalStream({ 
            type: "blob",      // è¾“å‡º Blob å—
            streamFiles: true  // å‘Šè¯‰ JSZip æµå¼å¤„ç†æ–‡ä»¶å†…å®¹
        });

        // 3. å°† JSZip çš„ StreamHelper åŒ…è£…æˆ Web ReadableStream
        const readableStream = new ReadableStream({
            start(controller) {
                zipStream.on('data', (chunk) => {
                    // å°† JSZip äº§å‡ºçš„æ•°æ®å—(chunk)æ”¾å…¥æµä¸­
                    controller.enqueue(chunk);
                }).on('end', () => {
                    // JSZip å®Œæˆï¼Œå…³é—­æµ
                    console.log("ZIP æµç”Ÿæˆå®Œæ¯•ã€‚");
                    controller.close();
                }).on('error', (err) => {
                    // JSZip å‡ºé”™ï¼ŒæŠ¥é”™
                    console.error("JSZip æµé”™è¯¯:", err);
                    controller.error(err);
                }).resume(); // å¯åŠ¨ JSZip æµ
            }
        });

        // 4. å°† ReadableStream ç®¡é“ä¼ è¾“åˆ° StreamSaver çš„æ–‡ä»¶æµ
        await readableStream.pipeTo(fileStream);

        // 5. ï¼ˆå¯é€‰ï¼‰ä¸‹è½½å®ŒæˆåŽç»™ä¸ªæç¤º
        if (failedDownloads > 0) {
            showCustomAlert("éƒ¨åˆ†ä¸‹è½½å®Œæˆ", `æˆåŠŸæ‰“åŒ… ${keys.size - failedDownloads} å¼ å›¾ç‰‡ã€‚æœ‰ ${failedDownloads} å¼ å›¾ç‰‡å› ç½‘ç»œæˆ–CORSé™åˆ¶ä¸‹è½½å¤±è´¥ã€‚`);
        }

    } catch (error) {
        console.error("æµå¼ä¸‹è½½ZIPå¤±è´¥:", error);
        await showCustomAlert("æµå¼ä¸‹è½½å¤±è´¥", `åˆ›å»ºZIPæµæ—¶å‡ºé”™: ${error.message}`);
    }
}
/**
 * ã€æ ¸å¿ƒ | V2.0 ä¿®å¤ç‰ˆã€‘æ‰§è¡Œæ‰¹é‡åˆ é™¤
 * (ä¿®å¤äº†å›  chatId åŒ…å«ä¸‹åˆ’çº¿ '_' å¯¼è‡´çš„è§£æžé”™è¯¯)
 */
async function executeBatchDeleteNaiImages(keysToDelete = null) {
    const keys = keysToDelete || selectedNaiImages;
    if (keys.size === 0) return;

    const confirmed = await showCustomConfirm(
        'ç¡®è®¤åˆ é™¤',
        `ç¡®å®šè¦ä»Žã€èŠå¤©è®°å½•å’ŒåŠ¨æ€ã€‘ä¸­æ°¸ä¹…åˆ é™¤è¿™ ${keys.size} å¼ NAIå›¾ç‰‡å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ¢å¤ã€‚`,
        { confirmButtonClass: 'btn-danger' }
    );

    if (!confirmed) return;

    await showCustomAlert("è¯·ç¨å€™...", "æ­£åœ¨æ‰§è¡Œåˆ é™¤æ“ä½œ...");

    let deletedCount = 0;
    const chatsToUpdate = new Map();
    const postsToDelete = new Set();
    const postsToModify = new Map();

    // é¢„åŠ è½½æ‰€æœ‰éœ€è¦ä¿®æ”¹çš„å¸–å­
    const postIdsToFetch = new Set();
    for (const key of keys) {
        if (key.startsWith('qzone_')) {
            const parts = key.split('_');
            const postId = parseInt(parts[1]); // qzone ID ä¸ä¼šåŒ…å« '_'
            if (!isNaN(postId)) {
                postIdsToFetch.add(postId);
            }
        }
    }
    const postsCache = new Map();
    if (postIdsToFetch.size > 0) {
        const posts = await db.qzonePosts.where('id').anyOf(Array.from(postIdsToFetch)).toArray();
        posts.forEach(post => postsCache.set(post.id, post));
    }


    for (const key of keys) {
        
        // --- â–¼â–¼â–¼ æ ¸å¿ƒä¿®å¤ â–¼â–¼â–¼ ---
        // æ—§çš„(é”™è¯¯çš„): const [sourceType, id, identifier] = key.split('_');
        // åŽŸå› æ˜¯ id (å¦‚ chat_12345) å¯èƒ½åŒ…å« '_'
        
        const parts = key.split('_');
        if (parts.length < 3) {
            console.warn("è·³è¿‡æ ¼å¼é”™è¯¯çš„NAIå›¾ç‰‡Key:", key);
            continue;
        }

        const sourceType = parts[0];
        const identifier = parts.pop(); // ä»Žæœ«å°¾å–å‡ºæ ‡è¯†ç¬¦ (æ—¶é—´æˆ³æˆ–ç´¢å¼•)
        const id = parts.slice(1).join('_'); // å°†ä¸­é—´çš„æ‰€æœ‰éƒ¨åˆ†é‡æ–°ç»„åˆä¸ºID (ä¾‹å¦‚ 'chat_12345')
        // --- â–²â–²â–² æ ¸å¿ƒä¿®å¤ â–²â–²â–² ---
        
        if (sourceType === 'chat') {
            const chatId = id;
            const msgTimestamp = parseInt(identifier);
            
            if (!chatsToUpdate.has(chatId)) {
                // ä»…å½“éœ€è¦æ—¶æ‰ä»Žæ•°æ®åº“èŽ·å–
                const chatData = await db.chats.get(chatId);
                if (chatData) {
                    chatsToUpdate.set(chatId, chatData);
                } else {
                    console.warn(`æœªæ‰¾åˆ° chatID: ${chatId}ï¼Œè·³è¿‡...`);
                    continue;
                }
            }

            const chat = chatsToUpdate.get(chatId);
            if (chat && chat.history) {
                const originalLength = chat.history.length;
                chat.history = chat.history.filter(msg => msg.timestamp !== msgTimestamp);
                if (chat.history.length < originalLength) {
                    deletedCount++;
                    chatsToUpdate.set(chatId, chat); // æ ‡è®°æ­¤chatéœ€è¦è¢«æ›´æ–°
                }
            }
        } else if (sourceType === 'qzone') {
            const postId = parseInt(id);
            const imageIndex = parseInt(identifier);
            
            const post = postsToModify.get(postId) || postsCache.get(postId);
            if (!post) {
                console.warn(`æœªæ‰¾åˆ° postID: ${postId}ï¼Œè·³è¿‡...`);
                continue;
            }

            const urls = post.imageUrls || (post.imageUrl ? [post.imageUrl] : []);
            
            if (urls.length <= 1) {
                // å¦‚æžœè¿™æ˜¯æœ€åŽä¸€å¼ å›¾ï¼Œæ ‡è®°æ•´ä¸ªå¸–å­å¾…åˆ é™¤
                postsToDelete.add(postId);
                if (postsToModify.has(postId)) {
                     postsToModify.delete(postId); // ä»Žä¿®æ”¹åˆ—è¡¨ç§»åˆ°åˆ é™¤åˆ—è¡¨
                }
            } else {
                // å¦åˆ™ï¼Œåªä»Žæ•°ç»„ä¸­ç§»é™¤
                const urlToRemove = urls[imageIndex];
                post.imageUrls = post.imageUrls.filter(url => url !== urlToRemove);
                
                if (post.prompt && Array.isArray(post.prompt) && post.prompt[imageIndex]) {
                    post.prompt.splice(imageIndex, 1);
                }
                post.imageUrl = post.imageUrls[0] || null; // æ›´æ–°å°é¢
                postsToModify.set(postId, post);
            }
            deletedCount++;
        }
    }

    try {
        await db.transaction('rw', db.chats, db.qzonePosts, async () => {
            if (chatsToUpdate.size > 0) {
                await db.chats.bulkPut(Array.from(chatsToUpdate.values()));
            }
            if (postsToModify.size > 0) {
                await db.qzonePosts.bulkPut(Array.from(postsToModify.values()));
            }
            if (postsToDelete.size > 0) {
                await db.qzonePosts.bulkDelete(Array.from(postsToDelete));
            }
        });

        // é€€å‡ºç®¡ç†æ¨¡å¼å¹¶åˆ·æ–°
        toggleNaiGalleryManagementMode();
        await openNaiGallery(); // é‡æ–°åŠ è½½æ•°æ®
        await showCustomAlert('åˆ é™¤æˆåŠŸ', `å·²æˆåŠŸåˆ é™¤ ${deletedCount} å¼ å›¾ç‰‡ã€‚`);

        // åˆ·æ–°å¯èƒ½æ‰“å¼€çš„ç•Œé¢
        if (document.getElementById('chat-interface-screen').classList.contains('active')) {
            renderChatInterface(state.activeChatId);
        }
        if (document.getElementById('qzone-screen').classList.contains('active')) {
            renderQzonePosts();
        }

    } catch (error) {
        console.error("æ‰¹é‡åˆ é™¤NAIå›¾ç‰‡æ—¶å‡ºé”™:", error);
        await showCustomAlert('åˆ é™¤å¤±è´¥', `æ“ä½œå¤±è´¥: ${error.message}`);
    }
}

/* ======================================================================= */
/* â–²â–²â–² NAIç”»å»Šæ ¸å¿ƒå‡½æ•°ç»“æŸ â–²â–²â–²                                          */
/* ======================================================================= */
/**
 * ã€å…¨æ–° | ä»ŽHTMLä¸­æå–çš„è¾…åŠ©å‡½æ•°ã€‘æ ¹æ®promptå’Œæ—¶é—´æˆ³ç”Ÿæˆæ™ºèƒ½æ–‡ä»¶å
 */
function generateFilenameForNai(prompt) {
    // å°è¯•ä»Žtitleå±žæ€§èŽ·å–promptï¼ˆç”¨äºŽæ–‡ä»¶åï¼‰
    const title = prompt || 'NAI_Image';
    
    // æ¸…ç†titleï¼Œæå–å‰30ä¸ªæœ‰æ•ˆå­—ç¬¦
    let cleanTitle = title
        .replace(/[^a-zA-Z0-9\u4e00-\u9fa5\s]/g, '_')  // ä¿ç•™ä¸­è‹±æ–‡å­—æ¯æ•°å­—å’Œç©ºæ ¼
        .replace(/\s+/g, '_')  // ç©ºæ ¼è½¬ä¸‹åˆ’çº¿
        .substring(0, 30);
    
    if (!cleanTitle) {
        cleanTitle = 'NAI_Image';
    }
    
    // æ·»åŠ æ—¶é—´æˆ³ï¼ˆç²¾ç¡®åˆ°ç§’ï¼‰
    const timestamp = new Date().toISOString()
        .replace(/[-:]/g, '')
        .replace('T', '_')
        .split('.')[0];  // æ ¼å¼ï¼š20250124_123045
    
    // ç”Ÿæˆæ–‡ä»¶å
    return `${cleanTitle}_${timestamp}.png`;
}
                async function init() {

    initLanguage();
async function handleWorldBookImport(file) {
    if (!file) return;

    try {
        const text = await file.text();
        const data = JSON.parse(text);

        
        if (data.type === 'EPhoneWorldBookBackup') {
            console.log("æ£€æµ‹åˆ° EPhone å¤‡ä»½æ–‡ä»¶ï¼Œæ‰§è¡Œæ ‡å‡†å¯¼å…¥...");
            await importWorldBooks(data); 
        } else {
            throw new Error("æ–‡ä»¶æ ¼å¼æ— æ³•è¯†åˆ«ã€‚è¯·ç¡®ä¿æ‚¨é€‰æ‹©çš„æ˜¯æœ‰æ•ˆçš„ EPhone ä¸–ç•Œä¹¦å¤‡ä»½æ–‡ä»¶ã€‚");
        }

    } catch (error) {
        console.error("å¯¼å…¥ä¸–ç•Œä¹¦æ—¶å‡ºé”™:", error);
        await showCustomAlert('å¯¼å…¥å¤±è´¥', `æ–‡ä»¶è§£æžæˆ–åº”ç”¨å¤±è´¥: ${error.message}`);
    }
}
        


        async function exportWorldBooks() {
            try {
                const books = await db.worldBooks.toArray();
                const categories = await db.worldBookCategories.toArray();
        
                if (books.length === 0 && categories.length === 0) {
                    alert("æ²¡æœ‰å¯å¯¼å‡ºçš„ä¸–ç•Œä¹¦æ•°æ®ã€‚");
                    return;
                }
        
                const backupData = {
                    type: 'EPhoneWorldBookBackup', 
                    version: 1,
                    timestamp: Date.now(),
                    books: books,
                    categories: categories
                };
        
                const blob = new Blob(
                    [JSON.stringify(backupData, null, 2)], 
                    { type: 'application/json' }
                );
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = `EPhone-WorldBooks-${new Date().toISOString().split('T')[0]}.json`;
                link.click();
                URL.revokeObjectURL(url);
                
                await showCustomAlert('å¯¼å‡ºæˆåŠŸ', 'æ‰€æœ‰ä¸–ç•Œä¹¦æ•°æ®å·²æˆåŠŸå¯¼å‡ºï¼');
        
            } catch (error) {
                console.error("å¯¼å‡ºä¸–ç•Œä¹¦æ—¶å‡ºé”™:", error);
                await showCustomAlert('å¯¼å‡ºå¤±è´¥', `å‘ç”Ÿäº†ä¸€ä¸ªé”™è¯¯: ${error.message}`);
            }
        }
        
/**
         * ã€å·²æ›´æ–°ã€‘å¯¼å…¥ EPhone ä¸–ç•Œä¹¦å¤‡ä»½æ•°æ®ï¼Œå¹¶è¦†ç›–çŽ°æœ‰æ•°æ®
         * @param {object} data - ä»Žå¤‡ä»½æ–‡ä»¶è§£æžå‡ºçš„JSONæ•°æ®
         */
        async function importWorldBooks(data) {
            
            try {
                if (data.type !== 'EPhoneWorldBookBackup' || !data.books) {
                    throw new Error("æ–‡ä»¶æ ¼å¼ä¸æ­£ç¡®ï¼Œè¿™ä¸æ˜¯ä¸€ä¸ªæœ‰æ•ˆçš„ä¸–ç•Œä¹¦å¤‡ä»½æ–‡ä»¶ã€‚");
                }
        
                const confirmed = await showCustomConfirm(
                    'å¯¼å…¥ä¸–ç•Œä¹¦',
                    'è¿™å°†ç”¨æ–‡ä»¶ä¸­çš„æ•°æ®ã€å®Œå…¨è¦†ç›–ã€‘æ‚¨å½“å‰æ‰€æœ‰çš„ä¸–ç•Œä¹¦å’Œåˆ†ç±»ã€‚æ­¤æ“ä½œä¸å¯æ’¤é”€ï¼',
                    { confirmButtonClass: 'btn-danger', confirmText: 'ç¡®è®¤è¦†ç›–' }
                );
        
                if (!confirmed) return;
        
                await db.transaction('rw', db.worldBooks, db.worldBookCategories, async () => {
                    await db.worldBooks.clear();
                    await db.worldBookCategories.clear();
                    
                    if (Array.isArray(data.books)) {
                        await db.worldBooks.bulkPut(data.books);
                    }
                    if (Array.isArray(data.categories)) {
                        await db.worldBookCategories.bulkPut(data.categories);
                    }
                });
        
                
                state.worldBooks = await db.worldBooks.toArray();
                await renderWorldBookScreen();
        
                await showCustomAlert('å¯¼å…¥æˆåŠŸ', 'ä¸–ç•Œä¹¦æ•°æ®å·²æˆåŠŸæ¢å¤ï¼');
        
            } catch (error) {
                console.error("å¯¼å…¥ä¸–ç•Œä¹¦æ—¶å‡ºé”™:", error);
                await showCustomAlert('å¯¼å…¥å¤±è´¥', `æ–‡ä»¶è§£æžæˆ–åº”ç”¨å¤±è´¥: ${error.message}`);
            }
        }


    
    const lastActiveTimestamp = localStorage.getItem('ephoneLastActiveTimestamp');
    if (lastActiveTimestamp) {
        const minutesOffline = (Date.now() - parseInt(lastActiveTimestamp)) / (1000 * 60);
        
        if (minutesOffline > 5) {
            
            
            simulateBackgroundActivity(minutesOffline);
        }
    }
    
setupCharPlayerControls();
    
    window.showScreen = showScreen;
    window.openRenderingRulesScreen = openRenderingRulesScreen;
    window.handleListenTogetherClick = handleListenTogetherClick; 
  
window.openCharacterSelector = openCharacterSelector;
window.openCharApp = openCharApp;
window.switchToMyPhone = switchToMyPhone;
window.openCharWallet = openCharWallet;
window.switchToCharHomeScreen = switchToCharHomeScreen;
window.openNpcEditor = openNpcEditor; 

    
        
        const stickerActionBar = document.createElement('div');
        stickerActionBar.id = 'sticker-action-bar';
        stickerActionBar.innerHTML = '<button id="delete-selected-stickers-btn">åˆ é™¤ (0)</button>';
        document.getElementById('sticker-panel').appendChild(stickerActionBar);
                    
                    const globalCssStyleTag = document.createElement('style');
                    globalCssStyleTag.id = 'global-custom-style';
                    document.head.appendChild(globalCssStyleTag);
                    
        
        qzoneStickerPanelState.panelEl = document.getElementById('qzone-sticker-panel');
        qzoneStickerPanelState.gridEl = document.getElementById('qzone-sticker-grid');
            
            const savedTheme = localStorage.getItem('ephone-theme') || 'light'; 
            applyTheme(savedTheme);
            
        
            
            const customBubbleStyleTag = document.createElement('style');
            customBubbleStyleTag.id = 'custom-bubble-style';
            document.head.appendChild(customBubbleStyleTag);
              
        
            
            const previewBubbleStyleTag = document.createElement('style');
            previewBubbleStyleTag.id = 'preview-bubble-style';
            document.head.appendChild(previewBubbleStyleTag);
              
        
        
            
            applyScopedCss('', '#chat-messages', 'custom-bubble-style'); 
            applyScopedCss('', '#settings-preview-area', 'preview-bubble-style'); 
              
                   window.openRenderingRulesScreen = openRenderingRulesScreen;
                    window.showScreen = showScreen;
                    window.renderChatListProxy = renderChatList;
                    window.renderApiSettingsProxy = renderApiSettings;
                    window.renderWallpaperScreenProxy = renderWallpaperScreen;
                    window.renderWorldBookScreenProxy = renderWorldBookScreen;
        
                    await loadAllDataFromDB();
                    applyStatusBarVisibility(); 
                    applyPhoneFrame(state.globalSettings.showPhoneFrame);
                    applyDetachStatusBarMode(state.globalSettings.detachStatusBar); 
                    applyMinimalChatUI(state.globalSettings.enableMinimalChatUI);
                    await migrateOldRedPacketData();
                      
                    
                    applyGlobalCss(state.globalSettings.globalCss);
                    
        
                    
                    const storedCount = parseInt(localStorage.getItem('unreadPostsCount')) || 0;
                    updateUnreadIndicator(storedCount);
                    
                    
        
                    if (state.globalSettings && state.globalSettings.fontUrl) {
                        applyCustomFont(state.globalSettings.fontUrl);
                    }
        
                    updateClock();
                    setInterval(updateClock, 1000 * 30);
                    applyGlobalWallpaper();
                    initBatteryManager(); 
        
        applyAppIcons();
        applyWidgetData(); 
        
                    
                    
                    
        
        document.getElementById('rules-tabs').addEventListener('click', (e) => {
            if (e.target.classList.contains('rules-tab')) {
                switchRuleCategory(e.target.dataset.categoryId);
            }
        });
          
        
        
        document.getElementById('add-new-rule-btn').addEventListener('click', () => openRuleEditor(null));
        document.getElementById('cancel-rule-editor-btn').addEventListener('click', () => {
            document.getElementById('rule-editor-modal').classList.remove('visible');
        });
        document.getElementById('save-rule-btn').addEventListener('click', saveRenderingRule);
        
        
        
        document.getElementById('pat-btn').addEventListener('click', () => {
            
            if (state.activeChatId && !state.chats[state.activeChatId].isGroup) {
                const chat = state.chats[state.activeChatId];
                
                handleUserPat(chat.id, chat.originalName);
            }
        });
          
        
        let activeAnnouncementId = null; 
        
        /**
         * ç‚¹å‡»â€œ...â€æ—¶ï¼Œæ˜¾ç¤ºæ“ä½œèœå•ï¼ˆç½®é¡¶/åˆ é™¤ï¼‰
         * @param {string} annoId - å…¬å‘Šçš„å”¯ä¸€ID
         */
        function showAnnouncementActions(annoId) {
            activeAnnouncementId = annoId;
            const chat = state.chats[state.activeChatId];
            const announcement = chat.announcements.find(a => a.id === annoId);
            if (!announcement) return;
        
            const pinButton = document.getElementById('announcement-action-pin');
            
            pinButton.textContent = announcement.isPinned ? 'å–æ¶ˆç½®é¡¶' : 'ç½®é¡¶å…¬å‘Š';
        
            document.getElementById('announcement-actions-modal').classList.add('visible');
        }
        
        /**
         * å¤„ç†â€œç½®é¡¶/å–æ¶ˆç½®é¡¶â€æ“ä½œ
         */
        async function handlePinAnnouncement() {
            if (!activeAnnouncementId) return;
            const chat = state.chats[state.activeChatId];
            const announcement = chat.announcements.find(a => a.id === activeAnnouncementId);
            if (announcement) {
                announcement.isPinned = !announcement.isPinned; 
                await db.chats.put(chat);
                showAnnouncementBoard(); 
            }
            document.getElementById('announcement-actions-modal').classList.remove('visible');
        }
        
        /**
         * å¤„ç†â€œåˆ é™¤å…¬å‘Šâ€æ“ä½œ
         */
        async function handleDeleteAnnouncement() {
            if (!activeAnnouncementId) return;
        
            const confirmed = await showCustomConfirm("ç¡®è®¤åˆ é™¤", "ç¡®å®šè¦åˆ é™¤è¿™æ¡å…¬å‘Šå—ï¼Ÿæ­¤æ“ä½œä¸å¯æ¢å¤ã€‚", { confirmButtonClass: 'btn-danger' });
        
            if (confirmed) {
                const chat = state.chats[state.activeChatId];
                
                chat.announcements = chat.announcements.filter(a => a.id !== activeAnnouncementId);
                await db.chats.put(chat);
                showAnnouncementBoard(); 
            }
            document.getElementById('announcement-actions-modal').classList.remove('visible');
        }
        
                    document.getElementById('custom-modal-cancel').addEventListener('click', hideCustomModal);
                    document.getElementById('custom-modal-overlay').addEventListener('click', (e) => { if (e.target === modalOverlay) hideCustomModal(); });
                   document.getElementById('export-data-btn').addEventListener('click', async () => {
    
    const choice = await showChoiceModal('é€‰æ‹©å¯¼å‡ºæ–¹å¼', [
        { text: 'åˆ†ç‰‡å¯¼å‡º (æŽ¨èï¼Œæ‰“åŒ…ä¸ºZIPï¼Œè§£åŽ‹æ¯ä¸ªåˆ‡ç‰‡é€‰æ‹©å¢žé‡å¯¼å…¥)', value: 'slice' },
        { text: 'æ™ºèƒ½å¯¼å‡º (å•ä¸ªå¤§æ–‡ä»¶ï¼Œå¤ªå¤§å¯èƒ½ä¼šå¯¼è‡´å¯¼å…¥ä¸äº†)', value: 'stream' },
        { text: 'ä¼ ç»Ÿå¯¼å‡º (å…¼å®¹æ—§ç‰ˆæˆ–å†…å­˜å°çš„æµè§ˆå™¨)', value: 'blob' }
    ]);

    
    if (choice === 'slice') {
        exportDataAsSlicedZip(); 
    } else if (choice === 'stream') {
        exportDataAsStream(); 
    } else if (choice === 'blob') {
        exportDataAsBlob(); 
    }
    
});
    

  
document.getElementById('cleanup-data-btn').addEventListener('click', cleanupRedundantData);

document.getElementById('offline-mode-toggle').addEventListener('change', (e) => {
    
    document.getElementById('offline-mode-options').style.display = e.target.checked ? 'block' : 'none';
});
                    document.getElementById('import-btn').addEventListener('click', () => document.getElementById('import-data-input').click());
    document.getElementById('time-perception-toggle').addEventListener('change', (e) => {
        document.getElementById('time-zone-group').style.display = e.target.checked ? 'block' : 'none';
    });
                    
document.getElementById('import-data-input').addEventListener('change', e => handleSmartImport(e.target.files[0]));
                    
                    document.getElementById('back-to-list-btn').addEventListener('click', () => { 
               ruleCache = {};
            
            applyScopedCss('', '#chat-messages', 'custom-bubble-style'); 
            applyScopedCss('', '#settings-preview-area', 'preview-bubble-style'); 
              
        
        exitSelectionMode(); state.activeChatId = null; showScreen('chat-list-screen'); });
                    
        
document.getElementById('add-chat-btn').addEventListener('click', async () => {
    const remarkName = await showCustomPrompt('åˆ›å»ºæ–°èŠå¤© (ç¬¬1/2æ­¥)', 'è¯·è¾“å…¥ä½ æƒ³ä¸ºTaè®¾ç½®çš„ã€å¤‡æ³¨åã€‘(ä¾‹å¦‚: å“¥å“¥)');
    if (!remarkName || !remarkName.trim()) return;

    const originalName = await showCustomPrompt('åˆ›å»ºæ–°èŠå¤© (ç¬¬2/2æ­¥)', 'è¯·è¾“å…¥Taçš„ã€æœ¬åã€‘(ä¾‹å¦‚: æŽæ˜Ÿè¾°ï¼Œè¿™ä¸ªåå­—å°†ç”¨äºŽAIè¯†åˆ«)');
    if (!originalName || !originalName.trim()) return;

    const newChatId = 'chat_' + Date.now();
    const newChat = {
        id: newChatId,
        name: remarkName.trim(),
        originalName: originalName.trim(),
        isGroup: false,
        isPinned: false, 
        unreadCount: 0,  
        relationship: { status: 'friend', blockedTimestamp: null, applicationReason: '' },
        status: { text: 'åœ¨çº¿', lastUpdate: Date.now(), isBusy: false },
        settings: {
            aiPersona: 'è¿™æ˜¯ä¸€ä¸ªé€šè¿‡æ‰‹åŠ¨åˆ›å»ºçš„è§’è‰²ã€‚',
            myPersona: 'æˆ‘æ˜¯è°å‘€ã€‚',
            myNickname: 'æˆ‘',
            maxMemory: 10,
            aiAvatar: defaultAvatar,
            myAvatar: defaultAvatar,
            background: '',
            theme: 'default',
            fontSize: 13,
            customCss: '',
            linkedWorldBookIds: [],
            aiAvatarLibrary: [],
            myAvatarLibrary: [],
            enableBackgroundActivity: true, 
            actionCooldownMinutes: 15,    
            enableTimePerception: true,     
            isOfflineMode: false,           
            offlineMinLength: 100,
            offlineMaxLength: 300,
            offlinePresetId: null,
            timeZone: 'Asia/Shanghai'       
        },
        history: [],
        musicData: { totalTime: 0 },
        longTermMemory: [],
        thoughtsHistory: [] 
    };
    state.chats[newChatId] = newChat;
    await db.chats.put(newChat);
    renderChatList();
});
          
        
                    
        document.getElementById('add-group-chat-btn').addEventListener('click', openContactPickerForGroupCreate);
                                
                    document.getElementById('transfer-cancel-btn').addEventListener('click', () => document.getElementById('transfer-modal').classList.remove('visible'));
                    document.getElementById('transfer-confirm-btn').addEventListener('click', sendUserTransfer);
        
                    document.getElementById('listen-together-btn').addEventListener('click', handleListenTogetherClick);
                    document.getElementById('music-exit-btn').addEventListener('click', () => endListenTogetherSession(true));
                    document.getElementById('music-return-btn').addEventListener('click', returnToChat);
                    document.getElementById('music-play-pause-btn').addEventListener('click', togglePlayPause);
                    document.getElementById('music-next-btn').addEventListener('click', playNext);
                    document.getElementById('music-prev-btn').addEventListener('click', playPrev);
                    document.getElementById('music-mode-btn').addEventListener('click', changePlayMode);
                    document.getElementById('music-playlist-btn').addEventListener('click', () => { updatePlaylistUI(); document.getElementById('music-playlist-panel').classList.add('visible'); });
                    document.getElementById('close-playlist-btn').addEventListener('click', () => document.getElementById('music-playlist-panel').classList.remove('visible'));
                    document.getElementById('add-song-url-btn').addEventListener('click', addSongFromURL);
                    document.getElementById('add-song-local-btn').addEventListener('click', () => document.getElementById('local-song-upload-input').click());
                    document.getElementById('local-song-upload-input').addEventListener('change', addSongFromLocal);

document.getElementById('playlist-body').addEventListener('click', (e) => {
    const target = e.target;
    const trackIndex = parseInt(target.dataset.index);

    if (isNaN(trackIndex)) return;

    if (target.classList.contains('album-art-btn')) {
        handleChangeAlbumArt(trackIndex);
    } else if (target.classList.contains('lyrics-btn')) {
        handleManualLrcImport(trackIndex);
    } else if (target.classList.contains('bg-btn')) {
        handleChangeBackground(trackIndex);
    } else if (target.classList.contains('delete-track-btn')) {
        deleteTrack(trackIndex);
    }
});

                    audioPlayer.addEventListener('ended', () => {
    
    document.getElementById('vinyl-view').classList.remove('spinning');
    playNext(); 
});





                    const chatInput = document.getElementById('chat-input');
                    

document.getElementById('send-btn').addEventListener('click', () => { 
playSilentAudio();
    const content = chatInput.value.trim();
    if (!content || !state.activeChatId) return;

    const chat = state.chats[state.activeChatId];
    const msg = {
        role: 'user',
        content,
        timestamp: Date.now()
    };

    if (currentReplyContext) {
        msg.quote = currentReplyContext;
    }

    
    appendMessage(msg, chat);

    
    (async () => {
        chat.history.push(msg);
        await db.chats.put(chat); 
    renderChatList(); 

    })();

    
    chatInput.value = '';
    chatInput.style.height = 'auto';
    chatInput.focus();
    cancelReplyMode();
   document.body.classList.remove('chat-actions-expanded');
});
                    document.getElementById('wait-reply-btn').addEventListener('click', triggerAiResponse);
                    chatInput.addEventListener('keypress', (e) => { if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); document.getElementById('send-btn').click(); } });
                    
        
                    document.getElementById('wallpaper-upload-input').addEventListener('change', async (event) => { const file = event.target.files[0]; if(file) { const dataUrl = await new Promise((res, rej) => { const reader = new FileReader(); reader.onload = () => res(reader.result); reader.onerror = () => rej(reader.error); reader.readAsDataURL(file); }); newWallpaperBase64 = dataUrl; renderWallpaperScreen(); } });
        
        document.getElementById('save-wallpaper-btn').addEventListener('click', async () => {
            
            if (newWallpaperBase64) {
                state.globalSettings.wallpaper = newWallpaperBase64;
            }
            
            
            

            state.globalSettings.globalCss = document.getElementById('global-css-input').value.trim();
            state.globalSettings.notificationSoundUrl = document.getElementById('notification-sound-url-input').value.trim();
            state.globalSettings.showStatusBar = document.getElementById('status-bar-toggle-switch').checked;
            
          state.globalSettings.showPhoneFrame = document.getElementById('phone-frame-toggle-switch').checked;  
          state.globalSettings.enableMinimalChatUI = document.getElementById('minimal-chat-ui-switch').checked;
          state.globalSettings.alwaysShowMusicIsland = document.getElementById('dynamic-island-music-toggle-switch').checked;
          state.globalSettings.detachStatusBar = document.getElementById('detach-status-bar-switch').checked;          
            await db.globalSettings.put(state.globalSettings);
            
            
            applyGlobalWallpaper();
            applyCPhoneWallpaper(); 
            newWallpaperBase64 = null; 

            applyAppIcons();
            applyCPhoneAppIcons(); 
            
            applyGlobalCss(state.globalSettings.globalCss);
            applyStatusBarVisibility();
            applyMinimalChatUI(state.globalSettings.enableMinimalChatUI);
            alert('å¤–è§‚è®¾ç½®å·²ä¿å­˜å¹¶åº”ç”¨ï¼');
            showScreen('home-screen');
        });
          

const messagesView = document.getElementById('messages-view'); 
messagesView.addEventListener('scroll', () => { 
    
    const { scrollTop, scrollHeight, clientHeight } = messagesView;

    
    
    if (scrollHeight - scrollTop - clientHeight < clientHeight) {
        
        if (!isLoadingMoreChats) {
            
            loadMoreChats();
        }
    }
});
  
        
        document.getElementById('save-api-settings-btn').addEventListener('click', async () => {
            
            state.apiConfig.proxyUrl = document.getElementById('proxy-url').value.trim();
            state.apiConfig.apiKey = document.getElementById('api-key').value.trim();
            state.apiConfig.model = document.getElementById('model-select').value;
state.apiConfig.minimaxGroupId = document.getElementById('minimax-group-id').value.trim();
state.apiConfig.minimaxApiKey = document.getElementById('minimax-api-key').value.trim();  
state.apiConfig.minimaxModel = document.getElementById('minimax-model-select').value; 
            
            state.apiConfig.secondaryProxyUrl = document.getElementById('secondary-proxy-url').value.trim();
            state.apiConfig.secondaryApiKey = document.getElementById('secondary-api-key').value.trim();
            state.apiConfig.secondaryModel = document.getElementById('secondary-model-select').value;
            
            await db.apiConfig.put(state.apiConfig);
        
            
            const backgroundSwitch = document.getElementById('background-activity-switch');
            const intervalInput = document.getElementById('background-interval-input');
            const cooldownInput = document.getElementById('block-cooldown-input');
        
            state.globalSettings.enableBackgroundActivity = backgroundSwitch.checked;
            state.globalSettings.backgroundActivityInterval = parseInt(intervalInput.value) || 60;
            state.globalSettings.blockCooldownHours = parseFloat(cooldownInput.value) || 1;
            state.globalSettings.enableAiDrawing = document.getElementById('enable-ai-drawing-switch').checked;
           state.globalSettings.chatRenderWindow = parseInt(document.getElementById('chat-render-window-input').value) || 50;
            state.globalSettings.chatListRenderWindow = parseInt(document.getElementById('chat-list-render-window-input').value) || 30;
            state.globalSettings.apiTemperature = parseFloat(document.getElementById('api-temperature-slider').value);
            await db.globalSettings.put(state.globalSettings);
        
            stopBackgroundSimulation(); 
            if (state.globalSettings.enableBackgroundActivity) {
                startBackgroundSimulation();
                console.log(`åŽå°æ´»åŠ¨æ¨¡æ‹Ÿå·²å¯åŠ¨ï¼Œé—´éš”: ${state.globalSettings.backgroundActivityInterval}ç§’`);
            } else {
                console.log("åŽå°æ´»åŠ¨æ¨¡æ‹Ÿå·²åœæ­¢ã€‚");
            }
            
            // ä¿å­˜NovelAIé…ç½®åˆ°localStorage
            const novelaiEnabled = document.getElementById('novelai-switch').checked;
            const novelaiModel = document.getElementById('novelai-model').value;
            const novelaiApiKey = document.getElementById('novelai-api-key').value.trim();
            localStorage.setItem('novelai-enabled', novelaiEnabled);
            localStorage.setItem('novelai-model', novelaiModel);
            localStorage.setItem('novelai-api-key', novelaiApiKey);
            
            alert('æ‰€æœ‰APIä¸ŽåŽå°è®¾ç½®å·²ä¿å­˜!'); 
        });
          
        
                            
                const ApiKeyInput = document.getElementById('api-key')
                ApiKeyInput.addEventListener('focus', (e) => {
                    e.target.setAttribute('type', 'text')
                })
                ApiKeyInput.addEventListener('blur', (e) => {
                    e.target.setAttribute('type', 'password')
                })
        
        
        
        
        
        async function fetchModels(urlInputId, keyInputId, selectId) {
            const url = document.getElementById(urlInputId).value.trim();
            const key = document.getElementById(keyInputId).value.trim();
            if (!url || !key) return alert('è¯·å…ˆå¡«å†™å¯¹åº”çš„åä»£åœ°å€å’Œå¯†é’¥');
            
            try {
                let isGemini = url === GEMINI_API_URL;
                const response = await fetch(isGemini ? `${GEMINI_API_URL}?key=${getRandomValue(key)}` : `${url}/v1/models`, isGemini ? undefined : { headers: { 'Authorization': `Bearer ${key}` } });
                if (!response.ok) throw new Error('æ— æ³•èŽ·å–æ¨¡åž‹åˆ—è¡¨');
                const data = await response.json();
                let models = isGemini ? data.models.map(model => ({ id: model.name.split('/')[1] || model.name })) : data.data;
                
                const modelSelect = document.getElementById(selectId);
                modelSelect.innerHTML = '';
                
                const savedModel = selectId === 'model-select' ? state.apiConfig.model : state.apiConfig.secondaryModel;
        
                models.forEach(model => {
                    const option = document.createElement('option');
                    option.value = model.id;
                    option.textContent = model.id;
                    if (model.id === savedModel) option.selected = true;
                    modelSelect.appendChild(option);
                });
                alert('æ¨¡åž‹åˆ—è¡¨å·²æ›´æ–°');
            } catch (error) {
                alert(`æ‹‰å–æ¨¡åž‹å¤±è´¥: ${error.message}`);
            }
        }
        
        
        document.getElementById('fetch-models-btn').addEventListener('click', () => {
            fetchModels('proxy-url', 'api-key', 'model-select');
        });
        
        
        document.getElementById('fetch-secondary-models-btn').addEventListener('click', () => {
            fetchModels('secondary-proxy-url', 'secondary-api-key', 'secondary-model-select');
        });
          
                    document.getElementById('add-world-book-btn').addEventListener('click', async () => { const name = await showCustomPrompt('åˆ›å»ºä¸–ç•Œä¹¦', 'è¯·è¾“å…¥ä¹¦å'); if (name && name.trim()) { const newBook = { id: 'wb_' + Date.now(), name: name.trim(), content: '' }; await db.worldBooks.add(newBook); state.worldBooks.push(newBook); renderWorldBookScreen(); openWorldBookEditor(newBook.id); } });

document.getElementById('save-world-book-btn').addEventListener('click', async () => {
    if (!editingWorldBookId) return;
    const book = state.worldBooks.find(wb => wb.id === editingWorldBookId);
    if (!book) return;

    
    const newName = document.getElementById('world-book-name-input').value.trim();
    if (!newName) { alert('ä¹¦åä¸èƒ½ä¸ºç©ºï¼'); return; }
    book.name = newName;
    const categoryId = document.getElementById('world-book-category-select').value;
    book.categoryId = categoryId ? parseInt(categoryId) : null;

    const entriesContainer = document.getElementById('world-book-entries-container');
    const entryBlocks = entriesContainer.querySelectorAll('.message-editor-block');
    const newEntries = [];

    entryBlocks.forEach(block => {
        const keysInput = block.querySelector('.entry-keys-input').value.trim();
        const content = block.querySelector('.entry-content-textarea').value.trim();
        const isEnabled = block.querySelector('.entry-enabled-switch').checked;
        if (content) {
            newEntries.push({
                comment: block.querySelector('.entry-comment-input').value.trim(),
                keys: keysInput ? keysInput.split(',').map(k => k.trim()).filter(k => k) : [],
                content: content,
                enabled: isEnabled
            });
        }
    });
    book.content = newEntries;

    
    await db.worldBooks.put(book);
    document.getElementById('world-book-editor-title').textContent = newName;
    editingWorldBookId = null;

    
    showScreen('world-book-screen');
    
    
    await renderWorldBookScreen();
});
  
        
        document.getElementById('chat-messages').addEventListener('click', async (e) => {
const regenBtn = e.target.closest('.nai-regenerate-btn');
            if (regenBtn) {
                e.stopPropagation();
                const bubble = e.target.closest('.message-bubble');
                if (bubble) {
                    const timestamp = parseInt(bubble.dataset.timestamp);
                    if (!isNaN(timestamp)) {
                        await handleRegenerateNaiImage(timestamp, regenBtn);
                    }
                }
                return; 
            }    
const voiceBody = e.target.closest('.voice-message-body[data-text]');
if (voiceBody) {
    
    const chat = state.chats[state.activeChatId];
    if (!chat) return; 

    
    toggleVoiceTranscript(voiceBody);

    
    const bubble = voiceBody.closest('.message-bubble');
    const transcriptEl = bubble ? bubble.querySelector('.voice-transcript') : null;

    
    if (voiceBody.dataset.voiceId && transcriptEl && transcriptEl.style.display === 'block') {

        
        if (chat.isGroup) {
            console.log("è¿™æ˜¯ä¸€æ¡ç¾¤èŠè¯­éŸ³æ¶ˆæ¯ï¼Œå·²ç¦æ­¢å‘èµ·TTSè¯·æ±‚ã€‚");
            return; 
        }
        if (chat.settings.enableTts === false) {
            console.log(`â€œ${chat.name}â€çš„TTSåŠŸèƒ½å·²å…³é—­ï¼Œå·²ç¦æ­¢å‘èµ·TTSè¯·æ±‚ã€‚`);
            return; 
        }

        
        playTtsAudio(voiceBody);
    }

    return; 
}
            
            const detailsBtn = e.target.closest('.waimai-details-btn');
            if (detailsBtn) {
                const bubble = detailsBtn.closest('.message-bubble');
                if (bubble) {
                    const timestamp = parseInt(bubble.dataset.timestamp);
                    if (!isNaN(timestamp)) {
                        showWaimaiDetails(timestamp); 
                        return; 
                    }
                }
            }
            
            
            
            const choiceBtn = e.target.closest('.waimai-user-actions button');
            if (choiceBtn) {
                const bubble = choiceBtn.closest('.message-bubble');
                if (bubble) {
                    const timestamp = parseInt(bubble.dataset.timestamp);
                    const choice = choiceBtn.dataset.choice; 
                    if (!isNaN(timestamp) && choice) {
                        await handleWaimaiResponse(timestamp, choice); 
                        return; 
                    }
                }
            }
        
            
            const deletedPostPlaceholder = e.target.closest('.post-deleted-placeholder');
            if (deletedPostPlaceholder) {
                const postId = parseInt(deletedPostPlaceholder.dataset.postId);
                if (!isNaN(postId)) {
                    const post = await db.qzonePosts.get(postId);
                    if (post) {
                        let originalContent = '';
                        const authorName = post.authorId === 'user' ? state.qzoneSettings.nickname : (state.chats[post.authorId]?.name || 'æœªçŸ¥ä½œè€…');
                        
                        if(post.type === 'shuoshuo'){
                            originalContent = post.content;
                        } else {
                            originalContent = post.publicText || '';
                            if(post.imageUrl) originalContent += `\n[å›¾ç‰‡]`;
                            if(post.hiddenContent) originalContent += `\n[æ–‡å­—å›¾å†…å®¹: ${post.hiddenContent}]`;
                        }
                        
                        showCustomAlert(
                            `æ¥è‡ª ${authorName} çš„å·²åˆ é™¤åŠ¨æ€`, 
                            originalContent.replace(/\n/g, '<br>')
                        );
                    } else {
                        showCustomAlert('æç¤º', 'è¿™æ¡åŠ¨æ€çš„åŽŸå§‹æ•°æ®å·²è¢«å½»åº•æ¸…é™¤ã€‚');
                    }
                }
                return;
            }
        
            const aiImage = e.target.closest('.ai-generated-image');
            if (aiImage) {
                const description = aiImage.dataset.description;
                if (description) showCustomAlert('ç…§ç‰‡æè¿°', description);
                return;
            }
        
            const quoteBlock = e.target.closest('.quoted-message');
            if (quoteBlock && quoteBlock.dataset.originalTimestamp) {
                const originalTimestamp = parseInt(quoteBlock.dataset.originalTimestamp);
                if (!isNaN(originalTimestamp)) {
                    scrollToOriginalMessage(originalTimestamp);
                }
            }
            
            const giftCard = e.target.closest('.gift-card');
            if (giftCard) {
                const bubble = giftCard.closest('.message-bubble');
                if (bubble) {
                    showGiftReceipt(parseInt(bubble.dataset.timestamp));
                }
            }
        
            const packetCard = e.target.closest('.red-packet-card');
            if (packetCard) {
                const messageBubble = packetCard.closest('.message-bubble');
                if (messageBubble && messageBubble.dataset.timestamp) {
                    const timestamp = parseInt(messageBubble.dataset.timestamp);
                    handlePacketClick(timestamp);
                }
            }
            
            const pollCard = e.target.closest('.poll-card');
            if (pollCard) {
                const timestamp = parseInt(pollCard.dataset.pollTimestamp);
                if (isNaN(timestamp)) return;
                
                const optionItem = e.target.closest('.poll-option-item');
                if (optionItem && !pollCard.classList.contains('closed')) {
                    handleUserVote(timestamp, optionItem.dataset.option);
                    return;
                }
                
                const actionBtn = e.target.closest('.poll-action-btn');
                if (actionBtn) {
                    if (pollCard.classList.contains('closed')) {
                        showPollResults(timestamp);
                    } else {
                        endPoll(timestamp);
                    }
                    return;
                }
        
                if (pollCard.classList.contains('closed')) {
                    showPollResults(timestamp);
                }
            }
        

        
            const placeholder = e.target.closest('.recalled-message-placeholder');
            if (placeholder) {
                const chat = state.chats[state.activeChatId];
                const wrapper = placeholder.closest('.message-wrapper');
                if (chat && wrapper) {
                    const timestamp = parseInt(wrapper.dataset.timestamp);
                    const recalledMsg = chat.history.find(m => m.timestamp === timestamp);
                    
                    if (recalledMsg && recalledMsg.recalledData) {
                        let originalContentText = '';
                        const recalled = recalledMsg.recalledData;
                        
                        if (recalled.originalType === 'text') {
                            originalContentText = `åŽŸæ–‡: "${recalled.originalContent}"`;
                        } else {
                            originalContentText = `æ’¤å›žäº†ä¸€æ¡[${recalled.originalType}]ç±»åž‹çš„æ¶ˆæ¯`;
                        }
                        showCustomAlert('å·²æ’¤å›žçš„æ¶ˆæ¯', originalContentText);
                    }
                }
            }
        
            const linkCard = e.target.closest('.link-share-card');
            if (linkCard && linkCard.closest('.message-bubble.is-link-share')) {
                const timestamp = parseInt(linkCard.dataset.timestamp);
                openSharedHistoryViewer(timestamp);
            }
        
            const bubble = e.target.closest('.message-bubble');
            if (bubble && bubble.classList.contains('ai') && bubble.classList.contains('is-transfer') && bubble.dataset.status === 'pending') {
                const timestamp = parseInt(bubble.dataset.timestamp);
                if (!isNaN(timestamp)) {
                    showTransferActionModal(timestamp);
                }
            }
        });
          
                    
                    const chatSettingsModal = document.getElementById('chat-settings-modal');
                    const worldBookSelectBox = document.querySelector('.custom-multiselect .select-box');
                    const worldBookCheckboxesContainer = document.getElementById('world-book-checkboxes-container');
        
        function updateWorldBookSelectionDisplay() {
            const checkedBoxes = worldBookCheckboxesContainer.querySelectorAll('input:checked');
            const displayText = document.querySelector('.selected-options-text');
            
            if (checkedBoxes.length === 0) {
                displayText.textContent = '-- ç‚¹å‡»é€‰æ‹© --';
            } else if (checkedBoxes.length > 2) {
                displayText.textContent = `å·²é€‰æ‹© ${checkedBoxes.length} æœ¬ä¸–ç•Œä¹¦`;
            } else {
                const displayItems = Array.from(checkedBoxes).map(cb => {
                    return cb.parentElement.textContent.trim();
                });
                displayText.textContent = displayItems.join(', ');
            }
        }
             
                    
                    worldBookSelectBox.addEventListener('click', (e) => { e.stopPropagation(); worldBookCheckboxesContainer.classList.toggle('visible'); worldBookSelectBox.classList.toggle('expanded'); });
                    document.getElementById('world-book-checkboxes-container').addEventListener('change', updateWorldBookSelectionDisplay);
                    window.addEventListener('click', (e) => { if (!document.querySelector('.custom-multiselect').contains(e.target)) { worldBookCheckboxesContainer.classList.remove('visible'); worldBookSelectBox.classList.remove('expanded'); } });
        
        document.getElementById('chat-settings-btn').addEventListener('click', async () => {
            loadThemePresetsDropdown(); 
            if (!state.activeChatId) return;
            const chat = state.chats[state.activeChatId];
            const isGroup = chat.isGroup;
        
            
            const switchGreetingGroup = document.getElementById('switch-greeting-group');
            if (!isGroup && chat.settings.alternateGreetings && chat.settings.alternateGreetings.length > 0) {
                switchGreetingGroup.style.display = 'block';
            } else {
                switchGreetingGroup.style.display = 'none';
            }
            
            document.getElementById('chat-name-group').style.display = 'block';
            document.getElementById('my-persona-group').style.display = 'block';
            document.getElementById('my-avatar-group').style.display = 'block';
            document.getElementById('my-group-nickname-group').style.display = isGroup ? 'block' : 'none';
            document.getElementById('my-nickname-group').style.display = isGroup ? 'none' : 'block';
            document.getElementById('group-avatar-group').style.display = isGroup ? 'block' : 'none';
            document.getElementById('group-members-group').style.display = isGroup ? 'block' : 'none';
            document.getElementById('ai-persona-group').style.display = isGroup ? 'none' : 'block';
            document.getElementById('ai-avatar-group').style.display = isGroup ? 'none' : 'block';
            document.getElementById('assign-group-section').style.display = isGroup ? 'none' : 'block';
            document.getElementById('ai-original-name-group').style.display = isGroup ? 'none' : 'block';
            document.getElementById('ai-voice-id-group').style.display = isGroup ? 'none' : 'block';
           document.getElementById('inject-thought-group').style.display = isGroup ? 'none' : 'block';
            document.getElementById('offline-mode-group').style.display = isGroup ? 'none' : 'block';
            document.getElementById('ai-cooldown-group').style.display = isGroup ? 'none' : 'block';
            document.getElementById('group-cooldown-group').style.display = isGroup ? 'block' : 'none';
            document.getElementById('chat-name-input').value = chat.name;
            document.getElementById('my-persona').value = chat.settings.myPersona;
            document.getElementById('my-avatar-preview').src = chat.settings.myAvatar || (isGroup ? defaultMyGroupAvatar : defaultAvatar);
            document.getElementById('max-memory').value = chat.settings.maxMemory;
            document.getElementById('linked-memory-count').value = chat.settings.linkedMemoryCount || 10;
            const bgPreview = document.getElementById('bg-preview');
            const removeBgBtn = document.getElementById('remove-bg-btn');
            if (chat.settings.background) {
                bgPreview.src = chat.settings.background;
                bgPreview.style.display = 'block';
                removeBgBtn.style.display = 'inline-block';
            } else {
                bgPreview.style.display = 'none';
                removeBgBtn.style.display = 'none';
            }
            document.getElementById('lyrics-position-group').style.display = isGroup ? 'none' : 'block';

document.getElementById('single-char-background-activity-group').style.display = isGroup ? 'none' : 'block';
document.getElementById('group-background-activity-group').style.display = isGroup ? 'block' : 'none';




const timePerceptionToggle = document.getElementById('time-perception-toggle');
const timeZoneGroup = document.getElementById('time-zone-group');
timePerceptionToggle.checked = chat.settings.enableTimePerception;
timeZoneGroup.style.display = timePerceptionToggle.checked ? 'block' : 'none';


const timezoneSelect = document.getElementById('time-zone-select');

const timezones = Intl.supportedValuesOf('timeZone');
timezoneSelect.innerHTML = ''; 
timezones.forEach(tz => {
    const option = document.createElement('option');
    option.value = tz;
    option.textContent = tz;
    timezoneSelect.appendChild(option);
});

timezoneSelect.value = chat.settings.timeZone || 'Asia/Shanghai';
if (isGroup) {
    
    document.getElementById('group-background-activity-switch').checked = chat.settings.enableBackgroundActivity;
    document.getElementById('my-group-nickname-input').value = chat.settings.myNickname || '';
    document.getElementById('group-avatar-preview').src = chat.settings.groupAvatar || defaultGroupAvatar;
    document.getElementById('group-action-cooldown-input').value = chat.settings.actionCooldownMinutes || 10;

    
    document.getElementById('single-char-background-activity-group').style.display = 'none';
    renderGroupMemberSettings(chat.members);
} else {
    
    document.getElementById('single-char-background-activity-group').style.display = 'block';
    document.getElementById('char-background-activity-switch').checked = chat.settings.enableBackgroundActivity;
    document.getElementById('inject-thought-toggle').checked = chat.settings.injectLatestThought;
    
    const offlineModeToggle = document.getElementById('offline-mode-toggle');
    const offlineModeOptions = document.getElementById('offline-mode-options');
    const offlineMinInput = document.getElementById('offline-min-length-input');
    const offlineMaxInput = document.getElementById('offline-max-length-input');
    offlineModeToggle.checked = chat.settings.isOfflineMode || false;
    offlineModeOptions.style.display = offlineModeToggle.checked ? 'block' : 'none';
    offlineMinInput.value = chat.settings.offlineMinLength || 100;
    offlineMaxInput.value = chat.settings.offlineMaxLength || 300;
await renderOfflinePresetSelector(chat);
    document.getElementById('ai-original-name-input').value = chat.originalName;
document.getElementById('ai-voice-id-input').value = chat.settings.minimaxVoiceId || '';
document.getElementById('enable-tts-switch').checked = chat.settings.enableTts !== false;
    document.getElementById('ai-persona').value = chat.settings.aiPersona;
    document.getElementById('ai-avatar-preview').src = chat.settings.aiAvatar || defaultAvatar;
    document.getElementById('my-nickname-input').value = chat.settings.myNickname || 'æˆ‘';
    document.getElementById('ai-action-cooldown-input').value = chat.settings.actionCooldownMinutes || 10;
    const select = document.getElementById('assign-group-select');
    select.innerHTML = '<option value="">æœªåˆ†ç»„</option>';
    const groups = await db.qzoneGroups.toArray();
    groups.forEach(group => {
        const option = document.createElement('option');
        option.value = group.id;
        option.textContent = group.name;
        if (chat.groupId === group.id) option.selected = true;
        select.appendChild(option);
    });
    const lyricsPos = chat.settings.lyricsPosition || { vertical: 'top', horizontal: 'center', offset: 10 };
    document.getElementById('lyrics-vertical-pos').value = lyricsPos.vertical;
    document.getElementById('lyrics-horizontal-pos').value = lyricsPos.horizontal;
    document.getElementById('lyrics-offset-input').value = lyricsPos.offset;
}
  
            
            
            const worldBookCheckboxesContainer = document.getElementById('world-book-checkboxes-container');
            worldBookCheckboxesContainer.innerHTML = ''; 
        
            const [allCategories, allBooks] = await Promise.all([
                db.worldBookCategories.toArray(),
                db.worldBooks.toArray()
            ]);
        
            const linkedBookIds = new Set(chat.settings.linkedWorldBookIds || []);
        
            if (allBooks.length === 0) {
                worldBookCheckboxesContainer.innerHTML = '<p style="text-align:center; color: #8a8a8a;">è¿˜æ²¡æœ‰åˆ›å»ºä»»ä½•ä¸–ç•Œä¹¦</p>';
            } else {
                
                allCategories.forEach(cat => {
                    const booksInCategory = allBooks.filter(book => book.categoryId === cat.id);
                    if (booksInCategory.length > 0) {
                        const categoryHeader = document.createElement('h4');
                        categoryHeader.textContent = cat.name; 
                        categoryHeader.style.cssText = 'margin: 10px 0 5px; color: #555; border-bottom: 1px solid #eee; padding-bottom: 3px;';
                        worldBookCheckboxesContainer.appendChild(categoryHeader);
        
                        booksInCategory.forEach(book => {
                            const isChecked = linkedBookIds.has(book.id);
                            const label = document.createElement('label');
                            
                            label.innerHTML = `<input type="checkbox" value="book_${book.id}" ${isChecked ? 'checked' : ''}> ${book.name}`;
                            worldBookCheckboxesContainer.appendChild(label);
                        });
                    }
                });
        
                
                const uncategorizedBooks = allBooks.filter(book => !book.categoryId);
                if (uncategorizedBooks.length > 0) {
                    const bookHeader = document.createElement('h4');
                    bookHeader.textContent = 'æœªåˆ†ç±»';
                    bookHeader.style.cssText = 'margin: 15px 0 5px; color: #555; border-bottom: 1px solid #eee; padding-bottom: 3px;';
                    worldBookCheckboxesContainer.appendChild(bookHeader);
        
                    uncategorizedBooks.forEach(book => {
                        const isChecked = linkedBookIds.has(book.id);
                        const label = document.createElement('label');
                        label.innerHTML = `<input type="checkbox" value="book_${book.id}" ${isChecked ? 'checked' : ''}> ${book.name}`;
                        worldBookCheckboxesContainer.appendChild(label);
                    });
                }
            }
            
        
            updateWorldBookSelectionDisplay();

            const linkMemoryToggle = document.getElementById('link-memory-toggle'); const linkedMemorySelection = document.getElementById('linked-memory-selection'); const linkedChatsContainer = document.getElementById('linked-chats-checkboxes-container'); const linkedMemoryIds = chat.settings.linkedMemoryChatIds || []; linkMemoryToggle.checked = linkedMemoryIds.length > 0; linkedMemorySelection.style.display = linkMemoryToggle.checked ? 'block' : 'none'; linkedChatsContainer.innerHTML = ''; Object.values(state.chats).forEach(c => { if (c.id === chat.id) return; const isChecked = linkedMemoryIds.includes(c.id); const prefix = c.isGroup ? '[ç¾¤èŠ]' : '[ç§èŠ]'; const label = document.createElement('label'); label.innerHTML = `<input type="checkbox" value="${c.id}" ${isChecked ? 'checked' : ''}> ${prefix} ${c.name}`; linkedChatsContainer.appendChild(label); }); function updateLinkedMemorySelectionDisplay() { const checkedBoxes = linkedChatsContainer.querySelectorAll('input:checked'); const displayText = linkedMemorySelection.querySelector('.selected-options-text'); if (checkedBoxes.length === 0) { displayText.textContent = '-- ç‚¹å‡»é€‰æ‹© --'; } else if (checkedBoxes.length > 2) { displayText.textContent = `å·²é€‰æ‹© ${checkedBoxes.length} é¡¹`; } else { displayText.textContent = Array.from(checkedBoxes).map(cb => cb.parentElement.textContent.trim()).join(', '); } } updateLinkedMemorySelectionDisplay(); linkMemoryToggle.addEventListener('change', () => { linkedMemorySelection.style.display = linkMemoryToggle.checked ? 'block' : 'none'; }); const linkedMemorySelectBox = linkedMemorySelection.querySelector('.select-box'); const newLinkedMemorySelectBox = linkedMemorySelectBox.cloneNode(true); linkedMemorySelectBox.parentNode.replaceChild(newLinkedMemorySelectBox, linkedMemorySelectBox); newLinkedMemorySelectBox.addEventListener('click', (e) => { e.stopPropagation(); linkedChatsContainer.classList.toggle('visible'); newLinkedMemorySelectBox.classList.toggle('expanded'); }); linkedChatsContainer.addEventListener('change', updateLinkedMemorySelectionDisplay);
            const themeRadio = document.querySelector(`input[name="theme-select"][value="${chat.settings.theme || 'default'}"]`); if (themeRadio) themeRadio.checked = true;
            const fontSizeSlider = document.getElementById('font-size-slider'); fontSizeSlider.value = chat.settings.fontSize || 13; document.getElementById('font-size-value').textContent = `${fontSizeSlider.value}px`;
            const customCssInput = document.getElementById('custom-css-input'); customCssInput.value = chat.settings.customCss || '';
            updateSettingsPreview();
            document.getElementById('auto-memory-toggle').checked = chat.settings.enableAutoMemory || false;
            document.getElementById('auto-memory-interval').value = chat.settings.autoMemoryInterval || 20;
        setTimeout(() => {
            updateTokenCountDisplay(); // é¦–æ¬¡æ‰“å¼€æ—¶è®¡ç®—ä¸€æ¬¡

            // ä¸ºæ‰€æœ‰å½±å“ä¸Šä¸‹æ–‡çš„è¾“å…¥æ¡†æ·»åŠ äº‹ä»¶ç›‘å¬
            const inputsToWatch = [
                'ai-persona', 'my-persona', 'max-memory', 
                'linked-memory-count', 'auto-memory-toggle', 'auto-memory-interval',
                'offline-mode-toggle', 'offline-min-length-input', 
                'offline-max-length-input', 'offline-preset-select'
            ];
            
            inputsToWatch.forEach(id => {
                const el = document.getElementById(id);
                if (el) {
                    el.addEventListener('input', updateTokenCountDisplay);
                }
            });

            // ä¸ºå¤šé€‰æ¡†å®¹å™¨æ·»åŠ äº‹ä»¶ç›‘å¬
            document.getElementById('world-book-checkboxes-container').addEventListener('change', updateTokenCountDisplay);
            document.getElementById('linked-chats-checkboxes-container').addEventListener('change', updateTokenCountDisplay);
            document.getElementById('link-memory-toggle').addEventListener('change', updateTokenCountDisplay);
        }, 100);
            showScreen('chat-settings-screen');
        });
          
                    

function renderGroupMemberSettings(members) { 
    const container = document.getElementById('group-members-settings'); 
    container.innerHTML = ''; 
    members.forEach(member => { 
        const div = document.createElement('div'); 
        div.className = 'member-editor'; 
        div.dataset.memberId = member.id; 
        
        
        
        
        const memberAvatar = member.avatar || (state.chats[member.id] ? state.chats[member.id].settings.aiAvatar : defaultGroupMemberAvatar);

        div.innerHTML = `<img src="${memberAvatar}" alt="${member.groupNickname}"><div class="member-name">${member.groupNickname}</div>`;
        div.addEventListener('click', () => openMemberEditor(member.id)); 
        container.appendChild(div); 
    }); 
}
  


document.getElementById('save-member-settings-btn').addEventListener('click', async () => {
    if (!editingMemberId) return; 
    const chat = state.chats[state.activeChatId]; 
    const member = chat.members.find(m => m.id === editingMemberId); 
    if (!member) return;

    const newNickname = document.getElementById('member-name-input').value.trim();
    if (!newNickname) {
        alert("ç¾¤æ˜µç§°ä¸èƒ½ä¸ºç©ºï¼");
        return;
    }
    member.groupNickname = newNickname; 
    member.persona = document.getElementById('member-persona-input').value; 
    
    const newAvatarUrl = document.getElementById('member-avatar-preview').src;

    
    
    member.avatar = newAvatarUrl;

    
    const characterProfile = state.chats[member.id];
    if (characterProfile) {
        characterProfile.settings.aiAvatar = newAvatarUrl;
        await db.chats.put(characterProfile);
    }
    
    
    await db.chats.put(chat);
    
    
    renderGroupMemberSettings(chat.members); 
    document.getElementById('member-settings-modal').classList.remove('visible'); 
    editingMemberId = null;
});
  
        
        
        function openMemberEditor(memberId) { 
            editingMemberId = memberId; 
            const chat = state.chats[state.activeChatId]; 
            const member = chat.members.find(m => m.id === memberId); 
            if (!member) return; 
        
            document.getElementById('member-name-input').value = member.groupNickname; 
            document.getElementById('member-persona-input').value = member.persona; 
            
            
            
            const memberAvatar = member.avatar || (state.chats[member.id] ? state.chats[member.id].settings.aiAvatar : defaultGroupMemberAvatar);
            document.getElementById('member-avatar-preview').src = memberAvatar;
        
            document.getElementById('member-settings-modal').classList.add('visible'); 
        }
          
                    document.getElementById('cancel-member-settings-btn').addEventListener('click', () => { document.getElementById('member-settings-modal').classList.remove('visible'); editingMemberId = null; });
                    
        
        document.getElementById('save-member-settings-btn').addEventListener('click', async () => {
            if (!editingMemberId) return; 
            const chat = state.chats[state.activeChatId]; 
            const member = chat.members.find(m => m.id === editingMemberId); 
            if (!member) return;
        
            const newNickname = document.getElementById('member-name-input').value.trim();
            if (!newNickname) {
                alert("ç¾¤æ˜µç§°ä¸èƒ½ä¸ºç©ºï¼");
                return;
            }
            member.groupNickname = newNickname; 
            member.persona = document.getElementById('member-persona-input').value; 
            
            const newAvatarUrl = document.getElementById('member-avatar-preview').src;
        
            
            
            member.avatar = newAvatarUrl;
        
            
            const characterProfile = state.chats[member.id];
            if (characterProfile) {
                characterProfile.settings.aiAvatar = newAvatarUrl;
                await db.chats.put(characterProfile);
            }
            
            
            await db.chats.put(chat);
            
            
            renderGroupMemberSettings(chat.members); 
            document.getElementById('member-settings-modal').classList.remove('visible'); 
            editingMemberId = null;
        });
          
                    document.getElementById('reset-theme-btn').addEventListener('click', () => { document.getElementById('theme-default').checked = true; });
                   
        

document.getElementById('save-chat-settings-btn').addEventListener('click', async () => {
    if (!state.activeChatId) return;
    const chat = state.chats[state.activeChatId];
    
    
    const oldOfflineModeState = chat.settings.isOfflineMode || false;

    
    const newName = document.getElementById('chat-name-input').value.trim();
    if (!newName) return alert('å¤‡æ³¨å/ç¾¤åä¸èƒ½ä¸ºç©ºï¼');
    if (!chat.isGroup && newName !== chat.name) {
        if (!chat.nameHistory) chat.nameHistory = [];
        if (!chat.nameHistory.includes(chat.name)) chat.nameHistory.push(chat.name);
    }
    chat.name = newName;
    const selectedThemeRadio = document.querySelector('input[name="theme-select"]:checked');
    chat.settings.theme = selectedThemeRadio ? selectedThemeRadio.value : 'default';
    chat.settings.fontSize = parseInt(document.getElementById('font-size-slider').value);
    chat.settings.customCss = document.getElementById('custom-css-input').value.trim();
    chat.settings.myPersona = document.getElementById('my-persona').value;
    chat.settings.myAvatar = document.getElementById('my-avatar-preview').src;
    chat.settings.maxMemory = parseInt(document.getElementById('max-memory').value) || 10;
    chat.settings.linkedMemoryCount = parseInt(document.getElementById('linked-memory-count').value) || 10;
    
    const checkedBookItems = document.querySelectorAll('#world-book-checkboxes-container input[type="checkbox"]:checked');
    const newLinkedBookIds = [];
    checkedBookItems.forEach(cb => {
        if (cb.value.startsWith('book_')) {
            newLinkedBookIds.push(cb.value.replace('book_', ''));
        }
    });
    chat.settings.linkedWorldBookIds = newLinkedBookIds;
    
    const linkMemoryToggleChecked = document.getElementById('link-memory-toggle').checked;
    if (linkMemoryToggleChecked) {
        const checkedChats = document.querySelectorAll('#linked-chats-checkboxes-container input:checked');
        chat.settings.linkedMemoryChatIds = Array.from(checkedChats).map(cb => cb.value);
    } else {
        chat.settings.linkedMemoryChatIds = [];
    }
    chat.settings.enableAutoMemory = document.getElementById('auto-memory-toggle').checked;
    chat.settings.autoMemoryInterval = parseInt(document.getElementById('auto-memory-interval').value) || 20;
    chat.settings.enableTimePerception = document.getElementById('time-perception-toggle').checked;
    chat.settings.timeZone = document.getElementById('time-zone-select').value;
    
    if (chat.isGroup) {
        chat.settings.enableBackgroundActivity = document.getElementById('group-background-activity-switch').checked;
        chat.settings.myNickname = document.getElementById('my-group-nickname-input').value.trim();
        chat.settings.groupAvatar = document.getElementById('group-avatar-preview').src;
        chat.settings.actionCooldownMinutes = parseInt(document.getElementById('group-action-cooldown-input').value) || 10;
    } else {
        chat.settings.enableBackgroundActivity = document.getElementById('char-background-activity-switch').checked;
        const newOfflineModeState = document.getElementById('offline-mode-toggle').checked;
        chat.settings.isOfflineMode = newOfflineModeState;

        
        
        
        
        
        if (oldOfflineModeState === true && newOfflineModeState === false) {
            
            
            const switchInstruction = {
                role: 'system',
                content: '[ç³»ç»ŸæŒ‡ä»¤ï¼šæ¨¡å¼å·²åˆ‡æ¢ï¼ä½ çŽ°åœ¨å›žåˆ°äº†çº¿ä¸ŠèŠå¤©æ¨¡å¼ã€‚ä½ çš„å›žå¤ã€å¿…é¡»ã€‘ä¸¥æ ¼éµå®ˆçº¿ä¸Šæ¨¡å¼çš„JSONæ•°ç»„æ ¼å¼ï¼Œä¾‹å¦‚ [{"type": "text", "content": "ä½ å¥½"}]]',
                timestamp: Date.now(),
                isHidden: true 
            };
            
            
            chat.history.push(switchInstruction);
            console.log("å·²æˆåŠŸæ³¨å…¥â€œåˆ‡æ¢åˆ°çº¿ä¸Šæ¨¡å¼â€çš„ç³»ç»ŸæŒ‡ä»¤ã€‚");
        }
        
        
        chat.settings.injectLatestThought = document.getElementById('inject-thought-toggle').checked;        
        chat.settings.offlineMinLength = parseInt(document.getElementById('offline-min-length-input').value) || 100;
        chat.settings.offlineMaxLength = parseInt(document.getElementById('offline-max-length-input').value) || 300;
        chat.settings.offlinePresetId = document.getElementById('offline-preset-select').value || null;
        
        const newOriginalName = document.getElementById('ai-original-name-input').value.trim();
        if (!newOriginalName) return alert('å¯¹æ–¹æœ¬åä¸èƒ½ä¸ºç©ºï¼');
        chat.originalName = newOriginalName;
        chat.settings.aiPersona = document.getElementById('ai-persona').value;
        chat.settings.minimaxVoiceId = document.getElementById('ai-voice-id-input').value.trim();
chat.settings.enableTts = document.getElementById('enable-tts-switch').checked;
        chat.settings.aiAvatar = document.getElementById('ai-avatar-preview').src;
        chat.settings.myNickname = document.getElementById('my-nickname-input').value.trim() || 'æˆ‘';
        chat.settings.actionCooldownMinutes = parseInt(document.getElementById('ai-action-cooldown-input').value) || 10;
        chat.settings.lyricsPosition = {
            vertical: document.getElementById('lyrics-vertical-pos').value,
            horizontal: document.getElementById('lyrics-horizontal-pos').value,
            offset: parseInt(document.getElementById('lyrics-offset-input').value) || 10
        };
        const selectedGroupId = document.getElementById('assign-group-select').value;
        chat.groupId = selectedGroupId ? parseInt(selectedGroupId) : null;
    }

    await db.chats.put(chat);
    if (!chat.isGroup) {
        await syncCharacterNameInGroups(chat);
        await syncCharacterAvatarInGroups(chat);
    }
    applyLyricsBarPosition(chat);
    applyScopedCss(chat.settings.customCss, '#chat-messages', 'custom-bubble-style');
    showScreen('chat-interface-screen');
    renderChatInterface(state.activeChatId);
    renderChatList();
});
  
        
        
        
        



document.getElementById('chat-settings-screen').addEventListener('click', (e) => {
    if (e.target.classList.contains('change-frame-btn')) {
        openFrameSelectorModal('chat');
    }
});
        
        
        document.getElementById('member-settings-modal').addEventListener('click', (e) => {
            if (e.target.classList.contains('change-frame-btn')) { 
                openFrameSelectorModal('member');
            }
        });
        
        
        const frameModal = document.getElementById('avatar-frame-modal');
        const aiFrameTab = document.getElementById('ai-frame-tab');
        const myFrameTab = document.getElementById('my-frame-tab');
        const aiFrameContent = document.getElementById('ai-frame-content');
        const myFrameContent = document.getElementById('my-frame-content');
        
        
        document.getElementById('save-frame-settings-btn').addEventListener('click', saveSelectedFrames);
        
        
        document.getElementById('cancel-frame-settings-btn').addEventListener('click', () => {
            frameModal.classList.remove('visible');
            editingFrameForMember = false; 
        });
        
        
        aiFrameTab.addEventListener('click', () => {
            aiFrameTab.classList.add('active');
            myFrameTab.classList.remove('active');
            aiFrameContent.style.display = 'block';
            myFrameContent.style.display = 'none';
        });
        
        
        myFrameTab.addEventListener('click', () => {
            myFrameTab.classList.add('active');
            aiFrameTab.classList.remove('active');
            myFrameContent.style.display = 'block';
            aiFrameContent.style.display = 'none';
        });
        
          
                    document.getElementById('clear-chat-btn').addEventListener('click', async () => { if (!state.activeChatId) return; const chat = state.chats[state.activeChatId]; const confirmed = await showCustomConfirm('æ¸…ç©ºèŠå¤©è®°å½•', 'æ­¤æ“ä½œå°†æ°¸ä¹…åˆ é™¤æ­¤èŠå¤©çš„æ‰€æœ‰æ¶ˆæ¯ï¼Œæ— æ³•æ¢å¤ã€‚ç¡®å®šè¦æ¸…ç©ºå—ï¼Ÿ', { confirmButtonClass: 'btn-danger' }); if (confirmed) { chat.history = [];chat.heartfeltVoice = '...';chat.randomJottings = '...'; await db.chats.put(chat); renderChatInterface(state.activeChatId); renderChatList(); chatSettingsModal.classList.remove('visible'); } });
                    
                    const setupFileUpload = (inputId, callback) => { document.getElementById(inputId).addEventListener('change', async (event) => { const file = event.target.files[0]; if (file) { const dataUrl = await new Promise((res, rej) => { const reader = new FileReader(); reader.onload = () => res(reader.result); reader.onerror = () => rej(reader.error); reader.readAsDataURL(file); }); callback(dataUrl); event.target.value = null; } }); };
                    setupFileUpload('ai-avatar-input', (base64) => document.getElementById('ai-avatar-preview').src = base64);
                    setupFileUpload('my-avatar-input', (base64) => document.getElementById('my-avatar-preview').src = base64);
                    setupFileUpload('group-avatar-input', (base64) => document.getElementById('group-avatar-preview').src = base64);
                    setupFileUpload('member-avatar-input', (base64) => document.getElementById('member-avatar-preview').src = base64);
                    setupFileUpload('bg-input', (base64) => { if(state.activeChatId) { state.chats[state.activeChatId].settings.background = base64; const bgPreview = document.getElementById('bg-preview'); bgPreview.src = base64; bgPreview.style.display = 'block'; document.getElementById('remove-bg-btn').style.display = 'inline-block'; } });
                    setupFileUpload('preset-avatar-input', (base64) => document.getElementById('preset-avatar-preview').src = base64);
                    document.getElementById('remove-bg-btn').addEventListener('click', () => { if (state.activeChatId) { state.chats[state.activeChatId].settings.background = ''; const bgPreview = document.getElementById('bg-preview'); bgPreview.src = ''; bgPreview.style.display = 'none'; document.getElementById('remove-bg-btn').style.display = 'none'; } });
        
                    const stickerPanel = document.getElementById('sticker-panel');
document.getElementById('open-sticker-panel-btn').addEventListener('click', () => { 
    const chat = state.chats[state.activeChatId];
    if (chat && chat.settings.stickerCategoryId) {
       
        activeStickerCategoryId = chat.settings.stickerCategoryId;
    } else {
    
        activeStickerCategoryId = 'all'; 
    }
    renderStickerPanel(); 
    stickerPanel.classList.add('visible'); 
});
                    document.getElementById('close-sticker-panel-btn').addEventListener('click', () => stickerPanel.classList.remove('visible'));
                    
        
        
        document.getElementById('add-sticker-batch-btn').addEventListener('click', openBatchStickerImportModal);
        



        
          
                    document.getElementById('upload-sticker-btn').addEventListener('click', () => document.getElementById('sticker-upload-input').click());
                    document.getElementById('sticker-upload-input').addEventListener('change', async (event) => { 
            const file = event.target.files[0]; 
            if (!file) return; 
            const reader = new FileReader(); 
            reader.readAsDataURL(file); 
            reader.onload = async () => { 
                const base64Url = reader.result; 
                const name = await showCustomPrompt("å‘½åè¡¨æƒ…", "è¯·ä¸ºè¿™ä¸ªè¡¨æƒ…å‘½å (ä¾‹å¦‚ï¼šå¥½è€¶ã€ç–‘æƒ‘)"); 
                if (name && name.trim()) { 
                    const newSticker = { 
                        id: 'sticker_' + Date.now(), 
                        url: base64Url, 
                        name: name.trim(),
                        
                        categoryId: (activeStickerCategoryId !== 'all' && activeStickerCategoryId !== 'uncategorized') ? activeStickerCategoryId : null
                    }; 
                    await db.userStickers.add(newSticker); 
                    state.userStickers.push(newSticker); 
                    renderStickerPanel(); 
                } else if (name !== null) alert("è¡¨æƒ…åä¸èƒ½ä¸ºç©ºï¼"); 
            }; 
            event.target.value = null; 
        });
        
                    document.getElementById('upload-image-btn').addEventListener('click', () => document.getElementById('image-upload-input').click());
                    document.getElementById('image-upload-input').addEventListener('change', async (event) => { const file = event.target.files[0]; if (!file || !state.activeChatId) return; const reader = new FileReader(); reader.onload = async (e) => { const base64Url = e.target.result; const chat = state.chats[state.activeChatId]; const msg = { role: 'user', content: [{ type: 'image_url', image_url: { url: base64Url } }], timestamp: Date.now() }; chat.history.push(msg); await db.chats.put(chat); appendMessage(msg, chat); renderChatList(); }; reader.readAsDataURL(file); event.target.value = null; });
                    document.getElementById('voice-message-btn').addEventListener('click', async () => {
    if (!state.activeChatId) return;

    const text = await showCustomPrompt("å‘é€è¯­éŸ³", "è¯·è¾“å…¥ä½ æƒ³è¯´çš„å†…å®¹ï¼š");
    if (text && text.trim()) {
        const chat = state.chats[state.activeChatId];
        
        
        const msg = {
            role: 'user',
            type: 'voice_message', 
            content: text.trim(),
            timestamp: Date.now()
        };
        
        chat.history.push(msg);
        await db.chats.put(chat);
        appendMessage(msg, chat);
        renderChatList();
    }
});
                    document.getElementById('send-photo-btn').addEventListener('click', async () => { if (!state.activeChatId) return; const description = await showCustomPrompt("å‘é€ç…§ç‰‡", "è¯·ç”¨æ–‡å­—æè¿°æ‚¨è¦å‘é€çš„ç…§ç‰‡ï¼š"); if (description && description.trim()) { const chat = state.chats[state.activeChatId]; const msg = { role: 'user', type: 'user_photo', content: description.trim(), timestamp: Date.now() }; chat.history.push(msg); await db.chats.put(chat); appendMessage(msg, chat); renderChatList(); } });
        
const waimaiModal = document.getElementById('waimai-request-modal');


document.getElementById('send-waimai-request-btn').addEventListener('click', () => {
    waimaiModal.classList.add('visible');
});


waimaiModal.addEventListener('click', (e) => {
    
    if (e.target === waimaiModal) {
        waimaiModal.classList.remove('visible');
    }
});


document.getElementById('waimai-order-for-ai-btn').addEventListener('click', sendWaimaiOrderForAI);


document.getElementById('waimai-confirm-btn').addEventListener('click', async () => {
    if (!state.activeChatId) return;
    
    const productInfoInput = document.getElementById('waimai-product-info');
    const amountInput = document.getElementById('waimai-amount');
    
    const productInfo = productInfoInput.value.trim();
    const amount = parseFloat(amountInput.value);

    if (!productInfo || isNaN(amount) || amount <= 0) {
        alert('è¯·å¡«å†™æœ‰æ•ˆçš„å•†å“ä¿¡æ¯å’Œé‡‘é¢ï¼');
        return;
    }

    const chat = state.chats[state.activeChatId];
    const now = Date.now();
    const myNickname = chat.isGroup ? (chat.settings.myNickname || 'æˆ‘') : 'æˆ‘';
    
    const msg = {
        role: 'user',
        senderName: myNickname, 
        type: 'waimai_request',
        productInfo: productInfo,
        amount: amount,
        status: 'pending',
        countdownEndTime: now + 15 * 60 * 1000,
        timestamp: now
    };

    chat.history.push(msg);
    await db.chats.put(chat);
    appendMessage(msg, chat);
    renderChatList();

    productInfoInput.value = '';
    amountInput.value = '';
    waimaiModal.classList.remove('visible');
});       
                    document.getElementById('open-persona-library-btn').addEventListener('click', openPersonaLibrary);
                    document.getElementById('close-persona-library-btn').addEventListener('click', closePersonaLibrary);
                    document.getElementById('add-persona-preset-btn').addEventListener('click', openPersonaEditorForCreate);
                    document.getElementById('cancel-persona-editor-btn').addEventListener('click', closePersonaEditor);
                    document.getElementById('save-persona-preset-btn').addEventListener('click', savePersonaPreset);
                    document.getElementById('preset-action-edit').addEventListener('click', openPersonaEditorForEdit);
                    document.getElementById('preset-action-delete').addEventListener('click', deletePersonaPreset);
                    document.getElementById('preset-action-cancel').addEventListener('click', hidePresetActions);
                    
                    document.getElementById('selection-cancel-btn').addEventListener('click', exitSelectionMode);
        
        

        
        document.getElementById('selection-soft-delete-btn').addEventListener('click', async () => {
            if (selectedMessages.size === 0) return;
            const confirmed = await showCustomConfirm('åˆ é™¤æ¶ˆæ¯', `ç¡®å®šè¦åˆ é™¤é€‰ä¸­çš„ ${selectedMessages.size} æ¡æ¶ˆæ¯å—ï¼Ÿè¿™ä¼šé€šçŸ¥AIè¿™äº›æ¶ˆæ¯å·²è¢«åˆ é™¤ã€‚`, { confirmButtonClass: 'btn-danger' });
            if (confirmed) {
                const chat = state.chats[state.activeChatId];
                let deletedPollsInfo = [];
                for (const timestamp of selectedMessages) {
                    const msg = chat.history.find(m => m.timestamp === timestamp);
                    if (msg && msg.type === 'poll') {
                        deletedPollsInfo.push(`å…³äºŽâ€œ${msg.question}â€çš„æŠ•ç¥¨(æ—¶é—´æˆ³: ${msg.timestamp})`);
                    }
                }
                chat.history = chat.history.filter(msg => !selectedMessages.has(msg.timestamp));
                let forgetReason = "ä¸€äº›ä¹‹å‰çš„æ¶ˆæ¯å·²è¢«ç”¨æˆ·åˆ é™¤ã€‚";
                if (deletedPollsInfo.length > 0) {
                    forgetReason += ` å…¶ä¸­åŒ…æ‹¬ä»¥ä¸‹æŠ•ç¥¨ï¼š${deletedPollsInfo.join('ï¼›')}ã€‚`;
                }
                forgetReason += " ä½ åº”è¯¥åƒå®ƒä»¬ä»Žæœªå­˜åœ¨è¿‡ä¸€æ ·ç»§ç»­å¯¹è¯ï¼Œå¹¶ç›¸åº”åœ°è°ƒæ•´ä½ çš„è®°å¿†å’Œè¡Œä¸ºï¼Œä¸è¦å†æåŠè¿™äº›è¢«åˆ é™¤çš„å†…å®¹ã€‚";
                const forgetInstruction = {
                    role: 'system',
                    content: `[ç³»ç»Ÿæç¤ºï¼š${forgetReason}]`,
                    timestamp: Date.now(),
                    isHidden: true
                };
                chat.history.push(forgetInstruction);
                await db.chats.put(chat);
                renderChatInterface(state.activeChatId);
                renderChatList();
            }
        });

        
        document.getElementById('selection-erase-btn').addEventListener('click', async () => {
            if (selectedMessages.size === 0) return;
            const confirmed = await showCustomConfirm(
                'å½»åº•åˆ é™¤æ¶ˆæ¯', 
                `è¿™å°†ä»ŽåŽ†å²è®°å½•ä¸­ã€æ°¸ä¹…æŠ¹é™¤ã€‘è¿™ ${selectedMessages.size} æ¡æ¶ˆæ¯ï¼ŒAIå°†å®Œå…¨é—å¿˜å®ƒä»¬çš„å­˜åœ¨ã€‚ç¡®å®šå—ï¼Ÿ`, 
                { confirmButtonClass: 'btn-danger', confirmText: 'ç¡®è®¤æŠ¹é™¤' }
            );
            if (confirmed) {
                const chat = state.chats[state.activeChatId];
                
                
                chat.history = chat.history.filter(msg => !selectedMessages.has(msg.timestamp));
                
                
                await db.chats.put(chat);
                
                
                renderChatInterface(state.activeChatId);
                renderChatList();
            }
        });
          
        
                    const fontUrlInput = document.getElementById('font-url-input');
                    fontUrlInput.addEventListener('input', () => applyCustomFont(fontUrlInput.value.trim(), true));
                    document.getElementById('save-font-btn').addEventListener('click', async () => {
                        const newFontUrl = fontUrlInput.value.trim();
                        if (!newFontUrl) { alert("è¯·è¾“å…¥æœ‰æ•ˆçš„å­—ä½“URLã€‚"); return; }
                        applyCustomFont(newFontUrl, false);
                        state.globalSettings.fontUrl = newFontUrl;
                        await db.globalSettings.put(state.globalSettings);
                        alert('å­—ä½“å·²ä¿å­˜å¹¶åº”ç”¨ï¼');
                    });
                    document.getElementById('reset-font-btn').addEventListener('click', resetToDefaultFont);
        
                    document.querySelectorAll('#chat-list-bottom-nav .nav-item').forEach(item => { item.addEventListener('click', () => switchToChatListView(item.dataset.view)); });
                    document.getElementById('qzone-back-btn').addEventListener('click', () => switchToChatListView('messages-view'));
                    document.getElementById('qzone-nickname').addEventListener('click', async () => { const newNickname = await showCustomPrompt("ä¿®æ”¹æ˜µç§°", "è¯·è¾“å…¥æ–°çš„æ˜µç§°", state.qzoneSettings.nickname); if (newNickname && newNickname.trim()) { state.qzoneSettings.nickname = newNickname.trim(); await saveQzoneSettings(); renderQzoneScreen(); } });
                    document.getElementById('qzone-avatar-container').addEventListener('click', () => document.getElementById('qzone-avatar-input').click());
                    document.getElementById('qzone-banner-container').addEventListener('click', () => document.getElementById('qzone-banner-input').click());
                    document.getElementById('qzone-avatar-input').addEventListener('change', async (event) => { const file = event.target.files[0]; if (file) { const dataUrl = await new Promise(res => { const reader = new FileReader(); reader.onload = () => res(reader.result); reader.readAsDataURL(file); }); state.qzoneSettings.avatar = dataUrl; await saveQzoneSettings(); renderQzoneScreen(); } event.target.value = null; });
                    document.getElementById('qzone-banner-input').addEventListener('change', async (event) => { const file = event.target.files[0]; if (file) { const dataUrl = await new Promise(res => { const reader = new FileReader(); reader.onload = () => res(reader.result); reader.readAsDataURL(file); }); state.qzoneSettings.banner = dataUrl; await saveQzoneSettings(); renderQzoneScreen(); } event.target.value = null; });
        
        
        document.getElementById('create-shuoshuo-btn').addEventListener('click', async () => {
            
            resetCreatePostModal();
            const modal = document.getElementById('create-post-modal');
            
            
            modal.dataset.mode = 'shuoshuo';
            
            
            modal.querySelector('.post-mode-switcher').style.display = 'none';
            modal.querySelector('#image-mode-content').style.display = 'none';
            modal.querySelector('#text-image-mode-content').style.display = 'none';
            
            
            modal.querySelector('#post-public-text').placeholder = 'åˆ†äº«æ–°é²œäº‹...';
            
            
            const visibilityGroupsContainer = document.getElementById('post-visibility-groups');
            visibilityGroupsContainer.innerHTML = '';
            const groups = await db.qzoneGroups.toArray();
            if (groups.length > 0) {
                groups.forEach(group => {
                    const label = document.createElement('label');
                    label.style.display = 'block';
                    label.innerHTML = `<input type="checkbox" name="visibility_group" value="${group.id}"> ${group.name}`;
                    visibilityGroupsContainer.appendChild(label);
                });
            } else {
                visibilityGroupsContainer.innerHTML = '<p style="color: var(--text-secondary);">æ²¡æœ‰å¯ç”¨çš„åˆ†ç»„</p>';
            }
            modal.classList.add('visible');
        });
        
        
        document.getElementById('create-post-btn').addEventListener('click', async () => {
            
            resetCreatePostModal();
            const modal = document.getElementById('create-post-modal');
            
            
            modal.dataset.mode = 'complex';
            
        
        modal.querySelector('.post-mode-switcher').style.display = 'flex';
        
        modal.querySelector('#image-mode-content').classList.add('active');
        
        modal.querySelector('#text-image-mode-content').classList.remove('active');
            
            
            modal.querySelector('#post-public-text').placeholder = 'åˆ†äº«æ–°é²œäº‹...ï¼ˆéžå¿…å¡«çš„å…¬å¼€æ–‡å­—ï¼‰';
        
            
            const visibilityGroupsContainer = document.getElementById('post-visibility-groups');
            visibilityGroupsContainer.innerHTML = '';
            const groups = await db.qzoneGroups.toArray();
            if (groups.length > 0) {
                groups.forEach(group => {
                    const label = document.createElement('label');
                    label.style.display = 'block';
                    label.innerHTML = `<input type="checkbox" name="visibility_group" value="${group.id}"> ${group.name}`;
                    visibilityGroupsContainer.appendChild(label);
                });
            } else {
                visibilityGroupsContainer.innerHTML = '<p style="color: var(--text-secondary);">æ²¡æœ‰å¯ç”¨çš„åˆ†ç»„</p>';
            }
            modal.classList.add('visible');
        });
                    document.getElementById('open-album-btn').addEventListener('click', async () => { await renderAlbumList(); showScreen('album-screen'); });
                    document.getElementById('album-back-btn').addEventListener('click', () => { showScreen('chat-list-screen'); switchToChatListView('qzone-screen'); });
        
        
        
        document.getElementById('album-photos-back-btn').addEventListener('click', () => {
            state.activeAlbumId = null;
            showScreen('album-screen');
        });
        
        document.getElementById('album-upload-photo-btn').addEventListener('click', () => document.getElementById('album-photo-input').click());
        
        document.getElementById('album-photo-input').addEventListener('change', async (event) => {
            if (!state.activeAlbumId) return;
            const files = event.target.files;
            if (!files.length) return;
        
            const album = await db.qzoneAlbums.get(state.activeAlbumId);
            
            for (const file of files) {
                const dataUrl = await new Promise(resolve => {
                    const reader = new FileReader();
                    reader.onload = () => resolve(reader.result);
                    reader.readAsDataURL(file);
                });
                await db.qzonePhotos.add({ albumId: state.activeAlbumId, url: dataUrl, createdAt: Date.now() });
            }
        
            const photoCount = await db.qzonePhotos.where('albumId').equals(state.activeAlbumId).count();
            const updateData = { photoCount };
            
            if (!album.photoCount || album.coverUrl.includes('placeholder')) {
                const firstPhoto = await db.qzonePhotos.where('albumId').equals(state.activeAlbumId).first();
                if(firstPhoto) updateData.coverUrl = firstPhoto.url;
            }
        
            await db.qzoneAlbums.update(state.activeAlbumId, updateData);
            await renderAlbumPhotosScreen();
            await renderAlbumList();
            
            event.target.value = null;
            alert('ç…§ç‰‡ä¸Šä¼ æˆåŠŸï¼');
        });
        
        
        
        
        
        document.getElementById('photos-grid-page').addEventListener('click', async (e) => {
            const deleteBtn = e.target.closest('.photo-delete-btn');
            const photoThumb = e.target.closest('.photo-thumb');
        
            if (deleteBtn) {
                e.stopPropagation(); 
                const photoId = parseInt(deleteBtn.dataset.photoId);
                const confirmed = await showCustomConfirm(
                    'åˆ é™¤ç…§ç‰‡',
                    'ç¡®å®šè¦åˆ é™¤è¿™å¼ ç…§ç‰‡å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ¢å¤ã€‚',
                    { confirmButtonClass: 'btn-danger' }
                );
        
                if (confirmed) {
                    const deletedPhoto = await db.qzonePhotos.get(photoId);
                    if (!deletedPhoto) return;
                    
                    await db.qzonePhotos.delete(photoId);
        
                    const album = await db.qzoneAlbums.get(state.activeAlbumId);
                    const photoCount = (album.photoCount || 1) - 1;
                    const updateData = { photoCount };
                    
                    if (album.coverUrl === deletedPhoto.url) {
                        const nextPhoto = await db.qzonePhotos.where('albumId').equals(state.activeAlbumId).first();
                        updateData.coverUrl = nextPhoto ? nextPhoto.url : 'https://i.postimg.cc/pT2xKzPz/album-cover-placeholder.png';
                    }
                    
                    await db.qzoneAlbums.update(state.activeAlbumId, updateData);
                    await renderAlbumPhotosScreen();
                    await renderAlbumList();
                    alert('ç…§ç‰‡å·²åˆ é™¤ã€‚');
                }
            } 
            else if (photoThumb) {
                
                openPhotoViewer(photoThumb.src);
            }
        });
        
        
        document.getElementById('photo-viewer-close-btn').addEventListener('click', closePhotoViewer);
        document.getElementById('photo-viewer-next-btn').addEventListener('click', showNextPhoto);
        document.getElementById('photo-viewer-prev-btn').addEventListener('click', showPrevPhoto);
        
        
        document.addEventListener('keydown', (e) => {
            if (!photoViewerState.isOpen) return; 
        
            if (e.key === 'ArrowRight') {
                showNextPhoto();
            } else if (e.key === 'ArrowLeft') {
                showPrevPhoto();
            } else if (e.key === 'Escape') {
                closePhotoViewer();
            }
        });
        
        
                 
        document.getElementById('create-album-btn-page').addEventListener('click', async () => { const albumName = await showCustomPrompt("åˆ›å»ºæ–°ç›¸å†Œ", "è¯·è¾“å…¥ç›¸å†Œåç§°"); if (albumName && albumName.trim()) { const newAlbum = { name: albumName.trim(), coverUrl: 'https://i.postimg.cc/pT2xKzPz/album-cover-placeholder.png', photoCount: 0, createdAt: Date.now() }; await db.qzoneAlbums.add(newAlbum); await renderAlbumList(); alert(`ç›¸å†Œ "${albumName}" åˆ›å»ºæˆåŠŸï¼`); } else if (albumName !== null) { alert("ç›¸å†Œåç§°ä¸èƒ½ä¸ºç©ºï¼"); } });
        
                    document.getElementById('cancel-create-post-btn').addEventListener('click', () => document.getElementById('create-post-modal').classList.remove('visible'));
                    document.getElementById('post-upload-local-btn').addEventListener('click', () => document.getElementById('post-local-image-input').click());
                    document.getElementById('post-local-image-input').addEventListener('change', (event) => { const file = event.target.files[0]; if (file) { const reader = new FileReader(); reader.onload = (e) => { document.getElementById('post-image-preview').src = e.target.result; document.getElementById('post-image-preview-container').classList.add('visible'); document.getElementById('post-image-desc-group').style.display = 'block'; }; reader.readAsDataURL(file); } });
                    document.getElementById('post-use-url-btn').addEventListener('click', async () => { const url = await showCustomPrompt("è¾“å…¥å›¾ç‰‡URL", "è¯·è¾“å…¥ç½‘ç»œå›¾ç‰‡çš„é“¾æŽ¥", "", "url"); if (url) { document.getElementById('post-image-preview').src = url; document.getElementById('post-image-preview-container').classList.add('visible'); document.getElementById('post-image-desc-group').style.display = 'block'; } });
                    document.getElementById('post-remove-image-btn').addEventListener('click', () => resetCreatePostModal());
                    const imageModeBtn = document.getElementById('switch-to-image-mode');
                    const textImageModeBtn = document.getElementById('switch-to-text-image-mode');
                    const imageModeContent = document.getElementById('image-mode-content');
                    const textImageModeContent = document.getElementById('text-image-mode-content');
                    imageModeBtn.addEventListener('click', () => { imageModeBtn.classList.add('active'); textImageModeBtn.classList.remove('active'); imageModeContent.classList.add('active'); textImageModeContent.classList.remove('active'); });
                    textImageModeBtn.addEventListener('click', () => { textImageModeBtn.classList.add('active'); imageModeBtn.classList.remove('active'); textImageModeContent.classList.add('active'); imageModeContent.classList.remove('active'); });
        
        
        document.getElementById('confirm-create-post-btn').addEventListener('click', async () => {
            const modal = document.getElementById('create-post-modal');
            const mode = modal.dataset.mode;
            
            
            const visibilityMode = document.querySelector('input[name="visibility"]:checked').value;
            let visibleGroupIds = null;
            
            if (visibilityMode === 'include') {
                visibleGroupIds = Array.from(document.querySelectorAll('input[name="visibility_group"]:checked')).map(cb => parseInt(cb.value));
            }
        
            let newPost = {};
            const basePostData = {
                timestamp: Date.now(),
                authorId: 'user',
                
                visibleGroupIds: visibleGroupIds,
            };
        
            
            if (mode === 'shuoshuo') {
                const content = document.getElementById('post-public-text').value.trim();
                if (!content) {
                    alert('è¯´è¯´å†…å®¹ä¸èƒ½ä¸ºç©ºå“¦ï¼');
                    return;
                }
                newPost = {
                    ...basePostData,
                    type: 'shuoshuo',
                    content: content,
                };
        
            } else { 
                const publicText = document.getElementById('post-public-text').value.trim();
                const isImageModeActive = document.getElementById('image-mode-content').classList.contains('active');
        
                if (isImageModeActive) {
                    const imageUrl = document.getElementById('post-image-preview').src;
                    const imageDescription = document.getElementById('post-image-description').value.trim();
                    if (!imageUrl || !(imageUrl.startsWith('http') || imageUrl.startsWith('data:'))) {
                        alert('è¯·å…ˆæ·»åŠ ä¸€å¼ å›¾ç‰‡å†å‘å¸ƒåŠ¨æ€å“¦ï¼');
                        return;
                    }
                    if (!imageDescription) {
                        alert('è¯·ä¸ºä½ çš„å›¾ç‰‡æ·»åŠ ä¸€ä¸ªç®€å•çš„æè¿°ï¼ˆå¿…å¡«ï¼Œç»™AIçœ‹çš„ï¼‰ï¼');
                        return;
                    }
                    newPost = {
                        ...basePostData,
                        type: 'image_post',
                        publicText: publicText,
                        imageUrl: imageUrl,
                        imageDescription: imageDescription,
                    };
                } else { 
                    const hiddenText = document.getElementById('post-hidden-text').value.trim();
                    if (!hiddenText) {
                        alert('è¯·è¾“å…¥æ–‡å­—å›¾æè¿°ï¼');
                        return;
                    }
                    newPost = {
                        ...basePostData,
                        type: 'text_image',
                        publicText: publicText,
                        hiddenContent: hiddenText,
                    };
                }
            }
        
            
            const newPostId = await db.qzonePosts.add(newPost);
            let postSummary = newPost.content || newPost.publicText || newPost.imageDescription || newPost.hiddenContent || "ï¼ˆæ— æ–‡å­—å†…å®¹ï¼‰";
            postSummary = postSummary.substring(0, 50) + (postSummary.length > 50 ? '...' : '');
        
            
            for (const chatId in state.chats) {
                const chat = state.chats[chatId];
                if (chat.isGroup) continue; 
        
                let shouldNotify = false;
                const postVisibleGroups = newPost.visibleGroupIds;
        
                
                if (!postVisibleGroups || postVisibleGroups.length === 0) {
                    shouldNotify = true;
                } 
                
                else if (chat.groupId && postVisibleGroups.includes(chat.groupId)) {
                    shouldNotify = true;
                }
        
                
                if (shouldNotify) {
        
        const historyMessage = {
            role: 'system',
            content: `[ç³»ç»Ÿæç¤ºï¼šç”¨æˆ·åˆšåˆšå‘å¸ƒäº†ä¸€æ¡åŠ¨æ€(ID: ${newPostId})ï¼Œå†…å®¹æ‘˜è¦æ˜¯ï¼šâ€œ${postSummary}â€ã€‚è¯·ä½ ã€ç»“åˆè‡ªå·±çš„è§’è‰²è®¾å®šã€ä¸–ç•Œè§‚å’Œä½ ä»¬çš„æœ€è¿‘èŠå¤©å†…å®¹ã€‘ï¼Œå¯¹è¿™æ¡åŠ¨æ€å‘è¡¨ä¸€æ¡è‡ªç„¶çš„è¯„è®ºã€‚]`,
            timestamp: Date.now(),
            isHidden: true
        };
        
                    chat.history.push(historyMessage);
                    await db.chats.put(chat);
                }
            }
            
        
            await renderQzonePosts();
            modal.classList.remove('visible');
            alert('åŠ¨æ€å‘å¸ƒæˆåŠŸï¼');
        });
        
        
        
        const postsList = document.getElementById('qzone-posts-list');
        let swipeState = { isDragging: false, startX: 0, startY: 0, currentX: 0, activeContainer: null, swipeDirection: null, isClick: true };
        
        function resetAllSwipes(exceptThisOne = null) {
            document.querySelectorAll('.qzone-post-container').forEach(container => {
                if (container !== exceptThisOne) {
                    container.querySelector('.qzone-post-item').classList.remove('swiped');
                }
            });
        }
        
        /**
         * ã€å…¨æ–°ã€‘å¤„ç†åŠ¨æ€åŒºåŸŸå†…æ‰€æœ‰ç‚¹å‡»äº‹ä»¶çš„ç»Ÿä¸€å…¥å£
         */
        async function handlePostClick(e) {
            e.stopPropagation();
            const target = e.target;
        
            
const deleteBtn = target.closest('.comment-delete-btn');
if (deleteBtn) {
    const postContainer = deleteBtn.closest('.qzone-post-container');
    const postId = parseInt(postContainer.dataset.postId);
    const commentIndex = parseInt(deleteBtn.dataset.commentIndex);
    if (isNaN(postId) || isNaN(commentIndex)) return;

    const post = qzonePostsCache.find(p => p.id === postId);
    if (!post || !post.comments || !post.comments[commentIndex]) return;
    
    
    
    const deletedComment = post.comments[commentIndex];
    
    const confirmed = await showCustomConfirm('åˆ é™¤è¯„è®º', 'ç¡®å®šè¦åˆ é™¤è¿™æ¡è¯„è®ºå—ï¼Ÿ', { confirmButtonClass: 'btn-danger' });
    if (confirmed) {
        
        post.comments.splice(commentIndex, 1);
        await db.qzonePosts.update(postId, { comments: post.comments });
        
        
        
        
        if (deletedComment && deletedComment.commenterName === state.qzoneSettings.nickname) {
            console.log("ç”¨æˆ·åˆ é™¤äº†è‡ªå·±çš„è¯„è®ºï¼Œå¼€å§‹æ¸…ç†AIè®°å¿†...");

            
            const aiToNotifyIds = new Set();
            if (post.authorId !== 'user') {
                aiToNotifyIds.add(post.authorId);
            }
            if (deletedComment.replyTo) {
                const repliedToChat = Object.values(state.chats).find(c => c.originalName === deletedComment.replyTo);
                if (repliedToChat) {
                    aiToNotifyIds.add(repliedToChat.id);
                }
            }

            
            const postSummary = (post.publicText || post.content || '').substring(0, 30);
            const userNickname = state.qzoneSettings.nickname;
            let notificationText;
            const stickerMatch = state.userStickers.find(s => s.url === deletedComment.text);

            if (stickerMatch) {
                 notificationText = `ç”¨æˆ·'${userNickname}'åˆšåˆšåœ¨ä½ çš„åŠ¨æ€â€œ${postSummary}â€ä¸‹ï¼Œå‘é€äº†ä¸€ä¸ªè¡¨æƒ…è¯„è®ºï¼Œæ„æ€æ˜¯ï¼šâ€œ${stickerMatch.name}â€ã€‚`;
            } else if (deletedComment.replyTo) {
                 const repliedToDisplayName = getDisplayNameByOriginalName(deletedComment.replyTo);
                 notificationText = `ç”¨æˆ·'${userNickname}'åˆšåˆšåœ¨ä½ çš„åŠ¨æ€â€œ${postSummary}â€ä¸‹ï¼Œå›žå¤äº†'${repliedToDisplayName}'çš„è¯„è®ºï¼Œå†…å®¹æ˜¯ï¼šâ€œ${deletedComment.text}â€ã€‚`;
            } else {
                 notificationText = `ç”¨æˆ·'${userNickname}'åˆšåˆšè¯„è®ºäº†ä½ çš„åŠ¨æ€â€œ${postSummary}â€ï¼Œå†…å®¹æ˜¯ï¼šâ€œ${deletedComment.text}â€ã€‚`;
            }
            const fullSystemContent = `[ç³»ç»Ÿæç¤ºï¼š${notificationText}è¯·ä½ å¯¹æ­¤ä½œå‡ºå›žåº”ã€‚]`;

            
            for (const aiId of aiToNotifyIds) {
                const chat = state.chats[aiId];
                if (chat) {
                    const originalLength = chat.history.length;
                    
                    chat.history = chat.history.filter(msg => 
                        !(msg.isHidden && msg.role === 'system' && msg.content === fullSystemContent)
                    );
                    
                    if (chat.history.length < originalLength) {
                        console.log(`åœ¨è§’è‰² "${chat.name}" çš„è®°å¿†ä¸­æ¸…é™¤äº†1æ¡å…³äºŽå·²åˆ é™¤è¯„è®ºçš„é€šçŸ¥ã€‚`);
                        await db.chats.put(chat);
                    }
                }
            }
        }
        

        await updateSinglePostInDOM(postId); 
    }
    
    return; 
}
            
            
            const stickerBtn = target.closest('.comment-sticker-btn');
            if (stickerBtn) {
                const postContainer = stickerBtn.closest('.qzone-post-container');
                if (!postContainer) return;
                const postId = parseInt(postContainer.dataset.postId);
                if (qzoneStickerPanelState.isOpen && qzoneStickerPanelState.activePostId === postId) {
                    closeQzoneStickerPanel();
                } else {
                    openQzoneStickerPanel(postId, stickerBtn);
                }
                return; 
            }
            const commentItem = target.closest('.comment-item');
            if (commentItem) {
                const postId = parseInt(commentItem.dataset.postId);
                const commenterOriginalName = commentItem.dataset.commenterOriginalName;
                const commenterDisplayName = commentItem.dataset.commenterDisplayName;
        
                if (!commenterOriginalName || !commenterDisplayName || commenterOriginalName === state.qzoneSettings.nickname) {
                    clearQzoneReplyContext(commentItem.closest('.qzone-post-container'));
                    return;
                }
                currentQzoneReplyContext = { postId, replyToName: commenterOriginalName, replyToDisplayName: commenterDisplayName };
                const postContainer = commentItem.closest('.qzone-post-container');
                const commentInput = postContainer.querySelector('.comment-input');
                commentInput.placeholder = `å›žå¤ ${commenterDisplayName}:`;
                commentInput.focus();
                return; 
            }
            if (target.classList.contains('post-actions-btn')) {
                const container = target.closest('.qzone-post-container');
                if (container && container.dataset.postId) showPostActions(parseInt(container.dataset.postId));
                return;
            }
            if (target.tagName === 'IMG' && target.dataset.hiddenText) {
                showCustomAlert("å›¾ç‰‡å†…å®¹", target.dataset.hiddenText.replace(/<br>/g, '\n'));
                return;
            }
        
            
            const postContainer = target.closest('.qzone-post-container');
            if (!postContainer) return;
            const postId = parseInt(postContainer.dataset.postId);
            if (isNaN(postId)) return;
        
            if (target.closest('.qzone-post-delete-action')) {
                const confirmed = await showCustomConfirm('åˆ é™¤åŠ¨æ€', 'ç¡®å®šè¦æ°¸ä¹…åˆ é™¤è¿™æ¡åŠ¨æ€å—ï¼Ÿ', { confirmButtonClass: 'btn-danger' });
                if (confirmed) {
                    postContainer.style.transition = 'all 0.3s ease';
                    postContainer.style.transform = 'scale(0.8)';
                    postContainer.style.opacity = '0';
                    setTimeout(async () => {
                         await db.qzonePosts.delete(postId);
                         const notificationIdentifier = `(ID: ${postId})`;
                         for (const chatId in state.chats) {
                             const chat = state.chats[chatId];
                             const originalHistoryLength = chat.history.length;
                             chat.history = chat.history.filter(msg => !(msg.role === 'system' && msg.content.includes(notificationIdentifier)));
                             if (chat.history.length < originalHistoryLength) await db.chats.put(chat);
                         }
                         await renderQzonePosts(); 
                         alert('åŠ¨æ€å·²åˆ é™¤ã€‚');
                    }, 300);
                }
                return;
            }
        
            const icon = target.closest('.action-icon');
            if (icon) {
                if (icon.classList.contains('repost')) { openRepostModal(postId); return; }
                if (icon.classList.contains('like')) {
                    const post = qzonePostsCache.find(p => p.id === postId);
                    if (!post) return;
                    if (!post.likes) post.likes = [];
                    const userOriginalName = state.qzoneSettings.nickname;
                    const userLikeIndex = post.likes.indexOf(userOriginalName);
                    if (userLikeIndex > -1) {
                        post.likes.splice(userLikeIndex, 1);
                    } else {
                        post.likes.push(userOriginalName);
                        icon.classList.add('animate-like');
                        icon.addEventListener('animationend', () => icon.classList.remove('animate-like'), { once: true });
                    }
                    await db.qzonePosts.update(postId, { likes: post.likes });
                    await updateSinglePostInDOM(postId); 
                }
                if (icon.classList.contains('favorite')) {
                    const existingFavorite = await db.favorites.where({ type: 'qzone_post', 'content.id': postId }).first();
                    if (existingFavorite) {
                        await db.favorites.delete(existingFavorite.id);
                        await showCustomAlert('æç¤º', 'å·²å–æ¶ˆæ”¶è—');
                    } else {
                        const postToSave = await db.qzonePosts.get(postId);
                        if (postToSave) {
                            await db.favorites.add({ type: 'qzone_post', content: postToSave, timestamp: Date.now() });
                            await showCustomAlert('æç¤º', 'æ”¶è—æˆåŠŸï¼');
                        }
                    }
                    await updateSinglePostInDOM(postId); 
                }
                return;
            }
        
            const sendBtn = target.closest('.comment-send-btn');
            if (sendBtn) {
                const commentInput = postContainer.querySelector('.comment-input');
                const commentText = commentInput.value.trim();
                if (!commentText) return alert('è¯„è®ºå†…å®¹ä¸èƒ½ä¸ºç©ºå“¦ï¼');
                
                const post = qzonePostsCache.find(p => p.id === postId);
                if (!post) return;
        
                if (!post.comments) post.comments = [];
                
                const newComment = {
                    commenterName: state.qzoneSettings.nickname,
                    text: commentText,
                    timestamp: Date.now(),
                    replyTo: (currentQzoneReplyContext && currentQzoneReplyContext.postId === postId) ? currentQzoneReplyContext.replyToName : null
                };
                
                post.comments.push(newComment);
                await db.qzonePosts.update(postId, { comments: post.comments });
                
                let postSummary = (post.publicText || post.content || '').substring(0, 30);
                const userNickname = state.qzoneSettings.nickname;
                const notifiedAiIds = new Set();
                if (post.authorId !== 'user') notifiedAiIds.add(post.authorId);
                if (newComment.replyTo && newComment.replyTo !== userNickname) {
                    const repliedToChat = Object.values(state.chats).find(c => c.originalName === newComment.replyTo);
                    if (repliedToChat) notifiedAiIds.add(repliedToChat.id);
                }
                for (const aiId of notifiedAiIds) {
                    const chat = state.chats[aiId];
                    if (chat && !chat.isGroup) {
                        const stickerMatch = state.userStickers.find(s => s.url === commentText);
                        let notificationText = stickerMatch ? `ç”¨æˆ·'${userNickname}'åˆšåˆšåœ¨ä½ çš„åŠ¨æ€â€œ${postSummary}â€ä¸‹ï¼Œå‘é€äº†ä¸€ä¸ªè¡¨æƒ…è¯„è®ºï¼Œæ„æ€æ˜¯ï¼šâ€œ${stickerMatch.name}â€ã€‚`
                            : newComment.replyTo ? `ç”¨æˆ·'${userNickname}'åˆšåˆšåœ¨ä½ çš„åŠ¨æ€â€œ${postSummary}â€ä¸‹ï¼Œå›žå¤äº†'${currentQzoneReplyContext.replyToDisplayName}'çš„è¯„è®ºï¼Œå†…å®¹æ˜¯ï¼šâ€œ${commentText}â€ã€‚`
                            : `ç”¨æˆ·'${userNickname}'åˆšåˆšè¯„è®ºäº†ä½ çš„åŠ¨æ€â€œ${postSummary}â€ï¼Œå†…å®¹æ˜¯ï¼šâ€œ${commentText}â€ã€‚`;
                        const historyMessage = { 
                            role: 'system', 
                            content: `[ç³»ç»Ÿæç¤ºï¼š${notificationText}è¯·ä½ å¯¹æ­¤ä½œå‡ºå›žåº”ã€‚]`, 
                            timestamp: Date.now(), 
                            isHidden: true 
                        };
                        chat.history.push(historyMessage);
                        await db.chats.put(chat);
                    }
                }
                
                commentInput.value = '';
                clearQzoneReplyContext(postContainer); 
                await updateSinglePostInDOM(postId); 
                return;
            }
        }
          
        
        
        
        
        
        const handleSwipeStart = (e) => {
            const target = e.target;
            
            if (target.closest('.post-footer, .post-feedback-icons, .post-actions-btn, .post-comments-container, .reposted-content-wrapper')) {
                return;
            }
            const targetContainer = e.target.closest('.qzone-post-container');
            if (!targetContainer) return;
        
            resetAllSwipes(targetContainer);
            swipeState.activeContainer = targetContainer;
            swipeState.isDragging = true;
            swipeState.isClick = true;
            swipeState.swipeDirection = null;
            swipeState.startX = e.type.includes('mouse') ? e.pageX : e.touches[0].pageX;
            swipeState.startY = e.type.includes('mouse') ? e.pageY : e.touches[0].pageY;
            swipeState.activeContainer.querySelector('.qzone-post-item').style.transition = 'none';
        
            
            document.addEventListener('mousemove', handleSwipeMove);
            document.addEventListener('mouseup', handleSwipeEnd);
            document.addEventListener('touchmove', handleSwipeMove, { passive: false });
            document.addEventListener('touchend', handleSwipeEnd);
        };
        
        
        const handleSwipeMove = (e) => {
            if (!swipeState.isDragging || !swipeState.activeContainer) return;
        
            const currentX = e.type.includes('mouse') ? e.pageX : e.touches[0].pageX;
            const currentY = e.type.includes('mouse') ? e.pageY : e.touches[0].pageY;
            const diffX = currentX - swipeState.startX;
            const diffY = currentY - swipeState.startY;
            
            if (swipeState.isClick && (Math.abs(diffX) > 5 || Math.abs(diffY) > 5)) {
                swipeState.isClick = false;
            }
        
            if (!swipeState.swipeDirection) {
                if (Math.abs(diffX) > Math.abs(diffY)) {
                    swipeState.swipeDirection = 'horizontal';
                } else {
                    swipeState.swipeDirection = 'vertical';
                }
            }
            
            if (swipeState.swipeDirection === 'horizontal') {
                e.preventDefault(); 
                swipeState.currentX = currentX;
                let translation = Math.min(0, Math.max(-90, diffX)); 
                swipeState.activeContainer.querySelector('.qzone-post-item').style.transform = `translateX(${translation}px)`;
            }
        };
        
        
        const handleSwipeEnd = (e) => {
            
            document.removeEventListener('mousemove', handleSwipeMove);
            document.removeEventListener('mouseup', handleSwipeEnd);
            document.removeEventListener('touchmove', handleSwipeMove);
            document.removeEventListener('touchend', handleSwipeEnd);
        
            if (!swipeState.isDragging || !swipeState.activeContainer) return;
            
            const postItem = swipeState.activeContainer.querySelector('.qzone-post-item');
            postItem.style.transition = 'transform 0.3s ease';
        
            if (swipeState.swipeDirection === 'horizontal' && !swipeState.isClick) {
                const finalX = e.type.includes('touchend') ? e.changedTouches[0].pageX : e.pageX;
                const diffX = finalX - swipeState.startX;
                if (diffX < -40) { 
                    postItem.classList.add('swiped');
                } else {
                    postItem.classList.remove('swiped');
                }
            }
            
            postItem.style.transform = ''; 
            
            
            swipeState.isDragging = false;
            swipeState.activeContainer = null;
            swipeState.swipeDirection = null;
            swipeState.isClick = true;
        };
        
        
        
        
        
        
          
        
        
        
        
        postsList.addEventListener('click', handlePostClick);
        postsList.addEventListener('mousedown', handleSwipeStart);
        postsList.addEventListener('touchstart', handleSwipeStart, { passive: true }); 
        
        
        
        postsList.addEventListener('click', (e) => {
            
            if (e.target && e.target.id === 'load-more-qzone-btn') {
                loadMoreQzonePosts();
            }
        });
          
        
        document.getElementById('refine-memory-btn-header').addEventListener('click', () => {
            if(state.activeChatId) {
                summarizeExistingLongTermMemory(state.activeChatId);
            }
        });
                    
                    document.getElementById('api-preset-select').addEventListener('change', handlePresetSelectionChange);
                    document.getElementById('save-api-preset-btn').addEventListener('click', saveApiPreset);
                    document.getElementById('delete-api-preset-btn').addEventListener('click', deleteApiPreset);
                      
        
        document.getElementById('add-world-book-entry-btn').addEventListener('click', () => {
            const container = document.getElementById('world-book-entries-container');
            
            if (container.querySelector('p')) {
                container.innerHTML = '';
            }
            const newBlock = createWorldBookEntryBlock(); 
            container.appendChild(newBlock);
            newBlock.querySelector('.entry-content-textarea').focus(); 
        });
          
                    
        document.getElementById('switch-greeting-btn').addEventListener('click', handleSwitchGreeting);
        
        document.getElementById('thoughts-history-list').addEventListener('click', (e) => {
            if (e.target && e.target.id === 'load-more-thoughts-btn') {
                loadMoreThoughts();
            }
        });
          
        
        
        
        document.getElementById('profile-history-icon-btn').addEventListener('click', showThoughtsHistory);
          
        document.getElementById('history-back-btn').addEventListener('click', hideThoughtsHistory);
        document.getElementById('character-profile-modal').addEventListener('click', (e) => {
            
            if (e.target.id === 'character-profile-modal') {
                e.target.classList.remove('visible');
            }
        });
        
        document.getElementById('manage-stickers-btn').addEventListener('click', toggleStickerManagementMode);
        document.getElementById('delete-selected-stickers-btn').addEventListener('click', executeBatchDeleteStickers);
          
                    
                    document.getElementById('qzone-back-btn').addEventListener('click', () => switchToChatListView('messages-view'));
                    document.getElementById('favorites-back-btn').addEventListener('click', () => switchToChatListView('messages-view'));
        
                      
        
                    
        
                    
                    const searchInput = document.getElementById('favorites-search-input');
                    const searchClearBtn = document.getElementById('favorites-search-clear-btn');
        
                    searchInput.addEventListener('input', () => {
                        const searchTerm = searchInput.value.trim().toLowerCase();
                        
                        
                        searchClearBtn.style.display = searchTerm ? 'block' : 'none';
        
                        if (!searchTerm) {
                            displayFilteredFavorites(allFavoriteItems); 
                            return;
                        }
        
                        
                        const filteredItems = allFavoriteItems.filter(item => {
                            let contentToSearch = '';
                            let authorToSearch = '';
        
                            if (item.type === 'qzone_post') {
                                const post = item.content;
                                contentToSearch += (post.publicText || '') + ' ' + (post.content || '');
                                if (post.authorId === 'user') {
                                    authorToSearch = state.qzoneSettings.nickname;
                                } else if (state.chats[post.authorId]) {
                                    authorToSearch = state.chats[post.authorId].name;
                                }
                            } else if (item.type === 'chat_message') {
                                const msg = item.content;
                                if (typeof msg.content === 'string') {
                                    contentToSearch = msg.content;
                                }
                                const chat = state.chats[item.chatId];
                                if (chat) {
                                   if (msg.role === 'user') {
                                        authorToSearch = chat.isGroup ? (chat.settings.myNickname || 'æˆ‘') : 'æˆ‘';
                                   } else {
                                        authorToSearch = chat.isGroup ? msg.senderName : chat.name;
                                   }
                                }
                            }
                            
                            
                            return contentToSearch.toLowerCase().includes(searchTerm) || 
                                   authorToSearch.toLowerCase().includes(searchTerm);
                        });
        
                        displayFilteredFavorites(filteredItems);
                    });
        
                    
                    searchClearBtn.addEventListener('click', () => {
                        searchInput.value = '';
                        searchClearBtn.style.display = 'none';
                        displayFilteredFavorites(allFavoriteItems);
                        searchInput.focus();
                    });
        
                    
        
                    
                    
                    
                                
                    document.getElementById('selection-favorite-btn').addEventListener('click', async () => {
                        if (selectedMessages.size === 0) return;
                        const chat = state.chats[state.activeChatId];
                        if (!chat) return;
        
                        const favoritesToAdd = [];
                        const timestampsToFavorite = [...selectedMessages];
        
                        for (const timestamp of timestampsToFavorite) {
                            
                            const existing = await db.favorites.where('originalTimestamp').equals(timestamp).first();
                            
                            if (!existing) {
                                const messageToSave = chat.history.find(msg => msg.timestamp === timestamp);
                                if (messageToSave) {
                                    favoritesToAdd.push({
                                        type: 'chat_message',
                                        content: messageToSave,
                                        chatId: state.activeChatId,
                                        timestamp: Date.now(), 
                                        originalTimestamp: messageToSave.timestamp 
                                    });
                                }
                            }
                        }
        
                        if (favoritesToAdd.length > 0) {
                            await db.favorites.bulkAdd(favoritesToAdd);
                            allFavoriteItems = await db.favorites.orderBy('timestamp').reverse().toArray(); 
                            await showCustomAlert('æ”¶è—æˆåŠŸ', `å·²æˆåŠŸæ”¶è— ${favoritesToAdd.length} æ¡æ¶ˆæ¯ã€‚`);
                        } else {
                            await showCustomAlert('æç¤º', 'é€‰ä¸­çš„æ¶ˆæ¯å‡å·²æ”¶è—è¿‡ã€‚');
                        }
                        
                        exitSelectionMode();
                    });
        
                    
                    const favoritesEditBtn = document.getElementById('favorites-edit-btn');
                    const favoritesView = document.getElementById('favorites-view');
                    const favoritesActionBar = document.getElementById('favorites-action-bar');
                    const mainBottomNav = document.getElementById('chat-list-bottom-nav'); 
                    const favoritesList = document.getElementById('favorites-list'); 
                    
                    favoritesEditBtn.addEventListener('click', () => {
                        isFavoritesSelectionMode = !isFavoritesSelectionMode;
                        favoritesView.classList.toggle('selection-mode', isFavoritesSelectionMode);
        
                        if (isFavoritesSelectionMode) {
                            
                            favoritesEditBtn.textContent = 'å®Œæˆ';
                            favoritesActionBar.style.display = 'block'; 
                            mainBottomNav.style.display = 'none'; 
                            favoritesList.style.paddingBottom = '80px'; 
                        } else {
                            
                            favoritesEditBtn.textContent = 'ç¼–è¾‘';
                            favoritesActionBar.style.display = 'none'; 
                            mainBottomNav.style.display = 'flex';  
                            favoritesList.style.paddingBottom = ''; 
        
                            
                            selectedFavorites.clear();
                            document.querySelectorAll('.favorite-item-card.selected').forEach(card => card.classList.remove('selected'));
                            document.getElementById('favorites-delete-selected-btn').textContent = `åˆ é™¤ (0)`;
                        }
                    });
        
        
        
        document.getElementById('favorites-list').addEventListener('click', (e) => {
            const target = e.target;
            const card = target.closest('.favorite-item-card');
        
            
            if (target.tagName === 'IMG' && target.dataset.hiddenText) {
                const hiddenText = target.dataset.hiddenText;
                showCustomAlert("å›¾ç‰‡å†…å®¹", hiddenText.replace(/<br>/g, '\n'));
                return; 
            }
            
            
            if (!isFavoritesSelectionMode) return;
        
            
            if (!card) return;
        
            const favId = parseInt(card.dataset.favid);
            if (isNaN(favId)) return;
        
            
            if (selectedFavorites.has(favId)) {
                selectedFavorites.delete(favId);
                card.classList.remove('selected');
            } else {
                selectedFavorites.add(favId);
                card.classList.add('selected');
            }
            
            
            document.getElementById('favorites-delete-selected-btn').textContent = `åˆ é™¤ (${selectedFavorites.size})`;
        });
        
        
        
        document.getElementById('favorites-delete-selected-btn').addEventListener('click', async () => {
            if (selectedFavorites.size === 0) return;
        
            const confirmed = await showCustomConfirm(
                'ç¡®è®¤åˆ é™¤', 
                `ç¡®å®šè¦ä»Žæ”¶è—å¤¹ä¸­ç§»é™¤è¿™ ${selectedFavorites.size} æ¡å†…å®¹å—ï¼Ÿ`, 
                { confirmButtonClass: 'btn-danger' }
            );
        
            if (confirmed) {
                const idsToDelete = [...selectedFavorites];
                await db.favorites.bulkDelete(idsToDelete);
                await showCustomAlert('åˆ é™¤æˆåŠŸ', 'é€‰ä¸­çš„æ”¶è—å·²è¢«ç§»é™¤ã€‚');
                
                
                allFavoriteItems = allFavoriteItems.filter(item => !idsToDelete.includes(item.id));
                
                
                displayFilteredFavorites(allFavoriteItems);
                
                
                favoritesEditBtn.click(); 
            }
        });
        
        
        if (state.globalSettings.enableBackgroundActivity) {
            startBackgroundSimulation();
            console.log("åŽå°æ´»åŠ¨æ¨¡æ‹Ÿå·²è‡ªåŠ¨å¯åŠ¨ã€‚");
        }
          
        
        
        
        
        
        
        document.querySelectorAll('input[name="theme-select"]').forEach(radio => {
            radio.addEventListener('change', updateSettingsPreview);
        });
        
        
        const fontSizeSlider = document.getElementById('font-size-slider');
        fontSizeSlider.addEventListener('input', () => {
            
            document.getElementById('font-size-value').textContent = `${fontSizeSlider.value}px`;
            
            updateSettingsPreview();
        });
        
        
        const customCssInputForPreview = document.getElementById('custom-css-input');
        customCssInputForPreview.addEventListener('input', updateSettingsPreview);
        
        
        document.getElementById('reset-theme-btn').addEventListener('click', () => {
            document.getElementById('theme-default').checked = true;
            updateSettingsPreview();
        });
        
        document.getElementById('reset-custom-css-btn').addEventListener('click', () => {
            document.getElementById('custom-css-input').value = '';
            updateSettingsPreview();
        });
        
        
        
        document.getElementById('lyrics-vertical-pos').addEventListener('change', updateSettingsPreview);
        document.getElementById('lyrics-horizontal-pos').addEventListener('change', updateSettingsPreview);
        document.getElementById('lyrics-offset-input').addEventListener('input', updateSettingsPreview);
        
        document.querySelectorAll('input[name="visibility"]').forEach(radio => {
            radio.addEventListener('change', function() {
                const groupsContainer = document.getElementById('post-visibility-groups');
                if (this.value === 'include' || this.value === 'exclude') {
                    groupsContainer.style.display = 'block';
                } else {
                    groupsContainer.style.display = 'none';
                }
            });
        });
        
        
        
        document.getElementById('manage-groups-btn').addEventListener('click', openGroupManager);
        document.getElementById('close-group-manager-btn').addEventListener('click', () => {
            document.getElementById('group-management-modal').classList.remove('visible');
            
            const chatSettingsBtn = document.getElementById('chat-settings-btn');
            if (document.getElementById('chat-settings-modal').classList.contains('visible')) {
               chatSettingsBtn.click(); 
            }
        });
        
        document.getElementById('add-new-group-btn').addEventListener('click', addNewGroup);
        document.getElementById('existing-groups-list').addEventListener('click', (e) => {
            if (e.target.classList.contains('delete-group-btn')) {
                const groupId = parseInt(e.target.dataset.id);
                deleteGroup(groupId);
            }
        });
        
        
        
        
        document.getElementById('cancel-message-action-btn').addEventListener('click', hideMessageActions);
        
        document.getElementById('edit-message-btn').addEventListener('click', openAdvancedMessageEditor);
          
        document.getElementById('copy-message-btn').addEventListener('click', copyMessageContent);
        
        
        document.getElementById('recall-message-btn').addEventListener('click', handleRecallClick);
          
        
        
        document.getElementById('select-message-btn').addEventListener('click', () => {
            
            const timestampToSelect = activeMessageTimestamp; 
            hideMessageActions();
            
            if (timestampToSelect) {
                enterSelectionMode(timestampToSelect);
            }
        });
          
        
        
        
        document.getElementById('chat-messages').addEventListener('click', (e) => {
            
            const bubble = e.target.closest('.message-bubble');
            if (!bubble) return; 
        
            
            if (bubble.classList.contains('ai') && 
                bubble.classList.contains('is-transfer') && 
                bubble.dataset.status === 'pending') {
                
                
                const timestamp = parseInt(bubble.dataset.timestamp);
                if (!isNaN(timestamp)) {
                    showTransferActionModal(timestamp);
                }
            }
        });
        
        
        document.getElementById('transfer-action-accept').addEventListener('click', () => handleUserTransferResponse('accepted'));
        document.getElementById('transfer-action-decline').addEventListener('click', () => handleUserTransferResponse('declined'));
        document.getElementById('transfer-action-cancel').addEventListener('click', hideTransferActionModal);
        
          
        
        
        
        document.getElementById('edit-post-btn').addEventListener('click', openPostEditor);
        document.getElementById('copy-post-btn').addEventListener('click', copyPostContent);
        document.getElementById('cancel-post-action-btn').addEventListener('click', hidePostActions);
        
          
        
        
        document.getElementById('cancel-contact-picker-btn').addEventListener('click', () => {
            showScreen('chat-list-screen');
        });
        
        document.getElementById('contact-picker-list').addEventListener('click', (e) => {
            const item = e.target.closest('.contact-picker-item');
            if (!item) return;
        
            const contactId = item.dataset.contactId;
            item.classList.toggle('selected');
            
            if (selectedContacts.has(contactId)) {
                selectedContacts.delete(contactId);
            } else {
                selectedContacts.add(contactId);
            }
            updateContactPickerConfirmButton();
        });
        
        
        document.getElementById('manage-members-btn').addEventListener('click', () => {
            
            
            
            openMemberManagementScreen();
        });
          
        
        
        document.getElementById('back-from-member-management').addEventListener('click', () => {
        
            showScreen('chat-interface-screen');    
            document.getElementById('chat-settings-btn').click();
        });
          
        
        document.getElementById('member-management-list').addEventListener('click', (e) => {
            
            if (e.target.classList.contains('remove-member-btn')) {
                removeMemberFromGroup(e.target.dataset.memberId);
            }
        });
        
        document.getElementById('add-existing-contact-btn').addEventListener('click', async () => {
            
            
            const confirmBtn = document.getElementById('confirm-contact-picker-btn');
            
            const newConfirmBtn = confirmBtn.cloneNode(true);
            confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);
            newConfirmBtn.addEventListener('click', handleAddMembersToGroup);
            
            await openContactPickerForAddMember();
        });
        
        document.getElementById('create-new-member-btn').addEventListener('click', createNewMemberInGroup);
          
        
        
        
        
        document.getElementById('video-call-btn').addEventListener('click', handleInitiateCall);
        document.getElementById('group-video-call-btn').addEventListener('click', handleInitiateCall);
        
        
        document.getElementById('hang-up-btn').addEventListener('click', endVideoCall);
        
        
        document.getElementById('cancel-call-btn').addEventListener('click', () => {
            videoCallState.isAwaitingResponse = false;
            showScreen('chat-interface-screen');
        });
        
        
        document.getElementById('join-call-btn').addEventListener('click', handleUserJoinCall);
        
        
        
        document.getElementById('decline-call-btn').addEventListener('click', async () => {
            hideIncomingCallModal();
            const chat = state.chats[videoCallState.activeChatId];
            if (!chat) return;
            
            
            if (videoCallState.isGroupCall) {
                videoCallState.isUserParticipating = false; 
                
                
                const systemNote = {
                    role: 'system',
                    content: `[ç³»ç»Ÿæç¤ºï¼šç”¨æˆ·æ‹’ç»äº†é€šè¯é‚€è¯·ï¼Œä½†ä½ ä»¬å¯ä»¥è‡ªå·±å¼€å§‹ã€‚è¯·ä½ ä»¬å„è‡ªå†³ç­–æ˜¯å¦åŠ å…¥ã€‚]`,
                    timestamp: Date.now(),
                    isHidden: true
                };
                chat.history.push(systemNote);
                await db.chats.put(chat);
                
                
                
                await triggerAiResponse(); 
                
            } else { 
                const declineMessage = { role: 'user', content: 'æˆ‘æ‹’ç»äº†ä½ çš„è§†é¢‘é€šè¯è¯·æ±‚ã€‚', timestamp: Date.now() };
                chat.history.push(declineMessage);
                await db.chats.put(chat);
                
                
                showScreen('chat-interface-screen');
                appendMessage(declineMessage, chat);
                
                
                triggerAiResponse();
            }
            
            
            videoCallState.isAwaitingResponse = false;
        });
          
        
        
        
        document.getElementById('accept-call-btn').addEventListener('click', async () => {
            hideIncomingCallModal();
            
            videoCallState.initiator = 'ai';
            videoCallState.isUserParticipating = true;
            videoCallState.activeChatId = state.activeChatId;
            
            
            if (videoCallState.isGroupCall) {
                
                const chat = state.chats[videoCallState.activeChatId];
                const requester = chat.members.find(m => m.name === videoCallState.callRequester);
                if (requester) {
                    
                    videoCallState.participants = [requester];
                } else {
                    videoCallState.participants = []; 
                }
            }
            
            
            startVideoCall();
        });
          
        
        
        
        
        document.getElementById('user-speak-btn').addEventListener('click', async () => {
            if (!videoCallState.isActive) return;
        
            
            const userAvatar = document.querySelector('.participant-avatar-wrapper[data-participant-id="user"] .participant-avatar');
            if (userAvatar) {
                userAvatar.classList.add('speaking');
            }
        
            const userInput = await showCustomPrompt('ä½ è¯´', 'è¯·è¾“å…¥ä½ æƒ³è¯´çš„è¯...');
            
            
            if (userAvatar) {
                userAvatar.classList.remove('speaking');
            }
        
            if (userInput && userInput.trim()) {
                triggerAiInCallAction(userInput.trim());
            }
        });
          
        
        
        
        document.querySelector('.nav-item[data-view="memories-view"]').addEventListener('click', () => {
            
            if (isFavoritesSelectionMode) {
                document.getElementById('favorites-edit-btn').click(); 
            }
            switchToChatListView('memories-view');
            renderMemoriesScreen(); 
        });
        
        
        document.getElementById('memories-back-btn').addEventListener('click', () => switchToChatListView('messages-view'));
        
          
        
        
        document.getElementById('confirm-create-countdown-btn').addEventListener('click', async () => {
            const title = document.getElementById('countdown-title-input').value.trim();
            const dateValue = document.getElementById('countdown-date-input').value;
            
            if (!title || !dateValue) {
                alert('è¯·å¡«å†™å®Œæ•´çš„çº¦å®šæ ‡é¢˜å’Œæ—¥æœŸï¼');
                return;
            }
        
            const targetDate = new Date(dateValue);
            if (isNaN(targetDate) || targetDate <= new Date()) {
                alert('è¯·è¾“å…¥ä¸€ä¸ªæœ‰æ•ˆçš„ã€æœªæ¥çš„æ—¥æœŸï¼');
                return;
            }
        
            
            const newCountdown = {
                authorId: 'user', 
                description: title,
                timestamp: Date.now(),
                type: 'countdown',
                targetDate: targetDate.getTime()
            };
              
            
            await db.memories.add(newCountdown);
            document.getElementById('create-countdown-modal').classList.remove('visible');
            renderMemoriesScreen();
        });
        
        
        document.getElementById('block-chat-btn').addEventListener('click', async () => {
            if (!state.activeChatId || state.chats[state.activeChatId].isGroup) return;
        
            const chat = state.chats[state.activeChatId];
            const confirmed = await showCustomConfirm(
                'ç¡®è®¤æ‹‰é»‘', 
                `ç¡®å®šè¦æ‹‰é»‘â€œ${chat.name}â€å—ï¼Ÿæ‹‰é»‘åŽæ‚¨å°†æ— æ³•å‘å…¶å‘é€æ¶ˆæ¯ï¼Œç›´åˆ°æ‚¨å°†Taç§»å‡ºé»‘åå•ï¼Œæˆ–ç­‰å¾…Taé‡æ–°ç”³è¯·å¥½å‹ã€‚`,
                { confirmButtonClass: 'btn-danger' }
            );
        
            if (confirmed) {
                chat.relationship.status = 'blocked_by_user';
                chat.relationship.blockedTimestamp = Date.now();
        
                
                const hiddenMessage = {
                    role: 'system',
                    content: `[ç³»ç»Ÿæç¤ºï¼šä½ åˆšåˆšè¢«ç”¨æˆ·æ‹‰é»‘äº†ã€‚åœ¨å¯¹æ–¹è§£é™¤æ‹‰é»‘ä¹‹å‰ï¼Œä½ æ— æ³•å†ä¸»åŠ¨å‘èµ·å¯¹è¯ï¼Œä¹Ÿæ— æ³•å›žåº”ã€‚]`,
                    timestamp: Date.now() + 1,
                    isHidden: true
                };
                chat.history.push(hiddenMessage);
                  
        
                await db.chats.put(chat);
                
                
                document.getElementById('chat-settings-modal').classList.remove('visible');
                renderChatInterface(state.activeChatId);
                
                renderChatList();
            }
        });
        
        document.getElementById('chat-lock-overlay').addEventListener('click', async (e) => {
            const chat = state.chats[state.activeChatId];
            if (!chat) return;
        
            if (e.target.id === 'force-apply-check-btn') {
                alert("æ­£åœ¨æ‰‹åŠ¨è§¦å‘å¥½å‹ç”³è¯·æµç¨‹ï¼Œè¯·ç¨åŽ...\nå¦‚æžœAPIè°ƒç”¨æˆåŠŸï¼Œå°†å¼¹å‡ºæç¤ºã€‚å¦‚æžœå¤±è´¥ï¼Œä¹Ÿä¼šæœ‰é”™è¯¯æç¤ºã€‚å¦‚æžœé•¿æ—¶é—´æ— ååº”ï¼Œè¯´æ˜ŽAIå¯èƒ½å†³å®šæš‚æ—¶ä¸ç”³è¯·ã€‚");
                await triggerAiFriendApplication(chat.id);
                renderChatInterface(chat.id); 
                return;
            }
        
            if (e.target.id === 'unblock-btn') {
                chat.relationship.status = 'friend';
                chat.relationship.blockedTimestamp = null;
        
                
                const hiddenMessage = {
                    role: 'system',
                    content: `[ç³»ç»Ÿæç¤ºï¼šç”¨æˆ·åˆšåˆšè§£é™¤äº†å¯¹ä½ çš„æ‹‰é»‘ã€‚çŽ°åœ¨ä½ ä»¬å¯ä»¥é‡æ–°å¼€å§‹å¯¹è¯äº†ã€‚]`,
                    timestamp: Date.now(),
                    isHidden: true
                };
                chat.history.push(hiddenMessage);
                  
        
                await db.chats.put(chat);
                renderChatInterface(chat.id);
                renderChatList();
                triggerAiResponse(); 
            }
        else if (e.target.id === 'accept-friend-btn') {
                
                
        
                
                chat.relationship.status = 'friend';
                chat.relationship.applicationReason = '';
        
                
                const systemMessage = {
                    role: 'system',
                    type: 'pat_message', 
                    content: `ä½ é€šè¿‡äº†â€œ${chat.name}â€çš„å¥½å‹è¯·æ±‚`,
                    timestamp: Date.now()
                };
                chat.history.push(systemMessage);
        
                
                const welcomeMessage = {
                    role: 'assistant',
                    senderName: chat.name,
                    content: 'å¤ªå¥½äº†ï¼æˆ‘ä»¬åˆå¯ä»¥èŠå¤©å•¦ï¼',
                    timestamp: Date.now() + 1 
                };
                chat.history.push(welcomeMessage);
        
                
                await db.chats.put(chat);
        
                
                renderChatInterface(chat.id);
                renderChatList();
            }
            else if (e.target.id === 'reject-friend-btn') {
                chat.relationship.status = 'blocked_by_user';
                chat.relationship.blockedTimestamp = Date.now();
                chat.relationship.applicationReason = '';
                await db.chats.put(chat);
                renderChatInterface(chat.id);
            }
            
            else if (e.target.id === 'apply-friend-btn') {
                const reason = await showCustomPrompt(
                    'å‘é€å¥½å‹ç”³è¯·', 
                    `è¯·è¾“å…¥ä½ æƒ³å¯¹â€œ${chat.name}â€è¯´çš„ç”³è¯·ç†ç”±ï¼š`,
                    "æˆ‘ä»¬å’Œå¥½å§ï¼"
                );
                
                if (reason !== null) {
                    
                    chat.relationship.status = 'pending_ai_approval';
                    chat.relationship.applicationReason = reason;
                    await db.chats.put(chat);
        
                    
                    renderChatInterface(chat.id);
                    renderChatList();
                    
                    
                    triggerAiResponse();
                }
            }
        });
        
        
        
        
        document.getElementById('transfer-btn').addEventListener('click', handlePaymentButtonClick);
        
        
        document.getElementById('cancel-red-packet-btn').addEventListener('click', () => {
            document.getElementById('red-packet-modal').classList.remove('visible');
        });
        document.getElementById('send-group-packet-btn').addEventListener('click', sendGroupRedPacket);
        document.getElementById('send-direct-packet-btn').addEventListener('click', sendDirectRedPacket);
        
        
        const rpTabGroup = document.getElementById('rp-tab-group');
        const rpTabDirect = document.getElementById('rp-tab-direct');
        const rpContentGroup = document.getElementById('rp-content-group');
        const rpContentDirect = document.getElementById('rp-content-direct');
        
        rpTabGroup.addEventListener('click', () => {
            rpTabGroup.classList.add('active');
            rpTabDirect.classList.remove('active');
            rpContentGroup.style.display = 'block';
            rpContentDirect.style.display = 'none';
        });
        rpTabDirect.addEventListener('click', () => {
            rpTabDirect.classList.add('active');
            rpTabGroup.classList.remove('active');
            rpContentDirect.style.display = 'block';
            rpContentGroup.style.display = 'none';
        });
        
        
        document.getElementById('rp-group-amount').addEventListener('input', (e) => {
            const amount = parseFloat(e.target.value) || 0;
            document.getElementById('rp-group-total').textContent = `Â¥ ${amount.toFixed(2)}`;
        });
        document.getElementById('rp-direct-amount').addEventListener('input', (e) => {
            const amount = parseFloat(e.target.value) || 0;
            document.getElementById('rp-direct-total').textContent = `Â¥ ${amount.toFixed(2)}`;
        });
        
        
        
        
        document.getElementById('chat-messages').addEventListener('click', (e) => {
            
            const packetCard = e.target.closest('.red-packet-card');
            if (!packetCard) return; 
        
            
            const messageBubble = packetCard.closest('.message-bubble');
            if (!messageBubble || !messageBubble.dataset.timestamp) return;
        
            
            const timestamp = parseInt(messageBubble.dataset.timestamp);
            handlePacketClick(timestamp);
        });
          
        
        
        
        document.getElementById('send-poll-btn').addEventListener('click', openCreatePollModal);
        
        
        document.getElementById('add-poll-option-btn').addEventListener('click', addPollOptionInput);
        document.getElementById('cancel-create-poll-btn').addEventListener('click', () => {
            document.getElementById('create-poll-modal').classList.remove('visible');
        });
        document.getElementById('confirm-create-poll-btn').addEventListener('click', sendPoll);
        
        
        document.getElementById('chat-messages').addEventListener('click', (e) => {
            const pollCard = e.target.closest('.poll-card');
            if (!pollCard) return;
        
            const timestamp = parseInt(pollCard.dataset.pollTimestamp);
            if (isNaN(timestamp)) return;
            
            
            const optionItem = e.target.closest('.poll-option-item');
            if (optionItem && !pollCard.classList.contains('closed')) {
                handleUserVote(timestamp, optionItem.dataset.option);
                return;
            }
            
            
            const actionBtn = e.target.closest('.poll-action-btn');
            if (actionBtn) {
                if (pollCard.classList.contains('closed')) {
                    showPollResults(timestamp);
                } else {
                    endPoll(timestamp);
                }
                return;
            }
        
            
            if (pollCard.classList.contains('closed')) {
                showPollResults(timestamp);
            }
        });
        
        
          
        document.getElementById('manage-ai-avatar-library-btn').addEventListener('click', openAiAvatarLibraryModal);
        
        
        document.getElementById('add-ai-avatar-batch-btn').addEventListener('click', () => openBatchImportModal('ai'));
        
        
        document.getElementById('add-group-avatar-batch-btn').addEventListener('click', () => openBatchImportModal('group'));
          
        
        
        document.getElementById('add-ai-avatar-url-btn').addEventListener('click', addAvatarToLibraryFromURL);
        
        
        document.getElementById('add-ai-avatar-upload-btn').addEventListener('click', () => {
            document.getElementById('ai-avatar-upload-input').click();
        });
        
        
        document.getElementById('ai-avatar-upload-input').addEventListener('change', handleLocalAvatarUpload);
          
        document.getElementById('close-ai-avatar-library-btn').addEventListener('click', closeAiAvatarLibraryModal);
          
        
        document.getElementById('manage-group-avatar-library-btn').addEventListener('click', openGroupAvatarLibraryModal);
        
        
        
        document.getElementById('add-group-avatar-url-btn').addEventListener('click', addAvatarToGroupLibraryFromURL);
        
        
        document.getElementById('add-group-avatar-upload-btn').addEventListener('click', () => {
            document.getElementById('group-avatar-upload-input').click();
        });
        
        
        document.getElementById('group-avatar-upload-input').addEventListener('change', handleLocalGroupAvatarUpload);
        
          
        document.getElementById('close-group-avatar-library-btn').addEventListener('click', closeGroupAvatarLibraryModal);
          
        

document.getElementById('icon-settings-grid').addEventListener('click', (e) => {
    if (e.target.classList.contains('change-icon-btn')) {
        const item = e.target.closest('.icon-setting-item');
        const iconId = item.dataset.iconId;
        if (iconId) {
            handleIconChange(iconId, 'ephone', item);
        }
    }
});
        
        
        
        
            document.getElementById('chat-messages').addEventListener('click', (e) => {
                
                const linkCard = e.target.closest('.link-share-card');
                if (linkCard) {
                    const timestamp = parseInt(linkCard.dataset.timestamp);
                    if (!isNaN(timestamp)) {
                        openBrowser(timestamp); 
                    }
                }
            });
        
            
            document.getElementById('browser-back-btn').addEventListener('click', () => {
                showScreen('chat-interface-screen');
            });
        
        
        
        qzoneStickerPanelState.panelEl.addEventListener('click', async (e) => {
            const stickerItem = e.target.closest('.sticker-item');
            if (stickerItem && qzoneStickerPanelState.activePostId !== null) {
                
                const stickerUrl = stickerItem.style.backgroundImage.slice(5, -2);
                
                
                const stickerObject = state.userStickers.find(s => s.url === stickerUrl);
        
                if (stickerObject) {
                    
                    await sendQzoneStickerComment(qzoneStickerPanelState.activePostId, stickerObject);
                } else {
                    console.warn("åœ¨åŠ¨æ€è¯„è®ºåŒºç‚¹å‡»äº†è¡¨æƒ…ï¼Œä½†åœ¨è¡¨æƒ…åº“ä¸­æœªæ‰¾åˆ°å¯¹è±¡:", stickerUrl);
                }
            }
        });
        
          
        
        
        document.addEventListener('click', (e) => {
            if (qzoneStickerPanelState.isOpen && 
                !qzoneStickerPanelState.panelEl.contains(e.target) && 
                !e.target.closest('.comment-sticker-btn')) {
                closeQzoneStickerPanel();
            }
        });
        
        
            
            document.getElementById('share-link-btn').addEventListener('click', openShareLinkModal);
        
            
            document.getElementById('cancel-share-link-btn').addEventListener('click', () => {
                document.getElementById('share-link-modal').classList.remove('visible');
            });
        
            
            document.getElementById('confirm-share-link-btn').addEventListener('click', sendUserLinkShare);
        
        
        
        document.getElementById('theme-toggle-switch').addEventListener('change', toggleTheme);
document.getElementById('detach-status-bar-switch').addEventListener('change', (e) => {
    applyDetachStatusBarMode(e.target.checked);
});
       document.getElementById('phone-frame-toggle-switch').addEventListener('change', (e) => {
                applyPhoneFrame(e.target.checked);
            }); 

        
        document.getElementById('share-location-btn').addEventListener('click', sendLocationShare);
        
        

        
        
        document.getElementById('chat-list-title').addEventListener('click', renderCallHistoryScreen);
        
        
        document.getElementById('call-history-back-btn').addEventListener('click', () => {
            
            showScreen('chat-list-screen');
        });
        
        
        document.getElementById('call-history-list').addEventListener('click', (e) => {
            const card = e.target.closest('.call-record-card');
            if (card && card.dataset.recordId) {
                showCallTranscript(parseInt(card.dataset.recordId));
            }
        });
        
        
document.getElementById('close-call-transcript-btn').addEventListener('click', () => {
    document.getElementById('call-transcript-modal').classList.remove('visible');
});
        
          
        

        
        document.getElementById('chat-header-status').addEventListener('click', handleEditStatusClick);
        
        
        document.getElementById('selection-share-btn').addEventListener('click', () => {
            if (selectedMessages.size > 0) {
                openShareTargetPicker(); 
            }
        });
        document.getElementById('selection-screenshot-btn').addEventListener('click', handleLongScreenshot);
        
        document.getElementById('confirm-share-target-btn').addEventListener('click', async () => {
            const sourceChat = state.chats[state.activeChatId];
            const selectedTargetIds = Array.from(document.querySelectorAll('.share-target-checkbox:checked'))
                                           .map(cb => cb.dataset.chatId);
        
            if (selectedTargetIds.length === 0) {
                alert("è¯·è‡³å°‘é€‰æ‹©ä¸€ä¸ªè¦åˆ†äº«çš„èŠå¤©ã€‚");
                return;
            }
        
            
            const sharedHistory = [];
            const sortedTimestamps = [...selectedMessages].sort((a, b) => a - b);
            for (const timestamp of sortedTimestamps) {
                const msg = sourceChat.history.find(m => m.timestamp === timestamp);
                if (msg) {
                    sharedHistory.push(msg);
                }
            }
            
            
            const shareCardMessage = {
                role: 'user',
                senderName: sourceChat.isGroup ? (sourceChat.settings.myNickname || 'æˆ‘') : 'æˆ‘',
                type: 'share_card',
                timestamp: Date.now(),
                payload: {
                    sourceChatName: sourceChat.name,
                    title: `æ¥è‡ªâ€œ${sourceChat.name}â€çš„èŠå¤©è®°å½•`,
                    sharedHistory: sharedHistory
                }
            };
        
            
            for (const targetId of selectedTargetIds) {
                const targetChat = state.chats[targetId];
                if (targetChat) {
                    targetChat.history.push(shareCardMessage);
                    await db.chats.put(targetChat);
                }
            }
            
            
            document.getElementById('share-target-modal').classList.remove('visible');
            exitSelectionMode(); 
            await showCustomAlert("åˆ†äº«æˆåŠŸ", `èŠå¤©è®°å½•å·²æˆåŠŸåˆ†äº«åˆ° ${selectedTargetIds.length} ä¸ªä¼šè¯ä¸­ã€‚`);
            renderChatList(); 
        });
        
        
        document.getElementById('cancel-share-target-btn').addEventListener('click', () => {
            document.getElementById('share-target-modal').classList.remove('visible');
        });
        
        
        document.getElementById('chat-messages').addEventListener('click', (e) => {
            
        
            
            const shareCard = e.target.closest('.link-share-card[data-timestamp]');
            if (shareCard && shareCard.closest('.message-bubble.is-link-share')) {
                const timestamp = parseInt(shareCard.dataset.timestamp);
                openSharedHistoryViewer(timestamp);
            }
        });
        
        
        document.getElementById('close-shared-history-viewer-btn').addEventListener('click', () => {
            document.getElementById('shared-history-viewer-modal').classList.remove('visible');
        });
        
        
async function openSharedHistoryViewer(timestamp) {
            const chat = state.chats[state.activeChatId];
            if (!chat) return;

            const message = chat.history.find(m => m.timestamp === timestamp);

            // --- æ ¸å¿ƒä¿®æ”¹ä»Žè¿™é‡Œå¼€å§‹ ---

            if (!message) {
                console.error("æ— æ³•æ‰¾åˆ°åˆ†äº«è®°å½•:", timestamp);
                await showCustomAlert("æŸ¥çœ‹å¤±è´¥", "æ— æ³•æ‰¾åˆ°å¯¹åº”çš„åˆ†äº«è®°å½•æˆ–è®°å½•å·²æŸåã€‚");
                return;
            }

            // 1. å¦‚æžœæ˜¯æ–‡ç« é“¾æŽ¥ï¼Œå°±è½¬äº¤ç»™ openBrowser å‡½æ•°å¤„ç†
            if (message.type === 'share_link') {
                openBrowser(timestamp);
                return; // ä»»åŠ¡å®Œæˆï¼Œç›´æŽ¥é€€å‡º
            }

            // 2. å¦‚æžœæ˜¯èŠå¤©è®°å½•ï¼Œä½†æ•°æ®ä¸å®Œæ•´ï¼Œæ‰æŠ¥é”™
            if (message.type === 'share_card') {
                if (!message.payload || !message.payload.sharedHistory) {
                    console.error("èŠå¤©è®°å½•åˆ†äº«å¡ç‰‡æ•°æ®æŸå:", message);
                    await showCustomAlert("æŸ¥çœ‹å¤±è´¥", "åˆ†äº«çš„èŠå¤©è®°å½•å·²æŸåã€‚");
                    return;
                }
                // å¦‚æžœæ˜¯æ­£å¸¸çš„èŠå¤©è®°å½•ï¼Œä»£ç ä¼šç»§ç»­å¾€ä¸‹æ‰§è¡Œ
            } else {
                // å¦‚æžœæ˜¯å…¶ä»–æœªçŸ¥ç±»åž‹çš„å¡ç‰‡ï¼Œä¹ŸæŠ¥é”™
                console.error("æœªçŸ¥çš„åˆ†äº«å¡ç‰‡ç±»åž‹:", message.type);
                await showCustomAlert("æŸ¥çœ‹å¤±è´¥", "ä¸æ”¯æŒçš„åˆ†äº«ç±»åž‹ã€‚");
                return;
            }
            
            // --- æ ¸å¿ƒä¿®æ”¹åœ¨è¿™é‡Œç»“æŸ ---


            // ä¸‹é¢çš„ä»£ç åªä¼šåœ¨å¤„ç† share_card æ—¶æ‰§è¡Œ
            const viewerModal = document.getElementById('shared-history-viewer-modal');
            const viewerTitle = document.getElementById('shared-history-viewer-title');
            const viewerContent = document.getElementById('shared-history-viewer-content');

            viewerTitle.textContent = message.payload.title;
            viewerContent.innerHTML = '';

            const fragment = document.createDocumentFragment();
            const sourceChat = Object.values(state.chats).find(c => c.name === message.payload.sourceChatName) || chat;

            for (const sharedMsg of message.payload.sharedHistory) {
                const bubbleEl = await createMessageElement(sharedMsg, sourceChat);
                if (bubbleEl) {
                    fragment.appendChild(bubbleEl);
                }
            }

            viewerContent.appendChild(fragment);
            viewerModal.classList.add('visible');
        }
        
        audioPlayer.addEventListener('timeupdate', updateMusicProgressBar);
        
        audioPlayer.addEventListener('pause', () => { 
            if(musicState.isActive) { 
                musicState.isPlaying = false; 
          phoneScreenForIsland.classList.remove('dynamic-island-active');
                updatePlayerUI(); 
            } 
        });
        audioPlayer.addEventListener('play', () => { 
            if(musicState.isActive) { 
                musicState.isPlaying = true; 
                updatePlayerUI(); 
            } 
        });
        


document.getElementById('playlist-body').addEventListener('click', async (e) => {
    const target = e.target;
    
    
    const albumArtBtn = target.closest('.album-art-btn');
    if (albumArtBtn) {
        const index = parseInt(albumArtBtn.dataset.index);
        if (!isNaN(index)) {
            
            await handleChangeAlbumArt(index);
        }
        return; 
    }
    
    const lyricsBtn = target.closest('.lyrics-btn');
    if (lyricsBtn) {
        const index = parseInt(lyricsBtn.dataset.index);
        if (isNaN(index)) return;

        
        
        await handleManualLrcImport(index);

        return; 
    }

    
    const deleteBtn = target.closest('.delete-track-btn');
    if (deleteBtn) {
        const index = parseInt(deleteBtn.dataset.index);
        if (isNaN(index)) return;
        const track = musicState.playlist[index];
        const confirmed = await showCustomConfirm('åˆ é™¤æ­Œæ›²', `ç¡®å®šè¦ä»Žæ’­æ”¾åˆ—è¡¨ä¸­åˆ é™¤ã€Š${track.name}ã€‹å—ï¼Ÿ`);
        if (confirmed) {
            deleteTrack(index);
        }
        return;
    }

    
    const itemInfo = target.closest('.playlist-item-info');
    if (itemInfo) {
        const item = itemInfo.closest('.playlist-item');
        const index = Array.from(item.parentElement.children).indexOf(item);
        if (index > -1) {
            playSong(index);
        }
    }
});
  
        
        document.querySelector('.progress-bar').addEventListener('click', (e) => {
            if (!audioPlayer.duration) return;
            const progressBar = e.currentTarget;
            const barWidth = progressBar.clientWidth;
            const clickX = e.offsetX;
            audioPlayer.currentTime = (clickX / barWidth) * audioPlayer.duration;
        });
        
        
        
        
        document.getElementById('chat-messages').addEventListener('click', (e) => {
            

const placeholder = e.target.closest('.recalled-message-placeholder');
if (placeholder) {
    const chat = state.chats[state.activeChatId];
    const wrapper = placeholder.closest('.message-wrapper');
    if (chat && wrapper) {
        const timestamp = parseInt(wrapper.dataset.timestamp);
        const recalledMsg = chat.history.find(m => m.timestamp === timestamp);

        if (recalledMsg && recalledMsg.recalledData) {
            let originalContentText = '';
            const recalled = recalledMsg.recalledData;

            
            switch (recalled.originalType) {
                case 'text':
                    originalContentText = `åŽŸæ–‡: "${recalled.originalContent}"`;
                    break;
                case 'user_photo':
                case 'ai_image':
                case 'text_image':
                    originalContentText = `[å›¾ç‰‡/æ–‡å­—å›¾] æè¿°: "${recalled.originalContent}"`;
                    break;
                case 'voice_message':
                    originalContentText = `[è¯­éŸ³] å†…å®¹: "${recalled.originalContent}"`;
                    break;
                case 'sticker':
                    
                    originalContentText = `[è¡¨æƒ…] å«ä¹‰: "${recalled.originalMeaning || '(æ— )'}" \n URL: ${recalled.originalContent}`;
                    break;
                case 'transfer':
                    originalContentText = `ä¸€æ¡[è½¬è´¦]æ¶ˆæ¯å·²è¢«æ’¤å›žã€‚`;
                    break;
                default:
                    
                    originalContentText = `æ’¤å›žäº†ä¸€æ¡[${recalled.originalType}]ç±»åž‹çš„æ¶ˆæ¯ã€‚\nå†…å®¹: ${JSON.stringify(recalled.originalContent)}`;
                    break;
            }
            

            showCustomAlert('å·²æ’¤å›žçš„æ¶ˆæ¯', originalContentText);
        }
    }
}
});
        
        
        
        
        document.getElementById('manage-world-book-categories-btn').addEventListener('click', openCategoryManager);
        document.getElementById('close-category-manager-btn').addEventListener('click', () => {
            document.getElementById('world-book-category-manager-modal').classList.remove('visible');
            renderWorldBookScreen(); 
        });
        document.getElementById('add-new-category-btn').addEventListener('click', addNewCategory);
        document.getElementById('existing-categories-list').addEventListener('click', (e) => {
            if (e.target.classList.contains('delete-group-btn')) {
                const categoryId = parseInt(e.target.dataset.id);
                deleteCategory(categoryId);
            }
        });
        
        document.getElementById('repost-cancel-btn').addEventListener('click', hideRepostModal);
        document.getElementById('repost-confirm-btn').addEventListener('click', handleConfirmRepost);
          

        
        
        
        document.getElementById('quote-message-btn').addEventListener('click', startReplyToMessage);
        
        
        document.getElementById('cancel-reply-btn').addEventListener('click', cancelReplyMode);
        
        
        
                
                
        
        
            
            
            
            document.getElementById('qzone-posts-list').addEventListener('input', (e) => {
                if (!e.target.matches('.comment-input')) return;
        
                const commentInput = e.target;
                const postContainer = commentInput.closest('.qzone-post-container');
                if (!postContainer) return;
                
                const popup = postContainer.querySelector('.at-mention-popup');
                const value = commentInput.value;
                const atMatch = value.match(/@([\p{L}\w]*)$/u);
        
                if (atMatch) {
                    const namesToMention = new Set();
                    const authorNickname = postContainer.querySelector('.post-nickname')?.textContent;
                    if (authorNickname) namesToMention.add(authorNickname);
                    postContainer.querySelectorAll('.commenter-name').forEach(nameEl => {
                        namesToMention.add(nameEl.textContent.replace(':', ''));
                    });
                    namesToMention.delete(state.qzoneSettings.nickname);
        
                    popup.innerHTML = '';
                    if (namesToMention.size > 0) {
                        const searchTerm = atMatch[1];
                        namesToMention.forEach(name => {
                            if (name.toLowerCase().includes(searchTerm.toLowerCase())) {
                                const item = document.createElement('div');
                                item.className = 'at-mention-item';
                                item.textContent = name;
                                item.addEventListener('mousedown', (evt) => {
                                    evt.preventDefault();
                                    const newText = value.substring(0, atMatch.index) + `@${name} `;
                                    commentInput.value = newText;
                                    popup.style.display = 'none';
                                    commentInput.focus();
                                });
                                popup.appendChild(item);
                            }
                        });
                        popup.style.display = popup.children.length > 0 ? 'block' : 'none';
                    } else {
                        popup.style.display = 'none';
                    }
                } else {
                    popup.style.display = 'none';
                }
            });
        
            document.getElementById('qzone-posts-list').addEventListener('focusout', (e) => {
                if (e.target.matches('.comment-input')) {
                    const postContainer = e.target.closest('.qzone-post-container');
                    if (postContainer) {
                        const popup = postContainer.querySelector('.at-mention-popup');
                        if (popup) {
                            setTimeout(() => { popup.style.display = 'none'; }, 200);
                        }
                    }
                }
            });
        
            
        
        
        
        const chatInputForMention = document.getElementById('chat-input');
        const chatMentionPopup = document.getElementById('chat-at-mention-popup');
        
        chatInputForMention.addEventListener('input', () => {
            
            if (!state.activeChatId || !state.chats[state.activeChatId].isGroup) {
                chatMentionPopup.style.display = 'none';
                return;
            }
            
            const chat = state.chats[state.activeChatId];
            const value = chatInputForMention.value;
            const atMatch = value.match(/@([\p{L}\w]*)$/u);
        
            if (atMatch) {
                
                const myNickname = chat.settings.myNickname || 'æˆ‘';
                const namesToMention = chat.members
                    .map(member => member.groupNickname)
                    .filter(name => name !== myNickname);
        
                chatMentionPopup.innerHTML = '';
                if (namesToMention.length > 0) {
                    const searchTerm = atMatch[1];
                    
                    namesToMention.forEach(name => {
                        if (name.toLowerCase().includes(searchTerm.toLowerCase())) {
                            const item = document.createElement('div');
                            item.className = 'at-mention-item';
                            item.textContent = name;
                            
                            item.addEventListener('mousedown', (e) => {
                                e.preventDefault();
                                const newText = value.substring(0, atMatch.index) + `@${name} `;
                                chatInputForMention.value = newText;
                                chatMentionPopup.style.display = 'none';
                                chatInputForMention.focus();
                            });
                            chatMentionPopup.appendChild(item);
                        }
                    });
                    
                    chatMentionPopup.style.display = chatMentionPopup.children.length > 0 ? 'block' : 'none';
                } else {
                    chatMentionPopup.style.display = 'none';
                }
            } else {
                chatMentionPopup.style.display = 'none';
            }
        });
        
        
        chatInputForMention.addEventListener('blur', () => {
            setTimeout(() => { chatMentionPopup.style.display = 'none'; }, 200);
        });
        
        
        document.getElementById('publish-to-announcement-btn').addEventListener('click', publishToAnnouncementBoard);
        document.getElementById('show-announcement-board-btn').addEventListener('click', showAnnouncementBoard);
        document.getElementById('close-announcement-board-btn').addEventListener('click', () => {
            document.getElementById('announcement-board-modal').classList.remove('visible');
        });
            
        
        document.getElementById('announcement-board-content').addEventListener('click', (e) => {
            if (e.target.classList.contains('announcement-item-actions')) {
                const annoId = e.target.dataset.annoId;
                if (annoId) {
                    showAnnouncementActions(annoId);
                }
            }
        });
        
        document.getElementById('announcement-action-pin').addEventListener('click', handlePinAnnouncement);
        document.getElementById('announcement-action-delete').addEventListener('click', handleDeleteAnnouncement);
        document.getElementById('announcement-action-cancel').addEventListener('click', () => {
            document.getElementById('announcement-actions-modal').classList.remove('visible');
        });
             
                    
                    document.getElementById('reset-global-css-btn').addEventListener('click', () => {
                        document.getElementById('global-css-input').value = '';
                        
                        
                    });
        
        
        document.getElementById('open-memory-screen-btn').addEventListener('click', openLongTermMemoryScreen);
        
        
        document.getElementById('memory-screen-back-btn').addEventListener('click', () => {
            showScreen('chat-interface-screen');
        });
        
        
        document.getElementById('add-manual-memory-btn-header').addEventListener('click', handleAddManualMemory);
        
        
        document.getElementById('summarize-recent-btn-header').addEventListener('click', handleManualSummary);
        
        
document.getElementById('memory-list-container').addEventListener('click', (e) => {
    const editBtn = e.target.closest('.edit-memory-btn');
    if (editBtn) {
        handleEditMemory(editBtn.dataset.authorId, parseInt(editBtn.dataset.memoryTimestamp));
        return;
    }
    const deleteBtn = e.target.closest('.delete-memory-btn');
    if (deleteBtn) {
        handleDeleteMemory(deleteBtn.dataset.authorId, parseInt(deleteBtn.dataset.memoryTimestamp));
        return;
    }
});
          
        
        document.getElementById('gomoku-btn').addEventListener('click', toggleGomokuBoard);
        document.getElementById('close-gomoku-btn').addEventListener('click', closeGomokuBoard);
        
        const gomokuCanvas = document.getElementById('gomoku-board');
        gomokuCanvas.addEventListener('mousemove', handleBoardHover);
        gomokuCanvas.addEventListener('mouseout', () => renderGomokuBoard(state.activeChatId)); 
        gomokuCanvas.addEventListener('click', handleBoardClick);
          
        
        document.getElementById('add-countdown-btn').addEventListener('click', () => {
            
            document.getElementById('countdown-title-input').value = '';
            document.getElementById('countdown-date-input').value = '';
            
            document.getElementById('create-countdown-modal').classList.add('visible');
        });
        
        
        document.getElementById('cancel-create-countdown-btn').addEventListener('click', () => {
            document.getElementById('create-countdown-modal').classList.remove('visible');
        });
        
        
                    
        document.getElementById('edit-call-message-btn').addEventListener('click', openCallMessageEditor);
        document.getElementById('delete-call-message-btn').addEventListener('click', deleteCallMessage);
        document.getElementById('cancel-call-message-action-btn').addEventListener('click', hideCallMessageActions);
          
        
        document.getElementById('edit-last-response-btn').addEventListener('click', openAiResponseEditor);
        document.getElementById('cancel-ai-response-editor-btn').addEventListener('click', () => {
            document.getElementById('ai-response-editor-modal').classList.remove('visible');
        });
        document.getElementById('save-ai-response-editor-btn').addEventListener('click', saveEditedAiResponse);
        document.getElementById('add-ai-response-block-btn').addEventListener('click', () => {
            
            const container = document.getElementById('ai-response-editor-container');
            const newBlock = createAiResponseEditorBlock('{\n  "type": "text",\n  "content": "åœ¨è¿™é‡Œè¾“å…¥æ–°æ¶ˆæ¯..."\n}');
            container.appendChild(newBlock);
            newBlock.querySelector('textarea').focus();
        });
          
        
        document.getElementById('manage-my-avatar-library-btn').addEventListener('click', openMyAvatarLibraryModal);
        document.getElementById('close-my-avatar-library-btn').addEventListener('click', closeMyAvatarLibraryModal);
        document.getElementById('add-my-avatar-url-btn').addEventListener('click', addAvatarToMyLibraryFromURL);
        document.getElementById('add-my-avatar-upload-btn').addEventListener('click', () => {
            document.getElementById('my-avatar-upload-input').click();
        });
        document.getElementById('my-avatar-upload-input').addEventListener('change', handleLocalMyAvatarUpload);
        document.getElementById('add-my-avatar-batch-btn').addEventListener('click', async () => {
            const placeholderText = `è¯·æŒ‰ç…§ä»¥ä¸‹æ ¼å¼ç²˜è´´ï¼Œä¸€è¡Œä¸€ä¸ªï¼š\n\nç„¦è™‘ 2a9wte.jpeg\nå¤§æƒŠå¤±è‰² or8qf4.png\næ²¡æœ‰çµæ„Ÿ njwujh.jpeg`;
            const pastedText = await showCustomPrompt('æ‰¹é‡å¯¼å…¥å¤´åƒ', placeholderText, '', 'textarea');
            if (pastedText && pastedText.trim()) {
                await handleBatchImportForMyAvatar(pastedText);
            }
        });
          
        
        document.getElementById('open-shopping-btn').addEventListener('click', openShoppingScreen);
        document.getElementById('shopping-back-btn').addEventListener('click', () => showScreen('chat-interface-screen'));
        document.getElementById('go-to-cart-btn').addEventListener('click', openCartScreen);
        document.getElementById('cart-back-btn').addEventListener('click', openShoppingScreen);
        document.getElementById('checkout-btn').addEventListener('click', handleCheckout);
        document.getElementById('close-receipt-btn').addEventListener('click', () => {
            document.getElementById('gift-receipt-modal').classList.remove('visible');
        });
        
        
document.getElementById('manage-products-btn').addEventListener('click', () => {
    isProductManagementMode = !isProductManagementMode;
    const btn = document.getElementById('manage-products-btn');
    const actionBar = document.getElementById('shopping-action-bar');
    const gridEl = document.getElementById('product-grid');

    btn.style.color = isProductManagementMode ? 'var(--accent-color)' : 'var(--text-primary)';

    if (isProductManagementMode) {
        actionBar.style.display = 'flex'; 
        gridEl.style.paddingBottom = '80px'; 
    } else {
        actionBar.style.display = 'none'; 
        gridEl.style.paddingBottom = ''; 
        
        selectedProducts.clear();
        document.querySelectorAll('.product-item.selected').forEach(item => item.classList.remove('selected'));
        document.getElementById('delete-selected-products-btn').textContent = `åˆ é™¤ (0)`;
        document.getElementById('select-all-products-checkbox').checked = false;
    }

    
    renderShoppingProducts();
    updateDeleteCategoryButtonVisibility();
});
        
        
        document.getElementById('add-new-product-btn').addEventListener('click', () => {
            if (isProductManagementMode) {
                openProductEditor(null);
            } else {
                alert("è¯·å…ˆç‚¹å‡»æ‰³æ‰‹å›¾æ ‡è¿›å…¥ç®¡ç†æ¨¡å¼ï¼Œæ‰èƒ½æ·»åŠ æ–°å•†å“ã€‚");
            }
        });
        
        

        document.getElementById('product-grid').addEventListener('click', async e => {
            const productItem = e.target.closest('.product-item');
            if (!productItem) return;
            const productId = parseInt(productItem.dataset.id);
            if (isNaN(productId)) return;

            
            if (isProductManagementMode) {
                
                if (e.target.classList.contains('edit-product-btn')) {
                    openProductEditor(productId);
                    return;
                }
                
                if (e.target.classList.contains('delete-product-btn')) {
                    const product = await db.shoppingProducts.get(productId);
                    if (!product) return;
                    const confirmed = await showCustomConfirm('åˆ é™¤å•†å“', `ç¡®å®šè¦æ°¸ä¹…åˆ é™¤å•†å“ â€œ${product.name}â€ å—ï¼Ÿ`, { confirmButtonClass: 'btn-danger' });
                    if(confirmed) {
                         await db.shoppingProducts.delete(productId);
                         await renderShoppingProducts(); 
                         alert("å•†å“å·²åˆ é™¤ã€‚");
                    }
                    return;
                }
                
                
                productItem.classList.toggle('selected');
                if (selectedProducts.has(productId)) {
                    selectedProducts.delete(productId);
                } else {
                    selectedProducts.add(productId);
                }
                document.getElementById('delete-selected-products-btn').textContent = `åˆ é™¤ (${selectedProducts.size})`;
                return;
            }

            
            if (e.target.classList.contains('add-to-cart-btn')) {
                const product = await db.shoppingProducts.get(productId);
                if (product.variations && product.variations.length > 0) {
                    openVariationSelector(productId);
                } else {
                    await addToCart(productId);
                    await showCustomAlert('æˆåŠŸ', 'å·²æˆåŠŸåŠ å…¥è´­ç‰©è½¦ï¼');
                }
                return;
            }

            
            if (productItem.contains(e.target)) {
                 console.log(`ç‚¹å‡»äº†å•†å“å¡ç‰‡: ${productId}`);
            }
        });
  
        
        
        document.getElementById('cart-items-list').addEventListener('click', e => {
            const target = e.target;
            if (target.classList.contains('decrease-qty-btn')) {
                updateCartItemQuantity(parseInt(target.dataset.id), -1);
            }
            if (target.classList.contains('increase-qty-btn')) {
                updateCartItemQuantity(parseInt(target.dataset.id), 1);
            }
            if (target.classList.contains('cart-item-checkbox')) {
                updateCartTotal();
            }
        });
        
        
        document.getElementById('clear-cart-btn').addEventListener('click', async () => {
            if (shoppingCart.length === 0) return;
            const confirmed = await showCustomConfirm('æ¸…ç©ºè´­ç‰©è½¦', 'ç¡®å®šè¦æ¸…ç©ºè´­ç‰©è½¦ä¸­çš„æ‰€æœ‰å•†å“å—ï¼Ÿ');
            if (confirmed) {
                shoppingCart = [];
                updateCartCount();
                renderCartItems();
            }
        });
        
        
        document.getElementById('select-all-cart-items').addEventListener('change', function(e) {
            document.querySelectorAll('.cart-item-checkbox').forEach(cb => {
                cb.checked = e.target.checked;
            });
            updateCartTotal();
        });
        
        
        document.getElementById('cancel-product-editor-btn').addEventListener('click', () => {
            document.getElementById('product-editor-modal').classList.remove('visible');
        });
        document.getElementById('save-product-btn').addEventListener('click', saveProduct);
        document.getElementById('product-image-input').addEventListener('change', e => {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (re) => { document.getElementById('product-image-preview').src = re.target.result; };
                reader.readAsDataURL(file);
            }
        });
        
        
        document.getElementById('chat-messages').addEventListener('click', e => {
            const giftCard = e.target.closest('.gift-card');
            if (giftCard) {
                const bubble = giftCard.closest('.message-bubble');
                if (bubble) {
                    showGiftReceipt(parseInt(bubble.dataset.timestamp));
                }
            }
        });
        
        
        document.getElementById('cancel-gift-recipient-btn').addEventListener('click', () => {
            document.getElementById('gift-recipient-modal').classList.remove('visible');
        });
        
        
        document.getElementById('confirm-gift-recipient-btn').addEventListener('click', async () => {
            
            const selectedRecipients = Array.from(document.querySelectorAll('#gift-recipient-list .contact-picker-item.selected'))
                .map(item => item.dataset.recipientName);
            
            if (selectedRecipients.length === 0) {
                alert("è¯·è‡³å°‘é€‰æ‹©ä¸€ä½æ”¶ç¤¼äººã€‚");
                return;
            }
            
            
            const selectedItems = shoppingCart.filter(item => 
                document.querySelector(`.cart-item-checkbox[data-id="${item.productId}"]:checked`)
            );
            
            
            await sendGiftMessage(selectedItems, selectedRecipients);
            
            
            document.getElementById('gift-recipient-modal').classList.remove('visible');
        });
          
        
        document.getElementById('gift-recipient-list').addEventListener('click', (e) => {
            const item = e.target.closest('.contact-picker-item');
            if (item) {
                item.classList.toggle('selected');
            }
        });
        
        document.getElementById('select-all-recipients').addEventListener('change', function(e) {
            const isChecked = e.target.checked;
            document.querySelectorAll('#gift-recipient-list .contact-picker-item').forEach(item => {
                item.classList.toggle('selected', isChecked);
            });
        });
          
        
        document.getElementById('regenerate-btn').addEventListener('click', handleRegenerateResponse);
        document.getElementById('regenerate-call-btn').addEventListener('click', handleRegenerateCallResponse);
            
        
        document.getElementById('propel-btn').addEventListener('click', handlePropelAction);
        
        
          



document.getElementById('test-sound-btn').addEventListener('click', () => {
    const player = document.getElementById('notification-sound-player');
    const url = document.getElementById('notification-sound-url-input').value.trim() || DEFAULT_NOTIFICATION_SOUND;
    player.src = url;
    player.play().catch(e => alert('æ’­æ”¾å¤±è´¥ï¼Œè¯·æ£€æŸ¥URLæ˜¯å¦æ­£ç¡®æˆ–æµè§ˆå™¨æ˜¯å¦æ”¯æŒè¯¥æ ¼å¼ã€‚'));
});

document.getElementById('reset-sound-btn').addEventListener('click', () => {
    document.getElementById('notification-sound-url-input').value = '';
    alert('å·²é‡ç½®ä¸ºé»˜è®¤æç¤ºéŸ³ï¼Œç‚¹å‡»â€œä¿å­˜æ‰€æœ‰å¤–è§‚è®¾ç½®â€åŽç”Ÿæ•ˆã€‚');
});
    
    document.getElementById('home-screen').addEventListener('click', (e) => {
        const target = e.target;
        
        if (target.classList.contains('editable-text')) {
            handleEditText(target);
        }
        
        if (target.classList.contains('editable-image')) {
            handleEditImage(target);
        }
    });
    
document.getElementById('add-song-search-btn').addEventListener('click', addSongFromSearch);    

document.getElementById('cancel-music-search-btn').addEventListener('click', () => {
    document.getElementById('music-search-results-modal').classList.remove('visible');
});


document.getElementById('add-song-search-btn').addEventListener('click', addSongFromSearch);

document.getElementById('cancel-music-search-btn').addEventListener('click', () => {
    document.getElementById('music-search-results-modal').classList.remove('visible');
});


document.getElementById('select-all-music-search').addEventListener('change', function(e) {
    document.querySelectorAll('#search-results-list .music-search-checkbox').forEach(cb => {
        cb.checked = e.target.checked;
    });
});


document.getElementById('search-results-list').addEventListener('click', (e) => {
    const item = e.target.closest('.search-result-item');
    if (item) {
        const checkbox = item.querySelector('.music-search-checkbox');
        if (checkbox) {
            
            if (e.target !== checkbox) {
                checkbox.checked = !checkbox.checked;
            }
        }
    }
});


document.getElementById('add-selected-music-btn').addEventListener('click', async () => {
    const selectedItems = document.querySelectorAll('.music-search-checkbox:checked');
    if (selectedItems.length === 0) {
        alert("è¯·å…ˆé€‰æ‹©è¦æ·»åŠ çš„æ­Œæ›²ã€‚");
        return;
    }

    document.getElementById('music-search-results-modal').classList.remove('visible');
    await showCustomAlert("è¯·ç¨å€™...", `æ­£åœ¨æ‰¹é‡æ·»åŠ  ${selectedItems.length} é¦–æ­Œæ›²...`);

    const songDataList = Array.from(selectedItems).map(cb => JSON.parse(cb.closest('.search-result-item').dataset.songJson));
    
    let successCount = 0;
    let failedNames = [];

    
    const songDetailPromises = songDataList.map(songData => getPlayableSongDetails(songData));
    const fullSongObjects = await Promise.all(songDetailPromises);

    fullSongObjects.forEach((songObject, index) => {
        if (songObject) {
            musicState.playlist.push(songObject);
            successCount++;
        } else {
            failedNames.push(songDataList[index].name);
        }
    });

    if (successCount > 0) {
        await saveGlobalPlaylist();
        updatePlaylistUI();
        if (musicState.currentIndex === -1) {
            musicState.currentIndex = musicState.playlist.length - successCount;
            updatePlayerUI();
        }
    }

    let resultMessage = `æ·»åŠ å®Œæˆï¼\n\næˆåŠŸæ·»åŠ  ${successCount} é¦–æ­Œæ›²ã€‚`;
    if (failedNames.length > 0) {
        resultMessage += `\n\n${failedNames.length} é¦–æ­Œæ›²èŽ·å–å¤±è´¥:\n- ${failedNames.join('\n- ')}`;
    }
    await showCustomAlert("æ“ä½œç»“æžœ", resultMessage);
});
  
  

document.getElementById('music-visual-container').addEventListener('click', () => {
    document.getElementById('music-visual-container').classList.toggle('lyrics-active');
});



document.getElementById('add-song-search-btn').addEventListener('click', addSongFromSearch);
document.getElementById('cancel-music-search-btn').addEventListener('click', () => {
    document.getElementById('music-search-results-modal').classList.remove('visible');
});

document.getElementById('search-results-list').addEventListener('click', (e) => {
    const item = e.target.closest('.search-result-item');
    if (item && item.dataset.songJson) {
        const songData = JSON.parse(item.dataset.songJson);
        handleSearchResultClick(songData);
    }
});
  


document.getElementById('cleanup-songs-btn').addEventListener('click', cleanupInvalidSongs);
document.getElementById('toggle-blur-btn').addEventListener('click', toggleBackgroundBlur);
 document.getElementById('toggle-fullscreen-btn').addEventListener('click', togglePlayerFullscreen);
document.getElementById('show-avatars-btn').addEventListener('click', toggleMusicPlayerAvatars);
  

document.getElementById('status-bar-toggle-switch').addEventListener('change', () => {
    
    state.globalSettings.showStatusBar = document.getElementById('status-bar-toggle-switch').checked;
    applyStatusBarVisibility();
});


document.getElementById('qzone-more-actions-btn').addEventListener('click', openClearPostsSelectorModal);


document.getElementById('cancel-clear-posts-btn').addEventListener('click', () => {
    document.getElementById('clear-posts-modal').classList.remove('visible');
});
document.getElementById('confirm-clear-posts-btn').addEventListener('click', handleConfirmClearPosts);


document.getElementById('clear-posts-list').addEventListener('click', (e) => {
    const item = e.target.closest('.clear-posts-item');
    if (item) {
        item.classList.toggle('selected');
    }
});

document.getElementById('global-bg-input').addEventListener('change', async (event) => {
    const file = event.target.files[0];
    if (file) {
        const dataUrl = await new Promise(resolve => {
            const reader = new FileReader();
            reader.onload = () => resolve(reader.result);
            reader.readAsDataURL(file);
        });
        
        state.globalSettings.globalChatBackground = dataUrl;
        
        renderWallpaperScreen();
    }
    event.target.value = null; 
});

document.getElementById('remove-global-bg-btn').addEventListener('click', () => {
    
    state.globalSettings.globalChatBackground = '';
    renderWallpaperScreen();
});


document.getElementById('save-wallpaper-btn').addEventListener('click', async () => {
    
    if (newWallpaperBase64) {
        state.globalSettings.wallpaper = newWallpaperBase64;
    }
    
    
    
    state.globalSettings.globalCss = document.getElementById('global-css-input').value.trim();
    state.globalSettings.notificationSoundUrl = document.getElementById('notification-sound-url-input').value.trim();
    state.globalSettings.showStatusBar = document.getElementById('status-bar-toggle-switch').checked;
    
    
    await db.globalSettings.put(state.globalSettings);
    
    
    applyGlobalWallpaper();
    newWallpaperBase64 = null;
    applyAppIcons();
    applyGlobalCss(state.globalSettings.globalCss);
    applyStatusBarVisibility();

    alert('å¤–è§‚è®¾ç½®å·²ä¿å­˜å¹¶åº”ç”¨ï¼');
    showScreen('home-screen');
});
  

document.getElementById('upload-global-bg-url-btn').addEventListener('click', async () => {
    
    const url = await showCustomPrompt("ç½‘ç»œå›¾ç‰‡", "è¯·è¾“å…¥èƒŒæ™¯å›¾ç‰‡çš„URL", "", "url");

    
    if (url && url.trim()) {
        
        state.globalSettings.globalChatBackground = url.trim();
        
        
        renderWallpaperScreen();
    } else if (url !== null) {
        
        alert("è¯·è¾“å…¥æœ‰æ•ˆçš„URLã€‚");
    }
});

document.getElementById('upload-ephone-bg-url-btn').addEventListener('click', async () => {
    const url = await showCustomPrompt("ç½‘ç»œå›¾ç‰‡ (EPhone)", "è¯·è¾“å…¥EPhoneä¸»å±å¹•çš„èƒŒæ™¯å›¾ç‰‡URL", "", "url");
    if (url && url.trim()) {
        
        newWallpaperBase64 = url.trim();
        
        renderWallpaperScreen();
    } else if (url !== null) {
        alert("è¯·è¾“å…¥æœ‰æ•ˆçš„URLã€‚");
    }
});


document.getElementById('upload-cphone-bg-url-btn').addEventListener('click', async () => {
    const url = await showCustomPrompt("ç½‘ç»œå›¾ç‰‡ (CPhone)", "è¯·è¾“å…¥CPhoneçš„èƒŒæ™¯å›¾ç‰‡URL", "", "url");
    if (url && url.trim()) {
        
        state.globalSettings.cphoneWallpaper = url.trim();
        
        renderWallpaperScreen();
    } else if (url !== null) {
        alert("è¯·è¾“å…¥æœ‰æ•ˆçš„URLã€‚");
    }
});



document.getElementById('remove-ephone-bg-btn').addEventListener('click', () => {
    
    newWallpaperBase64 = null;
    state.globalSettings.wallpaper = '';
    
    renderWallpaperScreen();
});


document.getElementById('remove-cphone-bg-btn').addEventListener('click', () => {
    
    state.globalSettings.cphoneWallpaper = '';
    
    renderWallpaperScreen();
});


        
        document.getElementById('css-preset-select').addEventListener('change', handleCssPresetSelectionChange);
        document.getElementById('save-css-preset-btn').addEventListener('click', saveCssPreset);
        document.getElementById('delete-css-preset-btn').addEventListener('click', deleteCssPreset);
          
        
        document.getElementById('font-preset-select').addEventListener('change', handleFontPresetSelectionChange);
        document.getElementById('save-font-preset-btn').addEventListener('click', saveFontPreset);
        document.getElementById('delete-font-preset-btn').addEventListener('click', deleteFontPreset);
          
        
        document.getElementById('theme-preset-select').addEventListener('change', handleThemePresetSelectionChange);
        document.getElementById('save-theme-preset-btn').addEventListener('click', saveThemePreset);
        document.getElementById('delete-theme-preset-btn').addEventListener('click', deleteThemePreset);
          
        
        
        
        document.getElementById('manage-sticker-categories-btn').addEventListener('click', openStickerCategoryManager);

        
        document.getElementById('close-sticker-category-manager-btn').addEventListener('click', () => {
            document.getElementById('sticker-category-manager-modal').classList.remove('visible');
            renderStickerPanel(); 
        });

        
        document.getElementById('add-new-sticker-category-btn').addEventListener('click', addNewStickerCategory);

        
        document.getElementById('existing-sticker-categories-list').addEventListener('click', (e) => {
            if (e.target.classList.contains('delete-group-btn')) {
                const categoryId = parseInt(e.target.dataset.id);
                deleteStickerCategory(categoryId);
            }
        });
        
        
        document.getElementById('sticker-category-tabs').addEventListener('click', (e) => {
            if (e.target.classList.contains('sticker-category-tab')) {
                const categoryId = e.target.dataset.categoryId;
                
                const finalId = (categoryId !== 'all' && categoryId !== 'uncategorized') ? parseInt(categoryId) : categoryId;
                switchStickerCategory(finalId);
            }
        });

          
        document.getElementById('select-all-stickers-checkbox').addEventListener('change', handleSelectAllStickers);

document.getElementById('export-single-chat-btn').addEventListener('click', exportSingleChat);

document.getElementById('import-single-chat-btn').addEventListener('click', () => {
    document.getElementById('import-single-chat-input').click();
});

document.getElementById('import-single-chat-input').addEventListener('change', (e) => {
    const file = e.target.files[0];
    if (file) {
        importSingleChat(file);
    }
    e.target.value = null; 
});
  

document.getElementById('add-char-memo-btn').addEventListener('click', () => openMemoEditor());
document.getElementById('add-char-diary-btn').addEventListener('click', () => openDiaryEditor());
document.getElementById('favorite-diary-btn').addEventListener('click', toggleDiaryFavorite);
document.getElementById('favorite-article-btn').addEventListener('click', toggleBrowserArticleFavorite);
document.getElementById('favorite-memo-btn').addEventListener('click', toggleMemoFavorite); 
        document.getElementById('copy-diary-content-btn').addEventListener('click', () => {
            const content = document.getElementById('char-diary-detail-content').innerText; // Use innerText to get formatted text
            copyTextToClipboard(content, 'æ—¥è®°å†…å®¹å·²å¤åˆ¶ï¼');
        });

        document.getElementById('copy-memo-content-btn').addEventListener('click', () => {
            const content = document.getElementById('char-memo-detail-content').value; // It's a textarea
            copyTextToClipboard(content, 'å¤‡å¿˜å½•å†…å®¹å·²å¤åˆ¶ï¼');
        });

        document.getElementById('copy-article-content-btn').addEventListener('click', () => {
            const content = document.getElementById('char-article-content').innerText;
            copyTextToClipboard(content, 'æ–‡ç« å†…å®¹å·²å¤åˆ¶ï¼');
        });  
        

document.getElementById('regenerate-char-qq-btn').addEventListener('click', async () => {
    
    showCustomAlert("æ­£åœ¨æ‰§è¡Œ...", "æ­£åœ¨ç”Ÿæˆæ–°çš„æ¨¡æ‹ŸèŠå¤©è®°å½•ï¼Œå¹¶åŒæ—¶è®©è§’è‰²æ€è€ƒå¦‚ä½•ä¸Žä½ ç»§ç»­å¯¹è¯...");

    try {
        
        await Promise.all([
            handleGenerateSimulatedQQ(),
            handleContinueRealConversationFromCPhone()
        ]);

        console.log("CPhone QQæ¨¡æ‹Ÿè®°å½•ç”Ÿæˆ å’Œ ä¸»èŠå¤©æŽ¨è¿› å·²åŒæ—¶å®Œæˆã€‚");

    } catch (error) {
        console.error("åœ¨åŒæ—¶æ‰§è¡Œä¸¤ä¸ªå‡½æ•°æ—¶å‡ºé”™:", error);
        await showCustomAlert("æ“ä½œå¤±è´¥", `åœ¨æ‰§è¡Œç»„åˆæ“ä½œæ—¶é‡åˆ°é”™è¯¯: ${error.message}`);
    }
});

        
        document.getElementById('char-chat-list').addEventListener('click', (e) => {
            const item = e.target.closest('.chat-list-item');
            if (item && item.dataset.conversationIndex) {
                const index = parseInt(item.dataset.conversationIndex);
                if (!isNaN(index)) {
                    
                    openCharSimulatedConversation(index);
                }
            }
        });



        document.getElementById('back-to-char-qq-list-btn').addEventListener('click', () => {
            switchToCharScreen('char-qq-screen');
        });


        
        const charConversationMessages = document.getElementById('char-conversation-messages');

        
        const cphoneScrollHandler = () => {
            
            if (cphoneActiveConversationType !== 'private_user') {
                return; 
            }
            
            
            if (charConversationMessages.scrollTop < 1 && !isLoadingMoreCphoneMessages) {
                const totalMessages = state.chats[activeCharacterId]?.history.length || 0;
                
                if (totalMessages > cphoneRenderedCount) {
                    
                    loadMoreMirroredMessages();
                }
            }
        };

        
        charConversationMessages.addEventListener('scroll', cphoneScrollHandler);

        
        
        document.getElementById('char-simulated-send-btn').addEventListener('click', () => {
            alert("è¿™æ˜¯æ¨¡æ‹Ÿå¯¹è¯ï¼Œæ— æ³•å‘é€æ¶ˆæ¯å“¦~");
        });

          
        
        document.getElementById('regenerate-char-album-btn').addEventListener('click', handleGenerateSimulatedAlbum);

        
        document.getElementById('char-album-grid').addEventListener('click', (e) => {
            
            const photoItem = e.target.closest('.char-photo-item');
            
            
            if (photoItem && photoItem.dataset.description) {
                const description = photoItem.dataset.description;
                
                
                showCustomAlert("ç…§ç‰‡è¯¦æƒ…", description.replace(/\n/g, '<br>'));
            }
        });
        document.getElementById('regenerate-char-browser-btn').addEventListener('click', handleGenerateBrowserHistory);
        
        document.getElementById('regenerate-char-taobao-btn').addEventListener('click', handleGenerateTaobaoHistory);
       
        
        
        document.getElementById('char-product-grid').addEventListener('click', (e) => {
            const item = e.target.closest('.char-product-item');
            if (item && item.dataset.reason) {
                const reason = item.dataset.reason;
                showCustomAlert("TAçš„æƒ³æ³•...", reason.replace(/\n/g, '<br>'));
            }
        });
        
        
        window.openCharWallet = openCharWallet;
document.getElementById('regenerate-char-memo-btn').addEventListener('click', handleGenerateSimulatedMemos);
document.getElementById('char-memo-detail-back-btn').addEventListener('click', () => switchToCharScreen('char-memo-screen'));

document.getElementById('regenerate-char-diary-btn').addEventListener('click', handleGenerateSimulatedDiaries);
document.getElementById('add-char-diary-btn').addEventListener('click', handleWriteNewDiaryEntry);
document.getElementById('char-diary-detail-back-btn').addEventListener('click', () => switchToCharScreen('char-diary-screen'));
document.getElementById('regenerate-char-amap-btn').addEventListener('click', handleGenerateAmapHistory);
document.getElementById('regenerate-char-usage-btn').addEventListener('click', handleGenerateAppUsage);
        document.getElementById('regenerate-char-music-btn').addEventListener('click', handleGenerateSimulatedMusic);
        document.getElementById('close-char-music-player-btn').addEventListener('click', closeCharMusicPlayer);
document.getElementById('regenerate-douban-btn').addEventListener('click', handleGenerateDoubanPosts);
document.getElementById('regenerate-douban-btn').addEventListener('click', handleGenerateDoubanPosts);
document.getElementById('douban-detail-back-btn').addEventListener('click', () => showScreen('douban-screen'));
document.getElementById('douban-send-comment-btn').addEventListener('click', handleSendDoubanComment);
document.getElementById('douban-wait-reply-btn').addEventListener('click', handleDoubanWaitReply);
        
        document.getElementById('cphone-wallpaper-upload-input').addEventListener('change', async (event) => {
            const file = event.target.files[0];
            if (file) {
                const dataUrl = await new Promise((res) => {
                    const reader = new FileReader();
                    reader.onload = () => res(reader.result);
                    reader.readAsDataURL(file);
                });
                
                state.globalSettings.cphoneWallpaper = dataUrl;
                
                renderWallpaperScreen();
            }
        });
        
        

document.getElementById('cphone-icon-settings-grid').addEventListener('click', (e) => {
    if (e.target.classList.contains('change-icon-btn')) {
        const item = e.target.closest('.icon-setting-item');
        const iconId = item.dataset.iconId;
        if (iconId) {
            handleIconChange(iconId, 'cphone', item);
        }
    }
});
document.getElementById('import-appearance-btn').addEventListener('click', () => {
    document.getElementById('import-appearance-input').click();
});

document.getElementById('import-appearance-input').addEventListener('change', (e) => {
    const file = e.target.files[0];
    if (file) {
        importAppearanceSettings(file);
    }
    e.target.value = null; 
});


/**
 * ç›‘å¬æµè§ˆå™¨çš„å¯è§æ€§å˜åŒ–äº‹ä»¶ã€‚
 * å½“ç”¨æˆ·å°†PWAåˆ‡æ¢åˆ°åŽå°æˆ–å…³é—­æµè§ˆå™¨æ ‡ç­¾é¡µæ—¶ï¼Œè¿™ä¸ªäº‹ä»¶ä¼šè¢«è§¦å‘ã€‚
 */
document.addEventListener('visibilitychange', () => {
    
    if (document.visibilityState === 'hidden') {
        
        localStorage.setItem('ephoneLastActiveTimestamp', Date.now());
        console.log("åº”ç”¨å·²åˆ‡æ¢åˆ°åŽå°ï¼Œè®°å½•å½“å‰æ—¶é—´ã€‚");
    }
});

        document.getElementById('export-world-book-btn').addEventListener('click', exportWorldBooks);
        

        document.getElementById('enable-ai-drawing-switch').addEventListener('change', async (e) => {
            const isEnabled = e.target.checked;
            state.globalSettings.enableAiDrawing = isEnabled;
            await db.globalSettings.put(state.globalSettings);

            
            const activeScreen = document.querySelector('.screen.active');
            if (activeScreen) {
                switch (activeScreen.id) {
                    case 'chat-interface-screen':
                        renderChatInterface(state.activeChatId);
                        break;
                    case 'chat-list-screen':
                        
                        if(document.getElementById('qzone-screen').classList.contains('active')) renderQzonePosts();
                        
                        if(document.getElementById('favorites-view').classList.contains('active')) renderFavoritesScreen();
                        break;
                    case 'douban-screen':
                        renderDoubanScreen();
                        break;
                    case 'douban-post-detail-screen':
                        openDoubanPostDetail(activeDoubanPostId);
                        break;
                    
                    case 'character-phone-screen':
                        const activeCharScreen = document.querySelector('.char-screen.active');
                        if (activeCharScreen) {
                            switch(activeCharScreen.id) {
                                case 'char-album-screen': renderCharAlbum(); break;
                                case 'char-taobao-screen': renderCharTaobao(); break;
                                case 'char-browser-article-screen': 
                                    const char = state.chats[activeCharacterId];
                                    const history = char.simulatedBrowserHistory || [];
                                    const lastArticleIndex = history.length > 0 ? history.length - 1 : 0; 
                                    renderCharArticle(history[lastArticleIndex]);
                                    break;
                                case 'char-usage-screen': renderCharAppUsage(); break;
                                case 'char-qq-screen': renderCharSimulatedQQ(); break;
                                case 'char-qq-conversation-screen': 
                                    const convoIndex = document.querySelector('#char-chat-list .chat-list-item')?.dataset.conversationIndex || 0;
                                    openCharSimulatedConversation(parseInt(convoIndex));
                                    break;
                            }
                        }
                        break;
                }
            }
            showCustomAlert('è®¾ç½®å·²åº”ç”¨', `AIç”Ÿå›¾åŠŸèƒ½å·²${isEnabled ? 'å¼€å¯' : 'å…³é—­'}ã€‚`);
        });

document.getElementById('search-history-btn').addEventListener('click', openSearchHistoryScreen);
document.getElementById('search-history-back-btn').addEventListener('click', () => {
    showScreen('chat-settings-screen');
});
document.getElementById('execute-search-btn').addEventListener('click', handleSearchHistory);
document.getElementById('clear-search-btn').addEventListener('click', clearSearchFilters);
  



document.getElementById('upload-custom-frame-btn').addEventListener('click', handleUploadFrame);
document.getElementById('batch-import-frames-btn').addEventListener('click', handleBatchUploadFrames);


document.querySelector('#avatar-frame-modal .modal-body').addEventListener('click', (e) => {
    
    if (e.target.classList.contains('delete-btn')) {
        const frameId = parseInt(e.target.dataset.id);
        if (!isNaN(frameId)) {
            handleDeleteCustomFrame(frameId);
        }
    }
});

  
        

        
        setupHomeScreenPagination();

        
        window.openPresetScreen = openPresetScreen;

        
        document.getElementById('add-preset-btn').addEventListener('click', async () => {
            const name = await showCustomPrompt('åˆ›å»ºæ–°é¢„è®¾', 'è¯·è¾“å…¥é¢„è®¾åç§°');
            if (name && name.trim()) {
                const newPreset = { id: 'preset_' + Date.now(), name: name.trim(), content: [] };
                await db.presets.add(newPreset);
                await renderPresetScreen();
                openPresetEditor(newPreset.id);
            }
        });

        document.getElementById('manage-preset-categories-btn').addEventListener('click', openPresetCategoryManager);
        
        document.getElementById('add-preset-entry-btn').addEventListener('click', () => {
            const container = document.getElementById('preset-entries-container');
            if (container.querySelector('p')) {
                container.innerHTML = '';
            }
            const newBlock = createPresetEntryBlock();
            container.appendChild(newBlock);
            newBlock.querySelector('.entry-content-textarea').focus();
        });


document.getElementById('save-preset-btn').addEventListener('click', async () => {
    if (!editingPresetId) return;
    const preset = await db.presets.get(editingPresetId);
    if (!preset) return;

    
    const newName = document.getElementById('preset-name-input').value.trim();
    if (!newName) { alert('é¢„è®¾åç§°ä¸èƒ½ä¸ºç©ºï¼'); return; }
    preset.name = newName;
    preset.categoryId = parseInt(document.getElementById('preset-category-select').value) || null;

    const entriesContainer = document.getElementById('preset-entries-container');
    const entryBlocks = entriesContainer.querySelectorAll('.message-editor-block');
    const newEntries = [];
    entryBlocks.forEach(block => {
        const content = block.querySelector('.entry-content-textarea').value.trim();
        if (content) {
            newEntries.push({
                comment: block.querySelector('.entry-comment-input').value.trim(),
                keys: (block.querySelector('.entry-keys-input').value.trim() || '').split(',').map(k => k.trim()).filter(Boolean),
                content: content,
                enabled: block.querySelector('.entry-enabled-switch').checked
            });
        }
    });
    preset.content = newEntries;

    
    await db.presets.put(preset);
    editingPresetId = null;

    
    showScreen('preset-screen');
    
    
    
    await renderPresetScreen();
});
  

          
        
       

        
          
document.getElementById('reset-button-order-btn').addEventListener('click', resetButtonOrder);

document.getElementById('clear-specific-data-btn').addEventListener('click', openDataClearWizard);


document.getElementById('cancel-clear-wizard-btn-step1').addEventListener('click', () => {
    document.getElementById('data-clear-wizard-modal').classList.remove('visible');
});
document.getElementById('go-to-clear-step2-btn').addEventListener('click', handleDataClearNext);


document.getElementById('back-to-clear-step1-btn').addEventListener('click', handleDataClearBack);
document.getElementById('cancel-clear-wizard-btn-step2').addEventListener('click', () => {
    document.getElementById('data-clear-wizard-modal').classList.remove('visible');
});
document.getElementById('confirm-final-clear-btn').addEventListener('click', handleConfirmDataClear);


document.getElementById('data-clear-wizard-modal').addEventListener('click', (e) => {
    const item = e.target.closest('.clear-posts-item');
    if (item) {
        
        e.stopPropagation();
        item.classList.toggle('selected');
    }
});
document.getElementById('data-clear-wizard-modal').addEventListener('change', (e) => {
    
    if (e.target.id === 'select-all-chars-for-clear') {
        const isChecked = e.target.checked;
        document.querySelectorAll('#data-clear-char-list .clear-posts-item').forEach(item => {
            item.classList.toggle('selected', isChecked);
        });
    } 
    
    else if (e.target.id === 'select-all-types-for-clear') {
        const isChecked = e.target.checked;
        document.querySelectorAll('#data-clear-type-list .clear-posts-item').forEach(item => {
            item.classList.toggle('selected', isChecked);
        });
    }
});
  
document.getElementById('compress-images-btn').addEventListener('click', compressAllLocalImages);

document.getElementById('copy-message-btn').addEventListener('click', copyMessageContent);

  
document.getElementById('copy-timestamp-btn').addEventListener('click', copyMessageTimestamp);

document.getElementById('npc-list-back-btn').addEventListener('click', () => {
    
    switchToChatListView('messages-view');
});


document.getElementById('add-npc-btn').addEventListener('click', () => openNpcEditor(null));


document.getElementById('save-npc-btn').addEventListener('click', saveNpc);
document.getElementById('npc-editor-modal').addEventListener('click', (e) => {
    if (e.target.id === 'manage-npc-groups-btn') {
        openNpcGroupManager();
    }
});
document.getElementById('close-npc-group-manager-btn').addEventListener('click', () => {
    document.getElementById('npc-group-manager-modal').classList.remove('visible');
    // é‡æ–°å¡«å……NPCç¼–è¾‘å™¨é‡Œçš„ä¸‹æ‹‰èœå•
    if (document.getElementById('npc-editor-modal').classList.contains('visible')) {
        openNpcEditor(editingNpcId);
    }
});
document.getElementById('add-new-npc-group-btn').addEventListener('click', addNewNpcGroup);
document.getElementById('existing-npc-groups-list').addEventListener('click', (e) => {
    if (e.target.classList.contains('delete-group-btn')) {
        deleteNpcGroup(parseInt(e.target.dataset.id));
    }
});
document.getElementById('cancel-npc-editor-btn').addEventListener('click', () => {
    document.getElementById('npc-editor-modal').classList.remove('visible');
});


document.getElementById('npc-avatar-input').addEventListener('change', (event) => {
    const file = event.target.files[0];
    if (file) {
        const reader = new FileReader();
        reader.onload = (e) => {
            document.getElementById('npc-avatar-preview').src = e.target.result;
        };
        reader.readAsDataURL(file);
    }
});
document.getElementById('chat-lock-overlay').addEventListener('click', (e) => {
    
    if (e.target.id === 'spectator-reroll-btn') {
        handleSpectatorReroll();
    }
    
    else if (e.target.id === 'spectator-edit-btn') {
        
        openAiResponseEditor();
    }
    
});
addLongPressListener(document.getElementById('music-visual-container'), () => { if (musicState.currentIndex > -1) { handleChangeAlbumArt(musicState.currentIndex); } });
document.getElementById('douban-settings-btn').addEventListener('click', openDoubanSettingsModal);
document.getElementById('save-douban-settings-btn').addEventListener('click', saveDoubanSettings);
document.getElementById('cancel-douban-settings-btn').addEventListener('click', () => {
    document.getElementById('douban-settings-modal').classList.remove('visible');
});

document.getElementById('time-zone-search-input').addEventListener('input', (e) => {
    const searchTerm = e.target.value.toLowerCase();
    const selectEl = document.getElementById('time-zone-select');
    
    
    for (const option of selectEl.options) {
        const optionText = option.textContent.toLowerCase();
        
        
        if (optionText.includes(searchTerm)) {
            option.style.display = ''; 
        } else {
            
            option.style.display = 'none';
        }
    }
});


    


window.openWerewolfLobby = openWerewolfLobby;


document.getElementById('werewolf-game-btn').addEventListener('click', () => openWerewolfLobby('group'));


document.getElementById('cancel-werewolf-lobby-btn').addEventListener('click', () => {
    document.getElementById('werewolf-lobby-modal').classList.remove('visible');
});
document.getElementById('start-werewolf-game-btn').addEventListener('click', initializeWerewolfGame);


        document.getElementById('werewolf-role-confirm-btn').addEventListener('click', () => {
            document.getElementById('werewolf-role-modal').classList.remove('visible');
            executeNightPhase(); 
        });
        
        document.getElementById('exit-werewolf-game-btn').addEventListener('click', async () => {
            const confirmed = await showCustomConfirm('é€€å‡ºæ¸¸æˆ', 'ç¡®å®šè¦é€€å‡ºå½“å‰è¿™å±€ç‹¼äººæ€å—ï¼Ÿæ¸¸æˆè¿›åº¦å°†ä¸ä¼šè¢«ä¿å­˜ã€‚', {confirmButtonClass: 'btn-danger'});
            if (confirmed) {
                werewolfGameState.isActive = false;
                
                showScreen(werewolfGameState.chatId ? 'chat-interface-screen' : 'home-screen');
            }
        });

        document.getElementById('werewolf-game-over-close-btn').addEventListener('click', () => {
            document.getElementById('werewolf-game-over-modal').classList.remove('visible');
            showScreen(werewolfGameState.chatId ? 'chat-list-screen' : 'home-screen');
        });



document.getElementById('cancel-wolf-kill-btn').addEventListener('click', () => {
    document.getElementById('werewolf-kill-modal').classList.remove('visible');
});
  


document.getElementById('cancel-werewolf-lobby-btn').addEventListener('click', () => {
    document.getElementById('werewolf-lobby-modal').classList.remove('visible');
});
  
document.getElementById('werewolf-retry-btn').addEventListener('click', handleWerewolfRetry);
document.getElementById('manual-werewolf-summary-btn').addEventListener('click', handleManualWerewolfSummary);
document.getElementById('check-and-fix-data-btn').addEventListener('click', checkAndFixData);
document.getElementById('dynamic-island-music-toggle-switch').addEventListener('change', (e) => {
            const isEnabled = e.target.checked;
            state.globalSettings.alwaysShowMusicIsland = isEnabled; // æ›´æ–°å†…å­˜ä¸­çš„çŠ¶æ€
            
            // ç«‹å³åº”ç”¨è§†è§‰å˜åŒ–
            const isFrameMode = document.body.classList.contains('frame-mode-active');
            
            // ä»…å½“éŸ³ä¹æ­£åœ¨æ’­æ”¾ ä¸” æ‰‹æœºå¤–æ¡†å…³é—­æ—¶ï¼Œè¿™ä¸ªå¼€å…³çš„å®žæ—¶åˆ‡æ¢æ‰éœ€è¦ä¸»åŠ¨æ›´æ–°UI
            if (musicState.isActive && !isFrameMode) {
                const lyricBar = document.getElementById('global-lyrics-bar');
                const phoneScreenForIsland = document.getElementById('phone-screen');
                
                if (isEnabled) {
                    // ä»Ž ç°è‰²æ¡ -> çµåŠ¨å²›
                    lyricBar.classList.remove('visible');
                    phoneScreenForIsland.classList.add('dynamic-island-active');
                } else {
                    // ä»Ž çµåŠ¨å²› -> ç°è‰²æ¡
                    phoneScreenForIsland.classList.remove('dynamic-island-active');
                    if (musicState.parsedLyrics && musicState.parsedLyrics.length > 0) {
                        lyricBar.classList.add('visible');
                    }
                }
            }
        });
document.getElementById('delete-world-books-btn').addEventListener('click', openWorldBookDeletionModal);


document.getElementById('cancel-delete-world-books-btn').addEventListener('click', () => {
    document.getElementById('delete-world-books-modal').classList.remove('visible');
});
document.getElementById('confirm-delete-world-books-btn').addEventListener('click', handleConfirmWorldBookDeletion);

document.getElementById('delete-world-books-modal').addEventListener('click', (e) => {
    
    const item = e.target.closest('.clear-posts-item');
    if (item) {
        item.classList.toggle('selected');
    }
    
    if (e.target.id === 'select-all-world-books-for-clear') {
        const isChecked = e.target.checked;
        document.querySelectorAll('#delete-world-books-list .clear-posts-item').forEach(el => {
            el.classList.toggle('selected', isChecked);
        });
    }
});


document.getElementById('sticker-search-input').addEventListener('input', () => {
    
    renderStickerPanel(false); 
});


document.getElementById('sticker-category-tabs').addEventListener('click', (e) => {
    if (e.target.classList.contains('sticker-category-tab')) {
        const categoryId = e.target.dataset.categoryId;
        const finalId = (categoryId !== 'all' && categoryId !== 'uncategorized') ? parseInt(categoryId) : categoryId;
        
        
        document.getElementById('sticker-search-input').value = ''; 
        
        
        switchStickerCategory(finalId);
    }
});
  



const chatMessagesContainer = document.getElementById('chat-messages');
chatMessagesContainer.addEventListener('scroll', () => {
    
    if (chatMessagesContainer.scrollTop < 1 && !isLoadingMoreMessages) {
        const totalMessages = state.chats[state.activeChatId]?.history.length || 0;
        
        if (totalMessages > currentRenderedCount) {
             loadMoreMessages();
        }
    }
});


const thoughtsHistoryList = document.getElementById('thoughts-history-list');
thoughtsHistoryList.addEventListener('scroll', () => {
    const { scrollTop, scrollHeight, clientHeight } = thoughtsHistoryList;
    
    if (scrollHeight - scrollTop <= clientHeight + 50 && !isLoadingMoreThoughts) { 
        const totalItems = state.chats[state.activeChatId]?.thoughtsHistory.length || 0;
        if (totalItems > thoughtsHistoryRenderCount) {
            loadMoreThoughts();
        }
    }
});


const qzoneContent = document.querySelector('#qzone-screen .qzone-content');
qzoneContent.addEventListener('scroll', () => {
    const { scrollTop, scrollHeight, clientHeight } = qzoneContent;
    
    if (scrollHeight - scrollTop <= clientHeight + 100 && !isLoadingMorePosts) { 
        if (qzonePostsCache.length > qzonePostsRenderCount) {
            loadMoreQzonePosts();
        }
    }
});

const naiGalleryGridEl = document.getElementById('nai-gallery-grid');
        naiGalleryGridEl.addEventListener('scroll', () => {
            const { scrollTop, scrollHeight, clientHeight } = naiGalleryGridEl;
            // å½“æ»šåŠ¨åˆ°åº•éƒ¨ 100px èŒƒå›´å†…æ—¶
            if (scrollHeight - scrollTop <= clientHeight + 100 && !isLoadingMoreNaiImages) {
                if (naiGalleryCache.length > naiGalleryRenderCount) {
                    loadMoreNaiGalleryImages();
                }
            }
        });

document.getElementById('read-together-btn').addEventListener('click', openReadingRoom);
const restoreBtn = document.getElementById('reading-restore-btn');

makeDraggable(restoreBtn, restoreBtn);
document.getElementById('close-reading-btn').addEventListener('click', closeReadingRoom);
document.getElementById('open-reading-library-btn').addEventListener('click', openBookLibrary);
document.getElementById('next-page-btn').addEventListener('click', showNextPage);
document.getElementById('prev-page-btn').addEventListener('click', showPrevPage);
document.getElementById('book-upload-input').addEventListener('change', handleBookFileUpload);


document.getElementById('minimize-reading-btn').addEventListener('click', minimizeReadingRoom);
document.getElementById('reading-restore-btn').addEventListener('click', restoreReadingRoom);


makeDraggable(document.getElementById('reading-window'), document.querySelector('#reading-window .reading-header'));
  

document.getElementById('open-reading-library-btn').addEventListener('click', openBookLibrary);

document.getElementById('close-reading-library-btn-header').addEventListener('click', () => {
    document.getElementById('reading-library-modal').classList.remove('visible');
});
document.getElementById('import-new-book-btn-header').addEventListener('click', importBook);
  


document.getElementById('reading-library-list').addEventListener('click', (e) => {
    const target = e.target;
    if (target.classList.contains('group-name')) { 
        const bookId = parseInt(target.dataset.bookId);
        loadBookFromLibrary(bookId);
    } else if (target.classList.contains('delete-group-btn')) { 
        const bookId = parseInt(target.dataset.bookId);
        deleteBookFromLibrary(bookId);
    }
});
  
document.getElementById('page-indicator').addEventListener('click', handlePageJump);
document.getElementById('reading-library-search-input').addEventListener('input', (e) => {
    
    renderBookLibrary(e.target.value);
});
const debouncedUpdateReadingContext = debounce(updateReadingContextOnScroll, 300); 


document.getElementById('reading-content').addEventListener('scroll', debouncedUpdateReadingContext);
document.getElementById('api-temperature-slider').addEventListener('input', (e) => {
    document.getElementById('api-temperature-value').textContent = e.target.value;
});
const chatListContainer = document.getElementById('messages-view');
chatListContainer.addEventListener('scroll', () => {
    const { scrollTop, scrollHeight, clientHeight } = chatListContainer;
    
    if (scrollHeight - scrollTop <= clientHeight + 150 && !isLoadingMoreChats) {
        loadMoreChats();
    }
});

        
        
        document.getElementById('manage-product-categories-btn').addEventListener('click', openProductCategoryManager);
document.getElementById('close-product-category-manager-btn').addEventListener('click', () => {
    document.getElementById('product-category-manager-modal').classList.remove('visible');
    
    
    openProductEditor(editingProductId); 
});
        document.getElementById('add-new-product-category-btn').addEventListener('click', addNewProductCategory);
        document.getElementById('existing-product-categories-list').addEventListener('click', (e) => {
            if (e.target.classList.contains('delete-group-btn')) {
                deleteProductCategory(parseInt(e.target.dataset.id));
            }
        });

        
        document.getElementById('add-product-variation-btn').addEventListener('click', () => addProductVariationInput());

        
        document.getElementById('cancel-variation-selection-btn').addEventListener('click', () => {
            document.getElementById('variation-selection-modal').classList.remove('visible');
        });
        document.getElementById('variation-decrease-qty').addEventListener('click', () => {
            const display = document.getElementById('variation-quantity-display');
            let qty = parseInt(display.textContent);
            if (qty > 1) display.textContent = qty - 1;
        });
        document.getElementById('variation-increase-qty').addEventListener('click', () => {
            const display = document.getElementById('variation-quantity-display');
            display.textContent = parseInt(display.textContent) + 1;
        });
document.getElementById('product-category-tabs').addEventListener('click', (e) => {
    
    if (e.target.classList.contains('product-category-tab')) {
        
        const categoryId = e.target.dataset.categoryId === 'all' ? 'all' : parseInt(e.target.dataset.categoryId);
        
        
        switchShoppingCategory(categoryId);
    }
});
document.getElementById('generate-shopping-items-btn').addEventListener('click', handleGenerateShoppingItems);
document.getElementById('shopping-settings-btn').addEventListener('click', openShoppingSettingsModal);
document.getElementById('save-shopping-settings-btn').addEventListener('click', saveShoppingSettings);
document.getElementById('cancel-shopping-settings-btn').addEventListener('click', () => {
    document.getElementById('shopping-settings-modal').classList.remove('visible');
});
document.getElementById('select-all-products-checkbox').addEventListener('change', (e) => {
    const isChecked = e.target.checked;
    
    const visibleItems = document.querySelectorAll('#product-grid .product-item');

    visibleItems.forEach(item => {
        const productId = parseInt(item.dataset.id);
        item.classList.toggle('selected', isChecked);
        if (isChecked) {
            selectedProducts.add(productId);
        } else {
            selectedProducts.delete(productId);
        }
    });
    document.getElementById('delete-selected-products-btn').textContent = `åˆ é™¤ (${selectedProducts.size})`;
});


document.getElementById('delete-selected-products-btn').addEventListener('click', async () => {
    if (selectedProducts.size === 0) {
        alert("è¯·å…ˆé€‰æ‹©è¦åˆ é™¤çš„å•†å“ã€‚");
        return;
    }

    const confirmed = await showCustomConfirm(
        'ç¡®è®¤åˆ é™¤',
        `ç¡®å®šè¦æ°¸ä¹…åˆ é™¤é€‰ä¸­çš„ ${selectedProducts.size} ä¸ªå•†å“å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ¢å¤ã€‚`,
        { confirmButtonClass: 'btn-danger' }
    );

    if (confirmed) {
        await db.shoppingProducts.bulkDelete([...selectedProducts]);

        
        document.getElementById('manage-products-btn').click(); 
        
        await renderShoppingProducts();

        await showCustomAlert("æˆåŠŸ", "é€‰ä¸­çš„å•†å“å·²æˆåŠŸåˆ é™¤ã€‚");
    }
});

document.getElementById('appearance-preset-select').addEventListener('change', handleAppearancePresetSelectionChange);
document.getElementById('save-appearance-preset-btn').addEventListener('click', saveAppearancePreset);
document.getElementById('delete-appearance-preset-btn').addEventListener('click', deleteAppearancePreset);

// ========================================
// ç¬¬å…«éƒ¨åˆ†ï¼šNovelAIç³»ç»Ÿçš„JavaScriptäº‹ä»¶ç›‘å¬å™¨
// ========================================

document.getElementById('novelai-switch').addEventListener('change', (e) => {
    const detailsDiv = document.getElementById('novelai-details');
    detailsDiv.style.display = e.target.checked ? 'block' : 'none';
});

// NovelAI API Keyæ˜¾ç¤º/éšè—åˆ‡æ¢
document.getElementById('novelai-key-toggle').addEventListener('click', function() {
    const input = document.getElementById('novelai-api-key');
    if (input.type === 'password') {
        input.type = 'text';
        this.textContent = 'ðŸ˜Œ';
    } else {
        input.type = 'password';
        this.textContent = 'ðŸ§';
    }
});

// æ‰“å¼€NovelAIè®¾ç½®å¼¹çª—
document.getElementById('novelai-settings-btn').addEventListener('click', () => {
    loadNovelAISettings();
    document.getElementById('novelai-settings-modal').style.display = 'flex';
});

// CORSä»£ç†é€‰æ‹©å™¨å˜åŒ–äº‹ä»¶
document.getElementById('nai-cors-proxy').addEventListener('change', (e) => {
    const customProxyGroup = document.getElementById('nai-custom-proxy-group');
    if (e.target.value === 'custom') {
        customProxyGroup.style.display = 'block';
    } else {
        customProxyGroup.style.display = 'none';
    }
});

// å…³é—­NovelAIè®¾ç½®å¼¹çª—
document.getElementById('close-novelai-settings').addEventListener('click', () => {
    document.getElementById('novelai-settings-modal').style.display = 'none';
});

// ä¿å­˜NovelAIè®¾ç½®
document.getElementById('save-nai-settings-btn').addEventListener('click', () => {
    saveNovelAISettings();
    document.getElementById('novelai-settings-modal').style.display = 'none';
    alert('NovelAIè®¾ç½®å·²ä¿å­˜ï¼');
});

// æ¢å¤é»˜è®¤è®¾ç½®
document.getElementById('reset-nai-settings-btn').addEventListener('click', () => {
    if (confirm('ç¡®å®šè¦æ¢å¤é»˜è®¤è®¾ç½®å—ï¼Ÿ')) {
        resetNovelAISettings();
    }
});

// æ‰“å¼€NovelAIæµ‹è¯•å¼¹çª—
document.getElementById('novelai-test-btn').addEventListener('click', () => {
    const apiKey = document.getElementById('novelai-api-key').value.trim();
    if (!apiKey) {
        alert('è¯·å…ˆå¡«å†™NovelAI API Keyï¼');
        return;
    }
    document.getElementById('novelai-test-modal').style.display = 'flex';
    document.getElementById('nai-test-result').style.display = 'none';
    document.getElementById('nai-test-error').style.display = 'none';
});

// å…³é—­NovelAIæµ‹è¯•å¼¹çª—
document.getElementById('close-novelai-test').addEventListener('click', () => {
    document.getElementById('novelai-test-modal').style.display = 'none';
});

document.getElementById('close-nai-test-btn').addEventListener('click', () => {
    document.getElementById('novelai-test-modal').style.display = 'none';
});

// NovelAIç”Ÿæˆå›¾åƒæŒ‰é’®
document.getElementById('nai-generate-btn').addEventListener('click', async () => {
    await generateNovelAIImage();
});

// ========================================
// ç¬¬ä¹éƒ¨åˆ†ï¼šNovelAIä¸‹è½½å›¾åƒå’Œè§’è‰²ä¸“å±žæç¤ºè¯äº‹ä»¶ç›‘å¬å™¨
// ========================================

// NovelAIä¸‹è½½å›¾åƒæŒ‰é’®
document.getElementById('nai-download-btn').addEventListener('click', () => {
    const img = document.getElementById('nai-result-image');
    const link = document.createElement('a');
    link.href = img.src;
    link.download = 'novelai-generated-' + Date.now() + '.png';
    link.click();
});

// â–¼â–¼â–¼ è§’è‰²ä¸“å±žNAIæç¤ºè¯å¼¹çª—äº‹ä»¶ç›‘å¬å™¨ â–¼â–¼â–¼

// æ‰“å¼€è§’è‰²ä¸“å±žNAIæç¤ºè¯é…ç½®å¼¹çª—
document.getElementById('character-nai-prompts-btn').addEventListener('click', () => {
    if (!state.activeChatId) return;
    const chat = state.chats[state.activeChatId];
    
    // åŠ è½½å½“å‰è§’è‰²çš„NAIæç¤ºè¯é…ç½®
    const naiSettings = chat.settings.naiSettings || {
        promptSource: 'system',
        characterPositivePrompt: '',
        characterNegativePrompt: ''
    };
    
    // â˜…â˜…â˜… ä¸¥æ ¼åŠ è½½è§’è‰²é…ç½®ï¼Œä¸ä¸Žç³»ç»Ÿé…ç½®æ··æ·† â˜…â˜…â˜…
    // å¡«äº†å°±æœ‰ï¼Œæ²¡å¡«å°±ä¸ºç©ºï¼Œç»ä¸ä½¿ç”¨ç³»ç»Ÿé…ç½®å¡«å……
    document.getElementById('character-nai-positive').value = naiSettings.characterPositivePrompt || '';
    document.getElementById('character-nai-negative').value = naiSettings.characterNegativePrompt || '';
    
    document.getElementById('character-nai-prompts-modal').style.display = 'flex';
});

// å…³é—­è§’è‰²ä¸“å±žNAIæç¤ºè¯å¼¹çª—
document.getElementById('close-character-nai-prompts').addEventListener('click', () => {
    document.getElementById('character-nai-prompts-modal').style.display = 'none';
});

// ä¿å­˜è§’è‰²ä¸“å±žNAIæç¤ºè¯
document.getElementById('save-character-nai-prompts-btn').addEventListener('click', async () => {
    if (!state.activeChatId) return;
    const chat = state.chats[state.activeChatId];
    
    if (!chat.settings.naiSettings) {
        chat.settings.naiSettings = {
            promptSource: 'system'
        };
    }
    
    chat.settings.naiSettings.characterPositivePrompt = document.getElementById('character-nai-positive').value.trim();
    chat.settings.naiSettings.characterNegativePrompt = document.getElementById('character-nai-negative').value.trim();
    
    console.log('ðŸ’¾ [ä¸“å±žå¼¹çª—] ä¿å­˜è§’è‰²NAIæç¤ºè¯');
    console.log('   characterPositivePrompt:', chat.settings.naiSettings.characterPositivePrompt);
    console.log('   characterNegativePrompt:', chat.settings.naiSettings.characterNegativePrompt);
    console.log('   promptSource:', chat.settings.naiSettings.promptSource);
    
    // ä¿å­˜åˆ°æ•°æ®åº“
    await db.chats.put(chat);
    
    document.getElementById('character-nai-prompts-modal').style.display = 'none';
    alert('è§’è‰²ä¸“å±žNAIæç¤ºè¯å·²ä¿å­˜ï¼');
});

// æ¸…ç©ºè§’è‰²ä¸“å±žNAIæç¤ºè¯é…ç½®
document.getElementById('reset-character-nai-prompts-btn').addEventListener('click', () => {
    if (confirm('ç¡®å®šè¦æ¸…ç©ºå½“å‰è§’è‰²çš„NAIæç¤ºè¯é…ç½®å—ï¼Ÿ')) {
        document.getElementById('character-nai-positive').value = '';
        document.getElementById('character-nai-negative').value = '';
    }
});

// â–²â–²â–² è§’è‰²ä¸“å±žNAIæç¤ºè¯å¼¹çª—äº‹ä»¶ç›‘å¬å™¨ç»“æŸ â–²â–²â–²

// â–¼â–¼â–¼ ç¾¤èŠè§’è‰²ä¸“å±žNAIæç¤ºè¯å¼¹çª—äº‹ä»¶ç›‘å¬å™¨ â–¼â–¼â–¼
document.getElementById('group-character-nai-prompts-btn').addEventListener('click', () => {
    if (!state.activeChatId) return;
    const chat = state.chats[state.activeChatId];
    
    // åŠ è½½å½“å‰è§’è‰²çš„NAIæç¤ºè¯é…ç½®
    const naiSettings = chat.settings.naiSettings || {
        promptSource: 'system',
        characterPositivePrompt: '',
        characterNegativePrompt: ''
    };
    
    // â˜…â˜…â˜… ä¸¥æ ¼åŠ è½½è§’è‰²é…ç½®ï¼Œä¸ä¸Žç³»ç»Ÿé…ç½®æ··æ·† â˜…â˜…â˜…
    // å¡«äº†å°±æœ‰ï¼Œæ²¡å¡«å°±ä¸ºç©ºï¼Œç»ä¸ä½¿ç”¨ç³»ç»Ÿé…ç½®å¡«å……
    document.getElementById('character-nai-positive').value = naiSettings.characterPositivePrompt || '';
    document.getElementById('character-nai-negative').value = naiSettings.characterNegativePrompt || '';
    
    document.getElementById('character-nai-prompts-modal').style.display = 'flex';
});
// â–²â–²â–² ç¾¤èŠè§’è‰²ä¸“å±žNAIæç¤ºè¯å¼¹çª—äº‹ä»¶ç›‘å¬å™¨ç»“æŸ â–²â–²â–²
  
document.getElementById('manage-frames-btn').addEventListener('click', toggleFrameManagementMode);
document.getElementById('select-all-frames-checkbox').addEventListener('change', handleSelectAllFrames);
document.getElementById('delete-selected-frames-btn').addEventListener('click', executeBatchDeleteFrames);
document.getElementById('delete-current-category-btn').addEventListener('click', handleDeleteCurrentCategory);
document.getElementById('char-wallet-back-btn').addEventListener('click', () => {

    switchToCharScreen('char-taobao-screen');
});
document.getElementById('sticker-binding-chat-list').addEventListener('click', (e) => {
    const item = e.target.closest('.contact-picker-item');
    if (item) {
        const checkbox = item.querySelector('.sticker-binding-checkbox');
        if (checkbox && e.target !== checkbox) {
            checkbox.checked = !checkbox.checked;
        }
    }
});
const stickerTabsContainer = document.getElementById('sticker-category-tabs');
addLongPressListener(stickerTabsContainer, (e) => {
    const tab = e.target.closest('.sticker-category-tab');
    if (tab) {
        e.preventDefault(); 
        const categoryIdStr = tab.dataset.categoryId;
        if (categoryIdStr === 'all') {
            showCustomAlert("æç¤º", "â€œå…¨éƒ¨â€åˆ†ç±»æ— æ³•è¢«ç»‘å®šã€‚");
            return;
        }
        const categoryId = categoryIdStr === 'uncategorized' ? 'uncategorized' : parseInt(categoryIdStr);
        openStickerCategoryBindingModal(categoryId);
    }
});

    document.getElementById('open-nai-gallery-btn').addEventListener('click', openNaiGallery);
    document.getElementById('close-nai-gallery-btn').addEventListener('click', () => {
        document.getElementById('nai-gallery-panel').classList.remove('visible');
    });

    document.getElementById('manage-nai-gallery-btn').addEventListener('click', toggleNaiGalleryManagementMode);
    
    document.getElementById('nai-gallery-grid').addEventListener('click', (e) => {
        handleNaiGalleryGridClick(e);
    });

    document.getElementById('select-all-nai-gallery-checkbox').addEventListener('change', (e) => {
        const isChecked = e.target.checked;
        document.querySelectorAll('#nai-gallery-grid .nai-gallery-item').forEach(item => {
            item.classList.toggle('selected', isChecked);
            const key = item.dataset.key;
            if (isChecked) {
                selectedNaiImages.add(key);
            } else {
                selectedNaiImages.delete(key);
            }
        });
        updateNaiGalleryActionButtons();
    });
  document.getElementById('download-selected-nai-gallery-btn').addEventListener('click', () => executeBatchDownloadNaiImages());
    document.getElementById('delete-selected-nai-gallery-btn').addEventListener('click', () => executeBatchDeleteNaiImages());
document.getElementById('chat-expand-btn').addEventListener('click', () => {
    document.body.classList.toggle('chat-actions-expanded');
});








    checkForUpdates();

                    showScreen('home-screen');
                }
        
                init();
            });
        
        
